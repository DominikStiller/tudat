diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestBodyShapeModels.cpp b/Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestBodyShapeModels.cpp
new file mode 100644
index 0000000..a13f3b1
--- /dev/null
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestBodyShapeModels.cpp
@@ -0,0 +1,162 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150409    D. Dirkx          Migrated from personal code.
+ *
+ *    References
+ *      Montebruck O, Gill E. Satellite Orbits, Springer, 2000.
+ *
+ *    Notes
+ *
+ */
+
+#define BOOST_TEST_MAIN
+
+#include <boost/format.hpp>
+#include <boost/test/unit_test.hpp>
+
+#include <Tudat/Astrodynamics/BasicAstrodynamics/unitConversions.h>
+#include <Tudat/Basics/testMacros.h>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/oblateSpheroidBodyShapeModel.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/sphericalBodyShapeModel.h"
+
+namespace tudat
+{
+namespace unit_tests
+{
+
+BOOST_AUTO_TEST_SUITE( test_geodetic_coordinate_conversions )
+
+//! Test shape models, for test data, see testGeodeticCoordinateConversions.
+BOOST_AUTO_TEST_CASE( testShapeModels )
+{
+    using namespace tudat::physical_constants;
+    using namespace tudat::coordinate_conversions;
+    using namespace tudat::unit_conversions;
+    using namespace tudat::basic_astrodynamics;
+
+    // Expected Cartesian state, Montenbruck & Gill (2000) Exercise 5.3.
+    const Eigen::Vector3d testCartesianPosition( 1917032.190, 6029782.349, -801376.113 );
+
+    // Expected Cartesian state, Montenbruck & Gill (2000) Exercise 5.3.
+    const Eigen::Vector3d testGeodeticPosition( -63.667,
+                                                convertDegreesToRadians( -7.26654999 ),
+                                                convertDegreesToRadians( 72.36312094 ) );
+
+    // Central body characteristics (WGS84 Earth ellipsoid).
+    const double flattening = 1.0 / 298.257223563;
+    const double equatorialRadius = 6378137.0;
+
+    // Test spherealtitude
+    {
+        SphericalBodyShapeModel shapeModel = SphericalBodyShapeModel(
+                    equatorialRadius );
+
+        // Calculate altitude from shape object.
+        const double altitudeFromObject = shapeModel.getAltitude(
+                    testCartesianPosition );
+
+        // Calculate object directly.
+        const double directAltitude = testCartesianPosition.norm( ) - equatorialRadius;
+
+        // Compare values.
+        BOOST_CHECK_EQUAL( altitudeFromObject, directAltitude );
+    }
+
+    // Test oblate spheroid
+    {
+        OblateSpheroidBodyShapeModel shapeModel = OblateSpheroidBodyShapeModel(
+                    equatorialRadius, flattening );
+
+        // Calculate altitude from shape object.
+        const double altitudeFromObject = shapeModel.getAltitude(
+                    testCartesianPosition );
+
+        // Calculate object from free function.
+        const double directAltitude = calculateAltitudeOverOblateSpheroid(
+                    testCartesianPosition, equatorialRadius, flattening, 1.0E-4 );
+
+        // Compare values.
+        BOOST_CHECK_SMALL( altitudeFromObject - testGeodeticPosition.x( ), 1.0E-4 );
+        BOOST_CHECK_EQUAL( altitudeFromObject, directAltitude );
+
+        // Test calculation of full geodetic position.
+        Eigen::Vector3d calculatedGeodeticPosition = shapeModel.getGeodeticPositionWrtShape(
+                    testCartesianPosition );
+        TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                    calculatedGeodeticPosition, testGeodeticPosition, 1.0E-6 );
+    }
+
+    // Test free function altitude calculations
+    {
+        boost::shared_ptr< OblateSpheroidBodyShapeModel > shapeModel =
+                boost::make_shared< OblateSpheroidBodyShapeModel >(
+                    equatorialRadius, flattening );
+
+        Eigen::Vector3d bodyPosition =
+                ( Eigen::Vector3d( )<<
+                  ASTRONOMICAL_UNIT / sqrt( 2.0 ),
+                  ASTRONOMICAL_UNIT / sqrt( 2.0 ),
+                  ASTRONOMICAL_UNIT  * 0.01 ).finished( );
+        Eigen::Vector3d inertialTestCartesianPosition = testCartesianPosition + bodyPosition;
+
+        double calculatedAltitute = getAltitudeFromNonBodyFixedPosition(
+                    shapeModel, testCartesianPosition, Eigen::Vector3d::Zero( ),
+                    Eigen::Quaterniond( Eigen::Matrix3d::Identity( ) ) );
+        BOOST_CHECK_SMALL( calculatedAltitute - testGeodeticPosition.x( ), 1.0E-4 );
+
+        calculatedAltitute = getAltitudeFromNonBodyFixedPosition(
+                    shapeModel, inertialTestCartesianPosition, bodyPosition,
+                    Eigen::Quaterniond( Eigen::Matrix3d::Identity( ) ) );
+        BOOST_CHECK_SMALL( calculatedAltitute - testGeodeticPosition.x( ), 1.0E-4 );
+
+        Eigen::Quaterniond dummyTestRotation =
+                Eigen::AngleAxisd( 0.4343, Eigen::Vector3d::UnitZ( ) ) *
+                Eigen::AngleAxisd( 2.4354, Eigen::Vector3d::UnitX( ) ) *
+                Eigen::AngleAxisd( 1.2434, Eigen::Vector3d::UnitY( ) );
+
+        calculatedAltitute = getAltitudeFromNonBodyFixedPosition(
+                    shapeModel, dummyTestRotation * inertialTestCartesianPosition,
+                    dummyTestRotation * bodyPosition,
+                    dummyTestRotation.inverse( ) );
+        BOOST_CHECK_SMALL( calculatedAltitute - testGeodeticPosition.x( ), 1.0E-4 );
+
+        calculatedAltitute = getAltitudeFromNonBodyFixedPositionFunctions(
+                    shapeModel, dummyTestRotation * inertialTestCartesianPosition,
+                    boost::lambda::constant(
+                        Eigen::Vector3d( dummyTestRotation * bodyPosition ) ),
+                    boost::lambda::constant( dummyTestRotation.inverse( ) ) );
+        BOOST_CHECK_SMALL( calculatedAltitute - testGeodeticPosition.x( ), 1.0E-4 );
+
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+} // namespace unit_tests
+} // namespace tudat
+
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/bodyShapeModel.cpp b/Tudat/Astrodynamics/BasicAstrodynamics/bodyShapeModel.cpp
new file mode 100644
index 0000000..2de48dd
--- /dev/null
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/bodyShapeModel.cpp
@@ -0,0 +1,62 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150409    D. Dirkx          Migrated from personal code.
+ *
+ *    References
+ *      Montebruck O, Gill E. Satellite Orbits, Springer, 2000.
+ *
+ *    Notes
+ *
+ */
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/bodyShapeModel.h"
+
+namespace tudat
+{
+
+namespace basic_astrodynamics
+{
+
+//! Function to calculate the altitude of a point over a central body from positions of both the point and the body (in any frame)
+double getAltitudeFromNonBodyFixedPosition(
+        const boost::shared_ptr< BodyShapeModel > bodyShapeModel, const Eigen::Vector3d& position, const Eigen::Vector3d& bodyPosition,
+        const Eigen::Quaterniond& toBodyFixedFrame )
+{    
+    return bodyShapeModel->getAltitude( toBodyFixedFrame * ( position - bodyPosition ) );
+}
+
+//! Function to calculate the altitude of a point over a central body from positions of both the point and the body (in any frame)
+double getAltitudeFromNonBodyFixedPositionFunctions(
+        const boost::shared_ptr< BodyShapeModel > bodyShapeModel, const Eigen::Vector3d& position,
+        const boost::function< Eigen::Vector3d( ) > bodyPositionFunction, const boost::function< Eigen::Quaterniond( ) > toBodyFixedFrameFunction )
+{
+    return getAltitudeFromNonBodyFixedPosition( bodyShapeModel, position,  bodyPositionFunction( ), toBodyFixedFrameFunction( ) );
+}
+
+}
+
+}
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/bodyShapeModel.h b/Tudat/Astrodynamics/BasicAstrodynamics/bodyShapeModel.h
new file mode 100644
index 0000000..3a058fb
--- /dev/null
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/bodyShapeModel.h
@@ -0,0 +1,135 @@
+#ifndef BODYSHAPEMODEL_H
+#define BODYSHAPEMODEL_H
+
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150409    D. Dirkx          Migrated from personal code.
+ *
+ *    References
+ *      Montebruck O, Gill E. Satellite Orbits, Springer, 2000.
+ *
+ *    Notes
+ *
+ */
+
+
+#include <Eigen/Core>
+#include <Eigen/Geometry>
+
+#include <boost/function.hpp>
+#include <boost/shared_ptr.hpp>
+
+namespace tudat
+{
+
+namespace basic_astrodynamics
+{
+
+//! Base class for body shape models.
+/*!
+ *  This is the base class for shape models for (celestial) bodies, such as spheres, ellipsoids,
+ *  or tri-axial ellipsoids. It can be used to calculate the altitude above such a shape or the
+ *  local radius.
+ */
+class BodyShapeModel
+{
+public:
+
+    //! Default constructor.
+    BodyShapeModel( ) { }
+
+    //! Virtual destructor.
+    virtual ~BodyShapeModel( ) { }
+
+    //! Calculates the altitude above the shape
+    /*!
+     *  Function to calculate the altitude above the shape from the a body fixed position.
+     *  \param bodyFixedPosition Cartesian, body-fixed position of the point at which the
+     *  altitude is to be determined.
+     *  \return Altitude above the body.
+     */
+    virtual double getAltitude( const Eigen::Vector3d& bodyFixedPosition ) = 0;
+
+    //! Function to return the mean radius of the shape model
+    /*!
+     *  Function to return the mean radius of the shape model, to be used for functions
+     *  requiring moderate to low accuracy for shape model, i.e. using a 'nearest equivalent'
+     *  sphere.
+     *  \return Average radius of shape model.
+     */
+    virtual double getAverageRadius( ) = 0;
+
+protected:
+
+};
+
+//! Function to calculate the altitude of a point over a central body from positions of both the
+//! point and the body (in any frame)
+/*!
+ *  Function to calculate the altitude of a point over a central body from positions of both the
+ *  point and the body (in any frame). The rotation to the body-fixed frame is provided to calculate
+ *  the input for the altitude function of the bodyShapeModel, which is to be in a body-fixed frame.
+ *  \param bodyShapeModel Shape model of central body
+ *  \param position Position of point of which altitude is to be calculated
+ *  \param position Position of central body above which altitude is to be calculated
+ *  \param position Rotation from frame in which input vectors are given to body-fixed frame.
+ *  \return Altitude above body shape.
+ */
+double getAltitudeFromNonBodyFixedPosition(
+        const boost::shared_ptr< BodyShapeModel > bodyShapeModel,
+        const Eigen::Vector3d& position,
+        const Eigen::Vector3d& bodyPosition,
+        const Eigen::Quaterniond& toBodyFixedFrame );
+
+//! Function to calculate the altitude of a point over a central body from positions of both the
+//! point and the body (in any frame)
+/*!
+ *  Function to calculate the altitude of a point over a central body from positions of both the
+ *  point and the body (in any frame).  The rotation to the body-fixed frame is provided to
+ *  calculate the input for the altitude function of the bodyShapeModel. The position of the central
+ *  body and rotation are not provided directly, but as function pointers to allow easy binding with
+ *  e.g. a Body class.
+ *  \param bodyShapeModel Shape model of central body
+ *  \param position Position of point of which altitude is to be calculated
+ *  \param position Function returning position of central body above which altitude is to be
+ *  calculated
+ *  \param position Function returning rotation from frame in which input vectors are given to
+ *  body-fixed frame.
+ *  \return Altitude above body shape.
+ */
+double getAltitudeFromNonBodyFixedPositionFunctions(
+        const boost::shared_ptr< BodyShapeModel > bodyShapeModel,
+        const Eigen::Vector3d& position,
+        const boost::function< Eigen::Vector3d( ) > bodyPositionFunction,
+        const boost::function< Eigen::Quaterniond( ) > toBodyFixedFrameFunction );
+
+
+}
+
+}
+
+#endif // BODYSHAPEMODEL_H
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/oblateSpheroidBodyShapeModel.h b/Tudat/Astrodynamics/BasicAstrodynamics/oblateSpheroidBodyShapeModel.h
new file mode 100644
index 0000000..6648c75
--- /dev/null
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/oblateSpheroidBodyShapeModel.h
@@ -0,0 +1,154 @@
+#ifndef OBLATESPHEROIDBODYSHAPEMODEL_H
+#define OBLATESPHEROIDBODYSHAPEMODEL_H
+
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150409    D. Dirkx          Migrated from personal code.
+ *
+ *    References
+ *      Montebruck O, Gill E. Satellite Orbits, Springer, 2000.
+ *
+ *    Notes
+ *
+ */
+
+
+#include <Eigen/Core>
+#include <iostream>
+
+#include <boost/lambda/lambda.hpp>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/bodyShapeModel.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/geodeticCoordinateConversions.h"
+
+namespace tudat
+{
+namespace basic_astrodynamics
+{
+
+//! Body shape model for an oblate spheroid
+/*!
+ *  Body shape model for an oblate spheroid (flattened sphere), typically used as approximation for
+ *  planets and large moons.
+ */
+class OblateSpheroidBodyShapeModel: public BodyShapeModel
+{
+public:
+
+    //! Constructor
+    /*!
+     *  Constructor, sets the geomtric properties of the shape.
+     *  \param equatorialRadius Equatorial radius of the oblate spheroid
+     *  \param flattening Flattening of the oblate spheroid
+     */
+    OblateSpheroidBodyShapeModel( const double equatorialRadius, const double flattening ):
+        equatorialRadius_( equatorialRadius ), flattening_( flattening )
+    {
+        // Calculate and set polar radius.
+        polarRadius_ = equatorialRadius * ( 1.0 - flattening_ );
+    }
+
+    //! Destructor
+    ~OblateSpheroidBodyShapeModel( ){ }
+
+    //! Calculates the altitude above the oblate spheroid
+    /*!
+     *  Function to calculate the altitude above the oblate spheroid from a body fixed position.
+     *  \param bodyFixedPosition Cartesian, body-fixed position of the point at which the altitude
+     *  is to be determined.
+     *  \return Altitude above the oblate spheroid.
+     */
+    double getAltitude( const Eigen::Vector3d& bodyFixedPosition )
+    {
+        return coordinate_conversions::calculateAltitudeOverOblateSpheroid(
+                    bodyFixedPosition, equatorialRadius_, flattening_, 1.0E-4 );
+    }
+
+    //! Calculates the geodetic position w.r.t. the oblate spheroid.
+    /*!
+     *  Function to calculate the geodetic position w.r.t. the oblate spheroid.
+     *  \sa convertCartesianToGeodeticCoordinates
+     *  \param bodyFixedPosition Cartesian, body-fixed position of the point at which the geodetic
+     *  position is to be determined.
+     *  \param tolerance Convergence criterion for iterative algorithm that is employed. Represents
+     *  the required change of position (in m) between two iterations.
+     *  \return Geodetic coordinates at requested point.
+     */
+    Eigen::Vector3d getGeodeticPositionWrtShape( const Eigen::Vector3d& bodyFixedPosition,
+                                        const double tolerance = 1.0E-4 )
+    {
+        return coordinate_conversions::convertCartesianToGeodeticCoordinates(
+                    bodyFixedPosition, equatorialRadius_, flattening_, tolerance );
+    }
+
+    //! Function to return the mean radius of the oblate spheroid.
+    /*!
+     *  Function to return the mean radius of the oblate spheroid.
+     *  \return Average radius of oblate spheroid.
+     */
+    double getAverageRadius( )
+    {
+        return ( ( 2.0 * equatorialRadius_+ polarRadius_) / 3.0 );
+    }
+
+    //! Function to obtain the equatorial radius
+    /*!
+     *  Function to obtain the equatorial radius
+     *  \return Equatorial radius of the oblate spheroid
+     */
+    double getEquatorialRadius( )
+    {
+        return equatorialRadius_;
+    }
+
+    //! Function to obtain the flattening of the oblate spheroid
+    /*!
+     *  Function to obtain the flattening of the oblate spheroid
+     *  \return Flattening radius of the oblate spheroid
+     */
+    double getFlattening( )
+    {
+        return flattening_;
+    }
+
+private:
+    //! Equatorial radius of the oblate spheroid
+    double equatorialRadius_;
+
+    //! Polar radius of the oblate spheroid
+    double polarRadius_;
+
+    //! Flattening of the oblate spheroid
+    double flattening_;
+};
+
+}
+
+}
+
+
+#endif // OBLATESPHEROIDBODYSHAPEMODEL_H
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/sphericalBodyShapeModel.h b/Tudat/Astrodynamics/BasicAstrodynamics/sphericalBodyShapeModel.h
new file mode 100644
index 0000000..4204da1
--- /dev/null
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/sphericalBodyShapeModel.h
@@ -0,0 +1,104 @@
+#ifndef SPHERICALBODYSHAPEMODEL_H
+#define SPHERICALBODYSHAPEMODEL_H
+
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150409    D. Dirkx          Migrated from personal code.
+ *
+ *    References
+ *      Montebruck O, Gill E. Satellite Orbits, Springer, 2000.
+ *
+ *    Notes
+ *
+ */
+
+
+#include <iostream>
+
+#include <boost/make_shared.hpp>
+#include <boost/lambda/lambda.hpp>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/bodyShapeModel.h"
+
+
+namespace tudat
+{
+namespace basic_astrodynamics
+{
+
+//! Body shape model defined as a sphere
+/*!
+ *  Body shape model defined as a sphere, defined by only its radius.
+ */
+class SphericalBodyShapeModel: public BodyShapeModel
+{
+public:
+
+    //! Constructor.
+    /*!
+     *  Constructor, defines body shape.
+     *  \param radius Radius of sphere
+     */
+    SphericalBodyShapeModel ( const double radius ):
+        radius_( radius ){ }
+
+    //! Destructor
+    ~SphericalBodyShapeModel( ){ }
+
+    //! Calculates the altitude above the sphere
+    /*!
+     *  Function to calculate the altitude above the sphere from a body fixed position.
+     *  \param bodyFixedPosition Cartesian, body-fixed position of the point at which the altitude
+     *  is to be determined.
+     *  \return Altitude above the sphere.
+     */
+    double getAltitude( const Eigen::Vector3d& bodyFixedPosition )
+    {
+        return bodyFixedPosition.norm( ) - radius_;
+    }
+
+    //! Function to return the mean radius of the shape model
+    /*!
+     *  Function to return the mean radius of the sphere, equal to its radius.
+     *  \return Average radius of shape model (equal to radius).
+     */
+    double getAverageRadius( )
+    {
+        return radius_;
+    }
+
+private:
+
+    //! Radius of sphere
+    double radius_;
+};
+
+}
+
+}
+
+#endif // SPHERICALBODYSHAPEMODEL_H
