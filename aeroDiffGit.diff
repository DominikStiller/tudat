diff --git a/Tudat/Astrodynamics/Aerodynamics/CMakeLists.txt b/Tudat/Astrodynamics/Aerodynamics/CMakeLists.txt
index e0069bf..3351f2a 100644
--- a/Tudat/Astrodynamics/Aerodynamics/CMakeLists.txt
+++ b/Tudat/Astrodynamics/Aerodynamics/CMakeLists.txt
@@ -36,10 +36,13 @@
 # Set the source files.
 set(AERODYNAMICS_SOURCES
   "${SRCROOT}${AERODYNAMICSDIR}/aerodynamicMoment.cpp"
+  "${SRCROOT}${AERODYNAMICSDIR}/aerodynamicAcceleration.cpp"
+  "${SRCROOT}${AERODYNAMICSDIR}/aerodynamicForce.cpp"
   "${SRCROOT}${AERODYNAMICSDIR}/aerodynamics.cpp"
   "${SRCROOT}${AERODYNAMICSDIR}/exponentialAtmosphere.cpp"
   "${SRCROOT}${AERODYNAMICSDIR}/hypersonicLocalInclinationAnalysis.cpp"
   "${SRCROOT}${AERODYNAMICSDIR}/tabulatedAtmosphere.cpp"
+  "${SRCROOT}${AERODYNAMICSDIR}/customAerodynamicCoefficientInterface.cpp"
 )
 
 # Set the header files.
@@ -56,6 +59,7 @@ set(AERODYNAMICS_HEADERS
   "${SRCROOT}${AERODYNAMICSDIR}/hypersonicLocalInclinationAnalysis.h"
   "${SRCROOT}${AERODYNAMICSDIR}/tabulatedAtmosphere.h"
   "${SRCROOT}${AERODYNAMICSDIR}/standardAtmosphere.h"
+  "${SRCROOT}${AERODYNAMICSDIR}/customAerodynamicCoefficientInterface.h"
 )
 
 # Add static libraries.
@@ -71,9 +75,9 @@ add_executable(test_AerodynamicsNamespace "${SRCROOT}${AERODYNAMICSDIR}/UnitTest
 setup_custom_test_program(test_AerodynamicsNamespace "${SRCROOT}${AERODYNAMICSDIR}")
 target_link_libraries(test_AerodynamicsNamespace tudat_aerodynamics ${Boost_LIBRARIES})
 
-add_executable(test_CoefficientGenerator "${SRCROOT}${AERODYNAMICSDIR}/UnitTests/unitTestCoefficientGenerator.cpp")
-setup_custom_test_program(test_CoefficientGenerator "${SRCROOT}${AERODYNAMICSDIR}")
-target_link_libraries(test_CoefficientGenerator tudat_aerodynamics tudat_geometric_shapes tudat_basic_mathematics ${Boost_LIBRARIES})
+add_executable(test_AerodynamicCoefficientGenerator "${SRCROOT}${AERODYNAMICSDIR}/UnitTests/unitTestCoefficientGenerator.cpp")
+setup_custom_test_program(test_AerodynamicCoefficientGenerator "${SRCROOT}${AERODYNAMICSDIR}")
+target_link_libraries(test_AerodynamicCoefficientGenerator tudat_aerodynamics tudat_geometric_shapes tudat_basic_mathematics ${Boost_LIBRARIES})
 
 add_executable(test_ExponentialAtmosphere "${SRCROOT}${AERODYNAMICSDIR}/UnitTests/unitTestExponentialAtmosphere.cpp")
 setup_custom_test_program(test_ExponentialAtmosphere "${SRCROOT}${AERODYNAMICSDIR}")
diff --git a/Tudat/Astrodynamics/Aerodynamics/UnitTests/unitTestAerodynamicMomentAndAerodynamicForce.cpp b/Tudat/Astrodynamics/Aerodynamics/UnitTests/unitTestAerodynamicMomentAndAerodynamicForce.cpp
index a45fa7b..3b43713 100644
--- a/Tudat/Astrodynamics/Aerodynamics/UnitTests/unitTestAerodynamicMomentAndAerodynamicForce.cpp
+++ b/Tudat/Astrodynamics/Aerodynamics/UnitTests/unitTestAerodynamicMomentAndAerodynamicForce.cpp
@@ -63,8 +63,7 @@
 #include <Eigen/Geometry>
 
 #include "Tudat/Basics/testMacros.h"
-
-#include "Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientInterface.h"
+#include "Tudat/Astrodynamics/Aerodynamics/customAerodynamicCoefficientInterface.h"
 #include "Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.h"
 #include "Tudat/Astrodynamics/Aerodynamics/aerodynamicRotationalAcceleration.h"
 
@@ -113,10 +112,9 @@ BOOST_AUTO_TEST_CASE( testAerodynamicForceAndAcceleration )
     {
         // Set coefficients and model parameters in aerodynamics coefficient interface object.
         AerodynamicCoefficientInterfacePointer aerodynamicCoefficientInterface =
-                boost::make_shared< AerodynamicCoefficientInterface >( );
-        aerodynamicCoefficientInterface->setCurrentForceCoefficients( forceCoefficients );
-        aerodynamicCoefficientInterface->setReferenceArea( referenceArea );
-        aerodynamicCoefficientInterface->setReferenceLength( referenceLength );
+                createConstantCoefficientAerodynamicCoefficientInterface(
+                    forceCoefficients, Eigen::Vector3d::Zero( ),
+                    referenceLength, referenceArea, referenceLength, Eigen::Vector3d::Zero( ) );
 
         // Compute aerodynamic force using free function with coefficient interface argument.
         Eigen::Vector3d force = computeAerodynamicForce( dynamicPressure,
@@ -124,6 +122,21 @@ BOOST_AUTO_TEST_CASE( testAerodynamicForceAndAcceleration )
 
         // Check if computed force matches expected.
         TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
+
+        // Test aerodynamic coefficient interface properties
+        BOOST_CHECK_EQUAL(
+                    aerodynamicCoefficientInterface->getIndependentVariableNames( ).size( ), 0 );
+
+        bool isVariableIndexTooHigh = 0;
+        try
+        {
+            aerodynamicCoefficientInterface->getIndependentVariableName( 0 );
+        }
+        catch ( std::runtime_error )
+        {
+            isVariableIndexTooHigh = 1;
+        }
+        BOOST_CHECK_EQUAL( isVariableIndexTooHigh, 1 );
     }
 
     // Test 3: test the acceleration model implemented as free function with primitive arguments,
@@ -131,10 +144,9 @@ BOOST_AUTO_TEST_CASE( testAerodynamicForceAndAcceleration )
     {
         // Set coefficients and model parameters in aerodynamics coefficient interface object.
         AerodynamicCoefficientInterfacePointer aerodynamicCoefficientInterface =
-                boost::make_shared< AerodynamicCoefficientInterface >( );
-        aerodynamicCoefficientInterface->setCurrentForceCoefficients( forceCoefficients );
-        aerodynamicCoefficientInterface->setReferenceArea( referenceArea );
-        aerodynamicCoefficientInterface->setReferenceLength( referenceLength );
+                createConstantCoefficientAerodynamicCoefficientInterface(
+                    forceCoefficients, Eigen::Vector3d::Zero( ),
+                    referenceLength, referenceArea, referenceLength, Eigen::Vector3d::Zero( ) );
 
         // Compute aerodynamic force from aerodynamic acceleration free function with primitive
         // arguments.
@@ -258,11 +270,9 @@ BOOST_AUTO_TEST_CASE( testAerodynamicMomentAndRotationalAcceleration )
     {
         // Set coefficients and model parameters in aerodynamics coefficient interface object.
         AerodynamicCoefficientInterfacePointer aerodynamicCoefficientInterface =
-                boost::make_shared< AerodynamicCoefficientInterface >( );
-        aerodynamicCoefficientInterface->setCurrentMomentCoefficients( momentCoefficients );
-        aerodynamicCoefficientInterface->setReferenceArea( referenceArea );
-        aerodynamicCoefficientInterface->setReferenceLength( referenceLength );
-        aerodynamicCoefficientInterface->setReferenceLength( referenceLength );
+        createConstantCoefficientAerodynamicCoefficientInterface(
+            Eigen::Vector3d::Zero( ), momentCoefficients,
+            referenceLength, referenceArea, referenceLength, Eigen::Vector3d::Zero( ) );
 
         // Compute aerodynamic moment using free function with coefficient interface argument.
         Eigen::Vector3d moment = computeAerodynamicMoment( dynamicPressure,
@@ -278,11 +288,9 @@ BOOST_AUTO_TEST_CASE( testAerodynamicMomentAndRotationalAcceleration )
     {
         // Set coefficients and model parameters in aerodynamics coefficient interface object.
         AerodynamicCoefficientInterfacePointer aerodynamicCoefficientInterface =
-                boost::make_shared< AerodynamicCoefficientInterface >( );
-        aerodynamicCoefficientInterface->setCurrentMomentCoefficients( momentCoefficients );
-        aerodynamicCoefficientInterface->setReferenceArea( referenceArea );
-        aerodynamicCoefficientInterface->setReferenceLength( referenceLength );
-        aerodynamicCoefficientInterface->setReferenceLength( referenceLength );
+                createConstantCoefficientAerodynamicCoefficientInterface(
+                    Eigen::Vector3d::Zero( ), momentCoefficients,
+                    referenceLength, referenceArea, referenceLength, Eigen::Vector3d::Zero( ) );
 
         // Compute aerodynamic moment from aerodynamic rotational acceleration free function with
         // primitive arguments.
diff --git a/Tudat/Astrodynamics/Aerodynamics/UnitTests/unitTestCoefficientGenerator.cpp b/Tudat/Astrodynamics/Aerodynamics/UnitTests/unitTestCoefficientGenerator.cpp
index 4ce3761..86844a3 100644
--- a/Tudat/Astrodynamics/Aerodynamics/UnitTests/unitTestCoefficientGenerator.cpp
+++ b/Tudat/Astrodynamics/Aerodynamics/UnitTests/unitTestCoefficientGenerator.cpp
@@ -54,6 +54,7 @@
 #include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
 
 #include "Tudat/Astrodynamics/Aerodynamics/hypersonicLocalInclinationAnalysis.h"
+#include "Tudat/Astrodynamics/Aerodynamics/customAerodynamicCoefficientInterface.h"
 #include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
 #include "Tudat/Mathematics/GeometricShapes/capsule.h"
 #include "Tudat/Mathematics/GeometricShapes/sphereSegment.h"
@@ -64,15 +65,17 @@ namespace unit_tests
 {
 
 using basic_mathematics::Vector6d;
+using mathematical_constants::PI;
+using std::vector;
+
+using namespace aerodynamics;
 
 BOOST_AUTO_TEST_SUITE( test_aerodynamic_coefficient_generator )
 
 //! Test coefficient generator.
 BOOST_AUTO_TEST_CASE( testAerodynamicCoefficientGenerator )
 {
-    using mathematical_constants::PI;
-    using std::vector;
-    using namespace aerodynamics;
+
 
     // Set units of coefficients
     const double expectedValueOfForceCoefficient = 1.0;
@@ -109,6 +112,8 @@ BOOST_AUTO_TEST_CASE( testAerodynamicCoefficientGenerator )
     independentVariableDataPoints[ 2 ] =
             getDefaultHypersonicLocalInclinationAngleOfSideslipPoints( );
 
+
+    // Set methods to use for aerodynamic analysis.
     std::vector< std::vector< int > > analysisMethod;
     analysisMethod.resize( 2 );
     analysisMethod[ 0 ].resize( 1 );
@@ -116,40 +121,148 @@ BOOST_AUTO_TEST_CASE( testAerodynamicCoefficientGenerator )
     analysisMethod[ 0 ][ 0 ] = 0;
     analysisMethod[ 1 ][ 0 ] = 1;
 
-    HypersonicLocalInclinationAnalysis analysis( independentVariableDataPoints, sphere,
-                                                 numberOfLines, numberOfPoints,
-                                                 invertOrder, analysisMethod, PI, 1.0,
-                                                 Eigen::Vector3d::Zero( ) );
+    // Generate sphere database of aerodynamic coefficients.
+    boost::shared_ptr< HypersonicLocalInclinationAnalysis > coefficientInterface =
+            boost::make_shared< HypersonicLocalInclinationAnalysis >(
+                independentVariableDataPoints, sphere,
+                numberOfLines, numberOfPoints,
+                invertOrder, analysisMethod, PI, 1.0,
+                Eigen::Vector3d::Zero( ) );
+
+    // Test basic properties of coefficient generator
+    BOOST_CHECK_EQUAL(
+                coefficientInterface->getIndependentVariableNames( ).size( ), 3 );
+    BOOST_CHECK_EQUAL( coefficientInterface->getIndependentVariableName( 0 ),
+                       mach_number_dependent );
+    BOOST_CHECK_EQUAL( coefficientInterface->getIndependentVariableName( 1 ),
+                       angle_of_attack_dependent );
+    BOOST_CHECK_EQUAL( coefficientInterface->getIndependentVariableName( 2 ),
+                       angle_of_sideslip_dependent );
+
+    bool isVariableIndexTooHigh = 0;
+    try
+    {
+        coefficientInterface->getIndependentVariableName( 3 );
+    }
+    catch ( std::runtime_error )
+    {
+        isVariableIndexTooHigh = 1;
+    }
+    BOOST_CHECK_EQUAL( isVariableIndexTooHigh, 1 );
 
-    // Generate sphere database.
-    analysis.generateCoefficients( );
 
     // Allocate memory for independent variables to pass to analysis for retrieval.
     boost::array< int, 3 > independentVariables;
     independentVariables[ 0 ] = 0;
     independentVariables[ 1 ] = 0;
     independentVariables[ 2 ] = 0;
+    std::vector< double > independentVariablesVector;
+    independentVariablesVector.resize( 3 );
+    std::vector< double > interpolatingIndependentVariablesVector;
+    interpolatingIndependentVariablesVector.resize( 3 );
 
     // Declare local test variables.
     Vector6d aerodynamicCoefficients_ = Vector6d::Zero( );
     double forceCoefficient_;
 
-    // Iterate over all angles of attack to verify sphere coefficients.
-    for ( int i = 0; i < analysis.getNumberOfValuesOfIndependentVariable( 0 ); i++ )
+    // Iterate over all angles of attack to verify sphere coefficients. Total force coefficient
+    // should be one; all moment coefficients should be zero.
+    // The functionality is tested directly from the generator, as well as from the
+    // coefficient interface, both interpolated at the nodes, and halfway between the nodes.
+    for ( int i = 0; i < coefficientInterface->getNumberOfValuesOfIndependentVariable( 0 ); i++ )
     {
         independentVariables[ 0 ] = i;
+        independentVariablesVector[ 0 ] = coefficientInterface->getIndependentVariablePoint( 0, i );
+        if( i < coefficientInterface->getNumberOfValuesOfIndependentVariable( 0 ) - 1 )
+        {
+            interpolatingIndependentVariablesVector[ 0 ] =
+                    coefficientInterface->getIndependentVariablePoint( 0, i ) + 0.5 * (
+                        coefficientInterface->getIndependentVariablePoint( 0, i + 1 ) -
+                        coefficientInterface->getIndependentVariablePoint( 0, i ) );
+        }
+
 
-        for ( int j = 0; j < analysis.getNumberOfValuesOfIndependentVariable( 1 ); j++ )
+        for ( int j = 0; j <
+              coefficientInterface->getNumberOfValuesOfIndependentVariable( 1 ); j++ )
         {
             independentVariables[ 1 ] = j;
+            independentVariablesVector[ 1 ] =
+                    coefficientInterface->getIndependentVariablePoint( 1, j );
+            if( j < coefficientInterface->getNumberOfValuesOfIndependentVariable( 1 ) - 1 )
+            {
+                interpolatingIndependentVariablesVector[ 1 ] =
+                        coefficientInterface->getIndependentVariablePoint( 1, j ) + 0.5 * (
+                            coefficientInterface->getIndependentVariablePoint( 1, j + 1 ) -
+                            coefficientInterface->getIndependentVariablePoint( 1, j ) );
+            }
 
-            for ( int k = 0; k < analysis.getNumberOfValuesOfIndependentVariable( 2 ); k++ )
+            for ( int k = 0; k <
+                  coefficientInterface->getNumberOfValuesOfIndependentVariable( 2 ); k++ )
             {
                 independentVariables[ 2 ] = k;
+                independentVariablesVector[ 2 ] =
+                        coefficientInterface->getIndependentVariablePoint( 2, k );
+                if( k < coefficientInterface->getNumberOfValuesOfIndependentVariable( 2 ) - 1 )
+                {
+                    interpolatingIndependentVariablesVector[ 2 ] =
+                            coefficientInterface->getIndependentVariablePoint( 2, k ) + 0.5 * (
+                                coefficientInterface->getIndependentVariablePoint( 2, k + 1 ) -
+                                coefficientInterface->getIndependentVariablePoint( 2, k ) );
+                }
 
                 // Retrieve aerodynamic coefficients.
-                aerodynamicCoefficients_ = analysis.getAerodynamicCoefficients(
-                        independentVariables );
+                aerodynamicCoefficients_ =
+                        coefficientInterface->getAerodynamicCoefficientsDataPoint(
+                            independentVariables );
+                forceCoefficient_ = ( aerodynamicCoefficients_.head( 3 ) ).norm( );
+
+                // Test if the computed force coefficient corresponds to the expected value
+                // within the specified tolerance.
+                BOOST_CHECK_CLOSE_FRACTION( forceCoefficient_,
+                                            expectedValueOfForceCoefficient,
+                                            toleranceForceCoefficient );
+
+                // Test if the computed moment coefficients correspond to the expected value (0.0)
+                // within the specified tolerance.
+                BOOST_CHECK_SMALL( aerodynamicCoefficients_( 3 ),
+                                   toleranceAerodynamicCoefficients3 );
+
+                BOOST_CHECK_SMALL( aerodynamicCoefficients_( 4 ),
+                                   toleranceAerodynamicCoefficients4 );
+
+                BOOST_CHECK_SMALL( aerodynamicCoefficients_( 5 ),
+                                   toleranceAerodynamicCoefficients5 );
+
+                // Retrieve aerodynamic coefficients from coefficient interface.
+                coefficientInterface->updateCurrentCoefficients( independentVariablesVector );
+
+                aerodynamicCoefficients_ =
+                        coefficientInterface->getCurrentAerodynamicCoefficients( );
+                forceCoefficient_ = ( aerodynamicCoefficients_.head( 3 ) ).norm( );
+
+                // Test if the computed force coefficient corresponds to the expected value
+                // within the specified tolerance.
+                BOOST_CHECK_CLOSE_FRACTION( forceCoefficient_,
+                                            expectedValueOfForceCoefficient,
+                                            toleranceForceCoefficient );
+
+                // Test if the computed moment coefficients correspond to the expected value (0.0)
+                // within the specified tolerance.
+                BOOST_CHECK_SMALL( aerodynamicCoefficients_( 3 ),
+                                   toleranceAerodynamicCoefficients3 );
+
+                BOOST_CHECK_SMALL( aerodynamicCoefficients_( 4 ),
+                                   toleranceAerodynamicCoefficients4 );
+
+                BOOST_CHECK_SMALL( aerodynamicCoefficients_( 5 ),
+                                   toleranceAerodynamicCoefficients5 );
+
+                // Retrieve aerodynamic coefficients from coefficient interface.
+                coefficientInterface->updateCurrentCoefficients(
+                            interpolatingIndependentVariablesVector );
+
+                aerodynamicCoefficients_ =
+                        coefficientInterface->getCurrentAerodynamicCoefficients( );
                 forceCoefficient_ = ( aerodynamicCoefficients_.head( 3 ) ).norm( );
 
                 // Test if the computed force coefficient corresponds to the expected value
@@ -176,10 +289,6 @@ BOOST_AUTO_TEST_CASE( testAerodynamicCoefficientGenerator )
 //! Apollo capsule test case.
 BOOST_AUTO_TEST_CASE( testApolloCapsule )
 {
-    using mathematical_constants::PI;
-    using std::vector;
-    using namespace aerodynamics;
-
     // Set units of coefficients.
     const double expectedValueOfAerodynamicCoefficients0 = -1.51;
     const double expectedValueOfAerodynamicCoefficients4 = -0.052;
@@ -195,7 +304,7 @@ BOOST_AUTO_TEST_CASE( testApolloCapsule )
     // Create test capsule.
     boost::shared_ptr< geometric_shapes::Capsule > capsule
             = boost::make_shared< geometric_shapes::Capsule >(
-                    4.694, 1.956, 2.662, -1.0 * 33.0 * PI / 180.0, 0.196 );
+                4.694, 1.956, 2.662, -1.0 * 33.0 * PI / 180.0, 0.196 );
 
     vector< int > numberOfLines;
     vector< int > numberOfPoints;
@@ -251,25 +360,59 @@ BOOST_AUTO_TEST_CASE( testApolloCapsule )
     selectedMethods[ 1 ][ 2 ] = 3;
     selectedMethods[ 1 ][ 3 ] = 3;
 
-    // Create analysis object.
-    HypersonicLocalInclinationAnalysis analysis = HypersonicLocalInclinationAnalysis(
+    // Create analysis object and capsule database.
+    boost::shared_ptr< HypersonicLocalInclinationAnalysis > coefficientInterface =
+            boost::make_shared< HypersonicLocalInclinationAnalysis >(
                 independentVariableDataPoints, capsule, numberOfLines, numberOfPoints,
                 invertOrders, selectedMethods, PI * pow( capsule->getMiddleRadius( ), 2.0 ),
                 3.9116, momentReference );
 
-    // Generate capsule database.
-    analysis.generateCoefficients( );
-
     // Retrieve coefficients at zero angle of attack for comparison.
     boost::array< int, 3 > independentVariables;
 
-    independentVariables[ 0 ] = analysis.getNumberOfValuesOfIndependentVariable( 0 ) - 1;
+    independentVariables[ 0 ] =
+            coefficientInterface->getNumberOfValuesOfIndependentVariable( 0 ) - 1;
     independentVariables[ 1 ] = 6;
     independentVariables[ 2 ] = 0;
 
     // Declare local test variables.
     Eigen::VectorXd aerodynamicCoefficients_;
-    aerodynamicCoefficients_ = analysis.getAerodynamicCoefficients( independentVariables );
+    aerodynamicCoefficients_ = coefficientInterface->getAerodynamicCoefficientsDataPoint(
+                independentVariables );
+
+    // Compare values to database values.
+    BOOST_CHECK_SMALL(
+                aerodynamicCoefficients_( 0 ) - expectedValueOfAerodynamicCoefficients0,
+                toleranceAerodynamicCoefficients0 );
+
+    BOOST_CHECK_SMALL( aerodynamicCoefficients_( 1 ),
+                       toleranceAerodynamicCoefficients1 );
+
+    BOOST_CHECK_SMALL( aerodynamicCoefficients_( 2 ),
+                       toleranceAerodynamicCoefficients2 );
+
+    BOOST_CHECK_SMALL( aerodynamicCoefficients_( 3 ),
+                       toleranceAerodynamicCoefficients3 );
+
+    BOOST_CHECK_SMALL(
+                aerodynamicCoefficients_( 4 ) - expectedValueOfAerodynamicCoefficients4,
+                toleranceAerodynamicCoefficients4 );
+
+    BOOST_CHECK_SMALL( aerodynamicCoefficients_( 5 ),
+                       toleranceAerodynamicCoefficients5 );
+
+
+    std::vector< double > independentVariablesVector;
+    independentVariablesVector.resize( 3 );
+    independentVariablesVector[ 0 ] = coefficientInterface->getIndependentVariablePoint(
+                0, coefficientInterface->getNumberOfValuesOfIndependentVariable( 0 ) - 1 );
+    independentVariablesVector[ 1 ] = coefficientInterface->getIndependentVariablePoint(
+                1, 6 );
+    independentVariablesVector[ 2 ] = coefficientInterface->getIndependentVariablePoint(
+                2, 0 );
+
+    coefficientInterface->updateCurrentCoefficients( independentVariablesVector );
+    aerodynamicCoefficients_ = coefficientInterface->getCurrentAerodynamicCoefficients( );
 
     // Compare values to database values.
     BOOST_CHECK_SMALL(
diff --git a/Tudat/Astrodynamics/Aerodynamics/UnitTests/unitTestExponentialAtmosphere.cpp b/Tudat/Astrodynamics/Aerodynamics/UnitTests/unitTestExponentialAtmosphere.cpp
index 84c20f6..c51863b 100644
--- a/Tudat/Astrodynamics/Aerodynamics/UnitTests/unitTestExponentialAtmosphere.cpp
+++ b/Tudat/Astrodynamics/Aerodynamics/UnitTests/unitTestExponentialAtmosphere.cpp
@@ -74,14 +74,8 @@ BOOST_AUTO_TEST_CASE( testExponentialAtmosphereGetSet )
     const double scaleHeight = 7.050e3;
 
     // Create an exponential atmosphere object.
-    aerodynamics::ExponentialAtmosphere exponentialAtmosphere;
-
-    // Initialize the exponential atmosphere.
-    exponentialAtmosphere.setConstantTemperature( constantTemperature );
-    exponentialAtmosphere.setDensityAtZeroAltitude( densityAtZeroAltitude );
-    exponentialAtmosphere.setScaleHeight( scaleHeight );
-    exponentialAtmosphere.setSpecificGasConstant(
-                    physical_constants::SPECIFIC_GAS_CONSTANT_AIR );
+    aerodynamics::ExponentialAtmosphere exponentialAtmosphere(
+                scaleHeight, constantTemperature, densityAtZeroAltitude );
 
     BOOST_CHECK_EQUAL( constantTemperature, exponentialAtmosphere.getConstantTemperature( ) );
     BOOST_CHECK_EQUAL( densityAtZeroAltitude, exponentialAtmosphere.getDensityAtZeroAltitude( ) );
@@ -102,14 +96,8 @@ BOOST_AUTO_TEST_CASE( testExponentialAtmosphereSeaLevel )
     const double pressureAtZeroAltitude = 101325.0;
 
     // Create an exponential atmosphere object.
-    aerodynamics::ExponentialAtmosphere exponentialAtmosphere;
-
-    // Initialize the exponential atmosphere.
-    exponentialAtmosphere.setConstantTemperature( constantTemperature );
-    exponentialAtmosphere.setDensityAtZeroAltitude( densityAtZeroAltitude );
-    exponentialAtmosphere.setScaleHeight( scaleHeight );
-    exponentialAtmosphere.setSpecificGasConstant(
-                    physical_constants::SPECIFIC_GAS_CONSTANT_AIR );
+    aerodynamics::ExponentialAtmosphere exponentialAtmosphere(
+                scaleHeight, constantTemperature, densityAtZeroAltitude );
 
     // Declare tolerance used for Boost tests.
     const double tolerance = std::numeric_limits< double >::epsilon( );
@@ -138,14 +126,8 @@ BOOST_AUTO_TEST_CASE( testExponentialAtmosphereAt10km )
     double time = 0.0;
 
     // Create an exponential atmosphere object.
-    aerodynamics::ExponentialAtmosphere exponentialAtmosphere;
-
-    // Initialize the exponential atmosphere.
-    exponentialAtmosphere.setConstantTemperature( constantTemperature );
-    exponentialAtmosphere.setDensityAtZeroAltitude( densityAtZeroAltitude );
-    exponentialAtmosphere.setScaleHeight( scaleHeight );
-    exponentialAtmosphere.setSpecificGasConstant(
-                    physical_constants::SPECIFIC_GAS_CONSTANT_AIR );
+    aerodynamics::ExponentialAtmosphere exponentialAtmosphere(
+                scaleHeight, constantTemperature, densityAtZeroAltitude );
 
     // Declare and set expected density.
     const double expectedDensity  = densityAtZeroAltitude * std::exp ( -altitude / scaleHeight );
@@ -178,14 +160,8 @@ BOOST_AUTO_TEST_CASE( testExponentialAtmospherePositionIndependentFunctions )
     double time = 0.0;
 
     // Create an exponential atmosphere object.
-    aerodynamics::ExponentialAtmosphere exponentialAtmosphere;
-
-    // Initialize the exponential atmosphere.
-    exponentialAtmosphere.setConstantTemperature( constantTemperature );
-    exponentialAtmosphere.setDensityAtZeroAltitude( densityAtZeroAltitude );
-    exponentialAtmosphere.setScaleHeight( scaleHeight );
-    exponentialAtmosphere.setSpecificGasConstant(
-                    physical_constants::SPECIFIC_GAS_CONSTANT_AIR );
+    aerodynamics::ExponentialAtmosphere exponentialAtmosphere(
+                scaleHeight, constantTemperature, densityAtZeroAltitude );
 
     const double density1 = exponentialAtmosphere.getDensity( altitude );
     const double density2 = exponentialAtmosphere.getDensity( altitude, longitude, latitude,
diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.cpp b/Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.cpp
new file mode 100644
index 0000000..343655a
--- /dev/null
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.cpp
@@ -0,0 +1,68 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      110617    D. Dirkx          File created.
+ *      120324    K. Kumar          Minor Doxygen comment corrections, added astrodynamics
+ *                                  namespace layer; added missing Eigen include-statement.
+ *      121020    D. Dirkx          Update to new acceleration model architecture.
+ *      130120    K. Kumar          Added shared pointer to AerodynamicAcceleration object.
+ *      140129    D. Dirkx          Changed Doxygen descriptions
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#include "Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.h"
+
+namespace tudat
+{
+namespace aerodynamics
+{
+
+//! Compute the aerodynamic acceleration in same reference frame as input coefficients.
+Eigen::Vector3d computeAerodynamicAcceleration( const double dynamicPressure,
+                                                const double referenceArea,
+                                                const Eigen::Vector3d& aerodynamicCoefficients,
+                                                const double vehicleMass )
+{
+    return computeAerodynamicForce( dynamicPressure, referenceArea, aerodynamicCoefficients )
+            / vehicleMass;
+}
+
+//! Compute the aerodynamic acceleration in same reference frame as input coefficients.
+Eigen::Vector3d computeAerodynamicAcceleration(
+        const double dynamicPressure,
+        AerodynamicCoefficientInterfacePointer coefficientInterface,
+        const double vehicleMass )
+{
+    return computeAerodynamicForce( dynamicPressure, coefficientInterface ) / vehicleMass;
+}
+
+
+} // namespace aerodynamics
+} // namespace tudat
diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.h b/Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.h
index 16be456..cbecef3 100644
--- a/Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.h
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.h
@@ -70,11 +70,7 @@ namespace aerodynamics
 Eigen::Vector3d computeAerodynamicAcceleration( const double dynamicPressure,
                                                 const double referenceArea,
                                                 const Eigen::Vector3d& aerodynamicCoefficients,
-                                                const double vehicleMass )
-{
-    return computeAerodynamicForce( dynamicPressure, referenceArea, aerodynamicCoefficients )
-            / vehicleMass;
-}
+                                                const double vehicleMass );
 
 //! Compute the aerodynamic acceleration in same reference frame as input coefficients.
 /*!
@@ -92,10 +88,7 @@ Eigen::Vector3d computeAerodynamicAcceleration( const double dynamicPressure,
 Eigen::Vector3d computeAerodynamicAcceleration(
         const double dynamicPressure,
         AerodynamicCoefficientInterfacePointer coefficientInterface,
-        const double vehicleMass )
-{
-    return computeAerodynamicForce( dynamicPressure, coefficientInterface ) / vehicleMass;
-}
+        const double vehicleMass );
 
 //! Class for calculation of aerodynamic accelerations.
 /*!
diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientGenerator.h b/Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientGenerator.h
index 3cc7ae9..bbb94cb 100644
--- a/Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientGenerator.h
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientGenerator.h
@@ -57,6 +57,8 @@
 #include <Eigen/Core>
 
 #include "Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientInterface.h"
+#include "Tudat/Mathematics/Interpolators/multiLinearInterpolator.h"
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
 
 namespace tudat
 {
@@ -69,7 +71,7 @@ namespace aerodynamics
  * and data points of independent variables. Coefficients are stored in a multi_array of pointers.
  */
 template< int NumberOfIndependentVariables, int NumberOfCoefficients = 6 >
-class AerodynamicCoefficientGenerator
+class AerodynamicCoefficientGenerator: public AerodynamicCoefficientInterface
 {
 public:
 
@@ -81,20 +83,37 @@ public:
      *  the data points of each of the independent variables for the coefficient generation.
      *  The number of subvectors must be equal to the number of independent variables. It is
      *  recommended that each of the subvectors is sorted in ascending order.
-     *  \param referenceArea Reference area used to non-dimensionalize aerodynamic forces
-     *  and moments.
-     *  \param referenceLength Reference length used to non-dimensionalize aerodynamic moments.
-     *  \param momentReferencePoint Reference point wrt which aerodynamic moments are calculated.
+     *  \param referenceLength Reference length with which aerodynamic moments (about x- and
+     *  z- axes) are non-dimensionalized.
+     *  \param referenceArea Reference area with which aerodynamic forces and moments are
+     *  non-dimensionalized.
+     *  \param lateralReferenceLength Reference length with which aerodynamic moments (about y-axis)
+     *  is non-dimensionalized.
+     *  \param momentReferencePoint Point w.r.t. aerodynamic moment is calculated
+     *  \param independentVariableNames Vector with identifiers the physical meaning of each
+     *  independent variable of the aerodynamic coefficients.
+     *  \param areCoefficientsInAerodynamicFrame Boolean to define whether the aerodynamic
+     *  coefficients are defined in the aerodynamic frame (lift, drag, side force) or in the body
+     *  frame (typically denoted as Cx, Cy, Cz).
+     *  \param areCoefficientsInNegativeAxisDirection Boolean to define whether the aerodynamic
+     *  coefficients are positiver along tyhe positive axes of the body or aerodynamic frame
+     *  (see areCoefficientsInAerodynamicFrame). Note that for (lift, drag, side force), the
+     *  coefficients are typically defined in negative direction.
      */
     AerodynamicCoefficientGenerator(
             const std::vector< std::vector< double > >& dataPointsOfIndependentVariables,
-            const double referenceArea,
             const double referenceLength,
-            const Eigen::Vector3d momentReferencePoint ):
-        dataPointsOfIndependentVariables_( dataPointsOfIndependentVariables ),
-        referenceArea_( referenceArea ),
-        referenceLength_( referenceLength ),
-        momentReferencePoint_( momentReferencePoint )
+            const double referenceArea,
+            const double lateralReferenceLength,
+            const Eigen::Vector3d& momentReferencePoint,
+            const std::vector< AerodynamicCoefficientsIndependentVariables > independentVariableNames,
+            const bool areCoefficientsInAerodynamicFrame = 1,
+            const bool areCoefficientsInNegativeAxisDirection = 1  ):
+        AerodynamicCoefficientInterface(
+            referenceLength, referenceArea, lateralReferenceLength, momentReferencePoint,
+            independentVariableNames, areCoefficientsInAerodynamicFrame,
+            areCoefficientsInNegativeAxisDirection ),
+        dataPointsOfIndependentVariables_( dataPointsOfIndependentVariables )
     {
         // Check that the size of dataPointsOfIndependentVariables matches the template parameter.
         assert( dataPointsOfIndependentVariables_.size( ) == NumberOfIndependentVariables );
@@ -149,9 +168,62 @@ public:
      * dataPointsOfIndependentVariables_ for which to retrieve aerodynamic coefficients.
      * \return vector of coefficients at specified independent variable indices.
      */
-    virtual Eigen::Matrix< double, NumberOfCoefficients, 1 > getAerodynamicCoefficients(
+    virtual Eigen::Matrix< double, NumberOfCoefficients, 1 > getAerodynamicCoefficientsDataPoint(
             const boost::array< int, NumberOfIndependentVariables > independentVariables ) = 0;
 
+    //! Function to return the complete set of aerodynamic coefficients that have been calculated.
+    /*!
+     *  Function to return the complete set of aerodynamic coefficients that have been calculated.
+     *  \return Complete set of aerodynamic coefficients that have been calculated.
+     */
+    boost::multi_array< Eigen::Matrix< double, NumberOfCoefficients, 1 >,
+    NumberOfIndependentVariables > getAerodynamicCoefficientsTables( )
+    {
+        return aerodynamicCoefficients_;
+    }
+\
+    //! Get the data points of the independent variables at which the coefficients are calculated.
+    /*!
+     *  Get the data points of the independent variables at which the coefficients are calculated.
+     *  The aerodynamic coefficients are calculated each set of combinations of the independent
+     *  variables.
+     *  \return Data points of the independent variables at which the coefficients are calculated.
+     */
+    std::vector< std::vector< double > > getDataPointsOfIndependentVariables( )
+    {
+        return dataPointsOfIndependentVariables_;
+    }
+
+    //! Compute the aerodynamic coefficients at current flight condition.
+    /*!
+     *  Compute the aerodynamic coefficients at current flight conditions (independent variables).
+     *  Input is a set of independent variables (doubles) which represent the variables from which
+     *  the coefficients are calculated. The physical nature of these variables depends on
+     *  the coefficientFunction_ variables. The size of the independent variable vector must be
+     *  numberOfIndependentVariables_
+     *  \param independentVariables Independent variables of force and moment coefficient
+     *  determination implemented by derived class
+     */
+    virtual void updateCurrentCoefficients( const std::vector< double >& independentVariables )
+    {
+        // Check if the correct number of aerodynamic coefficients is provided.
+        if( independentVariables.size( ) != numberOfIndependentVariables_ )
+        {
+            throw std::runtime_error(
+                        "Error in AerodynamicCoefficientGenerator, number of "
+                        "input variables is inconsistent " );
+        }
+
+        // Update current coefficients.
+        basic_mathematics::Vector6d currentCoefficients = coefficientInterpolator_->interpolate(
+                    independentVariables );
+        currentForceCoefficients_ = currentCoefficients.segment( 0, 3 );
+        currentMomentCoefficients_ = currentCoefficients.segment( 3, 3 );
+    }
+
+protected:
+
+
     //! Generate aerodynamic coefficients.
     /*!
      * Virtual function to generate aerodynamic coefficients for the list of independent variables
@@ -159,38 +231,41 @@ public:
      */
     virtual void generateCoefficients( ) = 0;
 
-protected:
+    //! Function to create the coefficient interpolator from the discrete set in
+    //! aerodynamicCoefficients_
+    void createInterpolator( )
+    {
+        // Create interpolator for coefficients.
+        coefficientInterpolator_ =
+                boost::make_shared< interpolators::MultiLinearInterpolator< double,
+                basic_mathematics::Vector6d, 3 > >
+                ( dataPointsOfIndependentVariables_, aerodynamicCoefficients_ );
+
+    }
 
-    //! List of pointers to VectorXds containing coefficients.
+    //! N-dimensional array containing all computer aerodynamic coefficients.
     /*!
-     * List of pointers to VectorXds containing coefficients.
+     *  N-dimensional array containing all computer aerodynamic coefficients. The k-th dimension
+     *  pertains to coefficients at the k-th independent variable, the data points for which are
+     *  defined by dataPointsOfIndependentVariables_ and the physical meaning of which are defined
+     *  by independentVariableNames_
      */
     boost::multi_array< Eigen::Matrix< double, NumberOfCoefficients, 1 >,
     NumberOfIndependentVariables > aerodynamicCoefficients_;
 
-    //! Array of arrays of data points for independent variables.
+    //! Data points of the independent variables at which the coefficients are calculated.
     /*!
-     * Array of arrays of data points for independent variables.
+     *  Data points of the independent variables at which the coefficients are calculated. The
+     *  k-th vector contains the vector of data points to which the k-th independent variables
+     *  (defined by independentVariableNames_) are set during the calculation of the aerodynamic
+     *  coefficients.
      */
     std::vector< std::vector< double > > dataPointsOfIndependentVariables_;
 
-    //! Aerodynamic reference area.
-    /*!
-     * Reference area with which aerodynamic forces and moments are non-dimensionalized.
-     */
-    double referenceArea_;
-
-    //! Aerodynamic reference length.
-    /*!
-     * Reference length with which aerodynamic moments are non-dimensionalized.
-     */
-    double referenceLength_;
-
-    //! Aerodynamic moment reference point.
-    /*!
-     * Point w.r.t. which the arm of the moment on a vehicle panel is determined.
-     */
-    Eigen::Vector3d momentReferencePoint_;
+    //! Interpolator producing continuous aerodynamic coefficients from the discrete calculations
+    //! contained in aerodynamicCoefficients_.
+    boost::shared_ptr< interpolators::Interpolator< double, basic_mathematics::Vector6d > >
+            coefficientInterpolator_;
 };
 
 } // namespace aerodynamics
diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientInterface.h b/Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientInterface.h
index 71ebdf9..3436a25 100644
--- a/Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientInterface.h
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientInterface.h
@@ -41,7 +41,11 @@
 #ifndef TUDAT_AERODYNAMIC_COEFFICIENT_INTERFACE_H
 #define TUDAT_AERODYNAMIC_COEFFICIENT_INTERFACE_H
 
+#include <stdexcept>
+#include <vector>
+
 #include <boost/shared_ptr.hpp>
+#include <boost/lexical_cast.hpp>
 
 #include <Eigen/Core>
 
@@ -50,6 +54,21 @@ namespace tudat
 namespace aerodynamics
 {
 
+//! Enum defining a list of independent variables on which the aerodynamic coefficients can depend.
+/*!
+ *  Enum defining a list of independent variables on which the aerodynamic coefficients can depend.
+ *  Note that for a custom coefficient interface with other variables, you may use the
+ *  undefined_independent_variable variable type, but at the expense of being able to use the
+ *  FlightConditions class to automatically update the aerodynamic coefficients during propagation.
+ */
+enum AerodynamicCoefficientsIndependentVariables
+{
+    mach_number_dependent = 0,
+    angle_of_attack_dependent = 1,
+    angle_of_sideslip_dependent = 2,
+    undefined_independent_variable = 3
+};
+
 //! Base class to hold an aerodynamic coefficient interface.
 /*!
  * This interface can, for instance, be a database of coefficients or an aerodynamic analysis code
@@ -59,14 +78,45 @@ class AerodynamicCoefficientInterface
 {
 public:
 
-    //! Default constructor.
+    //! Constructor.
     /*!
-     * Default constructor.
+     *  Constructor, sets quantities common to all derived class aerodynamic coefficient interfaces.
+     *  \param referenceLength Reference length with which aerodynamic moments
+     *  (about x- and z- axes) are non-dimensionalized.
+     *  \param referenceArea Reference area with which aerodynamic forces and moments are
+     *  non-dimensionalized.
+     *  \param lateralReferenceLength Reference length with which aerodynamic moments (about y-axis)
+     *  is non-dimensionalized.
+     *  \param momentReferencePoint Point w.r.t. aerodynamic moment is calculated
+     *  \param independentVariableNames Vector with identifiers the physical meaning of each
+     *  independent variable of the aerodynamic coefficients.
+     *  \param areCoefficientsInAerodynamicFrame Boolean to define whether the aerodynamic
+     *  coefficients are defined in the aerodynamic frame (lift, drag, side force) or in the body
+     *  frame (typically denoted as Cx, Cy, Cz).
+     *  \param areCoefficientsInNegativeAxisDirection Boolean to define whether the aerodynamic
+     *  coefficients are positive along tyhe positive axes of the body or aerodynamic frame
+     *  (see areCoefficientsInAerodynamicFrame). Note that for (lift, drag, side force), the
+     *  coefficients are typically defined in negative direction.
      */
-    AerodynamicCoefficientInterface( ) : currentForceCoefficients_( Eigen::Vector3d::Zero( ) ),
-        currentMomentCoefficients_( Eigen::Vector3d::Zero( ) ), referenceLength_( -0.0 ),
-        referenceArea_( -0.0 ), lateralReferenceLength_( -0.0 ),
-        momentReferencePoint_( Eigen::Vector3d::Zero( ) ) { }
+    AerodynamicCoefficientInterface(
+            const double referenceLength,
+            const double referenceArea,
+            const double lateralReferenceLength,
+            const Eigen::Vector3d& momentReferencePoint,
+            const std::vector< AerodynamicCoefficientsIndependentVariables >
+            independentVariableNames,
+            const bool areCoefficientsInAerodynamicFrame = 1,
+            const bool areCoefficientsInNegativeAxisDirection = 1 ):
+        referenceLength_( referenceLength ),
+        referenceArea_( referenceArea ),
+        lateralReferenceLength_( lateralReferenceLength ),
+        momentReferencePoint_( momentReferencePoint ),
+        independentVariableNames_( independentVariableNames ),
+        areCoefficientsInAerodynamicFrame_( areCoefficientsInAerodynamicFrame ),
+        areCoefficientsInNegativeAxisDirection_( areCoefficientsInNegativeAxisDirection )\
+    {
+        numberOfIndependentVariables_ = independentVariableNames.size( );
+    }
 
     //! Default destructor.
     /*!
@@ -74,13 +124,6 @@ public:
      */
     virtual ~AerodynamicCoefficientInterface( ) { }
 
-    //! Set reference area.
-    /*!
-     * Sets reference area used to non-dimensionalize aerodynamic forces and moments.
-     * \param referenceArea Aerodynamic reference area.
-     */
-    void setReferenceArea( double referenceArea ) { referenceArea_ = referenceArea; }
-
     //! Get reference area.
     /*!
      * Returns reference area used to non-dimensionalize aerodynamic forces and moments.
@@ -88,13 +131,6 @@ public:
      */
     double getReferenceArea( ) { return referenceArea_; }
 
-    //! Set reference length.
-    /*!
-     * Sets reference length used to non-dimensionalize aerodynamic moments.
-     * \param referenceLength Aerodynamic reference length.
-     */
-    void setReferenceLength( double referenceLength ) { referenceLength_ = referenceLength; }
-
     //! Get reference length.
     /*!
      * Returns reference length used to non-dimensionalize aerodynamic moments.
@@ -102,16 +138,6 @@ public:
      */
     double getReferenceLength( ) { return referenceLength_; }
 
-    //! Set lateral reference length.
-    /*!
-     * Sets lateral reference length used to non-dimensionalize aerodynamic moments.
-     * \param lateralReferenceLength Aerodynamic reference length.
-     */
-    void setLateralReferenceLength( double lateralReferenceLength )
-    {
-        lateralReferenceLength_ = lateralReferenceLength;
-    }
-
     //! Get lateral reference length.
     /*!
      * Returns lateral reference length used to non-dimensionalize aerodynamic moments.
@@ -119,17 +145,6 @@ public:
      */
     double getLateralReferenceLength( ) { return lateralReferenceLength_; }
 
-    //! Set moment reference point.
-    /*!
-     * Sets the point w.r.t. which the arm of the aerodynamic moment on a vehicle panel is
-     * determined.
-     * \param momentReferencePoint Aerodynamic moment reference point.
-     */
-    void setMomentReferencePoint( const Eigen::Vector3d& momentReferencePoint )
-    {
-        momentReferencePoint_ = momentReferencePoint;
-    }
-
     //! Get moment reference point.
     /*!
      * Returns the point w.r.t. which the arm of the aerodynamic moment on a vehicle panel is
@@ -138,51 +153,98 @@ public:
      */
     Eigen::VectorXd getMomentReferencePoint( ) { return momentReferencePoint_; }
 
-    //! Get the current force coefficients.
+    //! Compute the aerodynamic coefficients at current flight condition.
+    /*!
+     *  Computes the current force and moment coefficients and is to be
+     *  implemented in derived classes. Input is a set of independent variables
+     *  (doubles) which represent the variables from which the coefficients are calculated
+     *  \param independentVariables Independent variables of force and moment coefficient
+     *  determination implemented by derived class
+     */
+    virtual void updateCurrentCoefficients( const std::vector< double >& independentVariables ) = 0;
+
+    //! Pure virtual function for calculating and returning aerodynamic force coefficients
     /*!
-     * Returns the force coefficients that have been set as the 'current' force coefficients,
-     * i.e. at the current flight condition.
-     * \return current force coefficients.
+     *  Pure virtual function for calculating and returning aerodynamic force coefficients.
+     *  \return Force coefficients at current independent variables
      */
-    Eigen::Vector3d getCurrentForceCoefficients( ) { return currentForceCoefficients_; }
+    Eigen::Vector3d getCurrentForceCoefficients( )
+    {
+        return currentForceCoefficients_;
+    }
 
-    //! Get the moment coefficients
+    //! Pure virtual function for calculating and returning aerodynamic moment coefficients
     /*!
-     * Return the moment coefficients that have been set as the 'current' moment coefficients,
-     * i.e. at the current flight condition.
-     * \return current moment coefficients.
+     *  Pure virtual function for calculating and returning aerodynamic moment coefficients.
+     *  \return Moment coefficients at current independent variables
      */
-    Eigen::Vector3d getCurrentMomentCoefficients( ) { return currentMomentCoefficients_; }
+    Eigen::Vector3d getCurrentMomentCoefficients( )
+    {
+        return currentMomentCoefficients_;
+    }
 
-    //! Set the force coefficients.
+    //! Function for calculating and returning aerodynamic force and moment coefficients
     /*!
-     * Sets the current force coefficients, i.e. at the current flight condition.
-     * \param currentForceCoefficients the current force coefficients.
+     *  Function for calculating and returning aerodynamic force and moment coefficients
+     *  \return Force and moment coefficients at given independent variables
      */
-    void setCurrentForceCoefficients( const Eigen::Vector3d& currentForceCoefficients )
+    Eigen::Matrix< double, 6, 1 > getCurrentAerodynamicCoefficients(  )
     {
-        currentForceCoefficients_ = currentForceCoefficients;
+        Eigen::Matrix< double, 6, 1 > coefficients;
+        coefficients.segment( 0, 3 ) = getCurrentForceCoefficients( );
+        coefficients.segment( 3, 3 ) = getCurrentMomentCoefficients( );
+        return coefficients;
     }
 
-    //! Set the moment coefficients.
+    //! Function to return the identifiers of the physical meaning of each independent variable.
     /*!
-     * Sets the current moment coefficients, i.e. at the current flight condition.
-     * \param currentMomentCoefficients the current force coefficients.
+     *  Function to return the identifiers of the physical meaning of each independent variable
+     *  of the aerodynamic coefficient interface.
+     *  \return A vector with the identifiers of the physical meaning of each independent variable.
      */
-    void setCurrentMomentCoefficients( const Eigen::Vector3d& currentMomentCoefficients )
+    std::vector< AerodynamicCoefficientsIndependentVariables > getIndependentVariableNames( )
     {
-        currentMomentCoefficients_ = currentMomentCoefficients;
+        return independentVariableNames_;
     }
 
-    //! Compute the aerodynamic coefficients at current flight condition.
+    //! Function to return a single identifier of the physical meaning of one independent variable.
+    /*!
+     *  Function to return a single identifier of the physical meaning of one of the independent
+     *  independent variable of the coefficient interface. The index of the variable is defined
+     *  by the input variable.
+     *  \param index Index of list of identfiers to return
+     *  \return The identifiers of the physical meaning of the independent variable at the position
+     *  of the input variable.
+     */
+    AerodynamicCoefficientsIndependentVariables getIndependentVariableName(
+            const unsigned int index )
+    {
+        if( index >= numberOfIndependentVariables_ )
+        {
+            throw std::runtime_error(
+                        std::string( "Error when retrieving aerodynamic coefficient interface " ) +
+                        ( " variable name, requested variable index " ) +
+                        boost::lexical_cast< std::string >( index ) +
+                        ", but only " + boost::lexical_cast< std::string >(
+                            numberOfIndependentVariables_ ) + " variables available." );
+        }
+
+        return independentVariableNames_.at( index );
+    }
+
+    //! Function to return the number of independent variables upon which the coeficients depend.
     /*!
-     * Computes the current force and moment coefficients and is to be
-     * implemented in derived classes. Such a calculation would be performed by, for instance,
-     * including a pointer to a Vehicle object, from which the current flight condition can
-     * be retrieved. The function here is not made pure virtual pending the inclusion of
-     * such functionality in derived classes.
+     *  Function to return the number of independent variables upon which the coeficients depend.
+     *  The size of the vector used as input for updateCurrentCoefficients should always have the
+     *  size returned by this variable.
+     *  \return Number of independent variables upon which the coeficients depend
      */
-    virtual void computeCurrentCoefficients( ) { }
+    unsigned int getNumberOfIndependentVariables( )
+    {
+        return numberOfIndependentVariables_;
+    }
+
+
 
 protected:
 
@@ -222,6 +284,33 @@ protected:
      */
     Eigen::Vector3d momentReferencePoint_;
 
+    //! Vector with identifiers for the physical meaning of each independent variable of the
+    //! aerodynamic coefficients.
+    std::vector< AerodynamicCoefficientsIndependentVariables > independentVariableNames_;
+
+    //! Number of independent variables upon which the force and moment coefficients depend.
+    /*!
+     *  Number of independent variables upon which the force and moment coefficients depend, i.e.
+     *  the length of the vectors that should be used as input to forceCoefficientFunction and
+     *  momentCoefficientFunction.
+     */
+    unsigned int numberOfIndependentVariables_;
+
+    //! Boolean to denote whether coefficients are defined in aerodynamic or body frame
+    /*! Boolean to define whether the aerodynamic
+     *  coefficients are defined in the aerodynamic frame (lift, drag, side force) or in the body
+     *  frame (typically denoted as Cx, Cy, Cz).
+     */
+    bool areCoefficientsInAerodynamicFrame_;
+
+     //! Boolean to denote whether coefficients are positive along frame axes
+     /*! Boolean to define whether the aerodynamic coefficients are
+      *  positive along tyhe positive axes of the body or aerodynamic frame
+      *  (see areCoefficientsInAerodynamicFrame). Note that for (lift, drag, side force), the
+      *  coefficients are typically defined in negative direction.
+     */
+    bool areCoefficientsInNegativeAxisDirection_;
+
 private:
 };
 
diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamicForce.cpp b/Tudat/Astrodynamics/Aerodynamics/aerodynamicForce.cpp
new file mode 100644
index 0000000..38624bf
--- /dev/null
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamicForce.cpp
@@ -0,0 +1,38 @@
+#include "Tudat/Astrodynamics/Aerodynamics/aerodynamicForce.h"
+
+namespace tudat
+{
+namespace aerodynamics
+{
+
+//! Compute the aerodynamic force in same reference frame as input coefficients.
+Eigen::Vector3d computeAerodynamicForce( const double dynamicPressure,
+                                         const double referenceArea,
+                                         const Eigen::Vector3d& aerodynamicCoefficients )
+{
+    return dynamicPressure * referenceArea * aerodynamicCoefficients;
+}
+
+//! Compute the aerodynamic force in same reference frame as input coefficients.
+/*!
+ * This function calculates the aerodynamic force. It takes the dynamic pressure and an
+ * aerodynamic coefficient interface as input. The coefficient interface has to have been
+ * updated with current vehicle conditions before being passed to this function. Aerodynamic
+ * coefficients and reference area are then retrieved from it.
+ * \param dynamicPressure Dynamic pressure at which the body undergoing the force flies.
+ * \param coefficientInterface AerodynamicCoefficientInterface class from which reference area
+ *          and coefficients are retrieved.
+ * \return Resultant aerodynamic force, given in reference frame in which the
+ *          aerodynamic coefficients were given.
+ */
+Eigen::Vector3d computeAerodynamicForce(
+        const double dynamicPressure,
+        AerodynamicCoefficientInterfacePointer coefficientInterface )
+{
+    return computeAerodynamicForce( dynamicPressure,
+                                    coefficientInterface->getReferenceArea( ),
+                                    coefficientInterface->getCurrentForceCoefficients( ) );
+}
+
+} // namespace aerodynamics
+} // namespace tudat
diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamicForce.h b/Tudat/Astrodynamics/Aerodynamics/aerodynamicForce.h
index 95abf96..6750aa6 100644
--- a/Tudat/Astrodynamics/Aerodynamics/aerodynamicForce.h
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamicForce.h
@@ -68,10 +68,7 @@ namespace aerodynamics
  */
 Eigen::Vector3d computeAerodynamicForce( const double dynamicPressure,
                                          const double referenceArea,
-                                         const Eigen::Vector3d& aerodynamicCoefficients )
-{
-    return dynamicPressure * referenceArea * aerodynamicCoefficients;
-}
+                                         const Eigen::Vector3d& aerodynamicCoefficients );
 
 //! Compute the aerodynamic force in same reference frame as input coefficients.
 /*!
@@ -87,12 +84,7 @@ Eigen::Vector3d computeAerodynamicForce( const double dynamicPressure,
  */
 Eigen::Vector3d computeAerodynamicForce(
         const double dynamicPressure,
-        AerodynamicCoefficientInterfacePointer coefficientInterface )
-{
-    return computeAerodynamicForce( dynamicPressure,
-                                    coefficientInterface->getReferenceArea( ),
-                                    coefficientInterface->getCurrentForceCoefficients( ) );
-}
+        AerodynamicCoefficientInterfacePointer coefficientInterface );
 
 } // namespace aerodynamics
 } // namespace tudat
diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamics.cpp b/Tudat/Astrodynamics/Aerodynamics/aerodynamics.cpp
index 0bb7c7b..4ef6ed7 100644
--- a/Tudat/Astrodynamics/Aerodynamics/aerodynamics.cpp
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamics.cpp
@@ -500,5 +500,11 @@ double computeShockDeflectionAngle( double shockAngle, double machNumber,
     return atan( tangentOfDeflectionAngle_ );
 }
 
+double computeSpeedOfSound( const double temperature, const double ratioOfSpecificHeats,
+                            const double specificGasConstant )
+{
+    return std::sqrt( temperature * ratioOfSpecificHeats * specificGasConstant );
+}
+
 } // namespace aerodynamics
 } // namespace tudat
diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamics.h b/Tudat/Astrodynamics/Aerodynamics/aerodynamics.h
index ae744e3..066f44e 100644
--- a/Tudat/Astrodynamics/Aerodynamics/aerodynamics.h
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamics.h
@@ -342,6 +342,9 @@ double computeShockTotalPressureRatio( double normalMachNumber,
 double computeShockDeflectionAngle( double shockAngle, double machNumber,
                                     double ratioOfSpecificHeats );
 
+double computeSpeedOfSound( const double temperature, const double ratioOfSpecificHeats,
+                            const double specificGasConstant );
+
 } // namespace aerodynamics
 } // namespace tudat
 
diff --git a/Tudat/Astrodynamics/Aerodynamics/atmosphereModel.h b/Tudat/Astrodynamics/Aerodynamics/atmosphereModel.h
index 4bcdda0..b7a305a 100644
--- a/Tudat/Astrodynamics/Aerodynamics/atmosphereModel.h
+++ b/Tudat/Astrodynamics/Aerodynamics/atmosphereModel.h
@@ -100,6 +100,18 @@ public:
     virtual double getTemperature( const double altitude, const double longitude,
                                    const double latitude, const double time ) = 0;
 
+    //! Get local speed of sound.
+    /*!
+    * Returns the local speed of sound of the atmosphere in m/s.
+    * \param altitude Altitude.
+    * \param longitude Longitude.
+    * \param latitude Latitude.
+    * \param time Time.
+    * \return Atmospheric speed of sound.
+    */
+    virtual double getSpeedOfSound( const double altitude, const double longitude,
+                                    const double latitude, const double time ) = 0;
+
 protected:
 
 private:
diff --git a/Tudat/Astrodynamics/Aerodynamics/customAerodynamicCoefficientInterface.cpp b/Tudat/Astrodynamics/Aerodynamics/customAerodynamicCoefficientInterface.cpp
new file mode 100644
index 0000000..117ecb1
--- /dev/null
+++ b/Tudat/Astrodynamics/Aerodynamics/customAerodynamicCoefficientInterface.cpp
@@ -0,0 +1,67 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150416    D. Dirkx          File created.
+ *
+ */
+
+#include <boost/lambda/lambda.hpp>
+
+#include "Tudat/Astrodynamics/Aerodynamics/customAerodynamicCoefficientInterface.h"
+
+namespace tudat
+{
+namespace aerodynamics
+{
+
+//! Function to create an aerodynamic coefficient interface containing constant coefficients.
+boost::shared_ptr< AerodynamicCoefficientInterface >
+createConstantCoefficientAerodynamicCoefficientInterface(
+        const Eigen::Vector3d constantForceCoefficient,
+        const Eigen::Vector3d constantMomentCoefficient,
+        const double referenceLength,
+        const double referenceArea,
+        const double lateralReferenceLength,
+        const Eigen::Vector3d& momentReferencePoint,
+        const bool areCoefficientsInAerodynamicFrame,
+        const bool areCoefficientsInNegativeAxisDirection  )
+{
+    // Create coefficient interface
+    boost::shared_ptr< AerodynamicCoefficientInterface > coefficientInterface =
+            boost::make_shared< CustomAerodynamicCoefficientInterface >(
+                    boost::lambda::constant( constantForceCoefficient ),
+                    boost::lambda::constant( constantMomentCoefficient ),
+                    referenceLength, referenceArea, lateralReferenceLength, momentReferencePoint,
+                std::vector< AerodynamicCoefficientsIndependentVariables >( ),
+                areCoefficientsInAerodynamicFrame, areCoefficientsInNegativeAxisDirection );
+    coefficientInterface->updateCurrentCoefficients( std::vector< double >( ) );
+
+    return coefficientInterface;
+}
+
+}
+
+}
diff --git a/Tudat/Astrodynamics/Aerodynamics/customAerodynamicCoefficientInterface.h b/Tudat/Astrodynamics/Aerodynamics/customAerodynamicCoefficientInterface.h
new file mode 100644
index 0000000..5d4d397
--- /dev/null
+++ b/Tudat/Astrodynamics/Aerodynamics/customAerodynamicCoefficientInterface.h
@@ -0,0 +1,248 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150416    D. Dirkx          File created.
+ *
+ */
+
+#ifndef TUDAT_CUSTOM_AERODYNAMIC_COEFFICIENT_INTERFACE_H
+#define TUDAT_CUSTOM_AERODYNAMIC_COEFFICIENT_INTERFACE_H
+
+#include <boost/function.hpp>
+#include <boost/bind.hpp>
+#include <boost/make_shared.hpp>
+
+#include "Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientInterface.h"
+#include "Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientGenerator.h"
+#include "Tudat/Astrodynamics/Aerodynamics/hypersonicLocalInclinationAnalysis.h"
+#include "Tudat/Mathematics/Interpolators/multiLinearInterpolator.h"
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+
+namespace tudat
+{
+namespace aerodynamics
+{
+
+//! Aerodynamic coefficient interface taking function pointers providing aerodynamics
+//! coefficients as a function of independent variables (doubles).
+/*!
+ *  Aerodynamic coefficient interface taking function pointers providing aerodynamics
+ *  coefficients as a function of independent variables (doubles). The origin of the coefficients
+ *  or the nature of the independent variables is irrelevant for this class.
+ *  A factory functios (createConstantCoefficientAerodynamicCoefficientInterface) is provided
+ *  at the end of this file, which can be used to define constant coefficients.
+ *  NOTE: Functionality of this class is tested in test_aerodynamic_coefficient_generator
+ *  test suite.
+ */
+class CustomAerodynamicCoefficientInterface: public AerodynamicCoefficientInterface
+{
+public:
+
+    //! Function to combined the force and moment coefficients from separate function pointers.
+    /*!
+     *  Function to combined the force and moment coefficients from separate function pointers.
+     *  The output is the concatenated force and moment coefficient vector, evaluated
+     *  at the current set of independent variables.
+     *  \param forceCoefficientFunction Function returning the aerodynamic force coefficients as
+     *  function of the set of independent variables.
+     *  \param momentCoefficientFunction Function returning the aerodynamic force coefficients as
+     *  function of the set of independent variables.
+     *  \param independentVariables Current list of values of the independent variables upon
+     *  which the coefficients depend.
+     */
+    basic_mathematics::Vector6d concatenateForceAndMomentCoefficients(
+            const boost::function< Eigen::Vector3d( const std::vector< double >& ) >&
+            forceCoefficientFunction,
+            const boost::function< Eigen::Vector3d( const std::vector< double >& ) >&
+            momentCoefficientFunction,
+            const std::vector< double >& independentVariables )
+    {
+        return ( basic_mathematics::Vector6d( )<<forceCoefficientFunction( independentVariables ),
+                 momentCoefficientFunction( independentVariables ) ).finished( );
+    }
+
+    //! Constructor.
+    /*!
+     *  Constructor.
+     *  \param forceCoefficientFunction Function returning the aerodynamic force coefficients as
+     *  function of the set of independent variables.
+     *  \param momentCoefficientFunction Function returning the aerodynamic force coefficients as
+     *  function of the set of independent variables.
+     *  \param referenceLength Reference length with which aerodynamic moments
+     *  (about x- and z- axes) are non-dimensionalized.
+     *  \param referenceArea Reference area with which aerodynamic forces and moments are
+     *  non-dimensionalized.
+     *  \param lateralReferenceLength Reference length with which aerodynamic moments (about y-axis)
+     *  is non-dimensionalized.
+     *  \param momentReferencePoint Point w.r.t. which aerodynamic moment is calculated.
+     *  \param independentVariableNames Vector with identifiers for the physical meaning of each
+     *  independent variable of the aerodynamic coefficients.
+     *  \param areCoefficientsInAerodynamicFrame Boolean to define whether the aerodynamic
+     *  coefficients are defined in the aerodynamic frame (lift, drag, side force) or in the body
+     *  frame (typically denoted as Cx, Cy, Cz).
+     *  \param areCoefficientsInNegativeAxisDirection Boolean to define whether the aerodynamic
+     *  coefficients are positiver along tyhe positive axes of the body or aerodynamic frame
+     *  (see areCoefficientsInAerodynamicFrame). Note that for (lift, drag, side force), the
+     *  coefficients are typically defined in negative direction.
+     */
+    CustomAerodynamicCoefficientInterface(
+            const boost::function< Eigen::Vector3d( const std::vector< double >& ) >
+            forceCoefficientFunction,
+            const boost::function< Eigen::Vector3d( const std::vector< double >& ) >
+            momentCoefficientFunction,
+            const double referenceLength,
+            const double referenceArea,
+            const double lateralReferenceLength,
+            const Eigen::Vector3d& momentReferencePoint,
+            const std::vector< AerodynamicCoefficientsIndependentVariables >
+            independentVariableNames,
+            const bool areCoefficientsInAerodynamicFrame = 1,
+            const bool areCoefficientsInNegativeAxisDirection = 1 ):
+        AerodynamicCoefficientInterface( referenceLength, referenceArea, lateralReferenceLength,
+                                         momentReferencePoint, independentVariableNames,
+                                         areCoefficientsInAerodynamicFrame,
+                                         areCoefficientsInNegativeAxisDirection )
+    {
+        coefficientFunction_ = boost::bind(
+                    &CustomAerodynamicCoefficientInterface::concatenateForceAndMomentCoefficients,
+                    this, forceCoefficientFunction, momentCoefficientFunction, _1 );
+    }
+
+    //! Constructor.
+    /*!
+     *  Constructor.
+
+     *  \param coefficientFunction Function returning the concatenated aerodynamic force and moment
+     *  coefficients as function of the set of independent variables.
+     *  \param referenceLength Reference length with which aerodynamic moments
+     *  (about x- and z- axes) are non-dimensionalized.
+     *  \param referenceArea Reference area with which aerodynamic forces and moments are
+     *  non-dimensionalized.
+     *  \param lateralReferenceLength Reference length with which aerodynamic moments (about y-axis)
+     *  is non-dimensionalized.
+     *  \param momentReferencePoint Point w.r.t. which aerodynamic moment is calculated
+     *  \param independentVariableNames Vector with identifiers for the physical meaning of each
+     *  independent variable of the aerodynamic coefficients.
+     *  \param areCoefficientsInAerodynamicFrame Boolean to define whether the aerodynamic
+     *  coefficients are defined in the aerodynamic frame (lift, drag, side force) or in the body
+     *  frame (typically denoted as Cx, Cy, Cz).
+     *  \param areCoefficientsInNegativeAxisDirection Boolean to define whether the aerodynamic
+     *  coefficients are positiver along tyhe positive axes of the body or aerodynamic frame
+     *  (see areCoefficientsInAerodynamicFrame). Note that for (lift, drag, side force), the
+     *  coefficients are typically defined in negative direction.
+     */
+    CustomAerodynamicCoefficientInterface(
+            const boost::function< basic_mathematics::Vector6d( const std::vector< double >& ) >
+            coefficientFunction,
+            const double referenceLength,
+            const double referenceArea,
+            const double lateralReferenceLength,
+            const Eigen::Vector3d& momentReferencePoint,
+            const std::vector< AerodynamicCoefficientsIndependentVariables >
+            independentVariableNames,
+            const bool areCoefficientsInAerodynamicFrame = 1,
+            const bool areCoefficientsInNegativeAxisDirection = 1 ):
+        AerodynamicCoefficientInterface( referenceLength, referenceArea, lateralReferenceLength,
+                                         momentReferencePoint, independentVariableNames,
+                                         areCoefficientsInAerodynamicFrame,
+                                         areCoefficientsInNegativeAxisDirection ),
+        coefficientFunction_( coefficientFunction ){ }
+
+    //! Compute the aerodynamic coefficients at current flight condition.
+    /*!
+     *  Compute the aerodynamic coefficients at current flight conditions (independent variables).
+     *  Input is a set of independent variables (doubles) which represent the variables from which
+     *  the coefficients are calculated. The physical nature of these variables depends on
+     *  the coefficientFunction_ variables. The size of the independent variable vector must be
+     *  numberOfIndependentVariables_
+     *  \param independentVariables Independent variables of force and moment coefficient
+     *  determination implemented by derived class
+     */
+    virtual void updateCurrentCoefficients( const std::vector< double >& independentVariables )
+    {
+        // Check if the correct number of aerodynamic coefficients is provided.
+        if( independentVariables.size( ) != numberOfIndependentVariables_ )
+        {
+            throw std::runtime_error(
+                        "Error in CustomAerodynamicCoefficientInterface, number of "
+                        "input variables is inconsistent " );
+        }
+
+        // Update current coefficients.
+        basic_mathematics::Vector6d currentCoefficients = coefficientFunction_(
+                    independentVariables );
+        currentForceCoefficients_ = currentCoefficients.segment( 0, 3 );
+        currentMomentCoefficients_ = currentCoefficients.segment( 3, 3 );
+    }
+
+private:
+
+    //! Function returning the concatenated aerodynamic force and moment coefficients as function of
+    //! the set of independent variables.
+    boost::function< basic_mathematics::Vector6d( const std::vector< double >& ) >
+    coefficientFunction_;
+
+
+};
+
+//! Function to create an aerodynamic coefficient interface containing constant coefficients.
+/*!
+ *  Function to create an aerodynamic coefficient interface containing constant coefficients,
+ *  As a result, the generated coefficient interface depends on zero parameters.
+ *  \param constantForceCoefficient Constant force coefficients.
+ *  \param constantMomentCoefficient Constant moment coefficients.
+ *  \param referenceLength Reference length with which aerodynamic moments
+ *  (about x- and z- axes) are non-dimensionalized.
+ *  \param referenceArea Reference area with which aerodynamic forces and moments are
+ *  non-dimensionalized.
+ *  \param lateralReferenceLength Reference length with which aerodynamic moments (about y-axis)
+ *  is non-dimensionalized.
+ *  \param momentReferencePoint Point w.r.t. aerodynamic moment is calculated
+ *  \param areCoefficientsInAerodynamicFrame Boolean to define whether the aerodynamic
+ *  coefficients are defined in the aerodynamic frame (lift, drag, side force) or in the body
+ *  frame (typically denoted as Cx, Cy, Cz).
+ *  \param areCoefficientsInNegativeAxisDirection Boolean to define whether the aerodynamic
+ *  coefficients are positiver along tyhe positive axes of the body or aerodynamic frame
+ *  (see areCoefficientsInAerodynamicFrame). Note that for (lift, drag, side force), the
+ *  coefficients are typically defined in negative direction.
+ *  \return Aerodynamic coefficient interface with constant coefficients.
+ */
+boost::shared_ptr< AerodynamicCoefficientInterface >
+createConstantCoefficientAerodynamicCoefficientInterface(
+        const Eigen::Vector3d constantForceCoefficient,
+        const Eigen::Vector3d constantMomentCoefficient,
+        const double referenceLength,
+        const double referenceArea,
+        const double lateralReferenceLength,
+        const Eigen::Vector3d& momentReferencePoint,
+        const bool areCoefficientsInAerodynamicFrame = 0,
+        const bool areCoefficientsInNegativeAxisDirection = 1 );
+
+}
+
+}
+
+#endif // CUSTOM_TUDAT_AERODYNAMIC_COEFFICIENT_INTERFACE_H
diff --git a/Tudat/Astrodynamics/Aerodynamics/exponentialAtmosphere.cpp b/Tudat/Astrodynamics/Aerodynamics/exponentialAtmosphere.cpp
index eb0b871..880409d 100644
--- a/Tudat/Astrodynamics/Aerodynamics/exponentialAtmosphere.cpp
+++ b/Tudat/Astrodynamics/Aerodynamics/exponentialAtmosphere.cpp
@@ -1,47 +1,4 @@
-/*    Copyright (c) 2010-2015, Delft University of Technology
- *    All rights reserved.
- *
- *    Redistribution and use in source and binary forms, with or without modification, are
- *    permitted provided that the following conditions are met:
- *      - Redistributions of source code must retain the above copyright notice, this list of
- *        conditions and the following disclaimer.
- *      - Redistributions in binary form must reproduce the above copyright notice, this list of
- *        conditions and the following disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *      - Neither the name of the Delft University of Technology nor the names of its contributors
- *        may be used to endorse or promote products derived from this software without specific
- *        prior written permission.
- *
- *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
- *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- *    OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *    Changelog
- *      YYMMDD    Author            Comment
- *      110224    F.M. Engelen      File created.
- *      110324    J. Melman         Added overloaded get functions.
- *      110427    F.M. Engelen      Changed input parameter to altitude, longitude and latitude.
- *      110629    F.M. Engelen      Added predefined feature.
- *      110705    F.M. Engelen      Changed to passing by reference. Changed reference values.
- *
- *    References
- *
- *    Notes
- *      The accuracy of this model could be increased by implementing different values for the
- *      scale height and temperature for different altitudes (e.g., lower, middle and upper
- *      atmosphere).
- *
- */
-
-#include <iostream>
-
-#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+#include <stdexcept>
 
 #include "Tudat/Astrodynamics/Aerodynamics/exponentialAtmosphere.h"
 
@@ -50,10 +7,8 @@ namespace tudat
 namespace aerodynamics
 {
 
-//! Set predefined exponential atmosphere settings.
-void ExponentialAtmosphere::setPredefinedExponentialAtmosphere(
-        ExponentialAtmosphere::BodiesWithPredefinedExponentialAtmospheres
-        bodyWithPredefinedExponentialAtmosphere )
+ExponentialAtmosphere::ExponentialAtmosphere(
+        const BodiesWithPredefinedExponentialAtmospheres bodyWithPredefinedExponentialAtmosphere )
 {
     switch( bodyWithPredefinedExponentialAtmosphere )
     {
@@ -62,24 +17,29 @@ void ExponentialAtmosphere::setPredefinedExponentialAtmosphere(
         // Rocket Motion by Prof. Ir. B.A.C. Ambrosius, November 2009.
 
         // Set scale height.
-        setScaleHeight( 7.200e3 );
+        scaleHeight_ = 7.200e3;
 
         //Set density at zero altitude.
-        setDensityAtZeroAltitude( 1.225 );
+        densityAtZeroAltitude_ = 1.225;
 
         //Set atmosphere temperature.
-        setConstantTemperature( 246.0 );
+        constantTemperature_ = 246.0;
 
         // Set specific gas constant.
-        setSpecificGasConstant( physical_constants::SPECIFIC_GAS_CONSTANT_AIR );
+        specificGasConstant_ = physical_constants::SPECIFIC_GAS_CONSTANT_AIR;
+
+        ratioOfSpecificHeats_ = 1.4;
 
         break;
 
     default:
-
-        std::cerr << "This is not a body with a predefined exponential atmophere." << std::endl;
+        throw std::runtime_error(
+                    "Error when making exponential atmosphere, predefined atmosphere" +
+                    boost::lexical_cast< std::string >(
+                        bodyWithPredefinedExponentialAtmosphere ) + "not recognized." );
     }
 }
 
-} // namespace aerodynamics
-} // namespace tudat
+}
+
+}
diff --git a/Tudat/Astrodynamics/Aerodynamics/exponentialAtmosphere.h b/Tudat/Astrodynamics/Aerodynamics/exponentialAtmosphere.h
index e379028..492b005 100644
--- a/Tudat/Astrodynamics/Aerodynamics/exponentialAtmosphere.h
+++ b/Tudat/Astrodynamics/Aerodynamics/exponentialAtmosphere.h
@@ -44,6 +44,7 @@
 #ifndef TUDAT_EXPONENTIAL_ATMOSPHERE_H
 #define TUDAT_EXPONENTIAL_ATMOSPHERE_H
 
+#include <boost/lexical_cast.hpp>
 #include <boost/shared_ptr.hpp>
 
 #include <cmath>
@@ -51,6 +52,8 @@
 #include "Tudat/Basics/utilityMacros.h"
 
 #include "Tudat/Astrodynamics/Aerodynamics/atmosphereModel.h"
+#include "Tudat/Astrodynamics/Aerodynamics/aerodynamics.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
 
 namespace tudat
 {
@@ -78,30 +81,34 @@ public:
 
     //! Default constructor.
     /*!
-     * Default constructor.
+     *  Default constructor setting all parameters manually.
+     *  \param scaleHeight Scale height of atmosphere model.
+     *  \param constantTemperature Constant atmospheric temperature.
+     *  \param densityAtZeroAltitude Atmospheric density at zero altitude.
+     *  \param specificGasConstant The constant specific gas constant of the air
+     *  \param ratioOfSpecificHeats The constant ratio of specific heats of the air
      */
-    ExponentialAtmosphere( )
-        : scaleHeight_( -0.0 ),
-          constantTemperature_( -0.0 ),
-          densityAtZeroAltitude_( -0.0 ),
-          specificGasConstant_( -0.0 )
+    ExponentialAtmosphere(
+            const double scaleHeight,
+            const double constantTemperature,
+            const double densityAtZeroAltitude,
+            const double specificGasConstant = physical_constants::SPECIFIC_GAS_CONSTANT_AIR,
+            const double ratioOfSpecificHeats = 1.4 )
+        : scaleHeight_( scaleHeight ),
+          constantTemperature_( constantTemperature ),
+          densityAtZeroAltitude_( densityAtZeroAltitude ),
+          specificGasConstant_( specificGasConstant ),
+          ratioOfSpecificHeats_( ratioOfSpecificHeats )
     { }
 
-    //! Set predefined exponential atmosphere settings.
+    //! Constructor from default atmospheric settings.
     /*!
-     * Sets predefined exponential atmosphere settings.
-     * \param bodyWithPredefinedExponentialAtmosphere Body with a predefined exponential
-     *          atmosphere.
+     *  Constructor from default atmospheric settings.
+     *  \param bodyWithPredefinedExponentialAtmosphere Identifier of body for which the
+     *  atmosphere is to be created.
      */
-    void setPredefinedExponentialAtmosphere( BodiesWithPredefinedExponentialAtmospheres
-                                             bodyWithPredefinedExponentialAtmosphere );
-
-    //! Set scale height.
-    /*!
-     * Sets the scale height (property of exponential atmosphere) in meters.
-     * \param scaleHeight New scale height of exponential atmosphere.
-     */
-    void setScaleHeight( const double scaleHeight ) { scaleHeight_ = scaleHeight; }
+    ExponentialAtmosphere(
+         const BodiesWithPredefinedExponentialAtmospheres bodyWithPredefinedExponentialAtmosphere );
 
     //! Get scale height.
     /*!
@@ -110,16 +117,6 @@ public:
      */
     double getScaleHeight( ) { return scaleHeight_; }
 
-    //! Set density at zero altitude.
-    /*!
-     * Sets the density at zero altitude (property of exponential atmosphere) in kg per meter^3.
-     * \param densityAtZeroAltitude Atmospheric density at zero altitude.
-     */
-    void setDensityAtZeroAltitude( const double densityAtZeroAltitude )
-    {
-        densityAtZeroAltitude_ = densityAtZeroAltitude;
-    }
-
     //! Get density at zero altitude.
     /*!
      * Returns the density at zero altitude (property of exponential atmosphere) in kg per meter^3.
@@ -127,16 +124,6 @@ public:
      */
     double getDensityAtZeroAltitude( ) { return densityAtZeroAltitude_; }
 
-    //! Set constant temperature.
-    /*!
-     * Sets the atmospheric temperature (constant, property of exponential atmosphere) in Kelvin.
-     * \param constantTemperature Constant atmospheric temperature in exponential atmosphere.
-     */
-    void setConstantTemperature( const double constantTemperature )
-    {
-        constantTemperature_ = constantTemperature;
-    }
-
     //! Get constant temperature.
     /*!
      * Returns the atmospheric temperature (constant, property of exponential atmosphere) in
@@ -145,24 +132,21 @@ public:
      */
     double getConstantTemperature( ) { return constantTemperature_; }
 
-    //! Set specific gas constant.
+    //! Get specific gas constant.
     /*!
-     * Sets the specific gas constant of the air in J/(kg K), its value is assumed constant,
+     * Returns the specific gas constant of the air in J/(kg K), its value is assumed constant,
      * due to the assumption of constant atmospheric composition.
-     * \param specificGasConstant Constant specific gas constant in exponential atmosphere.
+     * \return Specific gas constant in exponential atmosphere.
      */
-    void setSpecificGasConstant( const double specificGasConstant )
-    {
-        specificGasConstant_ = specificGasConstant;
-    }
+    double getSpecificGasConstant( ) { return specificGasConstant_; }
 
-    //! Get specific gas constant.
+    //! Get ratio of specific heats.
     /*!
-     * Returns the specific gas constant of the air in J/(kg K), its value is assumed constant,
+     * Returns the ratio of specific hears of the air, its value is assumed constant,
      * due to the assumption of constant atmospheric composition.
-     * \return specificGasConstant Specific gas constant in exponential atmosphere.
+     * \return Ratio of specific heats exponential atmosphere.
      */
-    double getSpecificGasConstant( ) { return specificGasConstant_; }
+    double getRatioOfSpecificHeats( ) { return ratioOfSpecificHeats_; }
 
     //! Get local density.
     /*!
@@ -228,6 +212,30 @@ public:
         return constantTemperature_;
     }
 
+    //! Get local speed of sound in the atmosphere.
+    /*!
+     * Returns the speed of sound in the atmosphere in m/s.
+     * \param altitude Altitude at which speed of sounds is to be computed.
+     * \param longitude Longitude at which speed of sounds is to be computed (not used but included
+     * for consistency with base class interface).
+     * \param latitude Latitude at which speed of sounds is to be computed (not used but included
+     * for consistency with base class interface).
+     * \param time Time at which speed of sounds is to be computed (not used but included for
+     * consistency with base class interface).
+     * \return Atmospheric speed of sounds at specified altitude.
+     */
+    double getSpeedOfSound( const double altitude, const double longitude = 0.0,
+                                    const double latitude = 0.0, const double time = 0.0 )
+    {
+        TUDAT_UNUSED_PARAMETER( altitude );
+        TUDAT_UNUSED_PARAMETER( longitude );
+        TUDAT_UNUSED_PARAMETER( latitude );
+        TUDAT_UNUSED_PARAMETER( time );
+        return computeSpeedOfSound(
+                    getTemperature( altitude, longitude, latitude, time ), ratioOfSpecificHeats_,
+                    specificGasConstant_ );
+    }
+
 protected:
 
 private:
@@ -253,9 +261,17 @@ private:
     //! Specific gas constant.
     /*!
      * Specific gas constant of the air, its value is assumed constant, due to the assumption of
-     * constant atmospheric composition.
+     * constant atmospheric composition.    
      */
     double specificGasConstant_;
+
+    //! Ratio of specific heats at constant pressure and constant volume.
+    /*!
+     *  Ratio of specific heats of the atmosphrer at constant pressure and constant volume.
+     *  This value is set to a constant, implying constant atmospheric composition.
+     */
+    double ratioOfSpecificHeats_;
+
 };
 
 //! Typedef for shared-pointer to ExponentialAtmosphere object.
diff --git a/Tudat/Astrodynamics/Aerodynamics/hypersonicLocalInclinationAnalysis.cpp b/Tudat/Astrodynamics/Aerodynamics/hypersonicLocalInclinationAnalysis.cpp
index f5004cc..d1a7476 100644
--- a/Tudat/Astrodynamics/Aerodynamics/hypersonicLocalInclinationAnalysis.cpp
+++ b/Tudat/Astrodynamics/Aerodynamics/hypersonicLocalInclinationAnalysis.cpp
@@ -51,6 +51,7 @@
 #include <boost/make_shared.hpp>
 #include <boost/pointer_cast.hpp>
 #include <boost/shared_ptr.hpp>
+#include <boost/assign/list_of.hpp>
 
 #include <Eigen/Geometry>
 
@@ -157,14 +158,15 @@ HypersonicLocalInclinationAnalysis::HypersonicLocalInclinationAnalysis(
         const std::vector< std::vector< int > >& selectedMethods,
         const double referenceArea,
         const double referenceLength,
-        const Eigen::Vector3d& momentReferencePoint,
-        const std::string& machRegime )
+        const Eigen::Vector3d& momentReferencePoint )
     : AerodynamicCoefficientGenerator< 3, 6 >(
-          dataPointsOfIndependentVariables, referenceArea, referenceLength, momentReferencePoint ),
+          dataPointsOfIndependentVariables, referenceLength, referenceArea, referenceLength,
+          momentReferencePoint,
+          boost::assign::list_of( mach_number_dependent )( angle_of_attack_dependent )
+          ( angle_of_sideslip_dependent ), 1, 1 ),
       stagnationPressureCoefficient( 2.0 ),
-      ratioOfSpecificHeats( 1.4 ),      // Refer to a constant in "constants file" in the future!
-      selectedMethods_( selectedMethods ),
-      machRegime_( machRegime )
+      ratioOfSpecificHeats( 1.4 ),
+      selectedMethods_( selectedMethods )
 {
     // Set geometry if it is a single surface.
     if ( boost::dynamic_pointer_cast< SingleSurfaceGeometry > ( inputVehicleSurface ) !=
@@ -183,15 +185,15 @@ HypersonicLocalInclinationAnalysis::HypersonicLocalInclinationAnalysis(
         {
             // Convert geometry to LaWGS surface mesh and set in vehicleParts_ list.
             vehicleParts_[ 0 ]->setMesh(
-                    boost::dynamic_pointer_cast< SingleSurfaceGeometry > ( inputVehicleSurface ),
-                    numberOfLines[ 0 ], numberOfPoints[ 0 ] );
+                        boost::dynamic_pointer_cast< SingleSurfaceGeometry > ( inputVehicleSurface ),
+                        numberOfLines[ 0 ], numberOfPoints[ 0 ] );
         }
 
         // Else, set geometry directly.
         else
         {
             vehicleParts_[ 0 ] = boost::dynamic_pointer_cast< LawgsPartGeometry >
-                                 ( inputVehicleSurface );
+                    ( inputVehicleSurface );
         }
     }
 
@@ -254,20 +256,25 @@ HypersonicLocalInclinationAnalysis::HypersonicLocalInclinationAnalysis(
         numberOfPointsPerIndependentVariables[ i ] =
                 dataPointsOfIndependentVariables_[ i ].size( );
     }
+
     isCoefficientGenerated_.resize( numberOfPointsPerIndependentVariables );
 
     std::fill( isCoefficientGenerated_.origin( ),
                isCoefficientGenerated_.origin( ) + isCoefficientGenerated_.num_elements( ), 0 );
+
+    generateCoefficients( );
+    createInterpolator( );
 }
 
 //! Get aerodynamic coefficients.
-Vector6d HypersonicLocalInclinationAnalysis::getAerodynamicCoefficients(
+Vector6d HypersonicLocalInclinationAnalysis::getAerodynamicCoefficientsDataPoint(
         const boost::array< int, 3 > independentVariables )
 {
     if( isCoefficientGenerated_( independentVariables ) == 0 )
     {
         determineVehicleCoefficients( independentVariables );
     }
+
     // Return requested coefficients.
     return aerodynamicCoefficients_( independentVariables );
 
@@ -281,17 +288,17 @@ void HypersonicLocalInclinationAnalysis::generateCoefficients( )
     boost::array< int, 3 > independentVariableIndices;
 
     // Iterate over all combinations of independent variables.
-    for ( unsigned int i = 0 ; i < dataPointsOfIndependentVariables_[ machIndex ].size( ) ; i++ )
+    for ( unsigned int i = 0 ; i < dataPointsOfIndependentVariables_[ 0 ].size( ) ; i++ )
     {
-        independentVariableIndices[ machIndex ] = i;
+        independentVariableIndices[ 0 ] = i;
         for ( unsigned  int j = 0 ; j < dataPointsOfIndependentVariables_[
-              angleOfAttackIndex ].size( ) ; j++ )
+              1 ].size( ) ; j++ )
         {
-            independentVariableIndices[ angleOfAttackIndex ] = j;
+            independentVariableIndices[ 1 ] = j;
             for ( unsigned  int k = 0 ; k < dataPointsOfIndependentVariables_[
-                  angleOfSideslipIndex ].size( ) ; k++ )
+                  2 ].size( ) ; k++ )
             {
-                independentVariableIndices[ angleOfSideslipIndex ] = k;
+                independentVariableIndices[ 2 ] = k;
 
                 determineVehicleCoefficients( independentVariableIndices );
             }
@@ -322,32 +329,32 @@ Vector6d HypersonicLocalInclinationAnalysis::determinePartCoefficients(
         const int partNumber, const boost::array< int, 3 > independentVariableIndices )
 {
     // Declare and determine angles of attack and sideslip for analysis.
-    double angleOfAttack =  dataPointsOfIndependentVariables_[ angleOfAttackIndex ]
-            [ independentVariableIndices[ angleOfAttackIndex ] ];
+    double angleOfAttack =  dataPointsOfIndependentVariables_[ 1 ]
+            [ independentVariableIndices[ 1 ] ];
 
-    double angleOfSideslip =  dataPointsOfIndependentVariables_[ angleOfSideslipIndex ]
-            [ independentVariableIndices[ angleOfSideslipIndex ] ];
+    double angleOfSideslip =  dataPointsOfIndependentVariables_[ 2 ]
+            [ independentVariableIndices[ 2 ] ];
 
     // Declare partCoefficient vector.
     Vector6d partCoefficients = Vector6d::Zero( );
 
     // Check whether the inclinations of the vehicle part have already been computed.
     if ( previouslyComputedInclinations_.count( std::pair< double, double >(
-            angleOfAttack, angleOfSideslip ) ) == 0 )
+                                                    angleOfAttack, angleOfSideslip ) ) == 0 )
     {
         // Determine panel inclinations for part.
         determineInclinations( angleOfAttack, angleOfSideslip );
 
         // Add panel inclinations to container
         previouslyComputedInclinations_[ std::pair< double, double >(
-                        angleOfAttack, angleOfSideslip ) ] = inclination_;
+                    angleOfAttack, angleOfSideslip ) ] = inclination_;
     }
 
     else
     {
         // Fetch inclinations from container
         inclination_ = previouslyComputedInclinations_[ std::pair< double, double >(
-                angleOfAttack, angleOfSideslip ) ];
+                    angleOfAttack, angleOfSideslip ) ];
     }
 
     // Set pressureCoefficient_ array for given independent variables.
@@ -367,8 +374,8 @@ void HypersonicLocalInclinationAnalysis::determinePressureCoefficients(
         const int partNumber, const boost::array< int, 3 > independentVariableIndices )
 {
     // Retrieve Mach number.
-    double machNumber = dataPointsOfIndependentVariables_[ machIndex ]
-            [ independentVariableIndices[ machIndex ] ];
+    double machNumber = dataPointsOfIndependentVariables_[ 0 ]
+            [ independentVariableIndices[ 0 ] ];
 
     // Determine stagnation point pressure coefficients. Value is computed once
     // here to prevent its calculation in inner loop.
@@ -496,7 +503,7 @@ void HypersonicLocalInclinationAnalysis::updateCompressionPressures( const doubl
     case 1:
         pressureFunction =
                 boost::bind( aerodynamics::computeModifiedNewtonianPressureCoefficient, _1,
-                                        stagnationPressureCoefficient );
+                             stagnationPressureCoefficient );
         break;
 
     case 2:
@@ -510,37 +517,37 @@ void HypersonicLocalInclinationAnalysis::updateCompressionPressures( const doubl
     case 4:
         pressureFunction =
                 boost::bind( aerodynamics::computeEmpiricalTangentWedgePressureCoefficient, _1,
-                                        machNumber );
+                             machNumber );
         break;
 
     case 5:
         pressureFunction =
                 boost::bind( aerodynamics::computeEmpiricalTangentConePressureCoefficient, _1,
-                                        machNumber );
+                             machNumber );
         break;
 
     case 6:
         pressureFunction =
                 boost::bind( aerodynamics::computeModifiedDahlemBuckPressureCoefficient, _1,
-                                        machNumber );
+                             machNumber );
         break;
 
     case 7:
         pressureFunction =
                 boost::bind( aerodynamics::computeVanDykeUnifiedPressureCoefficient, _1,
-                                        machNumber, ratioOfSpecificHeats, 1 );
+                             machNumber, ratioOfSpecificHeats, 1 );
         break;
 
     case 8:
         pressureFunction =
                 boost::bind( aerodynamics::computeSmythDeltaWingPressureCoefficient, _1,
-                                        machNumber );
+                             machNumber );
         break;
 
     case 9:
         pressureFunction =
                 boost::bind( aerodynamics::computeHankeyFlatSurfacePressureCoefficient, _1,
-                                        machNumber );
+                             machNumber );
         break;
 
     default:
@@ -622,14 +629,14 @@ void HypersonicLocalInclinationAnalysis::updateExpansionPressures( const double
                         machNumber, ratioOfSpecificHeats );
             pressureFunction =
                     boost::bind( &aerodynamics::computePrandtlMeyerFreestreamPressureCoefficient,
-                                            _1, machNumber, ratioOfSpecificHeats,
-                                            freestreamPrandtlMeyerFunction );
+                                 _1, machNumber, ratioOfSpecificHeats,
+                                 freestreamPrandtlMeyerFunction );
             break;
 
         case 5:
             pressureFunction =
                     boost::bind( &aerodynamics::computePrandtlMeyerFreestreamPressureCoefficient,
-                                            _1, machNumber, ratioOfSpecificHeats, -1 );
+                                 _1, machNumber, ratioOfSpecificHeats, -1 );
             break;
 
         case 6:
@@ -657,32 +664,9 @@ void HypersonicLocalInclinationAnalysis::updateExpansionPressures( const double
     else
     {
         std::cerr << "Error, expansion local inclination method number "<< method <<
-                " not recognized" << std::endl;
+                     " not recognized" << std::endl;
     }
 }
 
-//! Overload ostream to print class information.
-std::ostream& operator<<( std::ostream& stream,
-                          HypersonicLocalInclinationAnalysis& hypersonicLocalInclinationAnalysis )
-{
-    stream << "This is a hypersonic local inclination analysis object."<< endl;
-    stream << "The Mach regime is "
-           << hypersonicLocalInclinationAnalysis.getMachRegime( ) << endl;
-    stream << "It contains "
-           << hypersonicLocalInclinationAnalysis.getNumberOfVehicleParts( )
-           << " parts in Lawgs format. " << endl;
-    stream << "The names of the vehicle parts are ";
-
-    for ( int i = 0; i < hypersonicLocalInclinationAnalysis.getNumberOfVehicleParts( ); i++ )
-    {
-        stream << hypersonicLocalInclinationAnalysis.getVehiclePart( i )->getName( ) << ", ";
-    }
-
-    stream << endl;
-
-    // Return stream.
-    return stream;
-}
-
 } // namespace aerodynamics
 } // namespace tudat
diff --git a/Tudat/Astrodynamics/Aerodynamics/hypersonicLocalInclinationAnalysis.h b/Tudat/Astrodynamics/Aerodynamics/hypersonicLocalInclinationAnalysis.h
index 709be49..d6d62aa 100644
--- a/Tudat/Astrodynamics/Aerodynamics/hypersonicLocalInclinationAnalysis.h
+++ b/Tudat/Astrodynamics/Aerodynamics/hypersonicLocalInclinationAnalysis.h
@@ -98,7 +98,7 @@ std::vector< double > getDefaultHypersonicLocalInclinationAngleOfSideslipPoints(
  * dependent on the local inclination angle w.r.t. the freestream flow and
  * freestream conditions, such as Mach number and ratio of specific heats.
  * All aerodynamic coefficients can be calculated using the generateCoefficients function, or on an
- * as needed basis by using the getAerodynamicCoefficients function. Note that during the
+ * as needed basis by using the getAerodynamicCoefficientsDataPoint function. Note that during the
  * panel inclination determination process, a geometry with outward surface-normals is assumed.
  * The resulting coefficients are expressed in the same reference frame as that of the input
  * geometry.
@@ -107,18 +107,6 @@ class HypersonicLocalInclinationAnalysis: public AerodynamicCoefficientGenerator
 {
 public:
 
-    //! Enum specifying meaning of indices of independent variables of generated coefficients
-    /*!
-     *  Enum specifying meaning of indices of independent variables of generated coefficients,
-     *  i.e. the three physical variables that can be varied in the analysis.
-     */
-    enum HypersonicLocalInclinationAnalysisIndependentVariables
-    {
-        machIndex = 0,
-        angleOfAttackIndex = 1,
-        angleOfSideslipIndex = 2
-    };
-
     //! Default constructor.
     /*!
      *  Default constructor of class, specified vehicle geometry, discretization properties,
@@ -126,9 +114,9 @@ public:
      *  to be used
      *  \param dataPointsOfIndependentVariables Vector of vector, with each subvector containing
      *  the data points of each of the independent variables for the coefficient generation.
-     *  The physical meaning of each of the three independent variables is defined by the
-     *  HypersonicLocalInclinationAnalysisIndependentVariables enum. Each of the subvectors must
-     *  be sorted in ascending order.
+     *  The physical meaning of each of the three independent variables is: 0 = mach numner,
+     *  1 = angle of attack, 2 = angle of sideslip.
+     *  Each of the subvectors must be sorted in ascending order.
      *  \param inputVehicleSurface Vehicle surface geometry for which the coefficients are to be
      *  determined.
      *  \param numberOfLines Number of discretization points in the first independent surface
@@ -146,7 +134,6 @@ public:
      *  and moments.
      *  \param referenceLength Reference length used to non-dimensionalize aerodynamic moments.
      *  \param momentReferencePoint Reference point wrt which aerodynamic moments are calculated.
-     *  \param machRegime NOTE: Variable no longer used. Remove?
      */
     HypersonicLocalInclinationAnalysis(
             const std::vector< std::vector< double > >& dataPointsOfIndependentVariables,
@@ -157,33 +144,26 @@ public:
             const std::vector< std::vector< int > >& selectedMethods,
             const double referenceArea,
             const double referenceLength,
-            const Eigen::Vector3d& momentReferencePoint,
-            const std::string& machRegime = "Full" );
+            const Eigen::Vector3d& momentReferencePoint );
 
     //! Default destructor.
     /*!
      * Default destructor.
      */
-    virtual ~HypersonicLocalInclinationAnalysis( ) { }
+    ~HypersonicLocalInclinationAnalysis( ) { }
 
     //! Get aerodynamic coefficients.
     /*!
-     * Returns aerodynamic coefficients.
+     *  Returns aerodynamic coefficients.
+     *  The physical meaning of each of the three independent variables is: 0 = mach numner,
+     *  1 = angle of attack, 2 = angle of sideslip.
      * \param independentVariables Array of values of independent variable
      *          indices in dataPointsOfIndependentVariables_.
      * \return vector of coefficients at specified independent variable indices.
      */
-    basic_mathematics::Vector6d getAerodynamicCoefficients(
+    basic_mathematics::Vector6d getAerodynamicCoefficientsDataPoint(
             const boost::array< int, 3 > independentVariables );
 
-    //! Generate aerodynamic database.
-    /*!
-     * Generates aerodynamic database. Settings of geometry,
-     * reference quantities, database point settings and analysis methods
-     *  should have been set previously.
-     */
-    void generateCoefficients( );
-
     //! Determine inclination angles of panels on a given part.
     /*!
      * Determines panel inclinations for all panels on all parts for given attitude.
@@ -216,16 +196,6 @@ public:
          return vehicleParts_[ vehicleIndex ];
      }
 
-    //! Get Mach regime.
-    /*!
-     * Returns Mach regime, see machRegime_.
-     * \return Mach regime.
-     */
-    std::string getMachRegime( ) const
-    {
-        return machRegime_;
-    }
-
     //! Overload ostream to print class information.
     /*!
      * Overloads ostream to print class information, prints the number of lawgs geometry parts and
@@ -240,6 +210,14 @@ public:
 
 private:
 
+    //! Generate aerodynamic database.
+    /*!
+     * Generates aerodynamic database. Settings of geometry,
+     * reference quantities, database point settings and analysis methods
+     *  should have been set previously.
+     */
+    void generateCoefficients( );
+
     //! Generate aerodynamic coefficients at a single set of independent variables.
     /*!
      * Generates aerodynamic coefficients at a single set of independent variables.
@@ -360,12 +338,6 @@ private:
      * second index represents vehicle part.
      */
     std::vector< std::vector< int > > selectedMethods_;
-
-    //! Mach regime.
-    /*!
-     * Mach regime, permissible values are "Full", "High" or "Low", default is "Full".
-     */
-    std::string machRegime_;
 };
 
 //! Typedef for shared-pointer to HypersonicLocalInclinationAnalysis object.
diff --git a/Tudat/Astrodynamics/Aerodynamics/standardAtmosphere.h b/Tudat/Astrodynamics/Aerodynamics/standardAtmosphere.h
index 01ca2b7..e2e4f13 100644
--- a/Tudat/Astrodynamics/Aerodynamics/standardAtmosphere.h
+++ b/Tudat/Astrodynamics/Aerodynamics/standardAtmosphere.h
@@ -92,6 +92,18 @@ public:
     */
     virtual double getTemperature( const double altitude, const double longitude = 0.0,
                                    const double latitude = 0.0, const double time = 0.0 ) = 0;
+
+    //! Get local speed of sound.
+    /*!
+    * Returns the local speed of sound of the atmosphere in m/s.
+    * \param altitude Altitude.
+    * \param longitude Longitude.
+    * \param latitude Latitude.
+    * \param time Time.
+    * \return Atmospheric speed of sound.
+    */
+    virtual double getSpeedOfSound( const double altitude, const double longitude = 0.0,
+                                    const double latitude = 0.0, const double time = 0.0 ) = 0;
 };
 
 //! Typedef for shared-pointer to StandardAtmosphere object.
diff --git a/Tudat/Astrodynamics/Aerodynamics/tabulatedAtmosphere.h b/Tudat/Astrodynamics/Aerodynamics/tabulatedAtmosphere.h
index e2ff150..c310868 100644
--- a/Tudat/Astrodynamics/Aerodynamics/tabulatedAtmosphere.h
+++ b/Tudat/Astrodynamics/Aerodynamics/tabulatedAtmosphere.h
@@ -50,6 +50,8 @@
 #include "Tudat/Basics/utilityMacros.h"
 
 #include "Tudat/Astrodynamics/Aerodynamics/atmosphereModel.h"
+#include "Tudat/Astrodynamics/Aerodynamics/aerodynamics.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
 #include "Tudat/Mathematics/Interpolators/cubicSplineInterpolator.h"
 
 namespace tudat
@@ -70,10 +72,19 @@ public:
 
     //! Default constructor.
     /*!
-     * Default constructor.
+     *  Default constructor.
+     *  \param atmosphereTableFile File containing atmospheric properties.
+     *  The file name of the atmosphere table. The file should contain four columns of data,
+     *  containing altitude (first column), and the associated density, pressure and density values
+     *  in the second, third and fourth columns
+     *  \param specificGasConstant The constant specific gas constant of the air
+     *  \param ratioOfSpecificHeats The constant ratio of specific heats of the air
      */
-    TabulatedAtmosphere( const std::string& atmosphereTableFile )
-        : atmosphereTableFile_( atmosphereTableFile )
+    TabulatedAtmosphere( const std::string& atmosphereTableFile,
+                         const double specificGasConstant = physical_constants::SPECIFIC_GAS_CONSTANT_AIR,
+                         const double ratioOfSpecificHeats = 1.4 )
+        : atmosphereTableFile_( atmosphereTableFile ), specificGasConstant_( specificGasConstant ),
+          ratioOfSpecificHeats_( ratioOfSpecificHeats )
     {
         initialize( atmosphereTableFile_ );
     }
@@ -85,14 +96,31 @@ public:
      */
     std::string getAtmosphereTableFile( ) { return atmosphereTableFile_; }
 
+    //! Get specific gas constant.
+    /*!
+     * Returns the specific gas constant of the air in J/(kg K), its value is assumed constant.
+     * \return specificGasConstant Specific gas constant in exponential atmosphere.
+     */
+    double getSpecificGasConstant( ) { return specificGasConstant_; }
+
+    //! Get ratio of specific heats.
+    /*!
+     * Returns the ratio of specific hears of the air, its value is assumed constant,.
+     * \return Ratio of specific heats exponential atmosphere.
+     */
+    double getRatioOfSpecificHeats( ) { return ratioOfSpecificHeats_; }
+
     //! Get local density.
     /*!
      * Returns the local density parameter of the atmosphere in kg per meter^3.
-     * \param altitude Altitude.
-     * \param longitude Longitude.
-     * \param latitude Latitude.
-     * \param time Time.
-     * \return Atmospheric density.
+     * \param altitude Altitude at which density is to be computed.
+     * \param longitude Longitude at which density is to be computed (not used but included for
+     * consistency with base class interface).
+     * \param latitude Latitude at which density is to be computed (not used but included for
+     * consistency with base class interface).
+     * \param time Time at which density is to be computed (not used but included for
+     * consistency with base class interface).
+     * \return Atmospheric density at specified altitude.
      */
     double getDensity( const double altitude, const double longitude = 0.0,
                        const double latitude = 0.0, const double time = 0.0 )
@@ -106,11 +134,14 @@ public:
     //! Get local pressure.
     /*!
      * Returns the local pressure of the atmosphere in Newton per meter^2.
-     * \param altitude Altitude.
-     * \param longitude Longitude.
-     * \param latitude Latitude.
-     * \param time Time.
-     * \return Atmospheric pressure.
+     * \param altitude Altitude  at which pressure is to be computed.
+     * \param longitude Longitude at which pressure is to be computed (not used but included for
+     * consistency with base class interface).
+     * \param latitude Latitude at which pressure is to be computed (not used but included for
+     * consistency with base class interface).
+     * \param time Time at which pressure is to be computed (not used but included for
+     * consistency with base class interface).
+     * \return Atmospheric pressure at specified altitude.
      */
     double getPressure( const double altitude, const double longitude = 0.0,
                         const double latitude = 0.0, const double time = 0.0 )
@@ -124,11 +155,14 @@ public:
     //! Get local temperature.
     /*!
      * Returns the local temperature of the atmosphere in Kelvin.
-     * \param altitude Altitude.
-     * \param longitude Longitude.
-     * \param latitude Latitude.
-     * \param time Time.
-     * \return Atmospheric temperature.
+     * \param altitude Altitude at which temperature is to be computed
+     * \param longitude Longitude at which temperature is to be computed (not used but included for
+     * consistency with base class interface).
+     * \param latitude Latitude at which temperature is to be computed (not used but included for
+     * consistency with base class interface).
+     * \param time Time at which temperature is to be computed (not used but included for
+     * consistency with base class interface).
+     * \return constantTemperature Atmospheric temperature at specified altitude.
      */
     double getTemperature( const double altitude, const double longitude = 0.0,
                            const double latitude = 0.0, const double time = 0.0 )
@@ -139,6 +173,29 @@ public:
         return cubicSplineInterpolationForTemperature_->interpolate( altitude );
     }
 
+    //! Get local speed of sound in the atmosphere.
+    /*!
+     * Returns the speed of sound in the atmosphere in m/s.
+     * \param altitude Altitude at which speed of sound is to be computed.
+     * \param longitude Longitude at which speed of sound is to be computed (not used but included
+     * for consistency with base class interface).
+     * \param latitude Latitude at which speed of sound is to be computed (not used but included
+     * for consistency with base class interface).
+     * \param time Time at which speed of sound is to be computed (not used but included for
+     * consistency with base class interface).
+     * \return Atmospheric speed of sound at specified altitude.
+     */
+    double getSpeedOfSound( const double altitude, const double longitude = 0.0,
+                            const double latitude = 0.0, const double time = 0.0 )
+    {
+        TUDAT_UNUSED_PARAMETER( longitude );
+        TUDAT_UNUSED_PARAMETER( latitude );
+        TUDAT_UNUSED_PARAMETER( time );
+        return computeSpeedOfSound(
+                    getTemperature( altitude, longitude, latitude, time ), ratioOfSpecificHeats_,
+                    specificGasConstant_ );
+    }
+
 protected:
 
 private:
@@ -152,7 +209,9 @@ private:
 
     //! The file name of the atmosphere table.
     /*!
-     *  The file name of the atmosphere table.
+     *  The file name of the atmosphere table. The file should contain four columns of data,
+     *  containing altitude (first column), and the associated density, pressure and density values
+     *  in the second, third and fourth columns.
      */
     std::string atmosphereTableFile_;
 
@@ -197,6 +256,19 @@ private:
      *  Cubic spline interpolation for temperature.
      */
     interpolators::CubicSplineInterpolatorDoublePointer cubicSplineInterpolationForTemperature_;
+
+    //! Specific gas constant.
+    /*!
+     * Specific gas constant of the air, its value is assumed constant, due to the assumption of
+     * constant atmospheric composition.
+     */
+    double specificGasConstant_;
+
+    /*!
+     *  Ratio of specific heats of the atmosphrer at constant pressure and constant volume.
+     *  This value is set to a constant, implying constant atmospheric composition.
+     */
+    double ratioOfSpecificHeats_;
 };
 
 //! Typedef for shared-pointer to TabulatedAtmosphere object.
