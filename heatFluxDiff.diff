diff --git a/Tudat/Astrodynamics/Aerodynamics/CMakeLists.txt b/Tudat/Astrodynamics/Aerodynamics/CMakeLists.txt
index 3103d2e..0b17491 100644
--- a/Tudat/Astrodynamics/Aerodynamics/CMakeLists.txt
+++ b/Tudat/Astrodynamics/Aerodynamics/CMakeLists.txt
@@ -67,6 +67,7 @@ set(AERODYNAMICS_HEADERS
   "${SRCROOT}${AERODYNAMICSDIR}/UnitTests/testApolloCapsuleCoefficients.h"
   "${SRCROOT}${AERODYNAMICSDIR}/flightConditions.cpp"
   "${SRCROOT}${AERODYNAMICSDIR}/aerodynamicGuidance.h"
+  "${SRCROOT}${AERODYNAMICSDIR}/heatFluxFunction.h"
 )
 
 if(USE_NRLMSISE00)
diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamics.cpp b/Tudat/Astrodynamics/Aerodynamics/aerodynamics.cpp
index 1aea0af..ad8b68e 100644
--- a/Tudat/Astrodynamics/Aerodynamics/aerodynamics.cpp
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamics.cpp
@@ -46,6 +46,15 @@
 #include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
 
 #include "Tudat/Astrodynamics/Aerodynamics/aerodynamics.h"
+#include "Tudat/Astrodynamics/Aerodynamics/heatFluxFunction.h"
+
+#include "Tudat/Mathematics/RootFinders/rootFinder.h"
+#include "Tudat/Mathematics/RootFinders/terminationConditions.h"
+#include "Tudat/Mathematics/RootFinders/bisection.h"
+#include "Tudat/Mathematics/RootFinders/secantRootFinder.h"
+
+#include <boost/shared_ptr.hpp>
+#include <boost/make_shared.hpp>
 
 namespace tudat
 {
@@ -520,5 +529,92 @@ double computeMeanFreePath( const double weightedAverageCollisionDiameter, const
                    weightedAverageCollisionDiameter * averageNumberDensity );
 }
 
+double computeAerodynamicLoadFromAcceleration( const Eigen::Vector3d& aerodynamicAccelerationVector )
+{
+    return aerodynamicAccelerationVector.norm( ) / physical_constants::SEA_LEVEL_GRAVITATIONAL_ACCELERATION;
+}
+
+
+//! Compute the aerodynamic load experienced by a vehicle.
+double computeAerodynamicLoad( const double airDensity,
+                               const double airSpeed,
+                               const double referenceArea,
+                               const double vehicleMass,
+                               const Eigen::Vector3d& aerodynamicForceCoefficients )
+{
+    return computeAerodynamicLoadFromAcceleration( 0.5 * airDensity * airSpeed * airSpeed * referenceArea * aerodynamicForceCoefficients / vehicleMass );
+}
+
+//! Compute the heat flux experienced by a vehicle.
+double computeEquilibriumHeatflux( const boost::function< double( const double ) > heatTransferFunction,
+                                   const double wallEmmisivity,
+                                   const double adiabaticWallTemperature )
+{
+    // Create the object that contains the function who's root needs to be found.
+    boost::shared_ptr< EquilibriumTemperatureFunction > equilibriumTemperatureFunction
+            = boost::make_shared< EquilibriumTemperatureFunction >(
+                heatTransferFunction, wallEmmisivity, adiabaticWallTemperature  );
+
+    // Attempt to find the root using the secant method.
+    static tudat::root_finders::SecantRootFinder::TerminationFunction terminationConditionFunction =
+            boost::bind( &tudat::root_finders::termination_conditions::RootRelativeToleranceTerminationCondition< double >::checkTerminationCondition,
+                         boost::make_shared< tudat::root_finders::termination_conditions::RootRelativeToleranceTerminationCondition< double > >(
+                             ), _1, _2, _3, _4, _5 );
+
+    static tudat::root_finders::SecantRootFinder secant( terminationConditionFunction );
+
+    double wallTemperature = secant.execute( equilibriumTemperatureFunction, equilibriumTemperatureFunction->getInitialGuess( ) );
+
+    return heatTransferFunction( wallTemperature );
+}
+
+double computeEquilibriumFayRiddellHeatFlux( const double airDensity,
+                                             const double airSpeed,
+                                             const double airTemperature,
+                                             const double machNumber,
+                                             const double noseRadius,
+                                             const double wallEmissivity )
+
+{
+
+    // Compute adiabatic wall temperature.
+    double adiabaticWallTemperature
+            = computeAdiabaticWallTemperature( airTemperature , machNumber );
+
+    boost::function< double( const double ) > heatTransferFunction = boost::bind(
+                &computeFayRiddellHeatFlux, airDensity, airSpeed, airTemperature, noseRadius, _1 );
+
+    return computeEquilibriumHeatflux( heatTransferFunction, wallEmissivity, adiabaticWallTemperature );
+}
+
+double computeFayRiddellHeatFlux( const double airDensity,
+                                  const double airSpeed,
+                                  const double airTemperature,
+                                  const double noseRadius,
+                                  const double wallTemperature )
+{
+    // Auxiliary constants.
+    const double heatFluxConstant = 3.53E-4;
+
+    // Compute the current heat flux.
+    double currentHeatFlux
+            = heatFluxConstant * sqrt( airDensity * std::pow( airSpeed , 2.0 ) / noseRadius )
+            * ( 0.5 * std::pow( airSpeed , 2.0 ) + 1004.0 * ( airTemperature - wallTemperature ) );
+
+    return currentHeatFlux;
+}
+
+//! Compute the adiabatic wall temperature experienced by a vehicle.
+double computeAdiabaticWallTemperature(
+        const double airTemperature, const double machNumber, const double ratioSpecificHeats,
+        const double recoveryFactor )
+{
+    double totalTemperature
+            = airTemperature * ( 1 + 0.5 * ( ratioSpecificHeats - 1 ) * machNumber * machNumber );
+
+    return airTemperature + recoveryFactor * ( totalTemperature - airTemperature );
+}
+
+
 } // namespace aerodynamics
 } // namespace tudat
diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamics.h b/Tudat/Astrodynamics/Aerodynamics/aerodynamics.h
index a4c29a7..8746cd9 100644
--- a/Tudat/Astrodynamics/Aerodynamics/aerodynamics.h
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamics.h
@@ -44,9 +44,15 @@
 #ifndef TUDAT_AERODYNAMICS_H
 #define TUDAT_AERODYNAMICS_H
 
+#include <boost/function.hpp>
+
+#include <Eigen/Core>
+
 #include <cmath>
 
 #include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
+#include "Tudat/Astrodynamics/Aerodynamics/flightConditions.h"
+#include "Tudat/Astrodynamics/SystemModels/vehicleSystems.h"
 
 namespace tudat
 {
@@ -373,6 +379,67 @@ double computeMachNumber( const double speed, const double speedOfSound );
  */
 double computeMeanFreePath( const double weightedAverageCollisionDiameter, const double averageNumberDensity );
 
+//! Function to compute the aerodynamic load experienced by a vehicle.
+/*!
+ * Function that computes the aerodynamic load (a.k.a. load factor) experienced by a vehicle.
+ * \param airDensity Freestream air density.
+ * \param airSpeed Airspeed of the vehicle.
+ * \param referenceArea Reference area of the vehicle.
+ * \param vehicleMass Mass of the vehicle.
+ * \param aerodynamicForceCoefficients Aerodynamic force coefficients of the vehicle.
+ * \return Aerodynamic load experienced by the vehicle.
+ */
+double computeAerodynamicLoad( const double airDensity,
+                               const double airSpeed,
+                               const double referenceArea,
+                               const double vehicleMass,
+                               const Eigen::Vector3d& aerodynamicForceCoefficients );
+
+//! Function to compute the aerodynamic load experienced by a vehicle.
+/*!
+ * Function that computes the aerodynamic load (a.k.a. load factor) experienced by a vehicle.
+ * \return Aerodynamic load experienced by the vehicle.
+ */
+double computeAerodynamicLoadFromAcceleration( const Eigen::Vector3d& aerodynamicAccelerationVector );
+
+double computeEquilibriumHeatflux( const boost::function< double( const double ) > heatTransferFunction,
+                                   const double wallEmmisivity,
+                                   const double adiabaticWallTemperature );
+
+double computeEquilibriumFayRiddellHeatFlux( const double airDensity,
+                                             const double airSpeed,
+                                             const double airTemperature,
+                                             const double machNumber,
+                                             const double noseRadius,
+                                             const double wallEmissivity = 0.80 );
+
+//! Function to compute the heat flux experienced by a vehicle.
+/*!
+ * Function that computes the heat flux experienced by a vehicle. This function is an implementation of the
+ * Fay-Riddell formula.
+ * \param airSpeed Airspeed of the vehicle.
+ * \param airTemperature Freestream air temperature.
+ * \param machNumber Freestream Mach number.
+ * \param noseRadius Nose radius of the vehicle.
+ * \param wallEmissivity Wall emissivity of the vehicle.
+ * \return Heat flux experienced by the vehicle.
+ */
+double computeFayRiddellHeatFlux( const double airDensity,
+                                  const double airSpeed,
+                                  const double airTemperature,
+                                  const double noseRadius,
+                                  const double wallTemperature );
+
+//! Function to compute the adiabatic wall temperature experienced by a vehicle.
+/*!
+ * Function that computes the adiabatic wall temperature experienced by a vehicle.
+ * \param airTemperature Freestream air temperature.
+ * \param machNumber Freestream Mach number.
+ * \return Adiabatic wall temperature experienced by the vehicle.
+ */
+double computeAdiabaticWallTemperature(
+        const double airTemperature, const double machNumber, const double ratioSpecificHeats = 1.4,
+        const double recoveryFactor = 0.845 );
 
 } // namespace aerodynamics
 } // namespace tudat
diff --git a/Tudat/Astrodynamics/Aerodynamics/flightConditions.cpp b/Tudat/Astrodynamics/Aerodynamics/flightConditions.cpp
index 57cd762..8e45a2c 100644
--- a/Tudat/Astrodynamics/Aerodynamics/flightConditions.cpp
+++ b/Tudat/Astrodynamics/Aerodynamics/flightConditions.cpp
@@ -15,6 +15,7 @@
 #include "Tudat/Astrodynamics/Aerodynamics/aerodynamics.h"
 #include "Tudat/Astrodynamics/Aerodynamics/flightConditions.h"
 #include "Tudat/Astrodynamics/Aerodynamics/standardAtmosphere.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/oblateSpheroidBodyShapeModel.h"
 #include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
 
 namespace tudat
@@ -27,16 +28,23 @@ namespace aerodynamics
 //! are retrieved.
 FlightConditions::FlightConditions(
         const boost::shared_ptr< aerodynamics::AtmosphereModel > atmosphereModel,
-        const boost::function< double( const Eigen::Vector3d ) > altitudeFunction,
+        const boost::shared_ptr< basic_astrodynamics::BodyShapeModel > shapeModel,
         const boost::shared_ptr< AerodynamicCoefficientInterface > aerodynamicCoefficientInterface,
         const boost::shared_ptr< reference_frames::AerodynamicAngleCalculator >
         aerodynamicAngleCalculator ):
     atmosphereModel_( atmosphereModel ),
-    altitudeFunction_( altitudeFunction ),
+    shapeModel_( shapeModel ),
     aerodynamicCoefficientInterface_( aerodynamicCoefficientInterface ),
-    aerodynamicAngleCalculator_( aerodynamicAngleCalculator ),currentAltitude_( TUDAT_NAN ),
-    currentLatitude_( TUDAT_NAN ), currentLongitude_( TUDAT_NAN ), currentTime_( TUDAT_NAN )
+    aerodynamicAngleCalculator_( aerodynamicAngleCalculator ),
+    currentTime_( TUDAT_NAN )
 {
+    if( boost::dynamic_pointer_cast< basic_astrodynamics::OblateSpheroidBodyShapeModel >( shapeModel ) != NULL )
+    {
+        geodeticLatitudeFunction_ = boost::bind(
+                    &basic_astrodynamics::OblateSpheroidBodyShapeModel::getGeodeticLatitude,
+                    boost::dynamic_pointer_cast< basic_astrodynamics::OblateSpheroidBodyShapeModel >( shapeModel ),
+                    _1, 1.0E-4 );
+    }
     updateLatitudeAndLongitude_ = 0;
 
     bodyCenteredPseudoBodyFixedStateFunction_ = boost::bind(
@@ -89,26 +97,6 @@ void FlightConditions::updateConditions( const double currentTime )
         // Calculate state of vehicle in global frame and corotating frame.
         currentBodyCenteredPseudoBodyFixedState_ = bodyCenteredPseudoBodyFixedStateFunction_( );
 
-        // Calculate altitute and airspeed of vehicle.
-        currentAltitude_ =
-                altitudeFunction_( currentBodyCenteredPseudoBodyFixedState_.segment( 0, 3 ) );
-        currentAirspeed_ = currentBodyCenteredPseudoBodyFixedState_.segment( 3, 3 ).norm( );
-
-
-
-        // Update latitude and longitude (if required)
-        if( updateLatitudeAndLongitude_ )
-        {
-            currentLatitude_ = aerodynamicAngleCalculator_->getAerodynamicAngle(
-                        reference_frames::latitude_angle );
-            currentLongitude_ = aerodynamicAngleCalculator_->getAerodynamicAngle(
-                        reference_frames::longitude_angle );
-        }
-
-        // Update density
-        currentDensity_ = atmosphereModel_->getDensity( currentAltitude_, currentLongitude_,
-                                                        currentLatitude_, currentTime_ );
-
         updateAerodynamicCoefficientInput( );
 
         // Update angles from aerodynamic to body-fixed frame (if relevant).
@@ -136,10 +124,7 @@ void FlightConditions::updateAerodynamicCoefficientInput( )
         {
         //Calculate Mach number if needed.
         case mach_number_dependent:
-            aerodynamicCoefficientIndependentVariables_.push_back(
-                        aerodynamics::computeMachNumber(
-                        currentAirspeed_, atmosphereModel_->getSpeedOfSound(
-                            currentAltitude_, currentLongitude_, currentLatitude_, currentTime_ ) ) );
+            aerodynamicCoefficientIndependentVariables_.push_back( getCurrentMachNumber( ) );
             break;
         //Get angle of attack if needed.
         case angle_of_attack_dependent:
diff --git a/Tudat/Astrodynamics/Aerodynamics/flightConditions.h b/Tudat/Astrodynamics/Aerodynamics/flightConditions.h
index 46ef0a7..1d43c17 100644
--- a/Tudat/Astrodynamics/Aerodynamics/flightConditions.h
+++ b/Tudat/Astrodynamics/Aerodynamics/flightConditions.h
@@ -19,6 +19,7 @@
 #include "Tudat/Astrodynamics/Aerodynamics/trimOrientation.h"
 #include "Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientInterface.h"
 #include "Tudat/Astrodynamics/Aerodynamics/atmosphereModel.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/bodyShapeModel.h"
 #include "Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.h"
 #include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
 
@@ -39,6 +40,21 @@ namespace aerodynamics
  */
 class FlightConditions
 {
+private:
+
+    enum FlightConditionVariables
+    {
+        altitude_flight_condition,
+        density_flight_condition,
+        temperature_flight_condition,
+        latitude_flight_condition,
+        longitude_flight_condition,
+        mach_number_flight_condition,
+        speed_of_sound_flight_condition,
+        airspeed_flight_condition,
+        geodetic_latitude_condition
+    };
+
 public:
 
     //! Constructor, sets objects and functions from which relevant environment and state variables
@@ -55,7 +71,7 @@ public:
      *  of the vehicle are calculated.
      */
     FlightConditions( const boost::shared_ptr< aerodynamics::AtmosphereModel > atmosphereModel,
-                      const boost::function< double( const Eigen::Vector3d ) > altitudeFunction,
+                      const boost::shared_ptr< basic_astrodynamics::BodyShapeModel > shapeModel,
                       const boost::shared_ptr< AerodynamicCoefficientInterface >
                       aerodynamicCoefficientInterface,
                       const boost::shared_ptr< reference_frames::AerodynamicAngleCalculator >
@@ -75,10 +91,13 @@ public:
      *  Function to return altitude that was set by previous call of updateConditions function.
      *  \return Current altitude
      */
-    double getCurrentAltitude( ) const
+    double getCurrentAltitude( )
     {
-        return currentAltitude_;
-    }
+        if( scalarFlightConditions_.count( altitude_flight_condition ) == 0 )
+        {
+            computeAltitude( );
+        }
+        return scalarFlightConditions_.at( altitude_flight_condition );    }
 
     //! Function to return density
     /*!
@@ -86,9 +105,22 @@ public:
      *  updateDensity function.
      *  \return Current density
      */
-    double getCurrentDensity( ) const
+    double getCurrentDensity( )
+    {
+        if( scalarFlightConditions_.count( density_flight_condition ) == 0 )
+        {
+            computeDensity( );
+        }
+        return scalarFlightConditions_.at( density_flight_condition );
+    }
+
+    double getCurrentFreestreamTemperature( )
     {
-        return currentDensity_;
+        if( scalarFlightConditions_.count( temperature_flight_condition ) == 0 )
+        {
+            computeTemperature( );
+        }
+        return scalarFlightConditions_.at( temperature_flight_condition );
     }
 
     //! Function to return airspeed
@@ -96,9 +128,13 @@ public:
      *  Function to return airspeed that was set by previous call of updateConditions.
      *  \return Current airspeed
      */
-    double getCurrentAirspeed( ) const
+    double getCurrentAirspeed( )
     {
-        return currentAirspeed_;
+        if( scalarFlightConditions_.count( airspeed_flight_condition ) == 0 )
+        {
+            computeAirspeed( );
+        }
+        return scalarFlightConditions_.at( airspeed_flight_condition );
     }
 
     //! Function to return speed of sound
@@ -108,8 +144,29 @@ public:
      */
     double getCurrentSpeedOfSound( )
     {
-        return atmosphereModel_->getSpeedOfSound(
-                    currentAltitude_, currentLongitude_, currentLatitude_, currentTime_ );
+        if( scalarFlightConditions_.count( speed_of_sound_flight_condition ) == 0 )
+        {
+            computeSpeedOfSound( );
+        }
+        return scalarFlightConditions_.at( speed_of_sound_flight_condition );
+    }
+
+    double getCurrentMachNumber( )
+    {
+        if( scalarFlightConditions_.count( mach_number_flight_condition ) == 0 )
+        {
+            computeMachNumber( );
+        }
+        return scalarFlightConditions_.at( mach_number_flight_condition );
+    }
+
+    double getCurrentGeodeticLatitude( )
+    {
+        if( scalarFlightConditions_.count( geodetic_latitude_condition ) == 0 )
+        {
+            computeGeodeticLAtitude( );
+        }
+        return scalarFlightConditions_.at( geodetic_latitude_condition );
     }
 
     //! Function to return the current time of the FlightConditions
@@ -117,7 +174,7 @@ public:
      *  Function to return the current time of the FlightConditions.
      *  \return Current time of the FlightConditions
      */
-    double getCurrentTime( ) const
+    double getCurrentTime( )
     {
         return currentTime_;
     }
@@ -217,12 +274,109 @@ public:
      */
     void resetCurrentTime( const double currentTime = TUDAT_NAN )
     {
+        scalarFlightConditions_.clear( );
         currentTime_ = currentTime;
         aerodynamicAngleCalculator_->resetCurrentTime( currentTime_ );
     }
 
 private:
 
+    void computeLatitudeAndLongitude( )
+    {
+        scalarFlightConditions_[ latitude_flight_condition ] = aerodynamicAngleCalculator_->getAerodynamicAngle(
+                    reference_frames::latitude_angle );
+        scalarFlightConditions_[ longitude_flight_condition ] = aerodynamicAngleCalculator_->getAerodynamicAngle(
+                    reference_frames::longitude_angle );
+    }
+
+    void computeAltitude( )
+    {
+        scalarFlightConditions_[ altitude_flight_condition ] =
+                shapeModel_->getAltitude( currentBodyCenteredPseudoBodyFixedState_.segment( 0, 3 ) );
+    }
+
+    void updateAtmosphereInput( )
+    {
+        if( ( scalarFlightConditions_.count( latitude_flight_condition ) == 0 ||
+              scalarFlightConditions_.count( longitude_flight_condition ) == 0 ) )
+        {
+            if( updateLatitudeAndLongitude_ )
+            {
+                computeLatitudeAndLongitude( );
+            }
+            else
+            {
+                scalarFlightConditions_[ latitude_flight_condition ] = 0.0;
+                scalarFlightConditions_[ longitude_flight_condition ] = 0.0;
+            }
+
+        }
+
+        if( scalarFlightConditions_.count( altitude_flight_condition ) == 0 )
+        {
+            computeAltitude( );
+        }
+    }
+
+    void computeDensity( )
+    {
+        updateAtmosphereInput( );
+        scalarFlightConditions_[ density_flight_condition ] =
+                atmosphereModel_->getDensity(
+                    scalarFlightConditions_.at( altitude_flight_condition ),
+                    scalarFlightConditions_.at( longitude_flight_condition ),
+                    scalarFlightConditions_.at( latitude_flight_condition ), currentTime_ );
+    }
+
+    void computeTemperature( )
+    {        updateAtmosphereInput( );
+
+             scalarFlightConditions_[ temperature_flight_condition ] =
+                     atmosphereModel_->getTemperature(
+                         scalarFlightConditions_.at( altitude_flight_condition ),
+                         scalarFlightConditions_.at( longitude_flight_condition ),
+                         scalarFlightConditions_.at( latitude_flight_condition ), currentTime_ );
+    }
+
+    void computeSpeedOfSound( )
+    {
+        updateAtmosphereInput( );
+        scalarFlightConditions_[ speed_of_sound_flight_condition ]  =
+                atmosphereModel_->getSpeedOfSound(
+                    scalarFlightConditions_.at( altitude_flight_condition ),
+                    scalarFlightConditions_.at( longitude_flight_condition ),
+                    scalarFlightConditions_.at( latitude_flight_condition ), currentTime_ );
+    }
+
+    void computeAirspeed( )
+    {
+        scalarFlightConditions_[ airspeed_flight_condition ] = currentBodyCenteredPseudoBodyFixedState_.segment( 3, 3 ).norm( );
+    }
+
+
+    void computeMachNumber( )
+    {
+        scalarFlightConditions_[ mach_number_flight_condition ] =
+                getCurrentAirspeed( ) / getCurrentSpeedOfSound( );
+    }
+
+    void computeGeodeticLAtitude( )
+    {
+        if( !geodeticLatitudeFunction_.empty( ) )
+        {
+            scalarFlightConditions_[ geodetic_latitude_condition ] = geodeticLatitudeFunction_(
+                        currentBodyCenteredPseudoBodyFixedState_.segment( 0, 3 ) );
+        }
+        else
+        {
+            if( scalarFlightConditions_.count( latitude_flight_condition ) == 0 )
+            {
+                computeLatitudeAndLongitude( );
+            }
+            scalarFlightConditions_[ geodetic_latitude_condition ] = scalarFlightConditions_[ latitude_flight_condition ] ;
+        }
+    }
+
     //! Function to update the independent variables of the aerodynamic coefficient interface
     void updateAerodynamicCoefficientInput( );
 
@@ -232,8 +386,8 @@ private:
     //! Atmosphere model of atmosphere through which vehicle is flying
     boost::shared_ptr< aerodynamics::AtmosphereModel > atmosphereModel_;
 
-    //! Function returning the altitude of the vehicle as a function of its body-fixed position.
-    const boost::function< double( const Eigen::Vector3d ) > altitudeFunction_;
+    const boost::shared_ptr< basic_astrodynamics::BodyShapeModel > shapeModel_;
+
 
     //! Function to return the current state of the vehicle in a body-fixed frame.
     boost::function< basic_mathematics::Vector6d( ) > bodyCenteredPseudoBodyFixedStateFunction_;
@@ -251,20 +405,9 @@ private:
     //! Current state of vehicle in body-fixed frame.
     basic_mathematics::Vector6d currentBodyCenteredPseudoBodyFixedState_;
 
-    //! Current density at vehicle's position.
-    double currentDensity_;
-
-    //! Current airspeed at vehicle's position.
-    double currentAirspeed_;
 
-    //! Current altitude of vehicle above central body's shapeModel_
-    double currentAltitude_;
 
-    //! Current latitude of vehicle above central body.
-    double currentLatitude_;
-
-    //! Current longitude of vehicle above central body.
-    double currentLongitude_;
+    std::map< FlightConditionVariables, double > scalarFlightConditions_;
 
     //! Current time of propagation.
     double currentTime_;
@@ -275,6 +418,8 @@ private:
     //! Boolean setting whether latitude and longitude are to be updated by updateConditions().
     bool updateLatitudeAndLongitude_;
 
+    boost::function< double( const Eigen::Vector3d& ) > geodeticLatitudeFunction_;
+
     //! Current list of independent variables of the aerodynamic coefficient interface
     std::vector< double > aerodynamicCoefficientIndependentVariables_;
 
diff --git a/Tudat/Astrodynamics/Aerodynamics/heatFluxFunction.h b/Tudat/Astrodynamics/Aerodynamics/heatFluxFunction.h
new file mode 100755
index 0000000..d79b3c8
--- /dev/null
+++ b/Tudat/Astrodynamics/Aerodynamics/heatFluxFunction.h
@@ -0,0 +1,64 @@
+
+#include <Tudat/Mathematics/BasicMathematics/basicFunction.h>
+#include <Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h>
+
+namespace tudat
+{
+
+namespace aerodynamics
+{
+
+class EquilibriumTemperatureFunction: public tudat::basic_mathematics::Function<double,double>
+{
+public:
+    //! Constructor.
+    EquilibriumTemperatureFunction(
+            const boost::function< double( const double ) > heatTransferFunction,
+            const double wallEmissivity,
+            double adiabaticWallTemperature ):
+       heatTransferFunction_( heatTransferFunction ), wallEmissivity_( wallEmissivity ),
+       adiabaticWallTemperature_( adiabaticWallTemperature ){ }
+
+
+    //! Destructor.
+    ~EquilibriumTemperatureFunction(){}
+
+    double evaluate( const double currentWallTemperature )
+    {
+        return heatTransferFunction_( currentWallTemperature )
+                - wallEmissivity_* tudat::physical_constants::STEFAN_BOLTZMANN_CONSTANT * std::pow( currentWallTemperature, 4.0 );
+    }
+
+    // FUNCTION NOT IMPLEMENTED
+    double computeDerivative( const unsigned int order, const double independentVariable )
+    {
+        throw std::runtime_error( "Error, derivative of heat flux not defined" );
+        return TUDAT_NAN;
+    }
+
+    // FUNCTION NOT IMPLEMENTED
+    double computeDefiniteIntegral( const unsigned int order, const double lowerBound, const double upperbound )
+    {
+        throw std::runtime_error( "Error, integrall of heat flux not defined" );
+        return TUDAT_NAN;
+    }
+
+    double getLowerBound( ) { return 0.0; }
+
+    double getUpperBound( ) { return adiabaticWallTemperature_*0.25; }
+
+    double getInitialGuess( ) { return adiabaticWallTemperature_*0.01; }
+
+protected:
+
+private:
+    // Private variables.
+    boost::function< double( const double ) > heatTransferFunction_;
+
+    const double wallEmissivity_;
+
+    double adiabaticWallTemperature_;
+};
+
+} //namespace_aerodynamics
+} //namespace_tudat
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/oblateSpheroidBodyShapeModel.h b/Tudat/Astrodynamics/BasicAstrodynamics/oblateSpheroidBodyShapeModel.h
index 2992f2b..e9761fa 100644
--- a/Tudat/Astrodynamics/BasicAstrodynamics/oblateSpheroidBodyShapeModel.h
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/oblateSpheroidBodyShapeModel.h
@@ -105,6 +105,13 @@ public:
                     bodyFixedPosition, equatorialRadius_, flattening_, tolerance );
     }
 
+    double getGeodeticLatitude( const Eigen::Vector3d& bodyFixedPosition,
+                                        const double tolerance = 1.0E-4 )
+    {
+        return coordinate_conversions::calculateGeodeticLatitude(
+                    bodyFixedPosition, equatorialRadius_, flattening_, tolerance );
+    }
+
     //! Function to return the mean radius of the oblate spheroid.
     /*!
      *  Function to return the mean radius of the oblate spheroid.
diff --git a/Tudat/Astrodynamics/CMakeLists.txt b/Tudat/Astrodynamics/CMakeLists.txt
index 76ab4a5..5f6a5a8 100755
--- a/Tudat/Astrodynamics/CMakeLists.txt
+++ b/Tudat/Astrodynamics/CMakeLists.txt
@@ -1,4 +1,4 @@
-#    Copyright (c) 2010-2015, Delft University of Technology
+ #    Copyright (c) 2010-2015, Delft University of Technology
  #    All rights reserved.
  #
  #    Redistribution and use in source and binary forms, with or without modification, are
@@ -34,6 +34,7 @@
  #
  #    Notes
  #
+
 # Define the main sub-directories.
 set(AERODYNAMICSDIR "${ASTRODYNAMICSDIR}/Aerodynamics")
 set(BASICASTRODYNAMICSDIR "${ASTRODYNAMICSDIR}/BasicAstrodynamics")
diff --git a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestDependentVariableOutput.cpp b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestDependentVariableOutput.cpp
index df968f1..241c52c 100644
--- a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestDependentVariableOutput.cpp
+++ b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestDependentVariableOutput.cpp
@@ -41,7 +41,7 @@ namespace unit_tests
 BOOST_AUTO_TEST_SUITE( test_dependent_variable_output )
 
 //! Propagate entry of Apollo capsule, and save a list of dependent variables during entry. The saved dependent variables
-//! are compared against theoretical/manual values in this test.
+//! are compred against theoretical/manual values in this test.
 BOOST_AUTO_TEST_CASE( testDependentVariableOutput )
 {
     using namespace tudat;
@@ -124,7 +124,7 @@ BOOST_AUTO_TEST_CASE( testDependentVariableOutput )
     accelerationsOfApollo[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
     accelerationsOfApollo[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( aerodynamic ) );
     accelerationsOfApollo[ "Moon" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
-    accelerationMap[ "Apollo" ] = accelerationsOfApollo;
+    accelerationMap[  "Apollo" ] = accelerationsOfApollo;
 
     bodiesToPropagate.push_back( "Apollo" );
     centralBodies.push_back( "Earth" );
@@ -188,14 +188,14 @@ BOOST_AUTO_TEST_CASE( testDependentVariableOutput )
     // Retrieve numerical solutions for state and dependent variables
     std::map< double, Eigen::Matrix< double, Eigen::Dynamic, 1 > > numericalSolution =
             dynamicsSimulator.getEquationsOfMotionNumericalSolution( );
-    std::map< double, Eigen::VectorXd > dependentVariableSolution =
+    std::map< double, Eigen::VectorXd > dependentVariableSoution =
             dynamicsSimulator.getDependentVariableHistory( );
 
     // Iterate over results for dependent variables, and check against manually retrieved values.
     basic_mathematics::Vector6d currentStateDerivative;
     Eigen::Vector3d manualCentralGravity;
-    for( std::map< double, Eigen::VectorXd >::iterator variableIterator = dependentVariableSolution.begin( );
-         variableIterator != dependentVariableSolution.end( ); variableIterator++ )
+    for( std::map< double, Eigen::VectorXd >::iterator variableIterator = dependentVariableSoution.begin( );
+         variableIterator != dependentVariableSoution.end( ); variableIterator++ )
     {
         currentStateDerivative = dynamicsSimulator.getDynamicsStateDerivative( )->computeStateDerivative(
                     variableIterator->first, numericalSolution.at( variableIterator->first ) );
diff --git a/Tudat/Astrodynamics/ReferenceFrames/UnitTests/unitTestReferenceFrameTransformations.cpp b/Tudat/Astrodynamics/ReferenceFrames/UnitTests/unitTestReferenceFrameTransformations.cpp
index 220ab9b..e989777 100644
--- a/Tudat/Astrodynamics/ReferenceFrames/UnitTests/unitTestReferenceFrameTransformations.cpp
+++ b/Tudat/Astrodynamics/ReferenceFrames/UnitTests/unitTestReferenceFrameTransformations.cpp
@@ -50,17 +50,13 @@
 
 #define BOOST_TEST_MAIN
 
-#include <iostream>
-
 #include <boost/test/unit_test.hpp>
 
 #include <Eigen/Core>
 
 #include "Tudat/Basics/testMacros.h"
 #include "Tudat/Astrodynamics/BasicAstrodynamics/unitConversions.h"
-#include "Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h"
 
-#include "Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.h"
 #include "Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h"
 
 namespace tudat
@@ -121,11 +117,11 @@ BOOST_AUTO_TEST_CASE( testRotatingPlanetocentricFrameTransformations )
         expectedLocation( 1 ) = horizontalStartLocationSize * sin( endAngle );
         expectedLocation( 2 ) = startLocation( 2 );
 
-        // Compute location of the point in the rotating frame subject to the transformation
+        // Compute location of the point in the rotating frame subject to the transformation 
         // matrix.
         Eigen::Vector3d transformedLocation;
         transformedLocation = reference_frames::
-                getInertialToPlanetocentricFrameTransformationMatrix( angleInTime )
+                getInertialToPlanetocentricFrameTransformationMatrix( angleInTime ) 
                 * startLocation;
 
         // Check whether both vectors are equal within tolerances.
@@ -207,8 +203,8 @@ BOOST_AUTO_TEST_CASE( testRotatingPlanetocentricFrameTransformationQuaternion )
                                            std::numeric_limits< double >::epsilon( ) );
     }
 
-    // Test 4: Same test as Test 2 for the transformation quaternion.
-    // Compute the error in the calculation.
+// Test 4: Same test as Test 2 for the transformation quaternion.
+// Compute the error in the calculation.
     {
         // Initialize initial location vector in inertial frame.
         Eigen::Vector3d startLocation;
@@ -263,7 +259,7 @@ BOOST_AUTO_TEST_CASE( testAirspeedBasedAerodynamicToBodyFrameTransformation )
         Eigen::Vector3d transformedLocation;
         transformedLocation = reference_frames::
                 getAirspeedBasedAerodynamicToBodyFrameTransformationMatrix(
-                    angleOfAttack, angleOfSideslip ) * startLocation;
+                        angleOfAttack, angleOfSideslip ) * startLocation;
 
         // Check whether both vectors are equal within tolerances.
         TUDAT_CHECK_MATRIX_CLOSE_FRACTION( transformedLocation, expectedLocation, 1.0e-14 );
@@ -308,7 +304,7 @@ BOOST_AUTO_TEST_CASE( testRotatingPlanetocentricToLocalVerticalFrameTransformati
         Eigen::Vector3d transformedLocation;
         transformedLocation = reference_frames::
                 getRotatingPlanetocentricToLocalVerticalFrameTransformationQuaternion(
-                    longitude, latitude ) * startLocation;
+                        longitude, latitude ) * startLocation;
 
         // Check whether both vectors are equal within tolerances.
         TUDAT_CHECK_MATRIX_CLOSE_FRACTION( transformedLocation, expectedLocation, 1.0e-14 );
@@ -428,50 +424,50 @@ BOOST_AUTO_TEST_CASE( testTrajectoryToLocalVerticalFrameTransformations )
                 Eigen::Vector3d expectedLocation;
                 Eigen::Matrix3d rotation;
                 rotation << cos( headingAngle ) * cos( flightPathAngle ),
-                        -sin( headingAngle ),
-                        cos( headingAngle ) * sin( flightPathAngle ),
-                        sin( headingAngle ) * cos( flightPathAngle ),
-                        cos( headingAngle ),
-                        sin( headingAngle ) * sin( flightPathAngle ),
-                        -sin( flightPathAngle ),
-                        0.0,
-                        cos( flightPathAngle );
-                expectedLocation = rotation * startLocation;
+                            -sin( headingAngle ),
+                            cos( headingAngle ) * sin( flightPathAngle ),
+                            sin( headingAngle ) * cos( flightPathAngle ),
+                            cos( headingAngle ),
+                            sin( headingAngle ) * sin( flightPathAngle ),
+                            -sin( flightPathAngle ),
+                            0.0,
+                            cos( flightPathAngle );
+                            expectedLocation = rotation * startLocation;
 
                 // Compute location of the point in the V-frame using the tested function.
                 Eigen::Vector3d transformedLocationQuat =
                         reference_frames::
                         getTrajectoryToLocalVerticalFrameTransformationQuaternion(
-                            flightPathAngle, headingAngle ) * startLocation;
+                                flightPathAngle, headingAngle ) * startLocation;
                 Eigen::Vector3d transformedLocationMat =
                         reference_frames::getTrajectoryToLocalVerticalFrameTransformationMatrix(
-                            flightPathAngle, headingAngle ) * startLocation;
+                                flightPathAngle, headingAngle ) * startLocation;
 
                 // Compute product of inverse rotations.
                 Eigen::Vector3d inverseRotationProductMat =
                         reference_frames::getTrajectoryToLocalVerticalFrameTransformationMatrix(
-                            flightPathAngle, headingAngle ) *
+                                flightPathAngle, headingAngle ) *
                         reference_frames::getLocalVerticalFrameToTrajectoryTransformationMatrix(
-                            flightPathAngle, headingAngle ) * startLocation;
+                                flightPathAngle, headingAngle ) * startLocation;
                 Eigen::Vector3d inverseRotationProductQuat =
                         reference_frames::
                         getTrajectoryToLocalVerticalFrameTransformationQuaternion(
-                            flightPathAngle, headingAngle ) *
+                                flightPathAngle, headingAngle ) *
                         reference_frames::
                         getLocalVerticalFrameToTrajectoryTransformationQuaternion(
-                            flightPathAngle, headingAngle ) * startLocation;
+                                flightPathAngle, headingAngle ) * startLocation;
 
                 // Check whether transformed vectors match within tolerances.
                 TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
-                            transformedLocationQuat, expectedLocation, 1.0e-14 );
+                        transformedLocationQuat, expectedLocation, 1.0e-14 );
                 TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
-                            transformedLocationMat, expectedLocation, 2.0e-14 );
+                        transformedLocationMat, expectedLocation, 2.0e-14 );
 
                 // Check whether product of inverse rotations equals unity.
                 TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
-                            inverseRotationProductMat, startLocation, 1.0e-14 );
+                        inverseRotationProductMat, startLocation, 1.0e-14 );
                 TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
-                            inverseRotationProductQuat, startLocation, 1.0e-14 );
+                        inverseRotationProductQuat, startLocation, 1.0e-14 );
             }
         }
     }
@@ -502,40 +498,40 @@ BOOST_AUTO_TEST_CASE( testTrajectoryToAerodynamicFrameTransformations )
             Eigen::Vector3d expectedLocation;
             Eigen::Matrix3d rotation;
             rotation << 1.0, 0.0, 0.0,
-                    0.0, cos( bankAngle ), -sin( bankAngle ),
-                    0.0, sin( bankAngle ), cos( bankAngle );
+                        0.0, cos( bankAngle ), -sin( bankAngle ),
+                        0.0, sin( bankAngle ), cos( bankAngle );
             expectedLocation = rotation * startLocation;
 
             // Compute location of the point in the rotating frame subject to the
             // transformation matrix.
             Eigen::Vector3d transformedLocationQuat =
                     reference_frames::getTrajectoryToAerodynamicFrameTransformationQuaternion(
-                        bankAngle ) * startLocation;
+                            bankAngle ) * startLocation;
             Eigen::Vector3d transformedLocationMat =
                     reference_frames::getTrajectoryToAerodynamicFrameTransformationMatrix(
-                        bankAngle ) * startLocation;
+                            bankAngle ) * startLocation;
 
             // Compute product of inverse rotations.
             Eigen::Vector3d inverseRotationProductMat =
                     reference_frames::getAerodynamicToTrajectoryFrameTransformationMatrix(
-                        bankAngle ) *
+                            bankAngle ) *
                     reference_frames::getTrajectoryToAerodynamicFrameTransformationMatrix(
-                        bankAngle ) * startLocation;
+                            bankAngle ) * startLocation;
             Eigen::Vector3d inverseRotationProductQuat =
                     reference_frames::getAerodynamicToTrajectoryFrameTransformationQuaternion(
-                        bankAngle ) *
+                            bankAngle ) *
                     reference_frames::getTrajectoryToAerodynamicFrameTransformationQuaternion(
-                        bankAngle ) * startLocation;
+                            bankAngle ) * startLocation;
 
             // Check whether transformed vectors match within tolerances.
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
-                        transformedLocationQuat, expectedLocation, 1.0e-14 );
+                    transformedLocationQuat, expectedLocation, 1.0e-14 );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION( transformedLocationMat, expectedLocation, 1.0e-14 );
 
             // Check whether product of inverse rotations equals unity.
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION( inverseRotationProductMat, startLocation, 1.0e-14 );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
-                        inverseRotationProductQuat, startLocation, 1.0e-14 );
+                    inverseRotationProductQuat, startLocation, 1.0e-14 );
         }
     }
 }
@@ -569,400 +565,58 @@ BOOST_AUTO_TEST_CASE( testAerodynamicToBodyFrameTransformations )
                 Eigen::Vector3d expectedLocation;
                 Eigen::Matrix3d rotation;
                 rotation << cos( angleOfAttack ) * cos( angleOfSideslip ),
-                        sin( angleOfSideslip ),
-                        sin( angleOfAttack ) * cos( angleOfSideslip ),
-                        -cos( angleOfAttack ) * sin( angleOfSideslip ),
-                        cos( angleOfSideslip ),
-                        -sin( angleOfAttack ) * sin( angleOfSideslip ),
-                        -sin( angleOfAttack ),
-                        0.0,
-                        cos( angleOfAttack );
+                            sin( angleOfSideslip ),
+                            sin( angleOfAttack ) * cos( angleOfSideslip ),
+                            -cos( angleOfAttack ) * sin( angleOfSideslip ),
+                            cos( angleOfSideslip ),
+                            -sin( angleOfAttack ) * sin( angleOfSideslip ),
+                            -sin( angleOfAttack ),
+                            0.0,
+                            cos( angleOfAttack );
                 expectedLocation = rotation * startLocation;
 
                 // Compute location of the point in the AA-frame using the tested function.
                 Eigen::Vector3d transformedLocationQuat =
                         reference_frames::
                         getBodyToAirspeedBasedAerodynamicFrameTransformationQuaternion(
-                            angleOfAttack, angleOfSideslip ) * startLocation;
+                                angleOfAttack, angleOfSideslip ) * startLocation;
                 Eigen::Vector3d transformedLocationMat =
                         reference_frames::
                         getBodyToAirspeedBasedAerodynamicFrameTransformationMatrix(
-                            angleOfAttack, angleOfSideslip ) * startLocation;
+                                angleOfAttack, angleOfSideslip ) * startLocation;
 
                 // Compute product of inverse rotations
                 Eigen::Vector3d inverseRotationProductMat =
                         reference_frames::
                         getAirspeedBasedAerodynamicToBodyFrameTransformationMatrix(
-                            angleOfAttack, angleOfSideslip ) *
+                                angleOfAttack, angleOfSideslip ) *
                         reference_frames::
                         getBodyToAirspeedBasedAerodynamicFrameTransformationMatrix(
-                            angleOfAttack, angleOfSideslip ) * startLocation;
+                                angleOfAttack, angleOfSideslip ) * startLocation;
                 Eigen::Vector3d inverseRotationProductQuat =
                         reference_frames::
                         getAirspeedBasedAerodynamicToBodyFrameTransformationQuaternion(
-                            angleOfAttack, angleOfSideslip ) *
+                                angleOfAttack, angleOfSideslip ) *
                         reference_frames::
                         getBodyToAirspeedBasedAerodynamicFrameTransformationQuaternion(
-                            angleOfAttack, angleOfSideslip ) * startLocation;
+                                angleOfAttack, angleOfSideslip ) * startLocation;
 
                 // Check whether transformed vectors match within tolerances.
                 TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
-                            transformedLocationQuat, expectedLocation, 1.0e-14 );
+                        transformedLocationQuat, expectedLocation, 1.0e-14 );
                 TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
-                            transformedLocationMat, expectedLocation, 1.0e-14 );
+                        transformedLocationMat, expectedLocation, 1.0e-14 );
 
                 // Check whether product of inverse rotations equals unity.
                 TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
-                            inverseRotationProductMat, startLocation, 1.0e-14 );
+                        inverseRotationProductMat, startLocation, 1.0e-14 );
                 TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
-                            inverseRotationProductQuat, startLocation, 1.0e-14 );
-            }
-        }
-    }
-}
-
-//! Function to test if a matrix is an identity matrix.
-void testIsIdentityMatrix( const Eigen::Matrix3d matrixToTest )
-{
-    for( unsigned int i = 0; i < 3; i++ )
-    {
-        for( unsigned int j = 0; j < 3; j++ )
-        {
-            if( i == j )
-            {
-                BOOST_CHECK_CLOSE_FRACTION( matrixToTest( i, j ), 1.0, std::numeric_limits< double >::epsilon( ) );
-            }
-            else
-            {
-                BOOST_CHECK_SMALL( std::fabs( matrixToTest( i, j ) ), std::numeric_limits< double >::epsilon( ) );
-            }
-        }
-    }
-}
-
-//! Function to test if a rotation matrix defines a right-handed frame.
-void testIsRotationMatrixRightHanded( const Eigen::Matrix3d matrixToTest )
-{
-    Eigen::Vector3d expectedUnitVectorZ =
-           ( Eigen::Vector3d( matrixToTest.block( 0, 0, 0, 3 ) ) ).cross(
-                Eigen::Vector3d( matrixToTest.block( 0, 1, 0, 3 ) ) );
-    Eigen::Vector3d expectedUnitVectorX =
-           ( Eigen::Vector3d( matrixToTest.block( 0, 1, 0, 3 ) ) ).cross(
-                Eigen::Vector3d( matrixToTest.block( 0, 2, 0, 3 ) ) );
-    Eigen::Vector3d expectedUnitVectorY  =
-           ( Eigen::Vector3d( matrixToTest.block( 0, 2, 0, 3 ) ) ).cross(
-                Eigen::Vector3d( matrixToTest.block( 0, 0, 0, 3 ) ) );
-    for( unsigned int i = 0; i < 3; i++ )\
-    {
-        BOOST_CHECK_CLOSE_FRACTION(
-                    expectedUnitVectorX( i ), matrixToTest( i, 0 ), 2.0 * std::numeric_limits< double >::epsilon( ) );
-        BOOST_CHECK_CLOSE_FRACTION(
-                    expectedUnitVectorY( i ), matrixToTest( i, 1 ), 2.0 * std::numeric_limits< double >::epsilon( ) );
-        BOOST_CHECK_CLOSE_FRACTION(
-                    expectedUnitVectorZ( i ), matrixToTest( i, 2 ), 2.0 * std::numeric_limits< double >::epsilon( ) );
-    }
-}
-
-// Test velocity based LVLH frame transformation.
-BOOST_AUTO_TEST_CASE( testVelocityBasedLvlhFrameTransformations )
-{
-    // Using declarations.
-    using std::atan2;
-    using std::cos;
-    using std::sin;
-    using std::pow;
-    using std::sqrt;
-
-    // Test 11: Test velocity=based LVLH frame to inertial (I) frame transformation: for arbitrary state vectors,
-    // test all expected properties of rotation matrices
-    {
-        // Position vectors to semi-random values
-        tudat::basic_mathematics::Vector6d vehicleStateCartesian, centralBodyStateCartesian, relativeState;
-        vehicleStateCartesian << 3.2, -1.7, 8.2, -1.4E-3, -5.6E-4, 9.2E-4;
-        centralBodyStateCartesian << 7.4, 6.3, -3.6, 5.3E-4, 7.64E3, -4.4E-4;
-
-        Eigen::Matrix3d nAxisAwayFromBodyMatrix = reference_frames::getVelocityBasedLvlhToInertialRotation(
-                    vehicleStateCartesian, centralBodyStateCartesian, true );
-        Eigen::Matrix3d nAxisAwayTowardsBodyMatrix = reference_frames::getVelocityBasedLvlhToInertialRotation(
-                    vehicleStateCartesian, centralBodyStateCartesian, false );
-
-        // Test if central body is properly processed.
-        {
-            Eigen::Matrix3d nAxisAwayFromBodyMatrixCentral = reference_frames::getVelocityBasedLvlhToInertialRotation(
-                        vehicleStateCartesian - centralBodyStateCartesian, basic_mathematics::Vector6d::Zero( ), true );
-            Eigen::Matrix3d nAxisAwayTowardsBodyMatrixCentral = reference_frames::getVelocityBasedLvlhToInertialRotation(
-                        vehicleStateCartesian - centralBodyStateCartesian, basic_mathematics::Vector6d::Zero( ), false );
-
-            for( unsigned int i = 0; i < 3; i++ )
-            {
-                for( unsigned int j = 0; j < 3; j++ )
-                {
-                    BOOST_CHECK_CLOSE_FRACTION(
-                                nAxisAwayFromBodyMatrixCentral( i, j ), nAxisAwayFromBodyMatrix( i, j ),
-                                2.0 * std::numeric_limits< double >::epsilon( ) );
-                    BOOST_CHECK_CLOSE_FRACTION(
-                                nAxisAwayTowardsBodyMatrix( i, j ), nAxisAwayTowardsBodyMatrixCentral( i, j ),
-                                2.0 * std::numeric_limits< double >::epsilon( ) );
-                }
-
-            }
-        }
-
-        // Compute Relative states
-        relativeState = vehicleStateCartesian - centralBodyStateCartesian;
-
-        // Test if n axis indeed points away from body
-        double positionDotProuctWithNAwayFromBody =
-                Eigen::Vector3d( nAxisAwayFromBodyMatrix.block( 0, 1, 3, 1 ) ).dot(
-                    relativeState.segment( 0, 3 ).normalized( ) );
-        BOOST_CHECK_EQUAL( positionDotProuctWithNAwayFromBody > 0, 1 );
-
-        // Test if n axis indeed points towards body
-        double positionDotProuctWithNTowardsBody =
-                Eigen::Vector3d( nAxisAwayTowardsBodyMatrix.block( 0, 1, 3, 1 ) ).dot(
-                    relativeState.segment( 0, 3 ).normalized( ) );
-        BOOST_CHECK_EQUAL( positionDotProuctWithNTowardsBody < 0, 1 );
-
-        // Check if axes point exactly in opposite directions
-        BOOST_CHECK_CLOSE_FRACTION( positionDotProuctWithNAwayFromBody, -positionDotProuctWithNTowardsBody,
-                                    std::numeric_limits< double >::epsilon( ) );
-
-        // Test if two matrices compare as they should
-        for( unsigned int i = 0; i < 3; i++ )
-        {
-            for( unsigned int j = 0; j < 3; j++ )
-            {
-                BOOST_CHECK_CLOSE_FRACTION(
-                            nAxisAwayFromBodyMatrix( i, j ), ( j == 0 ? 1.0 : -1.0 ) * nAxisAwayTowardsBodyMatrix( i, j ),
-                            2.0 * std::numeric_limits< double >::epsilon( ) );
-            }
-        }
-
-        // Test orthonormality of matrices
-        Eigen::Matrix3d matrixProduct;
-        matrixProduct = nAxisAwayFromBodyMatrix * nAxisAwayFromBodyMatrix.transpose( );
-        testIsIdentityMatrix( matrixProduct );
-
-        matrixProduct = nAxisAwayTowardsBodyMatrix * nAxisAwayTowardsBodyMatrix.transpose( );
-        testIsIdentityMatrix( matrixProduct );
-
-        matrixProduct = nAxisAwayFromBodyMatrix * nAxisAwayFromBodyMatrix.inverse( );
-        testIsIdentityMatrix( matrixProduct );
-
-        matrixProduct = nAxisAwayTowardsBodyMatrix * nAxisAwayTowardsBodyMatrix.inverse( );
-        testIsIdentityMatrix( matrixProduct );
-
-        // Test if matrices define right-handed frames
-        testIsRotationMatrixRightHanded( nAxisAwayFromBodyMatrix );
-        testIsRotationMatrixRightHanded( nAxisAwayTowardsBodyMatrix );
-
-        Eigen::Vector3d lvlhFrameThrust1, lvlhFrameThrust2;
-
-        // Define semi-random thrust vector along velocity vector
-        double thrustScale = 25.2;
-        Eigen::Vector3d inertialThrustVectorAlongVelocity = thrustScale * relativeState.segment( 3, 3 );
-        {
-            // Compute local thrust vectors
-            lvlhFrameThrust1 =
-                    nAxisAwayFromBodyMatrix.transpose( ) * inertialThrustVectorAlongVelocity;
-            lvlhFrameThrust2 =
-                    nAxisAwayTowardsBodyMatrix.transpose( ) * inertialThrustVectorAlongVelocity;
-
-            // Compute thrust vector magnitudes
-            double thrustMagnitudeAlongVelocityVector = inertialThrustVectorAlongVelocity.norm( );
-
-            // Test if entry 0 of two vectors are the same
-            BOOST_CHECK_CLOSE_FRACTION( lvlhFrameThrust1( 0 ), lvlhFrameThrust2( 0 ),
-                                        std::numeric_limits< double >::epsilon( ) );
-
-            // Test thrust vector norms.
-            BOOST_CHECK_CLOSE_FRACTION( thrustMagnitudeAlongVelocityVector, lvlhFrameThrust1.norm( ),
-                                        5.0 * std::numeric_limits< double >::epsilon( ) );
-            BOOST_CHECK_CLOSE_FRACTION( thrustMagnitudeAlongVelocityVector, lvlhFrameThrust2.norm( ),
-                                        5.0 * std::numeric_limits< double >::epsilon( ) );
-
-            // Test if entry 0 magnitude is equal to norm
-            BOOST_CHECK_CLOSE_FRACTION( std::fabs( lvlhFrameThrust1( 0 ) ), thrustMagnitudeAlongVelocityVector,
-                                        std::numeric_limits< double >::epsilon( ) );
-            BOOST_CHECK_CLOSE_FRACTION( std::fabs( lvlhFrameThrust2( 0 ) ), thrustMagnitudeAlongVelocityVector,
-                                        std::numeric_limits< double >::epsilon( ) );
-
-            // Test if other entries are 0 (to numerical precision).
-            BOOST_CHECK_SMALL( lvlhFrameThrust1( 1 ),
-                               thrustMagnitudeAlongVelocityVector * std::numeric_limits< double >::epsilon( ) );
-            BOOST_CHECK_SMALL( lvlhFrameThrust2( 1 ),
-                               thrustMagnitudeAlongVelocityVector * std::numeric_limits< double >::epsilon( ) );
-            BOOST_CHECK_SMALL( lvlhFrameThrust1( 2 ),
-                               thrustMagnitudeAlongVelocityVector * std::numeric_limits< double >::epsilon( ) );
-            BOOST_CHECK_SMALL( lvlhFrameThrust2( 2 ),
-                               thrustMagnitudeAlongVelocityVector * std::numeric_limits< double >::epsilon( ) );
-        }
-
-        // Define semi-random thrust vector perpendicular to plane
-        Eigen::Vector3d inertialThrustPerpendicularToPlane = thrustScale *  (
-                    Eigen::Vector3d( relativeState.segment( 0, 3 ) ).cross(
-                        Eigen::Vector3d( relativeState.segment( 3, 3 ) ) ) );
-        {
-            // Compute local thrust vectors
-            lvlhFrameThrust1 =
-                    nAxisAwayFromBodyMatrix.transpose( ) * inertialThrustPerpendicularToPlane;
-            lvlhFrameThrust2 =
-                    nAxisAwayTowardsBodyMatrix.transpose( ) * inertialThrustPerpendicularToPlane;
-
-            // Compute thrust vector magnitudes
-            double thrustMagnitudePerpendicularToPlane = inertialThrustPerpendicularToPlane.norm( );
-
-            // Test if entry 2 of two vectors are the same but opposite
-            BOOST_CHECK_CLOSE_FRACTION( lvlhFrameThrust1( 2 ), -lvlhFrameThrust2( 2 ),
-                                        std::numeric_limits< double >::epsilon( ) );
-
-            // Test thrust vector norms.
-            BOOST_CHECK_CLOSE_FRACTION( thrustMagnitudePerpendicularToPlane, lvlhFrameThrust1.norm( ),
-                                        5.0 * std::numeric_limits< double >::epsilon( ) );
-            BOOST_CHECK_CLOSE_FRACTION( thrustMagnitudePerpendicularToPlane, lvlhFrameThrust2.norm( ),
-                                        5.0 * std::numeric_limits< double >::epsilon( ) );
-
-
-            // Test if entry 2 magnitude is equal to norm
-            BOOST_CHECK_CLOSE_FRACTION( std::fabs( lvlhFrameThrust1( 2 ) ), thrustMagnitudePerpendicularToPlane,
-                                        std::numeric_limits< double >::epsilon( ) );
-            BOOST_CHECK_CLOSE_FRACTION( std::fabs( lvlhFrameThrust2( 2 ) ), thrustMagnitudePerpendicularToPlane,
-                                        std::numeric_limits< double >::epsilon( ) );
-
-            // Test if other entries are 0 (to numerical precision).
-            BOOST_CHECK_SMALL( lvlhFrameThrust1( 0 ),
-                               thrustMagnitudePerpendicularToPlane * std::numeric_limits< double >::epsilon( ) );
-            BOOST_CHECK_SMALL( lvlhFrameThrust2( 0 ),
-                               thrustMagnitudePerpendicularToPlane * std::numeric_limits< double >::epsilon( ) );
-            BOOST_CHECK_SMALL( lvlhFrameThrust1( 1 ),
-                               thrustMagnitudePerpendicularToPlane * std::numeric_limits< double >::epsilon( ) );
-            BOOST_CHECK_SMALL( lvlhFrameThrust2( 1 ),
-                               thrustMagnitudePerpendicularToPlane * std::numeric_limits< double >::epsilon( ) );
-        }
-
-        // Define semi-random thrust vector along local y-axis
-        Eigen::Vector3d inertialThrustAlongLocalYAxis = inertialThrustPerpendicularToPlane.cross(
-                    inertialThrustVectorAlongVelocity );
-        {
-            // Compute local thrust vectors
-            lvlhFrameThrust1 =
-                    nAxisAwayFromBodyMatrix.transpose( ) * inertialThrustAlongLocalYAxis;
-            lvlhFrameThrust2 =
-                    nAxisAwayTowardsBodyMatrix.transpose( ) * inertialThrustAlongLocalYAxis;
-
-            // Compute thrust vector magnitudes
-            double thrustMagnitudeAlongYAxis = inertialThrustAlongLocalYAxis.norm( );
-
-            // Test if entry 1 of two vectors are the same
-            BOOST_CHECK_CLOSE_FRACTION( lvlhFrameThrust1( 1 ), -lvlhFrameThrust2( 1 ),
-                                        std::numeric_limits< double >::epsilon( ) );
-
-            // Test thrust vector norms.
-            BOOST_CHECK_CLOSE_FRACTION( thrustMagnitudeAlongYAxis, lvlhFrameThrust1.norm( ),
-                                        5.0 * std::numeric_limits< double >::epsilon( ) );
-            BOOST_CHECK_CLOSE_FRACTION( thrustMagnitudeAlongYAxis, lvlhFrameThrust2.norm( ),
-                                        5.0 * std::numeric_limits< double >::epsilon( ) );
-
-            // Test if entry 1 magnitude is equal to norm
-            BOOST_CHECK_CLOSE_FRACTION( std::fabs( lvlhFrameThrust1( 1 ) ), thrustMagnitudeAlongYAxis,
-                                        std::numeric_limits< double >::epsilon( ) );
-            BOOST_CHECK_CLOSE_FRACTION( std::fabs( lvlhFrameThrust2( 1 ) ), thrustMagnitudeAlongYAxis,
-                                        std::numeric_limits< double >::epsilon( ) );
-
-            // Test if other entries are 0 (to numerical precision).
-            BOOST_CHECK_SMALL( lvlhFrameThrust1( 0 ), thrustMagnitudeAlongYAxis * std::numeric_limits< double >::epsilon( ));
-            BOOST_CHECK_SMALL( lvlhFrameThrust2( 0 ), thrustMagnitudeAlongYAxis * std::numeric_limits< double >::epsilon( ));
-            BOOST_CHECK_SMALL( lvlhFrameThrust1( 2 ), thrustMagnitudeAlongYAxis * std::numeric_limits< double >::epsilon( ));
-            BOOST_CHECK_SMALL( lvlhFrameThrust2( 2 ), thrustMagnitudeAlongYAxis * std::numeric_limits< double >::epsilon( ));
-        }
-
-    }
-
-    // Test 11: Test velocity based LVLH frame to inertial (I) frame transformation.
-    {
-        // Initialize initial thrust vector in velocity based LVLH frame.
-        Eigen::Vector3d startThrustVector;
-        startThrustVector( 0 ) = 2.0; // T direction
-        startThrustVector( 1 ) = 4.0; // N direction
-        startThrustVector( 2 ) = 1.0; // W direction
-        bool doesNaxisPointAwayFromCentralBody = false;
-
-        tudat::basic_mathematics::Vector6d vehicleStateCartesian, centralBodyStateCartesian;
-        vehicleStateCartesian << 0.0, -1.0, 0.0, -1.0, -0.5, 0.0;
-        centralBodyStateCartesian << 0.0, 2.0, 0.0, -0.5, 0.0, 0.0;
-
-        // Compute angle between positive T axis and negative y axis
-        double angle = atan2( ( vehicleStateCartesian( 3 ) - centralBodyStateCartesian( 3 ) ),
-                              ( vehicleStateCartesian( 4 ) - centralBodyStateCartesian( 4 ) ) );
-
-        // Declare the expected thrust vector in the inertial (I) reference frame.
-        Eigen::Vector3d expectedThrustVector;
-        expectedThrustVector( 0 ) = startThrustVector( 0 ) * sin( angle ) + startThrustVector( 1 ) * cos( angle );
-        expectedThrustVector( 1 ) = startThrustVector( 0 ) * cos( angle ) - startThrustVector( 1 ) * sin( angle );
-        expectedThrustVector( 2 ) = -startThrustVector( 2 ); // z direction
-
-        // Compute location of the point in the rotating frame subject to the transformation
-        // matrix.
-        Eigen::Vector3d transformedThrustVector;
-        transformedThrustVector = reference_frames::getVelocityBasedLvlhToInertialRotation(
-                    vehicleStateCartesian, centralBodyStateCartesian, doesNaxisPointAwayFromCentralBody ) * startThrustVector;
-
-        // Check whether both vectors are equal within tolerances.
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedThrustVector, transformedThrustVector, 1.0e-15 );
-    }
-
-    // Test 12: Test velocity based LVLH frame to planetocentric frame transformation with Keplerian elements.
-    {
-        // Initialize initial thrust vector in velocity based LVLH frame.
-        Eigen::Vector3d startThrustVector;
-        startThrustVector( 0 ) = 15.0; // T direction
-        startThrustVector( 1 ) = -1.0; // N direction
-        startThrustVector( 2 ) = 2.0; // W direction
-
-        tudat::basic_mathematics::Vector6d vehicleStateKeplerian;
-        vehicleStateKeplerian << 1.0, 0.5, convertDegreesToRadians( 60.0 ),
-                convertDegreesToRadians( 180.0 ), convertDegreesToRadians( 15.0 ), convertDegreesToRadians( 90.0 );
-
-        // Declare the expected thrust vector in the inertial (I) reference frame. Reference data comes from Matlab file
-        Eigen::Vector3d expectedThrustVector;
-        expectedThrustVector( 0 ) = 13.959420290978478079; // x direction
-        expectedThrustVector( 1 ) = -1.988147005863377672; // y direction
-        expectedThrustVector( 2 ) = -5.5840716885526107944; // z direction
-
-        // Compute location of the point in the rotating frame subject to the transformation
-        // matrix.
-        Eigen::Matrix3d rotationMatrixFromKeplerElements =
-                reference_frames::getVelocityBasedLvlhToPlanetocentricRotationKeplerian(
-                    vehicleStateKeplerian ).toRotationMatrix( );
-        Eigen::Vector3d transformedThrustVector;
-        transformedThrustVector = rotationMatrixFromKeplerElements * startThrustVector;
-
-        // Check whether both vectors are equal within tolerances.
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedThrustVector, transformedThrustVector,
-                                           ( 10.0 * std::numeric_limits< double >::epsilon( ) ) );
-
-        tudat::basic_mathematics::Vector6d vehicleStateCartesian =
-                orbital_element_conversions::convertKeplerianToCartesianElements(
-                    vehicleStateKeplerian, 3.986E14 );
-
-        Eigen::Matrix3d rotationMatrixFromCartesianElements =
-                reference_frames::getVelocityBasedLvlhToInertialRotation(
-                                    vehicleStateCartesian, basic_mathematics::Vector6d::Zero( ), false );
-
-        for( unsigned int i = 0; i < 3; i++ )
-        {
-            for( unsigned int j = 0; j < 3; j++ )
-            {
-                BOOST_CHECK_SMALL(
-                            std::fabs( rotationMatrixFromCartesianElements( i, j ) -
-                                       rotationMatrixFromKeplerElements( i, j ) ),
-                            5.0 * std::numeric_limits< double >::epsilon( ) );
+                        inverseRotationProductQuat, startLocation, 1.0e-14 );
             }
         }
     }
 }
 
-
 BOOST_AUTO_TEST_CASE( testEulerAngleRetrieval )
 {
     const double angleX = 2.1;
@@ -971,8 +625,8 @@ BOOST_AUTO_TEST_CASE( testEulerAngleRetrieval )
 
     Eigen::Matrix3d rotationMatrix =
             ( Eigen::AngleAxisd( -angleX, Eigen::Vector3d::UnitX( ) ) *
-              Eigen::AngleAxisd( -angleZ, Eigen::Vector3d::UnitZ( ) ) *
-              Eigen::AngleAxisd( -angleY, Eigen::Vector3d::UnitY( ) ) ).toRotationMatrix( );
+            Eigen::AngleAxisd( -angleZ, Eigen::Vector3d::UnitZ( ) ) *
+            Eigen::AngleAxisd( -angleY, Eigen::Vector3d::UnitY( ) ) ).toRotationMatrix( );
 
     Eigen::Vector3d eulerAngles = reference_frames::get132EulerAnglesFromRotationMatrix(
                 rotationMatrix );
diff --git a/Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.cpp b/Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.cpp
index c44342f..080a27a 100644
--- a/Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.cpp
+++ b/Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.cpp
@@ -386,7 +386,7 @@ void AerodynamicAngleCalculator::setOrientationAngleFunctions(
 
     if( !angleOfSideslipFunction.empty( ) )
     {
-        if( !angleOfSideslipFunction_.empty( ) )
+        if( !angleOfAttackFunction_.empty( ) )
         {
             std::cerr << "Warning, overriding existing angle of sideslip function in AerodynamicAngleCalculator" << std::endl;
         }
@@ -395,7 +395,7 @@ void AerodynamicAngleCalculator::setOrientationAngleFunctions(
 
     if( !bankAngleFunction.empty( ) )
     {
-        if( !bankAngleFunction_.empty( ) )
+        if( !angleOfAttackFunction_.empty( ) )
         {
             std::cerr << "Warning, overriding existing bank angle function in AerodynamicAngleCalculator" << std::endl;
         }
diff --git a/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.cpp b/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.cpp
index dff31b6..eb59b3b 100644
--- a/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.cpp
+++ b/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.cpp
@@ -37,8 +37,6 @@
  *      130121    K. Kumar          Updated functions to be const-correct.
  *      130219    D. Dirkx          Migrated from personal code.
  *      130312    A. Ronse          Added V-T, TA-AA and AA-B transformations.
- *      161116    M. Van den Broeck Added velocity based LVLH to planetocentric frame transformation. (Keplerian input)
- *      161117    M. Van den Broeck Added velocity based LVLH to Inertial frame transformation. (Cartesian input)
  *
  *    References
  *      Mooij, E. The Motion of a Vehicle in a Planetary Atmosphere, TU Delft, 1997.
@@ -186,77 +184,6 @@ Eigen::Matrix3d getInertialToPlanetocentricFrameTransformationMatrix(
     return eigenRotationObject.toRotationMatrix( );
 }
 
-//! Get rotation from velocity based LVLH frame to inertial frame (I) frame.
-Eigen::Matrix3d getVelocityBasedLvlhToInertialRotation(
-        const basic_mathematics::Vector6d& vehicleState,
-        const basic_mathematics::Vector6d& centralBodyState,
-        const bool doesNaxisPointAwayFromCentralBody )
-{
-    Eigen::Vector3d vehicleVelocity, vehicleRadius;
-    vehicleRadius = vehicleState.head( 3 ) - centralBodyState.head( 3 );
-    vehicleVelocity = vehicleState.tail( 3 ) - centralBodyState.tail( 3 );
-
-    Eigen::Vector3d unitT = vehicleVelocity / vehicleVelocity.norm( );
-    if ( vehicleRadius.cross( vehicleVelocity ).norm( ) == 0.0 )
-    {
-        std::string errorMessage = "Division by zero: radius and velocity are in the same direction.";
-        throw std::runtime_error( errorMessage );
-    }
-
-    Eigen::Vector3d unitW =  ( ( ( doesNaxisPointAwayFromCentralBody == true ) ? -1.0 : 1.0 ) *
-            ( vehicleRadius.cross( vehicleVelocity ) ).normalized( ) );
-
-    Eigen::Vector3d unitN = ( unitW.cross( unitT ) ).normalized( );
-
-    Eigen::Matrix3d transformationMatrix;
-    transformationMatrix << unitT( 0 ), unitN( 0 ), unitW( 0 ),
-                            unitT( 1 ), unitN( 1 ), unitW( 1 ),
-                            unitT( 2 ), unitN( 2 ), unitW( 2 );
-
-    return transformationMatrix;
-}
-
-//! Get rotation from velocity based LVLH frame to inertial frame (I) frame.
-Eigen::Matrix3d getVelocityBasedLvlhToInertialRotationFromFunctions(
-        const boost::function< basic_mathematics::Vector6d( ) >& vehicleStateFunction,
-        const boost::function< basic_mathematics::Vector6d( ) >& centralBodyStateFunction,
-        const bool doesNaxisPointAwayFromCentralBody )
-{
-    return getVelocityBasedLvlhToInertialRotation( vehicleStateFunction( ), centralBodyStateFunction( ) );
-}
-
-//! Get rotation from velocity based LVLH frame to planetocentric frame.
-Eigen::Quaterniond getVelocityBasedLvlhToPlanetocentricRotationKeplerian(
-        const Eigen::Matrix< double, 6, 1 > spacecraftKeplerianState )
-{
-
-    double eccentricity = spacecraftKeplerianState( 1 );
-    double inclination = spacecraftKeplerianState( 2 );
-    double argumentOfPeriapsis = spacecraftKeplerianState( 3 );
-    double rightAscensionOfAscendingNode = spacecraftKeplerianState( 4 );
-    double trueAnomaly = spacecraftKeplerianState( 5 );
-
-    double flightPathAngle = std::atan( ( eccentricity * std::sin( trueAnomaly ) ) /
-                                        ( 1.0 + eccentricity * std::cos( trueAnomaly ) ) );
-
-    // Compute first rotation around Z axis.
-    Eigen::AngleAxisd firstRotationAroundZaxis(
-                -( -mathematical_constants::PI * 0.5 + flightPathAngle - ( trueAnomaly + argumentOfPeriapsis ) ),
-                Eigen::Vector3d::UnitZ( ) );
-
-    // Compute rotation around X axis.
-    Eigen::AngleAxisd rotationAroundXaxis( inclination, Eigen::Vector3d::UnitX( ) );
-
-    // Compute second rotation around Z axis.
-    Eigen::AngleAxisd secondRotationAroundZaxis( rightAscensionOfAscendingNode, Eigen::Vector3d::UnitZ( ) );
-
-    Eigen::Quaterniond frameTransformationQuaternion = Eigen::Quaterniond(
-                ( secondRotationAroundZaxis * rotationAroundXaxis * firstRotationAroundZaxis) );
-
-    // Return transformation quaternion.
-    return frameTransformationQuaternion;
-}
-
 //! Get inertial (I) to rotating planetocentric (R) reference frame transformtion quaternion.
 Eigen::Quaterniond getInertialToPlanetocentricFrameTransformationQuaternion(
         const double angleFromXItoXR )
diff --git a/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h b/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h
index 4399d42..16f7cf6 100644
--- a/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h
+++ b/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h
@@ -38,8 +38,6 @@
  *      130121    K. Kumar          Updated functions to be const-correct.
  *      130219    D. Dirkx          Migrated from personal code.
  *      130312    A. Ronse          Added V-T, TA-AA and AA-B transformations.
- *      161116    M. Van den Broeck Added velocity based LVLH to planetocentric frame transformation. (Keplerian input)
- *      161117    M. Van den Broeck Added velocity based LVLH to Inertial frame transformation. (Cartesian input)
  *
  *
  *    References
@@ -63,9 +61,6 @@
 #include <Eigen/Geometry>
 
 #include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
-#include "Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.h"
-#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
-
 
 namespace tudat
 {
@@ -148,7 +143,7 @@ Eigen::Matrix3d getRotatingPlanetocentricToInertialFrameTransformationMatrix(
  * \return Reference frame (R) to inertial reference frame (I) transformation quaternion.
  */
 Eigen::Quaterniond getRotatingPlanetocentricToInertialFrameTransformationQuaternion(
-        const double angleFromXItoXR );
+    const double angleFromXItoXR );
 
 //! Get rotation from planet-fixed to inertial frame.
 /*!
@@ -178,64 +173,6 @@ Eigen::Quaterniond getRotatingPlanetocentricToInertialFrameTransformationQuatern
 Eigen::Matrix3d getInertialToPlanetocentricFrameTransformationMatrix(
         const double angleFromXItoXR );
 
-//! Get rotation from velocity based LVLH frame to inertial (I) frame.
-/*!
- * Returns rotation from inertial (i) to the velocity based LVLH frame. The velocity based LVLH frame is
- * a right-handed orthogonal frame defined as follows:
- * x-axis tangent to the velocity direction,
- * y-axis in the orbital plane and pointing inwards (if doesNaxisPointAwayFromCentralBody is false),
- * i.e. to the left when looking in velocity-direction,
- * z-axis normal to the orbital plane.
- * \param vehicleState State of the vehicle for which the LVLH frame is to be computed.
- * \param centralBodyState State of the central body w.r.t. which the LVLH frame is to be computed.
- * \param doesNaxisPointAwayFromCentralBody Boolean denoting whether the local y-axis points away from (if true) or
- * towards (if false) central body.
- * \return Velocity based LVLH to inertial (I) frame transformation matrix.
- */
-Eigen::Matrix3d getVelocityBasedLvlhToInertialRotation(const basic_mathematics::Vector6d& vehicleState,
-                                                       const basic_mathematics::Vector6d& centralBodyState,
-                                                       const bool doesNaxisPointAwayFromCentralBody = true );
-
-//! Get rotation from velocity based LVLH frame to inertial (I) frame.
-/*!
- * Returns rotation from inertial (i) to the velocity based LVLH frame. The velocity based LVLH frame is
- * a right-handed orthogonal frame defined as follows:
- * x-axis tangent to the velocity direction,
- * y-axis in the orbital plane and pointing inwards (if doesNaxisPointAwayFromCentralBody is false),
- * i.e. to the left when looking in velocity-direction,
- * z-axis normal to the orbital plane.
- * \param vehicleStateFunction Function returning the state of the vehicle for which the LVLH frame is to be computed
- * \param centralBodyStateFunction Function returning the state of the central body w.r.t. which the LVLH frame is to be
- * computed
- * \param doesNaxisPointAwayFromCentralBody Boolean denoting whether the local y-axis points away from (if true) or
- * towards (if false) central body.
- * \return Velocity based LVLH to inertial (I) frame transformation matrix.
- */
-Eigen::Matrix3d getVelocityBasedLvlhToInertialRotationFromFunctions(
-        const boost::function< basic_mathematics::Vector6d( ) >& vehicleStateFunction,
-        const boost::function< basic_mathematics::Vector6d( ) >& centralBodyStateFunction,
-        bool doesNaxisPointAwayFromCentralBody = true );
-
-//! Get rotation from velocity based LVLH frame to planet-fixed frame.
-/*!
- * Returns rotation from the velocity based LVLH frame to the planet-fixed frame. The velocity based LVLH frame is
- * a right-handed orthogonal frame defined as follows:
- * x-axis tangent to the velocity direction,
- * y-axis in the orbital plane and pointing inwards, i.e. to the left when looking in velocity-direction,
- * z-axis normal to the orbital plane.
- * \param spacecraftKeplerianState containging the following elements:
- *          semi-major axis -> not used
- *          eccentricity
- *          inclination
- *          argumentOfPeriapsis
- *          longitudeOfAscendingNode
- *          trueAnomaly
- * \return Computed rotation quaternion.
- */
-//! Get rotation from velocity based LVLH frame to planetocentric frame.
-Eigen::Quaterniond getVelocityBasedLvlhToPlanetocentricRotationKeplerian(
-        const Eigen::Matrix< double, 6, 1 > spacecraftKeplerianState );
-
 //! Get inertial (I) to rotating planetocentric (R) reference frame transformation quaternion.
 /*!
  * Returns transformation quaternion from inertial referenceframe (I) to the rotating
@@ -296,7 +233,7 @@ Eigen::Quaterniond getQuaternionObjectFromQuaternionValues(
  * \return Transformation matrix from Planetocentric (R) to the local vertical (V) frame.
  */
 Eigen::Matrix3d getRotatingPlanetocentricToLocalVerticalFrameTransformationMatrix(
-        const double longitude, const double latitude );
+    const double longitude, const double latitude );
 
 //! Get transformation quaternion from Planetocentric (R) to the local vertical (V) frame.
 /*!
@@ -310,7 +247,7 @@ Eigen::Matrix3d getRotatingPlanetocentricToLocalVerticalFrameTransformationMatri
  * \return Transformation quaternion from Planetocentric (R) to the local vertical (V) frame.
  */
 Eigen::Quaterniond getRotatingPlanetocentricToLocalVerticalFrameTransformationQuaternion(
-        const double longitude, const double latitude );
+    const double longitude, const double latitude );
 
 //! Get transformation matrix from local vertical (V) to the Planetocentric frame (R).
 /*!
@@ -324,11 +261,11 @@ Eigen::Quaterniond getRotatingPlanetocentricToLocalVerticalFrameTransformationQu
  * \return Transformation matrix from local vertical (V) to the Planetocentric (R) frame.
  */
 Eigen::Matrix3d getLocalVerticalToRotatingPlanetocentricFrameTransformationMatrix(
-        const double longitude, const double latitude );
+    const double longitude, const double latitude );
 
 //! Get transformation quaternion from local vertical (V) to the Planetocentric frame (R).
 /*!
- * Returns the frame transformation quaternion from the local vertical (V) to the
+ * Returns the frame transformation quaternion from the local vertical (V) to the 
  * Planetocentric (R) reference frame. The Z-axis is aligned with the local gravity vector.
  * Whether or not, this is in the direction of the center of the central body, depends which kind
  * of latitude is provided (geocentric, geodetic, gravitation latitude).
@@ -338,7 +275,7 @@ Eigen::Matrix3d getLocalVerticalToRotatingPlanetocentricFrameTransformationMatri
  * \return Transformation quaternion from local vertical (V) to the Planetocentric (R) frame.
  */
 Eigen::Quaterniond getLocalVerticalToRotatingPlanetocentricFrameTransformationQuaternion(
-        const double longitude, const double latitude );
+    const double longitude, const double latitude );
 
 //! Get transformation matrix from the TA/TG to the V-frame.
 /*!
@@ -415,7 +352,7 @@ Eigen::Matrix3d getTrajectoryToAerodynamicFrameTransformationMatrix( const doubl
  * \return Transformation quaternion from the TA- to the AA-frame.
  */
 Eigen::Quaterniond getTrajectoryToAerodynamicFrameTransformationQuaternion( 
-        const double bankAngle );
+    const double bankAngle );
 
 //! Get transformation matrix from the AA- to the TA-frame.
 /*!
@@ -507,7 +444,7 @@ double calculateFlightPathAngle( const Eigen::Vector3d& velocityInVerticalFrame
  *  \return Transformation quaternion.
  */
 Eigen::Quaterniond getRotatingPlanetocentricToEnuLocalVerticalFrameTransformationQuaternion(
-        const double longitude, const double latitude );
+    const double longitude, const double latitude );
 
 //! Get V-frame to ECEF quaternion
 /*!
@@ -518,7 +455,7 @@ Eigen::Quaterniond getRotatingPlanetocentricToEnuLocalVerticalFrameTransformatio
  *  \return Transformation quaternion.
  */
 Eigen::Quaterniond getEnuLocalVerticalToRotatingPlanetocentricFrameTransformationQuaternion(
-        const double longitude, const double latitude );
+    const double longitude, const double latitude );
 
 } // namespace reference_frames
 
diff --git a/Tudat/Astrodynamics/SystemModels/vehicleSystems.h b/Tudat/Astrodynamics/SystemModels/vehicleSystems.h
index 8223d19..cc61355 100644
--- a/Tudat/Astrodynamics/SystemModels/vehicleSystems.h
+++ b/Tudat/Astrodynamics/SystemModels/vehicleSystems.h
@@ -79,6 +79,26 @@ public:
         return dryMass_;
     }
 
+    void setNoseRadius( const double noseRadius )
+    {
+        noseRadius_ = noseRadius;
+    }
+
+    double getNoseRadius( )
+    {
+        return noseRadius_;
+    }
+
+    void setWallEmissivitys( const double wallEmissivity )
+    {
+        wallEmissivity_ = wallEmissivity;
+    }
+
+    double getWallEmissivity( )
+    {
+        return wallEmissivity_;
+    }
+
 private:
 
     //! Named list of engine models in the vehicle
@@ -87,6 +107,10 @@ private:
     //! Total dry mass of the vehicle
     double dryMass_;
 
+    double noseRadius_;
+
+    double wallEmissivity_;
+
 };
 
 
diff --git a/Tudat/CMakeLists.txt b/Tudat/CMakeLists.txt
index 01d9988..0a70e05 100755
--- a/Tudat/CMakeLists.txt
+++ b/Tudat/CMakeLists.txt
@@ -263,13 +263,13 @@ endif()
 
 
 list(APPEND TUDAT_PROPAGATION_LIBRARIES tudat_simulation_setup tudat_propagators
-    tudat_aerodynamics tudat_geometric_shapes tudat_relativity tudat_gravitation tudat_mission_segments
+    tudat_aerodynamics tudat_system_models tudat_geometric_shapes tudat_relativity tudat_gravitation tudat_mission_segments
     tudat_electro_magnetism tudat_propulsion tudat_ephemerides tudat_numerical_integrators tudat_reference_frames
     tudat_basic_astrodynamics tudat_input_output tudat_basic_mathematics tudat_propagators ${TUDAT_EXTERNAL_LIBRARIES})
 
 list(APPEND TUDAT_ESTIMATION_LIBRARIES tudat_simulation_setup tudat_observation_models tudat_acceleration_partials
     tudat_observation_partials tudat_estimatable_parameters tudat_orbit_determination  tudat_propagators
-    tudat_aerodynamics tudat_geometric_shapes tudat_relativity tudat_gravitation tudat_mission_segments
+    tudat_aerodynamics tudat_system_models tudat_geometric_shapes tudat_relativity tudat_gravitation tudat_mission_segments
     tudat_electro_magnetism tudat_propulsion tudat_ephemerides tudat_numerical_integrators tudat_reference_frames
     tudat_basic_astrodynamics tudat_input_output tudat_basic_mathematics tudat_propagators ${TUDAT_EXTERNAL_LIBRARIES})
 
diff --git a/Tudat/InputOutput/matrixTextFileReader.cpp b/Tudat/InputOutput/matrixTextFileReader.cpp
index 5f386f0..9031a8f 100644
--- a/Tudat/InputOutput/matrixTextFileReader.cpp
+++ b/Tudat/InputOutput/matrixTextFileReader.cpp
@@ -35,7 +35,7 @@
  *    References
  *
  *    Notes
- *      If tabs are used as spaces, it doesn't work. The separator should also be tabs then.
+ *      If tabs are used as spaces, it doesn't work. The seperator should also be tabs then.
  *
  */
 
diff --git a/Tudat/Mathematics/BasicMathematics/UnitTests/unitTestNearestNeighbourSearch.cpp b/Tudat/Mathematics/BasicMathematics/UnitTests/unitTestNearestNeighbourSearch.cpp
index 3392ef7..d4813d6 100644
--- a/Tudat/Mathematics/BasicMathematics/UnitTests/unitTestNearestNeighbourSearch.cpp
+++ b/Tudat/Mathematics/BasicMathematics/UnitTests/unitTestNearestNeighbourSearch.cpp
@@ -25,7 +25,6 @@
  *    Changelog
  *      YYMMDD    Author            Comment
  *      120207    K. Kumar          File created.
- *      160930    M. Van den Broeck Added unit test for int computeNearestNeighborUsingBinarySearch
  *
  *    References
  *      Press W.H., et al. Numerical Recipes in C++: The Art of Scientific Computing. Cambridge
@@ -203,31 +202,6 @@ BOOST_AUTO_TEST_CASE( testNearestLeftNeighborUsingBinarySearch )
             }
         }
     }
-
-    // Case 5: test Eigen-interface of NearestNeighbourSearch.
-    {
-        // Populate vector of 10 sorted elements.
-        Eigen::VectorXd vectorOfSortedData( 10 );
-        vectorOfSortedData << 1.0, 4.5, 10.6, 14.98, 54.65, 88.9, 101.31, 144.63, 180.01, 201.94;
-
-        // Declare vector of target values.
-        Eigen::VectorXd vectorOfTargetValues( 10 );
-        vectorOfTargetValues << 1.1, 2.74, 2.75, 2.76, 4.6, 10.5, 54.55, 181.63, 200.0, 205.0;
-
-        // Declare vector of expected indices.
-        Eigen::VectorXi vectorOfExpectedIndices( 10 );
-        vectorOfExpectedIndices << 0, 0, 0, 1, 1, 2, 4, 8, 9, 9;
-
-        // Compute nearest left neighbors and check if they match expectations.
-        for ( int i = 0; i < vectorOfTargetValues.rows( ); i++ )
-        {
-            BOOST_CHECK_EQUAL(
-                        vectorOfExpectedIndices[ i ],
-                        computeNearestNeighborUsingBinarySearch(
-                            vectorOfSortedData, vectorOfTargetValues[ i ] ) );
-        }
-    }
-
 }
 
 //! Close Boost test suite.
diff --git a/Tudat/Mathematics/BasicMathematics/nearestNeighbourSearch.cpp b/Tudat/Mathematics/BasicMathematics/nearestNeighbourSearch.cpp
index f940f29..b057ddc 100644
--- a/Tudat/Mathematics/BasicMathematics/nearestNeighbourSearch.cpp
+++ b/Tudat/Mathematics/BasicMathematics/nearestNeighbourSearch.cpp
@@ -37,7 +37,6 @@
  *      110913    K. Kumar          Implemented automatic root-path functions based on
  *                                  suggestions by M. Persson.
  *      111117    K. Kumar          Added listAllFilesInDirectory( ) function.
- *      160930    M. Van den Broeck Added computeNearestNeighborUsingBinarySearch function
  *
  *    References
  *      Press W.H., et al. Numerical Recipes in C++: The Art of Scientific Computing. Cambridge
@@ -108,67 +107,6 @@ int computeNearestLeftNeighborUsingBinarySearch(
     return currentPositionInVectorOfSortedData;
 }
 
-//! Nearest neighbor binary search.
-int computeNearestNeighborUsingBinarySearch(
-        const Eigen::VectorXd& vectorOfSortedData,
-        const double targetValueInVectorOfSortedData )
-{
-    // Declare local variables.
-    // Declare bounds of vector of sorted data and current position.
-    int leftLimitOfVectorOfSortedData = 0;
-    int rightLimitOfVectorOfSortedData = vectorOfSortedData.rows( ) - 1;
-    int currentPositionInVectorOfSortedData;
-
-    // Check if data is sorted in ascending order.
-    // ( true if ascending, else false ).
-    bool isVectorOfSortedDataAscending
-            = ( vectorOfSortedData[ rightLimitOfVectorOfSortedData ]
-                >= vectorOfSortedData[ leftLimitOfVectorOfSortedData ] );
-
-    // Loop through vector of sorted data until left and right limits
-    // are neighbours.
-    while ( rightLimitOfVectorOfSortedData
-            - leftLimitOfVectorOfSortedData > 1 ) // No rounding off errors because limits are integers
-    {
-        // Compute midpoint ( bitshift is same as division by 2.0 ).
-        currentPositionInVectorOfSortedData
-                = ( rightLimitOfVectorOfSortedData
-                    + leftLimitOfVectorOfSortedData ) >> 1;
-
-        // Check which limit to replace ( if ascending and target datum
-        // is in right half, replace left limit ).
-        if ( targetValueInVectorOfSortedData
-             >= vectorOfSortedData[ currentPositionInVectorOfSortedData ]
-             && isVectorOfSortedDataAscending )
-        {
-            // Set left limit to current position in vector of sorted data.
-            leftLimitOfVectorOfSortedData = currentPositionInVectorOfSortedData;
-        }
-
-        else
-        {
-            // Set right limit to current position in vector of sorted data.
-            rightLimitOfVectorOfSortedData = currentPositionInVectorOfSortedData;
-        }
-    }
-
-    // Set current position to left or right limit, whichever is closer.
-    currentPositionInVectorOfSortedData = leftLimitOfVectorOfSortedData;
-    if( ( ( vectorOfSortedData[ rightLimitOfVectorOfSortedData ] +
-              vectorOfSortedData[ leftLimitOfVectorOfSortedData ] ) / 2.0 ) < targetValueInVectorOfSortedData )
-    {
-        currentPositionInVectorOfSortedData = rightLimitOfVectorOfSortedData;
-    }
-
-    else
-    {
-        currentPositionInVectorOfSortedData = leftLimitOfVectorOfSortedData;
-    }
-
-    // Return current position in vector.
-    return currentPositionInVectorOfSortedData;
-}
-
 //! Nearest left neighbor binary search.
 int computeNearestLeftNeighborUsingBinarySearch(
         const std::map < double, Eigen::VectorXd >& sortedIndepedentAndDependentVariables,
diff --git a/Tudat/Mathematics/BasicMathematics/nearestNeighbourSearch.h b/Tudat/Mathematics/BasicMathematics/nearestNeighbourSearch.h
index 19d6d7d..01d0a85 100644
--- a/Tudat/Mathematics/BasicMathematics/nearestNeighbourSearch.h
+++ b/Tudat/Mathematics/BasicMathematics/nearestNeighbourSearch.h
@@ -41,7 +41,6 @@
  *      120716    D. Dirkx          Updated with new nearest neighbour search algorithms.
  *      130114    D. Dirkx          Added missing include statements; corrected include guard
  *                                  name.
- *      160930    M. Van den Broeck Added computeNearestNeighborUsingBinarySearch function
  *
  *    References
  *      Press W.H., et al. Numerical Recipes in C++: The Art of Scientific Computing. Cambridge
@@ -78,17 +77,6 @@ namespace basic_mathematics
 int computeNearestLeftNeighborUsingBinarySearch( const Eigen::VectorXd& vectorOfSortedData,
                                                  const double targetValueInVectorOfSortedData );
 
-//! Nearest neighbor binary search.
-/*!
- * Searches for the nearest neighbor in a vector of sorted data using a
- * binary algorithm (Press W.H., et al., 2002).
- * \param vectorOfSortedData Vector of data sorted in ascending/descending order.
- * \param targetValueInVectorOfSortedData Target value in vector of sorted data.
- * \return Index of nearest neighbor to target value.
- */
-int computeNearestNeighborUsingBinarySearch( const Eigen::VectorXd& vectorOfSortedData,
-                                             const double targetValueInVectorOfSortedData );
-
 //! Nearest left neighbor binary search.
 /*!
  * Searches for the nearest left neighbor in a map of sorted data using a
diff --git a/Tudat/Mathematics/NumericalIntegrators/UnitTests/unitTestRungeKuttaFehlberg78Integrator.cpp b/Tudat/Mathematics/NumericalIntegrators/UnitTests/unitTestRungeKuttaFehlberg78Integrator.cpp
index 65b3e86..c8e14b0 100644
--- a/Tudat/Mathematics/NumericalIntegrators/UnitTests/unitTestRungeKuttaFehlberg78Integrator.cpp
+++ b/Tudat/Mathematics/NumericalIntegrators/UnitTests/unitTestRungeKuttaFehlberg78Integrator.cpp
@@ -85,7 +85,7 @@ using numerical_integrators::RungeKuttaCoefficients;
 
 using numerical_integrator_test_functions::computeNonAutonomousModelStateDerivative;
 using numerical_integrator_test_functions::computeFehlbergLogirithmicTestODEStateDerivative ;
-using numerical_integrator_test_functions::computeAnalyticalStateFehlbergODE;
+using numerical_integrator_test_functions::computeAnalyticalStateFehlbergODE ;
 
 //! Test Runge-Kutta-Fehlberg 78 integrator using benchmark ODE of Fehlberg (1968)
 BOOST_AUTO_TEST_CASE( test_RungeKuttaFehlberg78_Integrator_Fehlberg_Benchmark )
diff --git a/Tudat/SimulationSetup/EnvironmentSetup/createFlightConditions.cpp b/Tudat/SimulationSetup/EnvironmentSetup/createFlightConditions.cpp
index b0788cd..3ffceba 100644
--- a/Tudat/SimulationSetup/EnvironmentSetup/createFlightConditions.cpp
+++ b/Tudat/SimulationSetup/EnvironmentSetup/createFlightConditions.cpp
@@ -179,10 +179,10 @@ boost::shared_ptr< aerodynamics::FlightConditions > createFlightConditions(
                     " has no aerodynamic coefficients." );
     }
 
-    // Create function to calculate the altitude from current body-fixed state
-    boost::function< double( const Eigen::Vector3d ) > altitudeFunction =
-            boost::bind( &basic_astrodynamics::BodyShapeModel::getAltitude,
-                         centralBody->getShapeModel( ), _1 );
+//    // Create function to calculate the altitude from current body-fixed state
+//    boost::function< double( const Eigen::Vector3d ) > altitudeFunction =
+//            boost::bind( &basic_astrodynamics::BodyShapeModel::getAltitude,
+//                         centralBody->getShapeModel( ), _1 );
 
     // Create function to rotate state from intertial to body-fixed frame.
     boost::function< Eigen::Quaterniond( ) > rotationToFrameFunction =
@@ -211,7 +211,7 @@ boost::shared_ptr< aerodynamics::FlightConditions > createFlightConditions(
     // Create flight conditions.
     boost::shared_ptr< aerodynamics::FlightConditions > flightConditions =
             boost::make_shared< aerodynamics::FlightConditions >(
-                centralBody->getAtmosphereModel( ), altitudeFunction,
+                centralBody->getAtmosphereModel( ), centralBody->getShapeModel( ),
                 bodyWithFlightConditions->getAerodynamicCoefficientInterface( ), aerodynamicAngleCalculator );
 
 
diff --git a/Tudat/SimulationSetup/PropagationSetup/propagationOutput.cpp b/Tudat/SimulationSetup/PropagationSetup/propagationOutput.cpp
index b6fa7db..743ea3c 100644
--- a/Tudat/SimulationSetup/PropagationSetup/propagationOutput.cpp
+++ b/Tudat/SimulationSetup/PropagationSetup/propagationOutput.cpp
@@ -53,6 +53,7 @@ Eigen::Matrix3d getMatrixFromVectorRotationRepresentation(
     return currentRotationMatrix;
 }
 
+
 //! Get the quaternion formulation of an orthonormal matrix, from input of a vector with 9 entries corresponding to matrix
 //! entries.
 Eigen::Quaterniond getQuaternionFromVectorRotationRepresentation(
@@ -61,6 +62,17 @@ Eigen::Quaterniond getQuaternionFromVectorRotationRepresentation(
     return Eigen::Quaterniond( getMatrixFromVectorRotationRepresentation( vectorRepresentation ) );
 }
 
+double computeEquilibriumFayRiddellHeatFluxFromProperties(
+        const boost::shared_ptr< aerodynamics::FlightConditions > flightConditions,
+        const boost::shared_ptr< system_models::VehicleSystems > vehicleSystems )
+{
+    return aerodynamics::computeEquilibriumFayRiddellHeatFlux(
+                flightConditions->getCurrentDensity( ), flightConditions->getCurrentAirspeed( ),
+                flightConditions->getCurrentFreestreamTemperature( ), flightConditions->getCurrentMachNumber( ),
+                vehicleSystems->getNoseRadius( ), vehicleSystems->getWallEmissivity( ) );
+}
+
+
 //! Function to evaluate a set of double and vector-returning functions and concatenate the results.
 Eigen::VectorXd evaluateListOfFunctions(
         const std::vector< boost::function< double( ) > >& doubleFunctionList,
@@ -159,6 +171,15 @@ int getDependentVariableSize(
     case body_fixed_airspeed_based_velocity_variable:
         variableSize = 3;
         break;
+    case total_aerodynamic_g_load_variable:
+        variableSize = 1;
+        break;
+    case stagnation_point_heat_flux_dependent_variable:
+        variableSize = 1;
+        break;
+    case local_temperature_dependent_variable:
+        variableSize = 1;
+        break;
     default:
         std::string errorMessage = "Error, did not recognize dependent variable size of type: " +
                 boost::lexical_cast< std::string >( dependentVariableSettings );
diff --git a/Tudat/SimulationSetup/PropagationSetup/propagationOutput.h b/Tudat/SimulationSetup/PropagationSetup/propagationOutput.h
index 7e468e1..eb99e68 100644
--- a/Tudat/SimulationSetup/PropagationSetup/propagationOutput.h
+++ b/Tudat/SimulationSetup/PropagationSetup/propagationOutput.h
@@ -34,7 +34,7 @@ namespace propagators
  *  \return Output from functionToEvaluate, using functions firstInput and secondInput as input.
  */
 template< typename OutputType, typename InputType >
-OutputType evaluateReferenceFunction(
+OutputType evaluateBivariateReferenceFunction(
         const boost::function< OutputType( const InputType&, const InputType& ) > functionToEvaluate,
         const boost::function< InputType( ) > firstInput,
         const boost::function< InputType( ) > secondInput )
@@ -42,6 +42,14 @@ OutputType evaluateReferenceFunction(
     return functionToEvaluate( firstInput( ), secondInput( ) );
 }
 
+template< typename OutputType, typename InputType >
+OutputType evaluateReferenceFunction(
+        const boost::function< OutputType( const InputType& ) > functionToEvaluate,
+        const boost::function< InputType( ) > firstInput )
+{
+    return functionToEvaluate( firstInput( ) );
+}
+
 //! Function to evaluate a function with two input variables from function pointers
 /*!
  *  Function to evaluate a function with two input variables from function pointers that return these
@@ -52,7 +60,7 @@ OutputType evaluateReferenceFunction(
  *  \return Output from functionToEvaluate, using functions firstInput and secondInput as input.
  */
 template< typename OutputType, typename InputType >
-OutputType evaluateFunction(
+OutputType evaluateBivariateFunction(
         const boost::function< OutputType( const InputType, const InputType ) > functionToEvaluate,
         const boost::function< InputType( ) > firstInput,
         const boost::function< InputType( ) > secondInput )
@@ -60,6 +68,20 @@ OutputType evaluateFunction(
     return functionToEvaluate( firstInput( ), secondInput( ) );
 }
 
+template< typename OutputType, typename InputType >
+OutputType evaluateHexaVariateFunction(
+        const boost::function< OutputType(
+            const InputType, const InputType, const InputType, const InputType, const InputType, const InputType ) > functionToEvaluate,
+        const boost::function< InputType( ) > firstInput,
+        const boost::function< InputType( ) > secondInput,
+        const boost::function< InputType( ) > thirdInput,
+        const boost::function< InputType( ) > fourthInput,
+        const boost::function< InputType( ) > fifthInput,
+        const boost::function< InputType( ) > sixthInput )
+{
+    return functionToEvaluate( firstInput( ), secondInput( ), thirdInput( ), fourthInput( ), fifthInput( ), sixthInput( ) );
+}
+
 //! Funtion to get the size of a dependent variable
 /*!
  * Funtion to get the size (i.e. number of values in variable: one for altitude, three for position, etc.)
@@ -103,6 +125,12 @@ Eigen::Matrix3d getMatrixFromVectorRotationRepresentation(
 Eigen::Quaterniond getQuaternionFromVectorRotationRepresentation(
         const Eigen::VectorXd vectorRepresentation );
 
+
+double computeEquilibriumFayRiddellHeatFluxFromProperties(
+        const boost::shared_ptr< aerodynamics::FlightConditions > flightConditions,
+        const boost::shared_ptr< system_models::VehicleSystems > vehicleSystems );
+
+
 //! Function to create a function returning a requested dependent variable value (of type double).
 /*!
  *  Function to create a function returning a requested dependent variable value (of type double), retrieved from
@@ -153,7 +181,7 @@ boost::function< double( ) > getDoubleDependentVariableFunction(
                              bodyMap.at( bodyWithProperty )->getFlightConditions( ) );
 
 
-        variableFunction = boost::bind( &evaluateFunction< double, double >,
+        variableFunction = boost::bind( &evaluateBivariateFunction< double, double >,
                                         functionToEvaluate, firstInput, secondInput );
         break;
     }
@@ -206,7 +234,7 @@ boost::function< double( ) > getDoubleDependentVariableFunction(
                 boost::bind( &simulation_setup::Body::getPosition, bodyMap.at( secondaryBody ) );
 
         variableFunction = boost::bind(
-                    &evaluateReferenceFunction< double, Eigen::Vector3d >, functionToEvaluate, firstInput, secondInput );
+                    &evaluateBivariateReferenceFunction< double, Eigen::Vector3d >, functionToEvaluate, firstInput, secondInput );
         break;
     }
     case relative_speed_dependent_variable:
@@ -220,7 +248,7 @@ boost::function< double( ) > getDoubleDependentVariableFunction(
                 boost::bind( &simulation_setup::Body::getVelocity, bodyMap.at( secondaryBody ) );
 
         variableFunction = boost::bind(
-                    &evaluateReferenceFunction< double, Eigen::Vector3d >, functionToEvaluate, firstInput, secondInput );
+                    &evaluateBivariateReferenceFunction< double, Eigen::Vector3d >, functionToEvaluate, firstInput, secondInput );
 
         break;
     }
@@ -249,7 +277,7 @@ boost::function< double( ) > getDoubleDependentVariableFunction(
                         accelerationDependentVariableSettings->associatedBody_ + " and " +
                         accelerationDependentVariableSettings->secondaryBody_ + " of type " +
                         boost::lexical_cast< std::string >(
-                                            accelerationDependentVariableSettings->accelerationModeType_ ) +
+                            accelerationDependentVariableSettings->accelerationModeType_ ) +
                         ", no such acceleration found";
                 throw std::runtime_error( errorMessage );
             }
@@ -294,10 +322,97 @@ boost::function< double( ) > getDoubleDependentVariableFunction(
         }
 
         variableFunction = boost::bind( &reference_frames::AerodynamicAngleCalculator::getAerodynamicAngle,
-                                 bodyMap.at( bodyWithProperty )->getFlightConditions( )->getAerodynamicAngleCalculator( ),
+                                        bodyMap.at( bodyWithProperty )->getFlightConditions( )->getAerodynamicAngleCalculator( ),
                                         bodyAerodynamicAngleVariableSaveSettings->angle_ );
         break;
     }
+    case total_aerodynamic_g_load_variable:
+    {
+        // Check input consistency
+        boost::shared_ptr< SingleAccelerationDependentVariableSaveSettings > aerodynamicAccelerationSettings =
+                boost::make_shared< SingleAccelerationDependentVariableSaveSettings >(
+                    basic_astrodynamics::aerodynamic, bodyWithProperty, secondaryBody, 0 );
+        boost::function< Eigen::VectorXd( ) > aerodynamicAccelerationFunction =
+                getVectorDependentVariableFunction( aerodynamicAccelerationSettings, bodyMap, stateDerivativeModels ).first;
+
+
+        boost::function< double( Eigen::Vector3d )> functionToEvaluate =
+                boost::bind( &aerodynamics::computeAerodynamicLoadFromAcceleration, _1 );
+        variableFunction = boost::bind(
+                    &evaluateReferenceFunction< double, Eigen::Vector3d >,
+                    functionToEvaluate, aerodynamicAccelerationFunction );
+
+        break;
+    }
+    case stagnation_point_heat_flux_dependent_variable:
+    {
+
+        if( bodyMap.at( bodyWithProperty )->getFlightConditions( ) == NULL )
+        {
+            std::string errorMessage = "Error no flight conditions available when requesting stagnation point heating output of" +
+                    bodyWithProperty + "w.r.t." + secondaryBody;
+            throw std::runtime_error( errorMessage );
+        }
+
+        boost::shared_ptr< aerodynamics::FlightConditions > flightConditions =
+                bodyMap.at( bodyWithProperty )->getFlightConditions( );
+
+        if( bodyMap.at( bodyWithProperty )->getVehicleSystems( ) == NULL )
+        {
+            std::string errorMessage = "Error, no vehicle systems available when requesting stagnation point heating output of " +
+                    bodyWithProperty + "w.r.t." + secondaryBody;
+            throw std::runtime_error( errorMessage );
+        }
+
+        boost::shared_ptr< system_models::VehicleSystems > vehicleSystems =
+                bodyMap.at( bodyWithProperty )->getVehicleSystems( );
+
+
+        if( !( vehicleSystems->getNoseRadius( ) == vehicleSystems->getNoseRadius( ) ) )
+        {
+            std::string errorMessage = "Error, no nose radius available when requesting stagnation point heating output of " +
+                    bodyWithProperty + "w.r.t." + secondaryBody;
+            throw std::runtime_error( errorMessage );
+        }
+
+        if( !( vehicleSystems->getWallEmissivity( ) == vehicleSystems->getWallEmissivity( ) ) )
+        {
+            std::string errorMessage = "Error, no wall emmisivityavailable when requesting stagnation point heating output of " +
+                    bodyWithProperty + "w.r.t." + secondaryBody;
+            throw std::runtime_error( errorMessage );
+        }
+
+        variableFunction = boost::bind(
+                    &computeEquilibriumFayRiddellHeatFluxFromProperties,
+                    flightConditions, vehicleSystems );
+
+        break;
+    }
+    case local_temperature_dependent_variable:
+    {
+        if( bodyMap.at( bodyWithProperty )->getFlightConditions( ) == NULL )
+        {
+            std::string errorMessage = "Error, no flight conditions available when requesting temperature output of " +
+                    bodyWithProperty + "w.r.t." + secondaryBody;
+            throw std::runtime_error( errorMessage );
+        }
+        variableFunction = boost::bind( &aerodynamics::FlightConditions::getCurrentFreestreamTemperature,
+                                        bodyMap.at( bodyWithProperty )->getFlightConditions( ) );
+        break;
+    }
+    case geodetic_latitude_dependent_variable:
+    {
+        if( bodyMap.at( bodyWithProperty )->getFlightConditions( ) == NULL )
+        {
+            std::string errorMessage = "Error, no flight conditions available when requesting geodetic latitude output of " +
+                    bodyWithProperty + "w.r.t." + secondaryBody;
+            throw std::runtime_error( errorMessage );
+        }
+
+        variableFunction = boost::bind( &aerodynamics::FlightConditions::getCurrentGeodeticLatitude,
+                                        bodyMap.at( bodyWithProperty )->getFlightConditions( ) );
+        break;
+    }
     default:
         std::string errorMessage =
                 "Error, did not recognize double dependent variable type when making variable function: " +
@@ -348,7 +463,7 @@ std::pair< boost::function< Eigen::VectorXd( ) >, int > getVectorDependentVariab
                 boost::bind( &simulation_setup::Body::getPosition, bodyMap.at( secondaryBody ) );
 
         variableFunction = boost::bind(
-                    &evaluateReferenceFunction< Eigen::Vector3d, Eigen::Vector3d >,
+                    &evaluateBivariateReferenceFunction< Eigen::Vector3d, Eigen::Vector3d >,
                     functionToEvaluate, firstInput, secondInput );
         parameterSize = 3;
         break;
@@ -364,7 +479,7 @@ std::pair< boost::function< Eigen::VectorXd( ) >, int > getVectorDependentVariab
                 boost::bind( &simulation_setup::Body::getVelocity, bodyMap.at( secondaryBody ) );
 
         variableFunction = boost::bind(
-                    &evaluateReferenceFunction< Eigen::Vector3d, Eigen::Vector3d >,
+                    &evaluateBivariateReferenceFunction< Eigen::Vector3d, Eigen::Vector3d >,
                     functionToEvaluate, firstInput, secondInput );
         parameterSize = 3;
 
@@ -408,7 +523,7 @@ std::pair< boost::function< Eigen::VectorXd( ) >, int > getVectorDependentVariab
                         accelerationDependentVariableSettings->associatedBody_ + " and " +
                         accelerationDependentVariableSettings->secondaryBody_ + " of type " +
                         boost::lexical_cast< std::string >(
-                                            accelerationDependentVariableSettings->accelerationModeType_ ) +
+                            accelerationDependentVariableSettings->accelerationModeType_ ) +
                         ", no such acceleration found";
                 throw std::runtime_error( errorMessage );
             }
diff --git a/Tudat/SimulationSetup/PropagationSetup/propagationOutputSettings.cpp b/Tudat/SimulationSetup/PropagationSetup/propagationOutputSettings.cpp
index a2a38d0..64cd2df 100644
--- a/Tudat/SimulationSetup/PropagationSetup/propagationOutputSettings.cpp
+++ b/Tudat/SimulationSetup/PropagationSetup/propagationOutputSettings.cpp
@@ -79,6 +79,15 @@ std::string getDependentVariableName( const PropagationDependentVariables propag
     case body_fixed_airspeed_based_velocity_variable:
         variableName = "Airspeed-based velocity ";
         break;
+    case total_aerodynamic_g_load_variable:
+        variableName = "Aerodynamic g-load ";
+        break;
+    case stagnation_point_heat_flux_dependent_variable:
+        variableName = "Stagnation-point heat flux ";
+        break;
+    case local_temperature_dependent_variable:
+        variableName = "Local freestream temperature ";
+        break;
     default:
         std::string errorMessage = "Error, dependent variable " +
                 boost::lexical_cast< std::string >( propagationDependentVariables ) +
diff --git a/Tudat/SimulationSetup/PropagationSetup/propagationOutputSettings.h b/Tudat/SimulationSetup/PropagationSetup/propagationOutputSettings.h
index ba6a9cb..93b72c4 100644
--- a/Tudat/SimulationSetup/PropagationSetup/propagationOutputSettings.h
+++ b/Tudat/SimulationSetup/PropagationSetup/propagationOutputSettings.h
@@ -44,8 +44,11 @@ enum PropagationDependentVariables
     rotation_matrix_to_body_fixed_frame_variable = 15,
     intermediate_aerodynamic_rotation_matrix_variable = 16,
     relative_body_aerodynamic_orientation_angle_variable = 17,
-    body_fixed_airspeed_based_velocity_variable = 18
-
+    body_fixed_airspeed_based_velocity_variable = 18,
+    total_aerodynamic_g_load_variable = 19,
+    stagnation_point_heat_flux_dependent_variable = 20,
+    local_temperature_dependent_variable = 21,
+    geodetic_latitude_dependent_variable = 22
 };
 
 //! Functional base class for defining settings for dependent variables that are to be saved during propagation
