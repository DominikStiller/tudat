diff --git a/Tudat/Astrodynamics/Aerodynamics/CMakeLists.txt b/Tudat/Astrodynamics/Aerodynamics/CMakeLists.txt
index 4e89b1c..e62082d 100644
--- a/Tudat/Astrodynamics/Aerodynamics/CMakeLists.txt
+++ b/Tudat/Astrodynamics/Aerodynamics/CMakeLists.txt
@@ -44,6 +44,7 @@ set(AERODYNAMICS_SOURCES
   "${SRCROOT}${AERODYNAMICSDIR}/tabulatedAtmosphere.cpp"
   "${SRCROOT}${AERODYNAMICSDIR}/customAerodynamicCoefficientInterface.cpp"
   "${SRCROOT}${AERODYNAMICSDIR}/flightConditions.cpp"
+  "${SRCROOT}${AERODYNAMICSDIR}/trimOrientation.cpp"
 )
 
 # Set the header files.
@@ -63,7 +64,8 @@ set(AERODYNAMICS_HEADERS
   "${SRCROOT}${AERODYNAMICSDIR}/standardAtmosphere.h"
   "${SRCROOT}${AERODYNAMICSDIR}/customAerodynamicCoefficientInterface.h"
   "${SRCROOT}${AERODYNAMICSDIR}/flightConditions.h"
-  "${SRCROOT}${AERODYNAMICSDIR}//UnitTests/testApolloCapsuleCoefficients.h"
+  "${SRCROOT}${AERODYNAMICSDIR}/UnitTests/testApolloCapsuleCoefficients.h"
+  "${SRCROOT}${AERODYNAMICSDIR}/trimOrientation.h"
 )
 
 if(USE_NRLMSISE00)
diff --git a/Tudat/Astrodynamics/Aerodynamics/UnitTests/testApolloCapsuleCoefficients.h b/Tudat/Astrodynamics/Aerodynamics/UnitTests/testApolloCapsuleCoefficients.h
index 2d7aef9..27a6b4e 100644
--- a/Tudat/Astrodynamics/Aerodynamics/UnitTests/testApolloCapsuleCoefficients.h
+++ b/Tudat/Astrodynamics/Aerodynamics/UnitTests/testApolloCapsuleCoefficients.h
@@ -47,7 +47,7 @@ boost::shared_ptr< HypersonicLocalInclinationAnalysis > getApolloCoefficientInte
     Eigen::Vector3d momentReference;
     momentReference( 0 ) = -0.6624;
     momentReference( 1 ) = 0.0;
-    momentReference( 2 ) = -0.1369;
+    momentReference( 2 ) = 0.1369;
 
     std::vector< std::vector< double > > independentVariableDataPoints;
     independentVariableDataPoints.resize( 3 );
diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.h b/Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.h
index 4873c4b..0318289 100644
--- a/Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.h
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.h
@@ -184,6 +184,7 @@ public:
         return computeAerodynamicAcceleration(
                     0.5 * currentDensity_ * currentAirspeed_ * currentAirspeed_,
                     currentReferenceArea_, currentForceCoefficients_, currentMass_ );
+
     }
 
     //! Update member variables used by the aerodynamic acceleration model.
diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientGenerator.h b/Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientGenerator.h
index d40a621..dcc91dc 100644
--- a/Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientGenerator.h
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientGenerator.h
@@ -206,9 +206,11 @@ public:
         // Check if the correct number of aerodynamic coefficients is provided.
         if( independentVariables.size( ) != numberOfIndependentVariables_ )
         {
-            throw std::runtime_error(
-                        "Error in AerodynamicCoefficientGenerator, number of "
-                        "input variables is inconsistent " );
+            std::string errorMessage =
+                    "Error in AerodynamicCoefficientGenerator, number of input variables is inconsistent " +
+                    boost::lexical_cast< std::string >( independentVariables.size( ) ) + ", " +
+                    boost::lexical_cast< std::string >( numberOfIndependentVariables_ );
+            throw std::runtime_error( errorMessage );
         }
 
         // Update current coefficients.
diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientInterface.h b/Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientInterface.h
index bd405ff..ee00aaf 100644
--- a/Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientInterface.h
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientInterface.h
@@ -41,6 +41,7 @@
 #ifndef TUDAT_AERODYNAMIC_COEFFICIENT_INTERFACE_H
 #define TUDAT_AERODYNAMIC_COEFFICIENT_INTERFACE_H
 
+#include <iostream>
 #include <stdexcept>
 #include <vector>
 
diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamics.cpp b/Tudat/Astrodynamics/Aerodynamics/aerodynamics.cpp
index 14577e6..d34f3e8 100644
--- a/Tudat/Astrodynamics/Aerodynamics/aerodynamics.cpp
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamics.cpp
@@ -500,6 +500,7 @@ double computeShockDeflectionAngle( double shockAngle, double machNumber,
     return atan( tangentOfDeflectionAngle_ );
 }
 
+
 //! Function to compute the speed of sound in a gas
 double computeSpeedOfSound( const double temperature, const double ratioOfSpecificHeats,
                             const double specificGasConstant )
@@ -507,6 +508,12 @@ double computeSpeedOfSound( const double temperature, const double ratioOfSpecif
     return std::sqrt( temperature * ratioOfSpecificHeats * specificGasConstant );
 }
 
+//! Compute Mach number
+double computeMachNumber( const double speed, const double speedOfSound )
+{
+    return speed / speedOfSound;
+}
+
 //! Function to compute the mean free path of a particle.
 double computeMeanFreePath( const double weightedAverageCollisionDiameter, const double averageNumberDensity )
 {
diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamics.h b/Tudat/Astrodynamics/Aerodynamics/aerodynamics.h
index 6583030..a4c29a7 100644
--- a/Tudat/Astrodynamics/Aerodynamics/aerodynamics.h
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamics.h
@@ -353,6 +353,15 @@ double computeShockDeflectionAngle( double shockAngle, double machNumber,
 double computeSpeedOfSound( const double temperature, const double ratioOfSpecificHeats,
                             const double specificGasConstant );
 
+//! Compute Mach number
+/*!
+ * Compute Mach number
+ * \param speed Airspeed of object for which Mach number is to be computed.
+ * \param speedOfSound Speed of sound for atmosphere position at which Mach number is to be computed.
+ * \return Mach number
+ */
+double computeMachNumber( const double speed, const double speedOfSound );
+
 //! Function to compute the mean free path of a particle.
 /*!
  * Function to compute the mean free path of a particle from e.g. (Chapman, S. & Cowling, T. The mathematical theory of
diff --git a/Tudat/Astrodynamics/Aerodynamics/flightConditions.cpp b/Tudat/Astrodynamics/Aerodynamics/flightConditions.cpp
index 473da57..28a04a4 100644
--- a/Tudat/Astrodynamics/Aerodynamics/flightConditions.cpp
+++ b/Tudat/Astrodynamics/Aerodynamics/flightConditions.cpp
@@ -8,10 +8,16 @@
  *    http://tudat.tudelft.nl/LICENSE.
  */
 
+#include <iostream>
+
+#include <boost/make_shared.hpp>
 #include <boost/shared_ptr.hpp>
+#include <boost/bind.hpp>
 
+#include "Tudat/Astrodynamics/Aerodynamics/aerodynamics.h"
 #include "Tudat/Astrodynamics/Aerodynamics/flightConditions.h"
 #include "Tudat/Astrodynamics/Aerodynamics/standardAtmosphere.h"
+#include "Tudat/Astrodynamics/Aerodynamics/trimOrientation.h"
 #include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
 
 namespace tudat
@@ -20,6 +26,8 @@ namespace tudat
 namespace aerodynamics
 {
 
+//! Constructor, sets objects and functions from which relevant environment and state variables
+//! are retrieved.
 FlightConditions::FlightConditions(
         const boost::shared_ptr< aerodynamics::AtmosphereModel > atmosphereModel,
         const boost::function< double( const Eigen::Vector3d ) > altitudeFunction,
@@ -73,7 +81,6 @@ void FlightConditions::setAerodynamicCoefficientsIndependentVariableFunction(
     }
 }
 
-
 //! Function to update all flight conditions.
 void FlightConditions::updateConditions( const double currentTime )
 {
@@ -89,10 +96,10 @@ void FlightConditions::updateConditions( const double currentTime )
             altitudeFunction_( currentBodyCenteredPseudoBodyFixedState_.segment( 0, 3 ) );
     currentAirspeed_ = currentBodyCenteredPseudoBodyFixedState_.segment( 3, 3 ).norm( );
 
-    // Update aerodynamic/geometric angles.
+    // Update aerodynamic angles (but not angles w.r.t. body-fixed frame).
     if( aerodynamicAngleCalculator_!= NULL )
     {
-        aerodynamicAngleCalculator_->update( );
+        aerodynamicAngleCalculator_->update( false );
     }
 
     // Update latitude and longitude (if required)
@@ -108,8 +115,25 @@ void FlightConditions::updateConditions( const double currentTime )
     currentDensity_ = atmosphereModel_->getDensity( currentAltitude_, currentLongitude_,
                                                     currentLatitude_, currentTime_ );
 
+    updateAerodynamicCoefficientInput( );
+
+    // Update angles from aerodynamic to body-fixed frame (if relevant).
+    if( aerodynamicAngleCalculator_!= NULL )
+    {
+        aerodynamicAngleCalculator_->update( true );
+        updateAerodynamicCoefficientInput( );
+    }
+
+    // Update aerodynamic coefficients.
+    aerodynamicCoefficientInterface_->updateCurrentCoefficients(
+                aerodynamicCoefficientIndependentVariables_ );
+}
+
+void FlightConditions::updateAerodynamicCoefficientInput( )
+{
+    aerodynamicCoefficientIndependentVariables_.clear( );
+
     // Calculate independent variables for aerodynamic coefficients.
-    std::vector< double > aerodynamicCoefficientIndependentVariables;
     for( unsigned int i = 0; i < aerodynamicCoefficientInterface_->
          getNumberOfIndependentVariables( ); i++ )
     {
@@ -117,9 +141,10 @@ void FlightConditions::updateConditions( const double currentTime )
         {
         //Calculate Mach number if needed.
         case mach_number_dependent:
-            aerodynamicCoefficientIndependentVariables.push_back(
-                        currentAirspeed_ / atmosphereModel_->getSpeedOfSound(
-                            currentAltitude_, currentLongitude_, currentLatitude_, currentTime_ ) );
+            aerodynamicCoefficientIndependentVariables_.push_back(
+                        aerodynamics::computeMachNumber(
+                        currentAirspeed_, atmosphereModel_->getSpeedOfSound(
+                            currentAltitude_, currentLongitude_, currentLatitude_, currentTime_ ) ) );
             break;
         //Get angle of attack if needed.
         case angle_of_attack_dependent:
@@ -128,7 +153,7 @@ void FlightConditions::updateConditions( const double currentTime )
             {
                 throw std::runtime_error( "Error, aerodynamic angle calculator is null, but require angle of attack" );
             }
-            aerodynamicCoefficientIndependentVariables.push_back(
+            aerodynamicCoefficientIndependentVariables_.push_back(
                         aerodynamicAngleCalculator_->getAerodynamicAngle(
                             reference_frames::angle_of_attack ) );
             break;
@@ -138,11 +163,10 @@ void FlightConditions::updateConditions( const double currentTime )
             {
                 throw std::runtime_error( "Error, aerodynamic angle calculator is null, but require angle of sideslip" );
             }
-            aerodynamicCoefficientIndependentVariables.push_back(
+            aerodynamicCoefficientIndependentVariables_.push_back(
                         aerodynamicAngleCalculator_->getAerodynamicAngle(
                             reference_frames::angle_of_sideslip ) );
             break;
-        // Check if value is custom-defined.
         default:
             if( customCoefficientDependencies_.count(
                         aerodynamicCoefficientInterface_->getIndependentVariableName( i ) ) == 0 )
@@ -153,21 +177,32 @@ void FlightConditions::updateConditions( const double currentTime )
             }
             else
             {
-                aerodynamicCoefficientIndependentVariables.push_back(
+                aerodynamicCoefficientIndependentVariables_.push_back(
                             customCoefficientDependencies_.at(
                                 aerodynamicCoefficientInterface_->getIndependentVariableName( i ) )( ) );
             }
         }
     }
-
-    // Update aerodynamic coefficients.
-    aerodynamicCoefficientInterface_->updateCurrentCoefficients(
-                aerodynamicCoefficientIndependentVariables );
-
-
 }
 
+//! Function to set the angle of attack to trimmed conditions.
+void setTrimmedConditions(
+        const boost::shared_ptr< FlightConditions > flightConditions )
+{
+    // Create trim object.
+    boost::shared_ptr< TrimOrientationCalculator > trimOrientation =
+            boost::make_shared< TrimOrientationCalculator >(
+                flightConditions->getAerodynamicCoefficientInterface( ) );
+
+    // Create angle-of-attack function from trim object.
+    boost::function< std::vector< double >( ) > untrimmedIndependentVariablesFunction =
+            boost::bind( &FlightConditions::getAerodynamicCoefficientIndependentVariables,
+                         flightConditions );
+    flightConditions->getAerodynamicAngleCalculator( )->setOrientationAngleFunctions(
+                boost::bind( &TrimOrientationCalculator::findTrimAngleOfAttackFromFunction, trimOrientation,
+                             untrimmedIndependentVariablesFunction ) );
+}
 
-} // namespace aerodynamics
+}
 
-} // namespace tudat
+}
diff --git a/Tudat/Astrodynamics/Aerodynamics/flightConditions.h b/Tudat/Astrodynamics/Aerodynamics/flightConditions.h
index e65859c..788f8ed 100644
--- a/Tudat/Astrodynamics/Aerodynamics/flightConditions.h
+++ b/Tudat/Astrodynamics/Aerodynamics/flightConditions.h
@@ -47,6 +47,8 @@ public:
      *  \param atmosphereModel Atmosphere model of atmosphere through which vehicle is flying
      *  \param altitudeFunction Function returning the altitude of the vehicle as a function of
      *  its body-fixed position.
+     *  \param aerodynamicCoefficientInterface Class from which the aerodynamic (force and moment)
+     *  coefficients are retrieved
      *  \param stateOfVehicle Function returning the current state of the vehicle
      *  (in the global frame)
      *  \param stateOfCentralBody Function returning the current state of the central body
@@ -110,6 +112,17 @@ public:
         return currentAirspeed_;
     }
 
+    //! Function to return speed of sound
+    /*!
+     *  Function to return speed of from quantities computed by previous call of updateConditions.
+     *  \return Current speed of sound.
+     */
+    double getCurrentSpeedOfSound( )
+    {
+        return atmosphereModel_->getSpeedOfSound(
+                    currentAltitude_, currentLongitude_, currentLatitude_, currentTime_ );
+    }
+
     //! Function to return the current time of the FlightConditions
     /*!
      *  Function to return the current time of the FlightConditions.
@@ -161,7 +174,6 @@ public:
     basic_mathematics::Vector6d getCurrentBodyCenteredBodyFixedState( )
     {
         return currentBodyCenteredPseudoBodyFixedState_;
-
     }
 
     //! Function to return aerodynamic angle calculator object
@@ -175,9 +187,31 @@ public:
         return aerodynamicAngleCalculator_;
     }
 
+    //! Function to return object from which the aerodynamic coefficients are obtained.
+    /*!
+     *  Function to return object from which the aerodynamic coefficients are obtained.
+     *  \return Object from which the aerodynamic coefficients are obtained.
+     */
+    boost::shared_ptr< AerodynamicCoefficientInterface > getAerodynamicCoefficientInterface( )
+    {
+        return aerodynamicCoefficientInterface_;
+    }
+
+    //! Function to return list of independent variables of the aerodynamic coefficient interface
+    /*!
+     *  Function to return list of independent variables of the aerodynamic coefficient interface
+     *  \return List of independent variables of the aerodynamic coefficient interface
+     */
+    std::vector< double > getAerodynamicCoefficientIndependentVariables( )
+    {
+        return aerodynamicCoefficientIndependentVariables_;
+    }
 
 private:
 
+    //! Function to update the independent variables of the aerodynamic coefficient interface
+    void updateAerodynamicCoefficientInput( );
+
     //! Name of central body (i.e. body with the atmosphere)
     std::string centralBody_;
 
@@ -201,9 +235,6 @@ private:
     //! Object from which the aerodynamic coefficients are obtained.
     boost::shared_ptr< AerodynamicCoefficientInterface > aerodynamicCoefficientInterface_;
 
-    //! List of custom functions for aerodynamic coefficient dependencies.
-    std::map< AerodynamicCoefficientsIndependentVariables, boost::function< double( ) > > customCoefficientDependencies_;
-
     //! Object from which the aerodynamic/trajectory angles of the vehicle are calculated.
     boost::shared_ptr< reference_frames::AerodynamicAngleCalculator > aerodynamicAngleCalculator_;
 
@@ -231,11 +262,28 @@ private:
     //! Current time of propagation.
     double currentTime_;
 
+    //! List of custom functions for aerodynamic coefficient dependencies.
+    std::map< AerodynamicCoefficientsIndependentVariables, boost::function< double( ) > > customCoefficientDependencies_;
+
     //! Boolean setting whether latitude and longitude are to be updated by updateConditions().
     bool updateLatitudeAndLongitude_;
+
+    //! Current list of independent variables of the aerodynamic coefficient interface
+    std::vector< double > aerodynamicCoefficientIndependentVariables_;
+
 };
 
+//! Function to set the angle of attack to trimmed conditions.
+/*!
+ * Function to set the angle of attack to trimmed conditions. Using this function requires teh aerodynamic coefficient
+ * interface to be dependent on the angle of attack.
+ * \param flightConditions Flight conditions for body that is to have trimmed conditions.
+ */
+void setTrimmedConditions(
+        const boost::shared_ptr< FlightConditions > flightConditions );
+
 } // namespace aerodynamics
 
 } // namespace tudat
+
 #endif // TUDAT_FLIGHTCONDITIONS_H
diff --git a/Tudat/Astrodynamics/Aerodynamics/nrlmsise00Atmosphere.cpp b/Tudat/Astrodynamics/Aerodynamics/nrlmsise00Atmosphere.cpp
index bc53337..e08266a 100644
--- a/Tudat/Astrodynamics/Aerodynamics/nrlmsise00Atmosphere.cpp
+++ b/Tudat/Astrodynamics/Aerodynamics/nrlmsise00Atmosphere.cpp
@@ -31,6 +31,7 @@
  */
 
 #include <iostream>
+
 #include "Tudat/Astrodynamics/Aerodynamics/nrlmsise00Atmosphere.h"
 #include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
 
diff --git a/Tudat/Astrodynamics/Aerodynamics/trimOrientation.cpp b/Tudat/Astrodynamics/Aerodynamics/trimOrientation.cpp
new file mode 100644
index 0000000..ce7558b
--- /dev/null
+++ b/Tudat/Astrodynamics/Aerodynamics/trimOrientation.cpp
@@ -0,0 +1,99 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#include <Tudat/Astrodynamics/Aerodynamics/trimOrientation.h>
+#include <Tudat/Mathematics/BasicMathematics/functionProxy.h>
+#include <Tudat/Mathematics/RootFinders/secantRootFinder.h>
+#include <Tudat/Mathematics/RootFinders/terminationConditions.h>
+
+namespace tudat
+{
+
+namespace aerodynamics
+{
+
+//! Constructor
+TrimOrientationCalculator::TrimOrientationCalculator(
+        const boost::shared_ptr< AerodynamicCoefficientInterface > coefficientInterface,
+        const boost::shared_ptr< root_finders::RootFinderCore< double > > rootFinder ):
+    coefficientInterface_( coefficientInterface ), rootFinder_( rootFinder )
+{
+    // Find index of angle of attack in aerodynamic coefficient interface (throw error if not found)
+    std::vector< AerodynamicCoefficientsIndependentVariables > independentVariables =
+            coefficientInterface->getIndependentVariableNames( );
+    std::vector< AerodynamicCoefficientsIndependentVariables >::iterator variableIterator =
+            std::find( independentVariables.begin( ), independentVariables.end( ), angle_of_attack_dependent );
+
+    if( variableIterator == independentVariables.end( ) )
+    {
+        throw std::runtime_error( "Error when getting trim angle of attack, no angle of attack dependency is found" );
+    }
+    variableIndex_ = std::distance( independentVariables.begin( ), variableIterator );
+
+    // If no root finder provided, use default value.
+    if ( !rootFinder_.get( ) )
+    {
+        rootFinder_ = boost::make_shared< root_finders::SecantRootFinderCore< double > >(
+                    boost::bind(
+                        &root_finders::termination_conditions::RootAbsoluteToleranceTerminationCondition< double >::
+                        checkTerminationCondition,
+                        boost::make_shared< root_finders::termination_conditions::RootAbsoluteToleranceTerminationCondition
+                        < double > >( 1.0E-15, 1000 ), _1, _2, _3, _4, _5 ), 0.5 );
+    }
+}
+
+//! Function to find the trimmed angle of attack for a given set of independent  variables
+double TrimOrientationCalculator::findTrimAngleOfAttack(
+        const std::vector< double > untrimmedIndependentVariables )
+{
+    // Determine function for which the root is to be determined.
+    boost::function< double( const double ) > coefficientFunction =
+            boost::bind( &TrimOrientationCalculator::getPerturbedMomentCoefficient,
+                         this, _1, untrimmedIndependentVariables );
+
+    double trimmedAngleOfAttack = TUDAT_NAN;
+
+    // Find root of pitch moment function
+    try
+    {
+        trimmedAngleOfAttack = rootFinder_->execute(
+                    boost::make_shared< basic_mathematics::FunctionProxy< double, double > >( coefficientFunction ),
+                    untrimmedIndependentVariables.at( variableIndex_ ) );
+    }
+    // Throw error if not converged
+    catch( std::runtime_error )
+    {
+        throw std::runtime_error( "Error when getting trim angle of attack, root finder did not converge." );
+
+    }
+
+    return trimmedAngleOfAttack;
+}
+
+
+//! Function to get the moment coefficient for a given angle of attack
+double TrimOrientationCalculator::getPerturbedMomentCoefficient(
+        const double perturbedAngleOfAttack,
+        const std::vector< double >& unperturbedConditions )
+{
+    // Update coefficients to perturbed independent variables
+    std::vector< double > perturbedConditions = unperturbedConditions;
+    perturbedConditions[ variableIndex_ ] = perturbedAngleOfAttack;
+    coefficientInterface_->updateCurrentCoefficients( perturbedConditions );
+
+    // Get pitch moment coefficient
+    return coefficientInterface_->getCurrentMomentCoefficients( )( 1 );
+}
+
+}
+
+}
+
+
diff --git a/Tudat/Astrodynamics/Aerodynamics/trimOrientation.h b/Tudat/Astrodynamics/Aerodynamics/trimOrientation.h
new file mode 100644
index 0000000..9e8c75d
--- /dev/null
+++ b/Tudat/Astrodynamics/Aerodynamics/trimOrientation.h
@@ -0,0 +1,112 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ *
+ *    NOTE: The code in this file, and the associated cpp file, is tested in the unitTestDependentVariableOutput.cpp file.
+ */
+
+#ifndef TUDAT_TRIMORIENTATION_H
+#define TUDAT_TRIMORIENTATION_H
+
+#include <boost/function.hpp>
+#include <boost/shared_ptr.hpp>
+
+#include <Eigen/Core>
+
+#include <Tudat/Astrodynamics/Aerodynamics/aerodynamicCoefficientInterface.h>
+#include <Tudat/Mathematics/RootFinders/rootFinder.h>
+
+namespace tudat
+{
+
+namespace aerodynamics
+{
+
+
+
+//! Class to determine the trimmed angle-of-attack for a given set of aerodynamic coefficients.
+/*!
+ *  Class to determine the trimmed angle-of-attack for a given set of aerodynamic coefficients. The coefficient interface
+ *  provided as input must be dependent on the angle of attack for this class to function.
+ */
+class TrimOrientationCalculator
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param coefficientInterface Object containing used to retrieve aerodynamic coefficients as function of independent
+     * variables.
+     * \param rootFinder Object to iteratively find the root of the equations C_m(alpha)=0, i.e. to determine the
+     * angle of attack for which the pitch moment is zero.
+     */
+    TrimOrientationCalculator(
+            const boost::shared_ptr< AerodynamicCoefficientInterface > coefficientInterface,
+            const boost::shared_ptr< root_finders::RootFinderCore< double > > rootFinder = NULL );
+
+    //! Function to find the trimmed angle of attack for a given set of independent  variables
+    /*!
+     * Function to find the trimmed angle of attack for a given set of independent  variables. This function iteratively
+     * changes the angle of attack in the untrimmedIndependentVariables vector (keeping any other variables the same) and
+     * returns the value of the trimmed angle of attack. Note that this function will typically have some small numerical
+     * error in the result, as a result of the error tolerances in the root finder.
+     * \param untrimmedIndependentVariables Untrimmed list of independent variables (in order required as input for
+     * coefficientInterface_
+     * \return Trimmed angle of attack.
+     */
+    double findTrimAngleOfAttack(
+            const std::vector< double > untrimmedIndependentVariables );
+
+    //! Function to find the trimmed angle of attack for a given set of independent  variables
+    /*!
+     * Function to find the trimmed angle of attack for a given set of independent  variables. This function iteratively
+     * changes the angle of attack in the untrimmedIndependentVariables vector (keeping any other variables the same) and
+     * returns the value of the trimmed angle of attack. Note that this function will typically have some small numerical
+     * error in the result, as a result of the error tolerances in the root finder.
+     * \param untrimmedIndependentVariablesFunction Function returning untrimmed list of independent variables
+     * (in order required as input for coefficientInterface_
+     * \return Trimmed angle of attack.
+     */
+    double findTrimAngleOfAttackFromFunction(
+            const boost::function< std::vector< double >( ) > untrimmedIndependentVariablesFunction )
+    {
+        return findTrimAngleOfAttack( untrimmedIndependentVariablesFunction( ) );
+    }
+
+private:
+
+    //! Function to get the moment coefficient for a given angle of attack
+    /*!
+     * Function to get the moment coefficient for a given perturbed angle of attack, keeping all other independent  variables
+     * constant. This function is used as input to the root finder to determine the trim point.
+     * \param perturbedAngleOfAttack Angle of attack to use
+     * \param unperturbedConditions Untrimmed list of independent variables (in order required as input for
+     * coefficientInterface_
+     * \return Moment coefficient at given independent variables.
+     */
+    double getPerturbedMomentCoefficient(
+            const double perturbedAngleOfAttack,
+            const std::vector< double >& unperturbedConditions );
+
+    //! Object containing used to retrieve aerodynamic coefficients as function of independent variables.
+    boost::shared_ptr< AerodynamicCoefficientInterface > coefficientInterface_;
+
+    //! Object to iteratively find the root of the equations C_m(alpha)=0, i.e. to determine the
+    //!  angle of attack for which the pitch moment is zero.
+    boost::shared_ptr< root_finders::RootFinderCore< double > > rootFinder_;
+
+    //! Index in independent variable list of coefficientInterface_ corresponding to the angle of attack.
+    int variableIndex_;
+};
+
+}
+
+}
+
+#endif // TUDAT_TRIMORIENTATION_H
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/CMakeLists.txt b/Tudat/Astrodynamics/BasicAstrodynamics/CMakeLists.txt
index 8d90a18..b87567c 100755
--- a/Tudat/Astrodynamics/BasicAstrodynamics/CMakeLists.txt
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/CMakeLists.txt
@@ -77,6 +77,7 @@ set(BASICASTRODYNAMICS_HEADERS
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/bodyShapeModel.h"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/oblateSpheroidBodyShapeModel.h"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/sphericalBodyShapeModel.h"
+  "${SRCROOT}${BASICASTRODYNAMICSDIR}/massRateModel.h"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/sphericalStateConversions.h"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/unifiedStateModelElementConversions.h"
 )
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h b/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h
index d5a109f..48d7192 100644
--- a/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h
@@ -46,7 +46,7 @@
 #define TUDAT_ACCELERATION_MODEL_H
 
 #include <map>
-#include <vector>
+#include <unordered_map>
 
 #include <boost/shared_ptr.hpp>
 
@@ -72,6 +72,11 @@ class AccelerationModel
 {
 public:
 
+
+    //! Constructor.
+    AccelerationModel( ):
+        currentTime_( TUDAT_NAN ){ }
+
     //! Virtual destructor.
     /*!
      * Virtual destructor, necessary to ensure that derived class destructors get called correctly.
@@ -103,6 +108,11 @@ public:
      */
     virtual void updateMembers( const double currentTime = TUDAT_NAN ) = 0;
 
+    //! Function to reset the current time
+    /*!
+     * Function to reset the current time of the acceleration model.
+     * \param currentTime Current time (default NaN).
+     */
     virtual void resetTime( const double currentTime = TUDAT_NAN )
     {
         currentTime_ = currentTime;
@@ -110,6 +120,7 @@ public:
 
 protected:
 
+    //! Previous time to which acceleration model was updated.
     double currentTime_;
 
 protected:
@@ -137,14 +148,16 @@ typedef boost::shared_ptr< AccelerationModel2d > AccelerationModel2dPointer;
  * \tparam AccelerationDataType Data type used to represent accelerations
  *          (default=Eigen::Vector3d).
  * \param accelerationModel Acceleration model that is to be evaluated.
+ * \param currentTime Time at which acceleration model is to be updated.
  * \return Acceleration that is obtained following the member update.
  */
 template < typename AccelerationDataType >
 AccelerationDataType updateAndGetAcceleration(
-        boost::shared_ptr< AccelerationModel< AccelerationDataType > > accelerationModel )
+        const boost::shared_ptr< AccelerationModel< AccelerationDataType > > accelerationModel,
+        const double currentTime = TUDAT_NAN )
 {
     // Update members.
-    accelerationModel->updateMembers( );
+    accelerationModel->updateMembers( currentTime );
 
     // Evaluate and return acceleration.
     return accelerationModel->getAcceleration( );
@@ -152,14 +165,14 @@ AccelerationDataType updateAndGetAcceleration(
 
 //! Typedef defining a list of accelerations acting on a single body, key is the name of each
 //! body exerting a acceletation, value is a list of accelerations exerted by that body.
-typedef std::map< std::string, std::vector<
+typedef std::unordered_map< std::string, std::vector<
 boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > > >
 SingleBodyAccelerationMap;
 
 //! Typedef defining a list of accelerations acting on a set of bodies, key is the name of each
 //! body undergoing a acceletation, value is SingleBodyAccelerationMap, defining all accelerations
 //! acting on it.
-typedef std::map< std::string, SingleBodyAccelerationMap > AccelerationMap;
+typedef std::unordered_map< std::string, SingleBodyAccelerationMap > AccelerationMap;
 
 } // namespace basic_astrodynamics
 } // namespace tudat
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.cpp b/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.cpp
index d7d8649..a656201 100644
--- a/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.cpp
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.cpp
@@ -68,11 +68,15 @@ AvailableAcceleration getAccelerationModelType(
     {
         accelerationType = third_body_central_gravity;
     }
-    else if( boost::dynamic_pointer_cast< SphericalHarmonicsGravitationalAccelerationModelXd >(
+    else if( boost::dynamic_pointer_cast< SphericalHarmonicsGravitationalAccelerationModel >(
                  accelerationModel ) != NULL  )
     {
         accelerationType = spherical_harmonic_gravity;
     }
+    else if( boost::dynamic_pointer_cast< MutualSphericalHarmonicsGravitationalAccelerationModel >( accelerationModel ) != NULL )
+    {
+        accelerationType = mutual_spherical_harmonic_gravity;
+    }
     else if( boost::dynamic_pointer_cast< AerodynamicAcceleration >(
                  accelerationModel ) != NULL )
     {
@@ -89,6 +93,42 @@ AvailableAcceleration getAccelerationModelType(
 
 }
 
+//! Function to identify the type of a mass rate model.
+AvailableMassRateModels getMassRateModelType(
+        const boost::shared_ptr< MassRateModel > massRateModel )
+{
+    // Nominal type is undefined
+    AvailableMassRateModels massRateType = undefined_mass_rate_model;
+
+    // Check for each mass rate mdoel type implemented as AvailableMassRateModels.
+    if( boost::dynamic_pointer_cast< basic_astrodynamics::CustomMassRateModel >(
+                massRateModel ) != NULL )
+    {
+        massRateType = custom;
+    }
+    else
+    {
+        throw std::runtime_error(
+                    "Error, mass rate model not identified when getting mass rate model type." );
+    }
+    return massRateType;
+}
+
+//! Function to get all acceleration models of a given type from a list of models
+std::vector< boost::shared_ptr< AccelerationModel3d > > getAccelerationModelsOfType(
+        const std::vector< boost::shared_ptr< AccelerationModel3d > >& fullList,
+        const AvailableAcceleration modelType )
+{
+    std::vector< boost::shared_ptr< AccelerationModel3d > > accelerationList;
+    for( unsigned int i = 0; i < fullList.size( ); i++ )
+    {
+        if( getAccelerationModelType( fullList.at( i ) ) == modelType )
+        {
+            accelerationList.push_back( fullList.at( i  ) );
+        }
+    }
+    return accelerationList;
+}
 
 } // namespace basic_astrodynamics
 
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.h b/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.h
index 83b6520..b314b6b 100644
--- a/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.h
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.h
@@ -38,8 +38,10 @@
 #include "Tudat/Astrodynamics/ElectroMagnetism/cannonBallRadiationPressureAcceleration.h"
 #include "Tudat/Astrodynamics/Gravitation/centralGravityModel.h"
 #include "Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h"
+#include "Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.h"
 #include "Tudat/Astrodynamics/Gravitation/thirdBodyPerturbation.h"
 #include "Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/massRateModel.h"
 
 
 namespace tudat
@@ -61,8 +63,21 @@ enum AvailableAcceleration
     aerodynamic,
     cannon_ball_radiation_pressure,
     spherical_harmonic_gravity,
+    mutual_spherical_harmonic_gravity,
     third_body_central_gravity,
-    third_body_spherical_harmonic_gravity
+    third_body_spherical_harmonic_gravity,
+    third_body_mutual_spherical_harmonic_gravity
+};
+
+//! List of model types for body mass rates.
+/*!
+*  List of model types for body mass rates available in simulations. Mass rate models not defined by this
+*  given enum cannot be used for automatic mass rate model setup.
+*/
+enum AvailableMassRateModels
+{
+    undefined_mass_rate_model,
+    custom
 };
 
 //! Function to identify the derived class type of an acceleration model.
@@ -76,6 +91,26 @@ AvailableAcceleration getAccelerationModelType(
         const boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > >
         accelerationModel );
 
+//! Function to identify the type of a mass rate model.
+/*!
+ *  Function to identify the type of a mass rate model. The type must be defined
+ *  in the AvailableMassRateModels enum to be recognized by this function.
+ *  \param massRateModel Mass rate model of which the type is to be identified.
+ *  \return Type of the massRateModel, as identified by AvailableMassRateModels enum.
+ */
+AvailableMassRateModels getMassRateModelType(
+        const boost::shared_ptr< MassRateModel > massRateModel );
+
+//! Function to get all acceleration models of a given type from a list of models
+/*!
+ * Function to get all acceleration models of a given type from a list of models
+ * \param fullList List of acceleration models
+ * \param modelType Type for which all models are to be retrieved
+ * \return Subset of fullList for which the acceleration model type is modelType
+ */
+std::vector< boost::shared_ptr< AccelerationModel3d > > getAccelerationModelsOfType(
+        const std::vector< boost::shared_ptr< AccelerationModel3d > >& fullList,
+        const AvailableAcceleration modelType );
 
 } // namespace basic_astrodynamics
 
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h b/Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h
index a68f5ed..3c0ab96 100644
--- a/Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h
@@ -147,7 +147,8 @@ Eigen::Matrix< ScalarType, 6, 1 > propagateKeplerOrbit(
         const ScalarType finalEccentricAnomaly =
                 convertMeanAnomalyToEccentricAnomaly< ScalarType >(
                     initialStateInKeplerianElements( eccentricityIndex ),
-                    initialMeanAnomaly + meanAnomalyChange );
+                    initialMeanAnomaly + meanAnomalyChange, true,
+                    TUDAT_NAN, aRootFinder );
 
         // Compute true anomaly for computed eccentric anomaly.
         finalStateInKeplerianElements( trueAnomalyIndex ) =
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/massRateModel.h b/Tudat/Astrodynamics/BasicAstrodynamics/massRateModel.h
new file mode 100644
index 0000000..5cb77d0
--- /dev/null
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/massRateModel.h
@@ -0,0 +1,136 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_MASSRATEMODEL_H
+#define TUDAT_MASSRATEMODEL_H
+
+#include <map>
+#include <vector>
+#include <iostream>
+#include <boost/function.hpp>
+#include <boost/shared_ptr.hpp>
+
+#include <Eigen/Core>
+
+#include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
+
+namespace tudat
+{
+namespace basic_astrodynamics
+{
+
+//! Base class for determining the rate of change of a body's mass, to be used in numerical integration.
+/*!
+ *  Base class for determining the rate of change of a body's mass, to be used in numerical integration. Specific types
+ *  of mass rate models are to be implemented in derived classes
+ */
+class MassRateModel
+{
+public:
+
+    //! Constructor
+    MassRateModel( ):
+        currentTime_( TUDAT_NAN ), currentMassRate_( TUDAT_NAN ){ }
+
+    //! Destructor
+    virtual ~MassRateModel( ) { }
+
+    //! Function to retrieve current mass rate
+    /*!
+     * Function to retrieve current mass rate, as set by last call to updateMembers (implemented in derived class)
+     * \return Current mass rate
+     */
+    virtual double getMassRate( )
+    {
+        return currentMassRate_;
+    }
+
+    //! Update member variables used by the mass rate model, and internally compute mass rate.
+    /*!
+     * Updates member variables used by the mass rate model, and internally compute mass rate. In the case of mass rate
+     * models containing varying parameters, function-pointers returning such a parameter (for instance
+     * the Cartesian state of a body) will be set as a member variable.
+     * This function evaluates such function-pointers and updates member variables to the 'current'
+     * values of these parameters. Only these current values, not the function-pointers are then
+     * used for the actual computation function.
+     * \param currentTime Time at which acceleration model is to be updated.
+     */
+    virtual void updateMembers( const double currentTime = TUDAT_NAN ) = 0;
+
+    //! Function to reset the current time
+    /*!
+     * Function to reset the current time of the acceleration model.
+     * \param currentTime Current time (default NaN).
+     */
+    virtual void resetTime( const double currentTime = TUDAT_NAN )
+    {
+        currentTime_ = currentTime;
+    }
+
+protected:
+
+    //! Previous time to which mass rate model was updated.
+    double currentTime_;
+
+    //! Current mass rate, as set by last call to updateMembers (implemented in derived class)
+    double currentMassRate_;
+
+private:
+};
+
+//! Derived class for determining the rate of change of a body's mass, user-defined by a function pointer.
+/*!
+ *  Derived class for determining the rate of change of a body's mass, user-defined by a function pointer.
+ *  This class can be used for any kind of mass rate model for which the user can define the dependency as a function
+ *  of time.
+ */
+class CustomMassRateModel: public MassRateModel
+{
+public:
+
+    //! Constructor.
+    /*!
+     * Constructor
+     * \param massRateFunction Function returning mass rate as a function of time.
+     */
+    CustomMassRateModel(
+            const boost::function< double( const double ) > massRateFunction ):
+    massRateFunction_( massRateFunction ){ }
+
+    //! Destructor.
+    ~CustomMassRateModel( ){ }
+
+    //! Update member variables used by the mass rate model and compute the mass rate
+    /*!
+     * Update member variables used by the mass rate model and compute the mass rate
+     * \param currentTime Time at which acceleration model is to be updated.
+     */
+    void updateMembers( const double currentTime = TUDAT_NAN )
+    {
+        // Check if update is needed.
+        if( !( currentTime_ == currentTime ) )
+        {
+            currentMassRate_ = massRateFunction_( currentTime );
+        }
+    }
+
+private:
+
+    //! Function returning mass rate as a function of time.
+    boost::function< double( const double ) > massRateFunction_;
+
+};
+
+
+} // namespace basic_astrodynamics
+
+} // namespace tudat
+
+#endif // TUDAT_MASSRATEMODEL_H
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/sphericalStateConversions.cpp b/Tudat/Astrodynamics/BasicAstrodynamics/sphericalStateConversions.cpp
index 24e9609..2f377cf 100644
--- a/Tudat/Astrodynamics/BasicAstrodynamics/sphericalStateConversions.cpp
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/sphericalStateConversions.cpp
@@ -42,7 +42,7 @@ basic_mathematics::Vector6d convertCartesianToSphericalOrbitalState(
     basic_mathematics::Vector6d sphericalOrbitalState;
 
     // Compute and set spherical position
-    Eigen::Vector3d sphericalPosition = coordinate_conversions::convertCartesianToSpherical(
+    Eigen::Vector3d sphericalPosition = coordinate_conversions::convertCartesianToSpherical< double >(
                 bodyFixedCartesianState.segment( 0, 3 ) );
     sphericalOrbitalState( radiusIndex ) = sphericalPosition( 0 );
     sphericalOrbitalState( latitudeIndex ) = mathematical_constants::PI / 2.0 - sphericalPosition( 1 );
diff --git a/Tudat/Astrodynamics/CMakeLists.txt b/Tudat/Astrodynamics/CMakeLists.txt
index 049c7df..a04f089 100755
--- a/Tudat/Astrodynamics/CMakeLists.txt
+++ b/Tudat/Astrodynamics/CMakeLists.txt
@@ -34,7 +34,6 @@
  #
  #    Notes
  #
-
 # Define the main sub-directories.
 set(AERODYNAMICSDIR "${ASTRODYNAMICSDIR}/Aerodynamics")
 set(BASICASTRODYNAMICSDIR "${ASTRODYNAMICSDIR}/BasicAstrodynamics")
@@ -44,8 +43,9 @@ set(GRAVITATIONDIR "${ASTRODYNAMICSDIR}/Gravitation")
 set(MISSIONSEGMENTSDIR "${ASTRODYNAMICSDIR}/MissionSegments")
 set(REFERENCEFRAMESDIR "${ASTRODYNAMICSDIR}/ReferenceFrames")
 set(OBSERVATIONMODELSDIR "${ASTRODYNAMICSDIR}/ObservationModels")
-set(STATEDERIVATIVEMODELSDIR "${ASTRODYNAMICSDIR}/StateDerivativeModels")
+set(ORBITDETERMINATIONDIR "${ASTRODYNAMICSDIR}/OrbitDetermination")
 set(PROPAGATORSDIR "${ASTRODYNAMICSDIR}/Propagators")
+set(RELATIVITYDIR "${ASTRODYNAMICSDIR}/Relativity")
 
 # Add subdirectories.
 add_subdirectory("${SRCROOT}${AERODYNAMICSDIR}")
@@ -56,8 +56,10 @@ add_subdirectory("${SRCROOT}${GRAVITATIONDIR}")
 add_subdirectory("${SRCROOT}${MISSIONSEGMENTSDIR}")
 add_subdirectory("${SRCROOT}${REFERENCEFRAMESDIR}")
 add_subdirectory("${SRCROOT}${OBSERVATIONMODELSDIR}")
-add_subdirectory("${SRCROOT}${STATEDERIVATIVEMODELSDIR}")
+add_subdirectory("${SRCROOT}${ORBITDETERMINATIONDIR}")
 add_subdirectory("${SRCROOT}${PROPAGATORSDIR}")
+add_subdirectory("${SRCROOT}${RELATIVITYDIR}")
+
 
 # Get target properties for static libraries.
 get_target_property(AERODYNAMICSSOURCES tudat_aerodynamics SOURCES)
@@ -68,5 +70,7 @@ get_target_property(GRAVITATIONSOURCES tudat_gravitation SOURCES)
 get_target_property(MISSIONSEGMENTSSOURCES tudat_mission_segments SOURCES)
 get_target_property(REFERENCEFRAMESSOURCES tudat_reference_frames SOURCES)
 get_target_property(OBSERVATIONMODELSDIR tudat_observation_models SOURCES)
-get_target_property(STATEDERIVATIVEMODELSSOURCES tudat_state_derivative_models SOURCES)
+get_target_property(ORBITDETERMINATIONSOURCES tudat_orbit_determination SOURCES)
+get_target_property(RELATIVITYSOURCES tudat_relativity SOURCES)
+
 get_target_property(PROPAGATORSDIR tudat_propagators SOURCES)
diff --git a/Tudat/Astrodynamics/ElectroMagnetism/cannonBallRadiationPressureAcceleration.cpp b/Tudat/Astrodynamics/ElectroMagnetism/cannonBallRadiationPressureAcceleration.cpp
index 80062f7..bac2c14 100644
--- a/Tudat/Astrodynamics/ElectroMagnetism/cannonBallRadiationPressureAcceleration.cpp
+++ b/Tudat/Astrodynamics/ElectroMagnetism/cannonBallRadiationPressureAcceleration.cpp
@@ -57,27 +57,5 @@ Eigen::Vector3d computeCannonBallRadiationPressureAcceleration(
                 radiationPressure, vectorToSource, area, radiationPressureCoefficient ) / mass;
 }
 
-//! Get radiation pressure acceleration.
-Eigen::Vector3d CannonBallRadiationPressureAcceleration::getAcceleration( )
-{
-    return computeCannonBallRadiationPressureAcceleration(
-                currentRadiationPressure_, currentVectorToSource_, currentArea_,
-                currentRadiationPressureCoefficient_, currentMass_ );
-}
-
-//! Update member variables used by the radiation pressure acceleration model.
-void CannonBallRadiationPressureAcceleration::updateMembers( const double currentTime )
-{
-    if( !( this->currentTime_ == currentTime ) )
-    {
-        currentVectorToSource_ = ( sourcePositionFunction_( )
-                                   - acceleratedBodyPositionFunction_( ) ).normalized( );
-        currentRadiationPressure_ = radiationPressureFunction_( );
-        currentRadiationPressureCoefficient_ = radiationPressureCoefficientFunction_( );
-        currentArea_ = areaFunction_( );
-        currentMass_ = massFunction_( );
-    }
-}
-
 } // namespace electro_magnetism
 } // namespace tudat
diff --git a/Tudat/Astrodynamics/ElectroMagnetism/cannonBallRadiationPressureAcceleration.h b/Tudat/Astrodynamics/ElectroMagnetism/cannonBallRadiationPressureAcceleration.h
index ca7c9d4..77b90fb 100644
--- a/Tudat/Astrodynamics/ElectroMagnetism/cannonBallRadiationPressureAcceleration.h
+++ b/Tudat/Astrodynamics/ElectroMagnetism/cannonBallRadiationPressureAcceleration.h
@@ -172,7 +172,12 @@ public:
      * \return Radiation pressure acceleration.
      * \sa computeCannonBallRadiationPressureAcceleration().
      */
-    Eigen::Vector3d getAcceleration( );
+    Eigen::Vector3d getAcceleration( )
+    {
+        return computeCannonBallRadiationPressureAcceleration(
+                    currentRadiationPressure_, currentVectorToSource_, currentArea_,
+                    currentRadiationPressureCoefficient_, currentMass_ );
+    }
 
     //! Update member variables used by the radiation pressure acceleration model.
     /*!
@@ -181,7 +186,28 @@ public:
      * not the function-pointers are then used by the getAcceleration( ) function.
      * \param currentTime Time at which acceleration model is to be updated.
      */
-    void updateMembers( const double currentTime = TUDAT_NAN );
+    void updateMembers( const double currentTime = TUDAT_NAN )
+    {
+        if( !( this->currentTime_ == currentTime ) )
+        {
+            currentVectorToSource_ = ( sourcePositionFunction_( )
+                                       - acceleratedBodyPositionFunction_( ) ).normalized( );
+            currentRadiationPressure_ = radiationPressureFunction_( );
+            currentRadiationPressureCoefficient_ = radiationPressureCoefficientFunction_( );
+            currentArea_ = areaFunction_( );
+            currentMass_ = massFunction_( );
+        }
+    }
+
+    //! Function to retrieve the function pointer returning mass of accelerated body.
+    /*!
+     * Function to retrieve the function pointer returning mass of accelerated body.
+     * \return Function pointer returning mass of accelerated body.
+     */
+    boost::function< double( ) > getMassFunction( )
+    {
+        return massFunction_;
+    }
 
 private:
 
diff --git a/Tudat/Astrodynamics/ElectroMagnetism/radiationPressureInterface.h b/Tudat/Astrodynamics/ElectroMagnetism/radiationPressureInterface.h
index 8d96d9a..b800bea 100644
--- a/Tudat/Astrodynamics/ElectroMagnetism/radiationPressureInterface.h
+++ b/Tudat/Astrodynamics/ElectroMagnetism/radiationPressureInterface.h
@@ -175,6 +175,16 @@ public:
         return radiationPressureCoefficient_;
     }
 
+    //! Function to reset the radiation pressure coefficient of the target body.
+    /*!
+     *  Function to reset the radiation pressure coefficient of the target body.
+     *  \param radiationPressureCoefficient The new radiation pressure coefficient of the target body.
+     */
+    void resetRadiationPressureCoefficient( const double radiationPressureCoefficient )
+    {
+        radiationPressureCoefficient_ = radiationPressureCoefficient;
+    }
+
     //! Function to return the function returning the current total power (in W) emitted by the
     //! source body.
     /*!
diff --git a/Tudat/Astrodynamics/Ephemerides/CMakeLists.txt b/Tudat/Astrodynamics/Ephemerides/CMakeLists.txt
index 10f90e3..406da50 100644
--- a/Tudat/Astrodynamics/Ephemerides/CMakeLists.txt
+++ b/Tudat/Astrodynamics/Ephemerides/CMakeLists.txt
@@ -101,12 +101,10 @@ if(USE_CSPICE)
 add_executable(test_FrameManager "${SRCROOT}${EPHEMERIDESDIR}/UnitTests/unitTestFrameManager.cpp")
 setup_custom_test_program(test_FrameManager "${SRCROOT}${EPHEMERIDESDIR}")
 target_link_libraries(test_FrameManager tudat_ephemerides tudat_reference_frames tudat_input_output tudat_basic_astrodynamics tudat_basic_mathematics ${TUDAT_EXTERNAL_LIBRARIES} ${Boost_LIBRARIES})
-endif()
 
-if(USE_CSPICE)
 add_executable(test_CompositeEphemeris "${SRCROOT}${EPHEMERIDESDIR}/UnitTests/unitTestCompositeEphemeris.cpp")
 setup_custom_test_program(test_CompositeEphemeris "${SRCROOT}${EPHEMERIDESDIR}")
-target_link_libraries(test_CompositeEphemeris tudat_simulation_setup tudat_electro_magnetism tudat_gravitation tudat_ephemerides tudat_reference_frames tudat_aerodynamics tudat_reference_frames tudat_input_output tudat_basic_astrodynamics tudat_basic_mathematics ${TUDAT_EXTERNAL_LIBRARIES} ${Boost_LIBRARIES})
+target_link_libraries(test_CompositeEphemeris ${TUDAT_PROPAGATION_LIBRARIES} ${Boost_LIBRARIES})
 endif()
 
 add_executable(test_KeplerEphemeris "${SRCROOT}${EPHEMERIDESDIR}/UnitTests/unitTestKeplerEphemeris.cpp")
diff --git a/Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestCompositeEphemeris.cpp b/Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestCompositeEphemeris.cpp
index 7e422b9..21fd962 100644
--- a/Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestCompositeEphemeris.cpp
+++ b/Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestCompositeEphemeris.cpp
@@ -67,7 +67,7 @@ BOOST_AUTO_TEST_CASE( testCompositeEphemeris )
     double buffer = 5.0 * maximumTimeStep;
 
     // Create bodies needed in simulation
-    std::map< std::string, boost::shared_ptr< Body > > bodyMap = createBodies(
+    NamedBodyMap bodyMap = createBodies(
                 getDefaultBodySettings( bodyNames,initialEphemerisTime - buffer, finalEphemerisTime + buffer ) );
     setGlobalFrameBodyEphemerides( bodyMap, "SSB", "ECLIPJ2000" );
 
diff --git a/Tudat/Astrodynamics/Gravitation/CMakeLists.txt b/Tudat/Astrodynamics/Gravitation/CMakeLists.txt
index fbcd824..56a8ae2 100644
--- a/Tudat/Astrodynamics/Gravitation/CMakeLists.txt
+++ b/Tudat/Astrodynamics/Gravitation/CMakeLists.txt
@@ -57,6 +57,7 @@ set(GRAVITATION_SOURCES
   "${SRCROOT}${GRAVITATIONDIR}/UnitTests/planetTestData.cpp"
   "${SRCROOT}${GRAVITATIONDIR}/unitConversionsCircularRestrictedThreeBodyProblem.cpp"
   "${SRCROOT}${GRAVITATIONDIR}/tabulatedGravityFieldVariations.cpp"
+  "${SRCROOT}${GRAVITATIONDIR}/mutualSphericalHarmonicGravityModel.cpp"
 )
 
 # Set the header files.
@@ -79,6 +80,7 @@ set(GRAVITATION_HEADERS
   "${SRCROOT}${GRAVITATIONDIR}/unitConversionsCircularRestrictedThreeBodyProblem.h"
   "${SRCROOT}${GRAVITATIONDIR}/UnitTests/planetTestData.h"
   "${SRCROOT}${GRAVITATIONDIR}/tabulatedGravityFieldVariations.h"
+  "${SRCROOT}${GRAVITATIONDIR}/mutualSphericalHarmonicGravityModel.h"
 )
 
 # Add static libraries.
@@ -120,10 +122,15 @@ target_link_libraries(test_SphericalHarmonicsGravityModel tudat_gravitation tuda
 
 add_executable(test_ThirdBodyPerturbation "${SRCROOT}${GRAVITATIONDIR}/UnitTests/unitTestThirdBodyPerturbation.cpp")
 setup_custom_test_program(test_ThirdBodyPerturbation "${SRCROOT}${GRAVITATIONDIR}")
-target_link_libraries(test_ThirdBodyPerturbation tudat_gravitation ${Boost_LIBRARIES} )
+target_link_libraries(test_ThirdBodyPerturbation tudat_gravitation tudat_basic_mathematics ${Boost_LIBRARIES} )
 
 if(USE_CSPICE)
 add_executable(test_GravityFieldVariations "${SRCROOT}${GRAVITATIONDIR}/UnitTests/unitTestGravityFieldVariations.cpp")
 setup_custom_test_program(test_GravityFieldVariations "${SRCROOT}${GRAVITATIONDIR}")
 target_link_libraries(test_GravityFieldVariations tudat_gravitation tudat_basic_mathematics tudat_spice_interface ${SPICE_LIBRARIES} ${Boost_LIBRARIES} )
+
+add_executable(test_MutualSphericalHarmonicsGravityModel "${SRCROOT}${GRAVITATIONDIR}/UnitTests/unitTestMutualSphericalHarmonicAcceleration.cpp")
+setup_custom_test_program(test_MutualSphericalHarmonicsGravityModel "${SRCROOT}${GRAVITATIONDIR}")
+target_link_libraries(test_MutualSphericalHarmonicsGravityModel ${TUDAT_PROPAGATION_LIBRARIES} ${Boost_LIBRARIES})
+
 endif()
diff --git a/Tudat/Astrodynamics/Gravitation/UnitTests/unitTestMutualSphericalHarmonicAcceleration.cpp b/Tudat/Astrodynamics/Gravitation/UnitTests/unitTestMutualSphericalHarmonicAcceleration.cpp
new file mode 100644
index 0000000..ae808c9
--- /dev/null
+++ b/Tudat/Astrodynamics/Gravitation/UnitTests/unitTestMutualSphericalHarmonicAcceleration.cpp
@@ -0,0 +1,313 @@
+#define BOOST_TEST_MAIN
+
+#include <string>
+#include <thread>
+
+#include <boost/test/unit_test.hpp>
+#include <boost/random/uniform_01.hpp>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+#include "Tudat/Basics/testMacros.h"
+
+#include "Tudat/Astrodynamics/Gravitation/thirdBodyPerturbation.h"
+#include "Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.h"
+#include "Tudat/External/SpiceInterface/spiceInterface.h"
+#include "Tudat/InputOutput/basicInputOutput.h"
+#include "Tudat/SimulationSetup/createAccelerationModels.h"
+#include "Tudat/SimulationSetup/createBodies.h"
+#include "Tudat/SimulationSetup/createGravityField.h"
+#include "Tudat/SimulationSetup/defaultBodies.h"
+
+
+namespace tudat
+{
+
+namespace unit_tests
+{
+
+using namespace tudat::spice_interface;
+using namespace tudat::simulation_setup;
+using namespace tudat::gravitation;
+using namespace tudat::basic_astrodynamics;
+using namespace tudat::simulation_setup;
+
+//! Generate (dummy_ spherical harmonic coefficients.
+std::pair< Eigen::MatrixXd, Eigen::MatrixXd > generateCosineSineCoefficients(
+        const int maximumDegree, const int maximumOrder, const int bodyIndex )
+{
+    Eigen::MatrixXd cosineCoefficients = Eigen::MatrixXd::Zero( maximumDegree + 1, maximumOrder + 1 );
+    Eigen::MatrixXd sineCoefficients = Eigen::MatrixXd::Zero( maximumDegree + 1, maximumOrder + 1 );
+
+    cosineCoefficients( 0, 0 ) = 1.0;
+
+    basic_mathematics::GlobalRandomNumberGeneratorType randomNumberGenerator(
+                static_cast< unsigned int >( bodyIndex ) );
+    boost::uniform_01< boost::mt19937> distribution( randomNumberGenerator );
+
+    for( int i = 1; i < maximumDegree + 1; i++ )
+    {
+        for( int j = 0; ( j < maximumOrder + 1 ) && ( j <= i ); j++ )
+        {
+            cosineCoefficients( i, j ) = ( ( distribution( ) > 0.5 ) ? ( 1.0 ): ( -1.0 ) ) * distribution( ) * 1.0E-2;
+            if( j > 0 )
+            {
+                sineCoefficients( i, j ) =  ( ( distribution( ) > 0.5 ) ? ( 1.0 ): ( -1.0 ) ) * distribution( ) * 1.0E-2;
+            }
+
+        }
+    }
+
+    return std::make_pair( cosineCoefficients, sineCoefficients );
+}
+
+//! Generate gravity field object (with severely exagerated magnitude).
+boost::shared_ptr< tudat::simulation_setup::GravityFieldSettings > getDummyJovianSystemGravityField(
+        const std::string& bodyName )
+{
+    boost::shared_ptr< GravityFieldSettings > gravityFieldSettings;
+
+    std::vector< double > randomNumberSettings;
+    randomNumberSettings.push_back( 0.0 );
+    randomNumberSettings.push_back( 1.0E-4 );
+
+    std::pair< Eigen::MatrixXd, Eigen::MatrixXd > coefficients;
+
+    if( bodyName == "Jupiter" )
+    {
+        coefficients = generateCosineSineCoefficients( 10, 10, 0 );
+
+        gravityFieldSettings = boost::make_shared< SphericalHarmonicsGravityFieldSettings >
+                ( getBodyGravitationalParameter( "Jupiter" ), getAverageRadius( "Jupiter" ),
+                  coefficients.first, coefficients.second, "IAU_Jupiter" );
+    }
+    else if( bodyName == "Io" )
+    {
+        coefficients = generateCosineSineCoefficients( 10, 10, 1 );
+
+        gravityFieldSettings = boost::make_shared< SphericalHarmonicsGravityFieldSettings >
+                ( 5.959916033410404E012, 200.0 * getAverageRadius( "Io" ),
+                  coefficients.first, coefficients.second, "IAU_Io" );
+    }
+    else if( bodyName == "Europa" )
+    {
+        coefficients = generateCosineSineCoefficients( 10, 10, 2 );
+
+        gravityFieldSettings = boost::make_shared< SphericalHarmonicsGravityFieldSettings >
+                ( 3.202738774922892E12, 200.0 * getAverageRadius( "Europa" ),
+                  coefficients.first, coefficients.second, "IAU_Europa" );
+    }
+
+    return gravityFieldSettings;
+
+}
+
+
+BOOST_AUTO_TEST_SUITE( test_mutual_spherical_harmonic_gravity )
+
+//! Test mutual spherical harmonic acceleration against manually combined spherical harmonic accelerations.
+//! Note that the size of the Galilean moons, as well as the magnitude of the spherical harmonic coefficients has
+//! been exaggerated to perform a more robust test (i.e ensure that typical errors in implementation are well above
+//! numerical errors).
+BOOST_AUTO_TEST_CASE( testMutualSphericalHarmonicGravity )
+{
+    // Load spice kernels.
+    std::string kernelsPath = input_output::getSpiceKernelPath( );
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de-403-masses.tpc");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "naif0009.tls");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "pck00009.tpc");
+    //spice_interface::loadSpiceKernelInTudat( kernelsPath + "jup230l.bsp");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de421.bsp");
+
+    // Create list of bodies to create.
+    std::vector< std::string > bodyNames;
+    bodyNames.push_back( "Jupiter" );
+    bodyNames.push_back( "Io" );
+    bodyNames.push_back( "Europa" );
+    bodyNames.push_back( "Sun" );
+
+    // Specify initial time
+    double initialTime = 1.0E7;
+    double finalTime = 1.2E7;
+
+    // Get body settings.
+    std::map< std::string, boost::shared_ptr< BodySettings > > bodySettings =
+            getDefaultBodySettings( bodyNames, initialTime, finalTime );
+    bodySettings[ "Jupiter" ]->gravityFieldSettings = getDummyJovianSystemGravityField( "Jupiter" );
+    bodySettings[ "Io" ]->gravityFieldSettings = getDummyJovianSystemGravityField( "Io" );
+    bodySettings[ "Europa" ]->gravityFieldSettings = getDummyJovianSystemGravityField( "Europa" );
+
+    bodySettings[ "Jupiter" ]->ephemerisSettings = boost::make_shared< KeplerEphemerisSettings >(
+                ( basic_mathematics::Vector6d( )<< 778.57E9, 0.0489, 1.3 / 60.0, 0.0, 0.0, 0.0 ).finished( ), 0.0,
+                  getBodyGravitationalParameter( "Sun" ), "Sun", "ECLIPJ2000" );
+    bodySettings[ "Io" ]->ephemerisSettings = boost::make_shared< KeplerEphemerisSettings >(
+                ( basic_mathematics::Vector6d( )<< 421.8E6, 0.004, 0.04 / 60.0, 0.0, 0.0, 0.0 ).finished( ), 0.0,
+                  getBodyGravitationalParameter( "Jupiter" ), "Sun", "ECLIPJ2000" );
+    bodySettings[ "Europa" ]->ephemerisSettings = boost::make_shared< KeplerEphemerisSettings >(
+                ( basic_mathematics::Vector6d( )<< 671.1E6, 0.009, 0.47 / 60.0, 0.0, 0.0, 0.0 ).finished( ), 0.0,
+                  getBodyGravitationalParameter( "Jupiter" ), "Sun", "ECLIPJ2000" );
+
+
+    // Create bodies needed in simulation
+    NamedBodyMap bodyMap = createBodies( bodySettings );
+    setGlobalFrameBodyEphemerides( bodyMap, "SSB", "ECLIPJ2000" );
+
+    // Set current state and rotation of bodies.
+    double currentTime = 1.1E7;
+    bodyMap[ "Jupiter" ]->setCurrentRotationToLocalFrameFromEphemeris( currentTime );
+    bodyMap[ "Jupiter" ]->setStateFromEphemeris( currentTime );
+    bodyMap[ "Io" ]->setCurrentRotationToLocalFrameFromEphemeris( currentTime );
+    bodyMap[ "Io" ]->setStateFromEphemeris( currentTime );
+    bodyMap[ "Europa" ]->setCurrentRotationToLocalFrameFromEphemeris( currentTime );
+    bodyMap[ "Europa" ]->setStateFromEphemeris( currentTime );
+
+    // Retrieve gravity fields.
+    boost::shared_ptr< SphericalHarmonicsGravityField > jupiterGravityField = boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >(
+                ( bodyMap.at( "Jupiter" ) )->getGravityFieldModel( ) );
+    boost::shared_ptr< SphericalHarmonicsGravityField > ioGravityField = boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >(
+                ( bodyMap.at( "Io" ) )->getGravityFieldModel( ) );
+    boost::shared_ptr< SphericalHarmonicsGravityField > europaGravityField = boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >(
+                ( bodyMap.at( "Europa" ) )->getGravityFieldModel( ) );
+
+    // Create central gravity acceleration (mu = Io + Jupiter)
+    boost::shared_ptr< AccelerationSettings > centralGravitySettings = boost::make_shared< AccelerationSettings >( central_gravity );
+    boost::shared_ptr< CentralGravitationalAccelerationModel3d > centralGravity =
+            boost::dynamic_pointer_cast< CentralGravitationalAccelerationModel3d >(
+                createAccelerationModel( bodyMap.at( "Io" ), bodyMap.at( "Jupiter" ), centralGravitySettings, "Io", "Jupiter",
+                                         bodyMap.at( "Jupiter" ), "Jupiter" ) );
+
+    // Calculate central gravity acceleration.
+    centralGravity->updateMembers( );
+    Eigen::Vector3d centralGravityAcceleration = centralGravity->getAcceleration( );
+
+    // Create spherical harmonic gravity of Jupiter on Io, Jupiter-fixed (mu = Io + Jupiter)
+    boost::shared_ptr< AccelerationSettings > sphericalHarmonicGravityOnIoFromJupiterSettings =
+            boost::make_shared< SphericalHarmonicAccelerationSettings >( 7, 7 );
+    boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModel > sphericalHarmonicGravityOnIoFromJupiter =
+            boost::dynamic_pointer_cast< SphericalHarmonicsGravitationalAccelerationModel >(
+                createAccelerationModel(  bodyMap.at( "Io" ), bodyMap.at( "Jupiter" ), sphericalHarmonicGravityOnIoFromJupiterSettings,
+                                          "Io", "Jupiter", bodyMap.at( "Jupiter" ), "Jupiter" ) );
+
+    // Calculate spherical harmonic gravity of Jupiter on Io.
+    sphericalHarmonicGravityOnIoFromJupiter->updateMembers( );
+    Eigen::Vector3d sphericalHarmonicGravityOnIoFromJupiterAcceleration = sphericalHarmonicGravityOnIoFromJupiter->getAcceleration( );
+
+    // Create spherical harmonic gravity of Io on Jupiter, Io-fixed (mu = Io + Jupiter)
+    boost::shared_ptr< AccelerationSettings > sphericalHarmonicGravityOnJupiterFromIoSettings =
+            boost::make_shared< SphericalHarmonicAccelerationSettings >( 2, 2 );
+    boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModel > sphericalHarmonicGravityOnJupiterFromIo =
+            boost::dynamic_pointer_cast< SphericalHarmonicsGravitationalAccelerationModel >(
+                createAccelerationModel( bodyMap.at( "Jupiter" ), bodyMap.at( "Io" ), sphericalHarmonicGravityOnJupiterFromIoSettings,
+                                         "Jupiter", "Io", bodyMap.at( "Io" ), "Io" ) );
+
+    // Calculate spherical harmonic gravity of Io on Jupiter.
+    sphericalHarmonicGravityOnJupiterFromIo->updateMembers( );
+    Eigen::Vector3d sphericalHarmonicGravityOnJupiterFromIoAcceleration = sphericalHarmonicGravityOnJupiterFromIo->getAcceleration( );
+
+    // Create mutual spherical harmonic gravity between Io and Jupiter on Io, Jupiter fixed (mu = Io + Jupiter)
+    boost::shared_ptr< AccelerationSettings > mutualDirectJupiterIoShGravitySettings =
+            boost::make_shared< MutualSphericalHarmonicAccelerationSettings >( 7, 7, 2, 2 );
+    boost::shared_ptr< MutualSphericalHarmonicsGravitationalAccelerationModel > mutualDirectJupiterIoShGravity =
+            boost::dynamic_pointer_cast< MutualSphericalHarmonicsGravitationalAccelerationModel >(
+                createAccelerationModel( bodyMap.at( "Io" ), bodyMap.at( "Jupiter" ), mutualDirectJupiterIoShGravitySettings,
+                                         "Io", "Jupiter", bodyMap.at( "Jupiter" ), "Jupiter" ) );
+
+    // Calculate mutual spherical harmonic gravity between Io and Jupiter on Io.
+    mutualDirectJupiterIoShGravity->updateMembers( );
+    Eigen::Vector3d mutualDirectJupiterIoShGravityAcceleration = mutualDirectJupiterIoShGravity->getAcceleration( );
+
+    // Calculate expected mutual spherical harmonic gravity from sub-accelerations.
+    Eigen::Vector3d expectedAcceleration = -centralGravityAcceleration + sphericalHarmonicGravityOnIoFromJupiterAcceleration -
+            sphericalHarmonicGravityOnJupiterFromIoAcceleration;
+
+    // Test against directly calculated mutual spherical harmonic gravity.
+    for( unsigned int i = 0; i < 3; i++ )
+    {
+        BOOST_CHECK_SMALL( std::fabs( expectedAcceleration( i ) - mutualDirectJupiterIoShGravityAcceleration( i ) ),
+                           10.0 * std::numeric_limits< double >::epsilon( ) * expectedAcceleration.norm( ) );
+    }
+
+    // Create mutual spherical harmonic gravity between Io and Jupiter on Jupiter, Io fixed (mu = Io + Jupiter)
+    boost::shared_ptr< AccelerationSettings > mutualDirectJupiterIoShGravitySettings2 =
+            boost::make_shared< MutualSphericalHarmonicAccelerationSettings >( 2, 2, 7, 7 );
+    boost::shared_ptr< MutualSphericalHarmonicsGravitationalAccelerationModel > mutualDirectJupiterIoShGravity2 =
+            boost::dynamic_pointer_cast< MutualSphericalHarmonicsGravitationalAccelerationModel >(
+                createAccelerationModel( bodyMap.at( "Jupiter" ), bodyMap.at( "Io" ), mutualDirectJupiterIoShGravitySettings2,
+                                         "Jupiter", "Io", bodyMap.at( "Io" ), "Io" ) );
+
+    // Calculate mutual spherical harmonic gravity between Io and Jupiter on Jupiter.
+    mutualDirectJupiterIoShGravity2->updateMembers( );
+    Eigen::Vector3d mutualDirectJupiterIoShGravityAcceleration2 = mutualDirectJupiterIoShGravity2->getAcceleration( );
+
+    expectedAcceleration = centralGravityAcceleration - sphericalHarmonicGravityOnIoFromJupiterAcceleration + sphericalHarmonicGravityOnJupiterFromIoAcceleration;
+
+
+    // Test against directly calculated mutual spherical harmonic gravity.
+    for( unsigned int i = 0; i < 3; i++ )
+    {
+        BOOST_CHECK_SMALL( std::fabs( expectedAcceleration( i ) - mutualDirectJupiterIoShGravityAcceleration2( i ) ),
+                           10.0 * ( std::numeric_limits< double >::epsilon( ) * expectedAcceleration.norm( ) ) );
+    }
+
+    // Test against directly calculated mutual spherical harmonic gravity.
+    for( unsigned int i = 0; i < 3; i++ )
+    {
+        BOOST_CHECK_SMALL( std::fabs( mutualDirectJupiterIoShGravityAcceleration( i ) + mutualDirectJupiterIoShGravityAcceleration2( i ) ),
+                           10.0 * std::numeric_limits< double >::epsilon( ) * mutualDirectJupiterIoShGravityAcceleration.norm( ) );
+    }
+
+
+    // Create 3rd body mutual spherical harmonics between Io and Europa on Europa, Jupiter fixed (mu = Io)
+    boost::shared_ptr< AccelerationSettings > mutualThirdBodyIoOnEuropaShGravitySettings =
+            boost::make_shared< MutualSphericalHarmonicAccelerationSettings >( 2, 2, 4, 4, 7, 7 );
+    boost::shared_ptr< ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel > mutualThirdBodyIoOnEuropaShGravity =
+            boost::dynamic_pointer_cast< ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel >(
+                createAccelerationModel( bodyMap.at( "Europa" ), bodyMap.at( "Io" ), mutualThirdBodyIoOnEuropaShGravitySettings,
+                                         "Europa", "Io", bodyMap.at( "Jupiter" ), "Jupiter" ) );
+
+    // Calculate 3rd body mutual spherical harmonics between Io and Europa on Europa.
+    mutualThirdBodyIoOnEuropaShGravity->updateMembers( );
+    Eigen::Vector3d mutualThirdBodyIoOnEuropaShGravityAcceleration = mutualThirdBodyIoOnEuropaShGravity->getAcceleration( );
+
+
+    // Create mutual spherical harmonics between Io and Europa on Europa, Io fixed (mu = Io + Europa)
+    boost::shared_ptr< MutualSphericalHarmonicsGravitationalAccelerationModel > mutualDirectIoOnEuropaShGravity =
+            boost::dynamic_pointer_cast< MutualSphericalHarmonicsGravitationalAccelerationModel >(
+                createAccelerationModel( bodyMap.at( "Europa" ), bodyMap.at( "Io" ), mutualThirdBodyIoOnEuropaShGravitySettings,
+                                         "Europa", "Io", bodyMap.at( "Io" ), "Io" ) );
+    mutualDirectIoOnEuropaShGravity->updateMembers( );
+    Eigen::Vector3d mutualDirectIoOnEuropaShGravityAcceleration = mutualDirectIoOnEuropaShGravity->getAcceleration( );
+
+    // Get sub accelerations from 3rd body acceleration.
+    Eigen::Vector3d directAccelerationFromThirdBodyModel = mutualThirdBodyIoOnEuropaShGravity->getAccelerationModelForBodyUndergoingAcceleration( )->getAcceleration( );
+    Eigen::Vector3d centralBodyAccelerationFromThirdBodyModel = mutualThirdBodyIoOnEuropaShGravity->getAccelerationModelForCentralBody( )->
+            getAcceleration( );
+
+    for( unsigned int i = 0; i < 3; i++ )
+    {
+        BOOST_CHECK_SMALL(
+                    ( directAccelerationFromThirdBodyModel( i ) -
+                      ( ioGravityField->getGravitationalParameter( ) /
+                        ( ioGravityField->getGravitationalParameter( ) + europaGravityField->getGravitationalParameter( ) ) *
+                        mutualDirectIoOnEuropaShGravityAcceleration( i ) ) ),
+                    ( 10.0 * std::numeric_limits< double >::epsilon( ) * directAccelerationFromThirdBodyModel.norm( ) ) );
+
+        BOOST_CHECK_SMALL(
+                    centralBodyAccelerationFromThirdBodyModel( i ) -
+                    ( ioGravityField->getGravitationalParameter( ) /
+                      ( ioGravityField->getGravitationalParameter( ) + jupiterGravityField->getGravitationalParameter( ) ) *
+                      mutualDirectJupiterIoShGravityAcceleration2( i ) ),
+                    ( 10.0 * std::numeric_limits< double >::epsilon( ) * centralBodyAccelerationFromThirdBodyModel.norm( ) ) );
+
+        BOOST_CHECK_SMALL(
+                    mutualThirdBodyIoOnEuropaShGravityAcceleration( i ) -
+                    ( directAccelerationFromThirdBodyModel( i ) - centralBodyAccelerationFromThirdBodyModel( i ) ),
+                    ( std::numeric_limits< double >::epsilon( ) * mutualThirdBodyIoOnEuropaShGravityAcceleration.norm( ) ) );
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+}
+
+}
diff --git a/Tudat/Astrodynamics/Gravitation/UnitTests/unitTestSphericalHarmonicsGravityModel.cpp b/Tudat/Astrodynamics/Gravitation/UnitTests/unitTestSphericalHarmonicsGravityModel.cpp
index 46c1724..6a000b7 100644
--- a/Tudat/Astrodynamics/Gravitation/UnitTests/unitTestSphericalHarmonicsGravityModel.cpp
+++ b/Tudat/Astrodynamics/Gravitation/UnitTests/unitTestSphericalHarmonicsGravityModel.cpp
@@ -57,6 +57,7 @@
 #include "Tudat/Basics/testMacros.h"
 
 #include "Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h"
+#include "Tudat/Mathematics/BasicMathematics/sphericalHarmonics.h"
 
 namespace tudat
 {
@@ -97,7 +98,8 @@ BOOST_AUTO_TEST_CASE( test_SphericalHarmonicsGravitationalAcceleration_Demo1 )
                 degree,
                 order,
                 cosineCoefficient,
-                sineCoefficient );
+                sineCoefficient,
+                boost::make_shared< basic_mathematics::SphericalHarmonicsCache >( 3, 1 ) );
 
     // Define expected acceleration according to the MATLAB function 'gravitysphericalharmonic'
     // described by Mathworks [2012] [m s^-2].
@@ -140,7 +142,8 @@ BOOST_AUTO_TEST_CASE( test_SphericalHarmonicsGravitationalAcceleration_Demo2 )
                 degree,
                 order,
                 cosineCoefficient,
-                sineCoefficient );
+                sineCoefficient,
+                boost::make_shared< basic_mathematics::SphericalHarmonicsCache >( 3, 2 ) );
 
     // Define expected acceleration according to the MATLAB function 'gravitysphericalharmonic'
     // described by Mathworks [2012] [m s^-2].
@@ -183,7 +186,8 @@ BOOST_AUTO_TEST_CASE( test_SphericalHarmonicsGravitationalAcceleration_Demo3 )
                 degree,
                 order,
                 cosineCoefficient,
-                sineCoefficient );
+                sineCoefficient,
+                boost::make_shared< basic_mathematics::SphericalHarmonicsCache >( 3, 3 ) );
 
     // Define expected acceleration according to the MATLAB function 'gravitysphericalharmonic'
     // described by Mathworks [2012] [m s^-2].
@@ -240,7 +244,8 @@ BOOST_AUTO_TEST_CASE( test_SphericalHarmonicsGravitationalAcceleration_Demo4 )
                 gravitationalParameter,
                 planetaryRadius,
                 cosineCoefficients,
-                sineCoefficients );
+                sineCoefficients,
+                boost::make_shared< basic_mathematics::SphericalHarmonicsCache >( 6, 6 ) );
 
     // Define expected acceleration according to the MATLAB function 'gravitysphericalharmonic'
     // described by Mathworks [2012] [m s^-2].
@@ -294,8 +299,8 @@ BOOST_AUTO_TEST_CASE( test_SphericalHarmonicsGravitationalAccelerationWrapperCla
     const Eigen::Vector3d position( 7.0e6, 8.0e6, 9.0e6 );
 
     // Declare spherical harmonics gravitational acceleration class object.
-    SphericalHarmonicsGravitationalAccelerationModelXdPointer earthGravity
-            = boost::make_shared< SphericalHarmonicsGravitationalAccelerationModelXd >(
+    SphericalHarmonicsGravitationalAccelerationModelPointer earthGravity
+            = boost::make_shared< SphericalHarmonicsGravitationalAccelerationModel >(
                 boost::lambda::constant( position ), gravitationalParameter, planetaryRadius,
                 cosineCoefficients, sineCoefficients );
 
diff --git a/Tudat/Astrodynamics/Gravitation/centralGravityModel.cpp b/Tudat/Astrodynamics/Gravitation/centralGravityModel.cpp
index 35a57a1..e47d18a 100644
--- a/Tudat/Astrodynamics/Gravitation/centralGravityModel.cpp
+++ b/Tudat/Astrodynamics/Gravitation/centralGravityModel.cpp
@@ -60,10 +60,10 @@ Eigen::Vector3d computeGravitationalAcceleration(
         const double gravitationalParameterOfBodyExertingAcceleration,
         const Eigen::Vector3d& positionOfBodyExertingAcceleration )
 {
+    double distance = ( positionOfBodySubjectToAcceleration - positionOfBodyExertingAcceleration ).norm( );
     return -gravitationalParameterOfBodyExertingAcceleration
             * ( positionOfBodySubjectToAcceleration - positionOfBodyExertingAcceleration )
-            / std::pow( ( positionOfBodySubjectToAcceleration
-                          - positionOfBodyExertingAcceleration ).norm( ), 3.0 );
+            / ( distance * distance * distance );
 }
 
 //! Compute gravitational force.
diff --git a/Tudat/Astrodynamics/Gravitation/centralGravityModel.h b/Tudat/Astrodynamics/Gravitation/centralGravityModel.h
index 82c4558..c0a8ce7 100644
--- a/Tudat/Astrodynamics/Gravitation/centralGravityModel.h
+++ b/Tudat/Astrodynamics/Gravitation/centralGravityModel.h
@@ -192,15 +192,21 @@ public:
      * \param aGravitationalParameter A (constant) gravitational parameter [m^2 s^-3].
      * \param positionOfBodyExertingAccelerationFunction Pointer to function returning position of
      *          body exerting gravitational acceleration (default = (0,0,0)).
+     * \param isMutualAttractionUsed Variable denoting whether attraction from body undergoing acceleration on
+     * body exerting acceleration is included (i.e. whether aGravitationalParameter refers to the property
+     * of the body exerting the acceleration, if variable is false, or the sum of the gravitational parameters,
+     * if the variable is true.
      */
     CentralGravitationalAccelerationModel(
             const typename Base::StateFunction positionOfBodySubjectToAccelerationFunction,
             const double aGravitationalParameter,
             const typename Base::StateFunction positionOfBodyExertingAccelerationFunction
-            = boost::lambda::constant( StateMatrix::Zero( ) ) )
+            = boost::lambda::constant( StateMatrix::Zero( ) ),
+            const bool isMutualAttractionUsed = 0 )
         : Base( positionOfBodySubjectToAccelerationFunction,
                 boost::lambda::constant( aGravitationalParameter ),
-                positionOfBodyExertingAccelerationFunction )
+                positionOfBodyExertingAccelerationFunction,
+                isMutualAttractionUsed )
     {
         this->updateMembers( );
     }
@@ -220,15 +226,21 @@ public:
      *          parameter [m^2 s^-3].
      * \param positionOfBodyExertingAccelerationFunction Pointer to function returning position of
      *          body exerting gravitational acceleration (default = (0,0,0)).
+     * \param isMutualAttractionUsed Variable denoting whether attraction from body undergoing acceleration on
+     * body exerting acceleration is included (i.e. whether aGravitationalParameter refers to the property
+     * of the body exerting the acceleration, if variable is false, or the sum of the gravitational parameters,
+     * if the variable is true.
      */
     CentralGravitationalAccelerationModel(
             const typename Base::StateFunction positionOfBodySubjectToAccelerationFunction,
             const boost::function< double( ) > aGravitationalParameterFunction,
             const typename Base::StateFunction positionOfBodyExertingAccelerationFunction
-            = boost::lambda::constant( StateMatrix::Zero( ) ) )
+            = boost::lambda::constant( StateMatrix::Zero( ) ),
+            const bool isMutualAttractionUsed = 0 )
         : Base( positionOfBodySubjectToAccelerationFunction,
                 aGravitationalParameterFunction,
-                positionOfBodyExertingAccelerationFunction )
+                positionOfBodyExertingAccelerationFunction,
+                isMutualAttractionUsed )
     {
         this->updateMembers( );
     }
diff --git a/Tudat/Astrodynamics/Gravitation/centralJ2GravityModel.h b/Tudat/Astrodynamics/Gravitation/centralJ2GravityModel.h
index 460f2ec..f97e7e2 100644
--- a/Tudat/Astrodynamics/Gravitation/centralJ2GravityModel.h
+++ b/Tudat/Astrodynamics/Gravitation/centralJ2GravityModel.h
@@ -137,7 +137,7 @@ public:
             = boost::lambda::constant( Eigen::Vector3d::Zero( ) ) )
         : Base( positionOfBodySubjectToAccelerationFunction,
                 aGravitationalParameter,
-                positionOfBodyExertingAccelerationFunction ),
+                positionOfBodyExertingAccelerationFunction, 0 ),
           equatorialRadius( anEquatorialRadius ),
           j2GravityCoefficient( aJ2GravityCoefficient )
     {
diff --git a/Tudat/Astrodynamics/Gravitation/centralJ2J3GravityModel.h b/Tudat/Astrodynamics/Gravitation/centralJ2J3GravityModel.h
index 9d02f5b..49dc922 100644
--- a/Tudat/Astrodynamics/Gravitation/centralJ2J3GravityModel.h
+++ b/Tudat/Astrodynamics/Gravitation/centralJ2J3GravityModel.h
@@ -142,7 +142,7 @@ public:
             = boost::lambda::constant( Eigen::Vector3d::Zero( ) ) )
         : Base( positionOfBodySubjectToAccelerationFunction,
                 aGravitationalParameter,
-                positionOfBodyExertingAccelerationFunction ),
+                positionOfBodyExertingAccelerationFunction, 0 ),
           equatorialRadius( anEquatorialRadius ),
           j2GravityCoefficient( aJ2GravityCoefficient ),
           j3GravityCoefficient( aJ3GravityCoefficient )
diff --git a/Tudat/Astrodynamics/Gravitation/centralJ2J3J4GravityModel.h b/Tudat/Astrodynamics/Gravitation/centralJ2J3J4GravityModel.h
index 67ecfd7..804155b 100644
--- a/Tudat/Astrodynamics/Gravitation/centralJ2J3J4GravityModel.h
+++ b/Tudat/Astrodynamics/Gravitation/centralJ2J3J4GravityModel.h
@@ -191,7 +191,7 @@ public:
             = boost::lambda::constant( Eigen::Vector3d::Zero( ) ) )
         : Base( positionOfBodySubjectToAccelerationFunction,
                 aGravitationalParameter,
-                positionOfBodyExertingAccelerationFunction ),
+                positionOfBodyExertingAccelerationFunction, 0 ),
           equatorialRadius( anEquatorialRadius ),
           j2GravityCoefficient( aJ2GravityCoefficient ),
           j3GravityCoefficient( aJ3GravityCoefficient ),
diff --git a/Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.cpp b/Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.cpp
new file mode 100644
index 0000000..4719ee2
--- /dev/null
+++ b/Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.cpp
@@ -0,0 +1,20 @@
+#include "Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.h"
+
+namespace tudat
+{
+
+namespace gravitation
+{
+
+//! Function to manually remove the C(0,0) term from cosine coefficients,
+Eigen::MatrixXd setDegreeAndOrderCoefficientToZero(
+        const boost::function< Eigen::MatrixXd( ) > originalCosineCoefficientFunction )
+{
+    Eigen::MatrixXd newCoefficients = originalCosineCoefficientFunction( );
+    newCoefficients( 0, 0 ) = 0.0;
+    return newCoefficients;
+}
+
+}
+
+}
diff --git a/Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.h b/Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.h
new file mode 100644
index 0000000..96b5d7f
--- /dev/null
+++ b/Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.h
@@ -0,0 +1,257 @@
+#ifndef MUTUALSPHERICALHARMONICGRAVITYMODEL_H
+#define MUTUALSPHERICALHARMONICGRAVITYMODEL_H
+
+
+#include <boost/function.hpp>
+#include <boost/lambda/lambda.hpp>
+#include <boost/shared_ptr.hpp>
+#include <boost/bind.hpp>
+#include <boost/make_shared.hpp>
+
+#include <Eigen/Core>
+#include <Eigen/Geometry>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
+#include "Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModelBase.h"
+#include "Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h"
+#include "Tudat/Mathematics/BasicMathematics/legendrePolynomials.h"
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+
+namespace tudat
+{
+
+namespace gravitation
+{
+
+//! Function to manually remove the C(0,0) term from cosine coefficients,
+/*!
+ *  Function to manually remove the C(0,0) term from cosine coefficients, used by
+ *  MutualSphericalHarmonicsGravitationalAccelerationModel. By using this function, the original function returning the sh
+ *  coefficients is left untouched, not compromising the environment  model, while the C(0,0) term is not calculated doubly
+ *  by the MutualSphericalHarmonicsGravitationalAccelerationModel class.
+ */
+Eigen::MatrixXd setDegreeAndOrderCoefficientToZero( const boost::function< Eigen::MatrixXd( ) > originalCosineCoefficientFunction );
+
+//! Class to calculate the mutual spherical harmonic gravitational acceleration between two bodies.
+/*!
+ *  Class to calculate the mutual spherical harmonic gravitational acceleration between two extended bodies A and B.
+ *  The calculations include the interaction of the point masses A and B, extended body A and point mass B, as well as
+ *  extended bodyB and point mass A.  As an example, the model can be used for precise calculations of the dynamics of
+ *  planetary system (Earth-Moon, Mars-Phoboss-Deimos, Jupiter-Galilean satellites).
+ *  Model is taken from Lainey et al. (2001, 2004)
+ */
+class MutualSphericalHarmonicsGravitationalAccelerationModel
+        : public basic_astrodynamics::AccelerationModel< Eigen::Vector3d >
+{
+private:
+
+    //! Typedef for coefficient-matrix-returning function.
+    typedef boost::function< Eigen::MatrixXd( ) > CoefficientMatrixReturningFunction;
+
+    //! Typedef for function returning body position.
+    typedef boost::function< Eigen::Vector3d( ) > StateFunction;
+
+    //! Typedef for function returning gravitational parameter.
+    typedef boost::function< double( ) > DataReturningFunction;
+
+public:
+
+    //! Constructor.
+    /*!
+     *  Constructor, provides the position functions of the involved bodies, and the required data on their gravitational
+     * fields.
+     *  \param positionOfBodySubjectToAccelerationFunction Function returning the current position of the body undergoing
+     *  the acceleration.
+     *  \param positionOfBodyExertingAccelerationFunction Function returning the current position of the body exerting
+     *  the acceleration.
+     *  \param gravitationalParameterFunction Function returning the current gravitational parameter, either of the body
+     *  exerting the acceleration or the sum of that of both bodies, depending on value of useCentralBodyFixedFrame,
+     *  (false for former, true for latter).
+     *  \param equatorialRadiusOfBodyExertingAcceleration Equatorial radius used in representation of spherical harmonic
+     *  coefficients of body exerting acceleration.
+     *  \param equatorialRadiusOfBodyUndergoingAcceleration Equatorial radius used in representation of spherical harmonic
+     *  coefficients of body undergoing acceleration.
+     *  \param cosineHarmonicCoefficientsFunctionOfBodyExertingAcceleration Function returning the spherical harmonic cosine
+     *  coefficients of the body exerting the acceleration.
+     *  \param sineHarmonicCoefficientsFunctionOfBodyExertingAcceleration Function returning the spherical harmonic sine
+     *  coefficients of  the body exerting the acceleration.
+     *  \param cosineHarmonicCoefficientsFunctionOfBodyUndergoingAcceleration Function returning the spherical harmonic
+     *  cosine coefficients of the body undergoing the acceleration.
+     *  \param sineHarmonicCoefficientsFunctionOfBodyUndergoingAcceleration Function returning the spherical harmonic
+     *  sine coefficients of the body undergoing the acceleration.
+     *  \param toLocalFrameOfBodyExertingAccelerationTransformation Function returning the quaternion to rotate from the
+     *  body-fixed frame of  the body exerting the acceleration, in  which the spherical harmonic coefficients are defined,
+     *  to the inertially oriented frame, in which the acceleration is expressed.
+     *  \param toLocalFrameOfBodyUndergoingAccelerationTransformation Function returning the quaternion to rotate from the
+     *  body-fixed frame of the body undergoing the acceleration, in  which the spherical harmonic coefficients are defined,
+     *  to the inertially oriented frame, in which the acceleration is expressed.
+     *  \param useCentralBodyFixedFrame Boolean denoting whether the acceleration is expressed in a frame centered on the
+     *  body exerting the acceleration, in which case the gravitational parameter that is used is the some of the
+     *  gravitational parameters of both bodies, to take into  account the inertial acceleration of the reference frame in
+     *  which the acceleration is performed.
+     *  \param sphericalHarmonicsCacheOfBodyExertingAcceleration Caching object for computation of spherical harmonic
+     *  potential (gradient) of body exerting acceleration.
+     *  *  \param sphericalHarmonicsCacheOfBodyUndergoingAcceleration Caching object for computation of spherical harmonic
+     *  potential (gradient) of body undergoing acceleration.
+     */
+    MutualSphericalHarmonicsGravitationalAccelerationModel(
+            const StateFunction& positionOfBodySubjectToAccelerationFunction,
+            const StateFunction& positionOfBodyExertingAccelerationFunction,
+            const DataReturningFunction& gravitationalParameterFunction,
+            const double equatorialRadiusOfBodyExertingAcceleration,
+            const double equatorialRadiusOfBodyUndergoingAcceleration,
+            const CoefficientMatrixReturningFunction& cosineHarmonicCoefficientsFunctionOfBodyExertingAcceleration,
+            const CoefficientMatrixReturningFunction& sineHarmonicCoefficientsFunctionOfBodyExertingAcceleration,
+            const CoefficientMatrixReturningFunction& cosineHarmonicCoefficientsFunctionOfBodyUndergoingAcceleration,
+            const CoefficientMatrixReturningFunction& sineHarmonicCoefficientsFunctionOfBodyUndergoingAcceleration,
+            const boost::function< Eigen::Quaterniond( ) >& toLocalFrameOfBodyExertingAccelerationTransformation,
+            const boost::function< Eigen::Quaterniond( ) >& toLocalFrameOfBodyUndergoingAccelerationTransformation,
+            const bool useCentralBodyFixedFrame,
+            boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache >
+            sphericalHarmonicsCacheOfBodyExertingAcceleration =
+            boost::make_shared< basic_mathematics::SphericalHarmonicsCache >( ),
+            boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache >
+            sphericalHarmonicsCacheOfBodyUndergoingAcceleration =
+            boost::make_shared< basic_mathematics::SphericalHarmonicsCache >( ) ):
+        useCentralBodyFixedFrame_( useCentralBodyFixedFrame ),
+        gravitationalParameterFunction_( gravitationalParameterFunction )
+    {
+
+        // Create spherical harmonic acceleration due to expansion of body exerting acceleration
+        accelerationModelFromShExpansionOfBodyExertingAcceleration_ = boost::make_shared<
+                SphericalHarmonicsGravitationalAccelerationModel >(
+                    positionOfBodySubjectToAccelerationFunction, gravitationalParameterFunction,
+                    equatorialRadiusOfBodyExertingAcceleration,
+                    cosineHarmonicCoefficientsFunctionOfBodyExertingAcceleration,
+                    sineHarmonicCoefficientsFunctionOfBodyExertingAcceleration,
+                    positionOfBodyExertingAccelerationFunction,
+                    toLocalFrameOfBodyExertingAccelerationTransformation,
+                    useCentralBodyFixedFrame, sphericalHarmonicsCacheOfBodyExertingAcceleration );
+
+        // Create spherical harmonic acceleration due to expansion of body undergoing acceleration, with the C(0,0) term set
+        // to zero to prevent the double computation of the central term. Note that the order of the position functions is
+        // switched wrt the regular input, to ensure that the acceleration vector points in the right direction
+        // (i.e. from body undergoing to body exerting acceleration).
+        accelerationModelFromShExpansionOfBodyundergoingAcceleration_ = boost::make_shared<
+                SphericalHarmonicsGravitationalAccelerationModel >(
+                    positionOfBodyExertingAccelerationFunction, gravitationalParameterFunction,
+                    equatorialRadiusOfBodyUndergoingAcceleration,
+                    boost::bind( &setDegreeAndOrderCoefficientToZero,
+                                 cosineHarmonicCoefficientsFunctionOfBodyUndergoingAcceleration ),
+                    sineHarmonicCoefficientsFunctionOfBodyUndergoingAcceleration,
+                    positionOfBodySubjectToAccelerationFunction,
+                    toLocalFrameOfBodyUndergoingAccelerationTransformation,
+                    useCentralBodyFixedFrame, sphericalHarmonicsCacheOfBodyUndergoingAcceleration );
+    }
+
+    //! Update member variables used by the acceleration model.
+    /*!
+     *  Update member variables used by the two constituent sh acceleration models.
+     */
+    virtual void updateMembers( const double currentTime = TUDAT_NAN )
+    {
+        accelerationModelFromShExpansionOfBodyExertingAcceleration_->updateMembers( currentTime );
+        accelerationModelFromShExpansionOfBodyundergoingAcceleration_->updateMembers( currentTime );
+        this->currentTime_ = currentTime;
+    }
+
+    //! Function to reset the current time
+    /*!
+     * Function to reset the current time of the acceleration model.
+     * \param currentTime Current time (default NaN).
+     */
+    virtual void resetTime( const double currentTime = TUDAT_NAN )
+    {
+        currentTime_ = currentTime;
+
+        accelerationModelFromShExpansionOfBodyExertingAcceleration_->resetTime( currentTime );
+        accelerationModelFromShExpansionOfBodyundergoingAcceleration_->resetTime( currentTime );
+    }
+
+    //! Function to get the mutual sh acceleration value.
+    /*!
+     *  Function to get the mutual sh acceleration value, determined from the sum of the two constituent acceleration models.
+     */
+    Eigen::Vector3d getAcceleration( )
+    {
+        return accelerationModelFromShExpansionOfBodyExertingAcceleration_->getAcceleration( ) -
+                accelerationModelFromShExpansionOfBodyundergoingAcceleration_->getAcceleration( );
+    }
+
+    //! Function returning whether the acceleration is expressed in a frame centered on the body exerting the acceleration.
+    /*!
+     *  Function returning whether the acceleration is expressed in a frame centered on the body exerting the acceleration.
+     */
+    bool getUseCentralBodyFixedFrame( )
+    {
+        return useCentralBodyFixedFrame_;
+    }
+
+    //! Function to return the function returning the relevant gravitational parameter.
+    /*!
+     * Function to return the function returning the relevant gravitational parameter.
+     * \return Function returning the gravitational parameter used in the computations.
+     */
+    DataReturningFunction getGravitationalParameterFunction( )
+    {
+        return gravitationalParameterFunction_;
+    }
+
+    //! Function returning the object calculating spherical harmonic acceleration due to the body exerting acceleration
+    /*!
+     *  Function returning the object calculating spherical harmonic acceleration due to the body exerting acceleration
+     */
+    boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModel >
+    getAccelerationModelFromShExpansionOfBodyExertingAcceleration( )
+    {
+        return accelerationModelFromShExpansionOfBodyExertingAcceleration_;
+    }
+
+    //! Function returning the object calculating spherical harmonic acceleration due to the body undergoing acceleration
+    /*!
+     *  Function returning the object calculating spherical harmonic acceleration due to the body undergoing acceleration
+     */
+    boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModel >
+    getAccelerationModelFromShExpansionOfBodyUndergoingAcceleration( )
+    {
+        return accelerationModelFromShExpansionOfBodyundergoingAcceleration_;
+    }
+
+protected:
+
+    //! Boolean denoting whether the acceleration is expressed in a frame centered on the body exerting the acceleration
+    /*!
+     *  Boolean denoting whether the acceleration is expressed in a frame centered on the body exerting the acceleration,
+     *  in which case the gravitational parameter that is used is the some of the gravitational parameters of both bodies,
+     *  to take into  account the inertial acceleration of the reference frame in which the acceleration is performed.
+     */
+    bool useCentralBodyFixedFrame_;
+
+    //! Function returning the gravitational parameter used for both spherical harmonic accelerations.
+    DataReturningFunction gravitationalParameterFunction_;
+
+    //! Object calculating spherical harmonic acceleration due to the body exerting acceleration
+    /*!
+     *  Object calculating spherical harmonic acceleration due to the body exerting acceleration
+     */
+    boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModel >
+    accelerationModelFromShExpansionOfBodyExertingAcceleration_;
+
+    //! Object calculating spherical harmonic acceleration due to the body undergoing acceleration
+    /*!
+     *  Object calculating spherical harmonic acceleration due to the body undergoing acceleration, as felt by the body
+     *  undergoing the acceleration due to the figure-point mass coupling between the body undergoing and the body
+     *  exerting the acceleration. Note that this acceleration has no central-central term (i.e. C(0,0) is set to zero),
+     *  as this term is only calculated by accelerationModelFromShExpansionOfBodyExertingAcceleration_.
+     */
+    boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModel >
+    accelerationModelFromShExpansionOfBodyundergoingAcceleration_;
+
+
+};
+
+}
+
+}
+
+#endif // MUTUALSPHERICALHARMONICGRAVITYMODEL_H
diff --git a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.cpp b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.cpp
index f038a95..c3a2cf0 100644
--- a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.cpp
+++ b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.cpp
@@ -51,7 +51,7 @@
 
 #include "Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.h"
 #include "Tudat/Mathematics/BasicMathematics/coordinateConversions.h"
-
+#include "Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.h"
 namespace tudat
 {
 
@@ -61,8 +61,11 @@ namespace gravitation
 //! Function to calculate the gravitational potential from a spherical harmonic field expansion.
 double calculateSphericalHarmonicGravitationalPotential(
         const Eigen::Vector3d& bodyFixedPosition, const double gravitationalParameter,
-        const double referenceRadius, const Eigen::MatrixXd& cosineCoefficients,
-        const Eigen::MatrixXd& sineCoefficients, const int minimumumDegree,
+        const double referenceRadius,
+        const Eigen::MatrixXd& cosineCoefficients,
+        const Eigen::MatrixXd& sineCoefficients,
+        boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache > sphericalHarmonicsCache,
+        const int minimumumDegree,
         const int minimumumOrder )
 {
     // Initialize (distance/reference radius)^n (n=ratioToPowerDegree)
@@ -91,9 +94,12 @@ double calculateSphericalHarmonicGravitationalPotential(
     else
     {
         startDegree = minimumumDegree;
-        ratioToPowerDegree *= std::pow( radiusRatio, startDegree - 1 );
+        ratioToPowerDegree *= basic_mathematics::raiseToIntegerPower< double >( radiusRatio, startDegree - 1 );
     }
 
+    basic_mathematics::LegendreCache& legendreCacheReference = *sphericalHarmonicsCache->getLegendreCache( );
+    legendreCacheReference.update( std::sin( latitude ) );
+
     // Iterate over all degrees
     for( int degree = startDegree; degree < cosineCoefficients.rows( ); degree++ )
     {
@@ -105,7 +111,7 @@ double calculateSphericalHarmonicGravitationalPotential(
         {
             // Calculate legendre polynomial (geodesy-normalized) at current degree and order
             legendrePolynomial = basic_mathematics::computeGeodesyLegendrePolynomial(
-                        degree, order, std::sin( latitude ) );
+                        degree, order, legendreCacheReference );
 
             // Calculate contribution to potential from current degree and order
             singleDegreeTerm += legendrePolynomial * ( cosineCoefficients( degree, order ) *
diff --git a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.h b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.h
index a36dc33..0132092 100644
--- a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.h
+++ b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.h
@@ -79,6 +79,8 @@ namespace gravitation
  *  \param referenceRadius Reference radius of spherical harmonic field expansion.
  *  \param cosineCoefficients Cosine spherical harmonic coefficients (geodesy normalized).
  *  \param sineCoefficients Sine spherical harmonic coefficients (geodesy normalized).
+ *  \param sphericalHarmonicsCache Cache object containing current values of trigonometric funtions of latitude anf longitude,
+ *  as well as legendre polynomials at current state.
  *  \param minimumumDegree Maximum degree of spherical harmonic expansion.
  *  \param minimumumOrder Maximum order of spherical harmonic expansion.
 
@@ -88,6 +90,7 @@ double calculateSphericalHarmonicGravitationalPotential(
         const Eigen::Vector3d& bodyFixedPosition, const double gravitationalParameter,
         const double referenceRadius,
         const Eigen::MatrixXd& cosineCoefficients, const Eigen::MatrixXd& sineCoefficients,
+        boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache > sphericalHarmonicsCache,
         const int minimumumDegree = 0, const int minimumumOrder = 0 );
 
 //! Class to represent a spherical harmonic gravity field expansion.
@@ -118,7 +121,11 @@ public:
         : GravityFieldModel( gravitationalParameter ), referenceRadius_( referenceRadius ),
           cosineCoefficients_( cosineCoefficients ), sineCoefficients_( sineCoefficients ),
           fixedReferenceFrame_( fixedReferenceFrame )
-    { }
+    {
+        sphericalHarmonicsCache_ = boost::make_shared< basic_mathematics::SphericalHarmonicsCache >( );
+        sphericalHarmonicsCache_->resetMaximumDegreeAndOrder( cosineCoefficients_.rows( ) + 1,
+                                                              cosineCoefficients_.cols( ) + 1 );
+    }
 
     //! Virtual destructor.
     /*!
@@ -263,6 +270,7 @@ public:
                     bodyFixedPosition, gravitationalParameter_, referenceRadius_,
                     cosineCoefficients_.block( 0, 0, maximumDegree + 1, maximumOrder + 1 ),
                     sineCoefficients_.block( 0, 0, maximumDegree + 1, maximumOrder + 1 ),
+                    sphericalHarmonicsCache_,
                     minimumDegree, minimumOrder );
     }
 
@@ -277,7 +285,7 @@ public:
     Eigen::Vector3d getGradientOfPotential( const Eigen::Vector3d& bodyFixedPosition )
     {
         return getGradientOfPotential( bodyFixedPosition, cosineCoefficients_.rows( ),
-                                          sineCoefficients_.cols( ) );
+                                       sineCoefficients_.cols( ) );
     }
 
     //! Get the gradient of the potential.
@@ -289,13 +297,13 @@ public:
      *  \return Gradient of potential.
      */
     Eigen::Vector3d getGradientOfPotential( const Eigen::Vector3d& bodyFixedPosition,
-                                                    const double maximumDegree,
-                                                    const double maximumOrder )
+                                            const double maximumDegree,
+                                            const double maximumOrder )
     {
         return computeGeodesyNormalizedGravitationalAccelerationSum(
                     bodyFixedPosition, gravitationalParameter_, referenceRadius_,
                     cosineCoefficients_.block( 0, 0, maximumDegree, maximumOrder ),
-                    sineCoefficients_.block( 0, 0, maximumDegree, maximumOrder ) );
+                    sineCoefficients_.block( 0, 0, maximumDegree, maximumOrder ), sphericalHarmonicsCache_ );
     }
 
     //! Function to retrieve the tdentifier for body-fixed reference frame
@@ -333,6 +341,9 @@ protected:
      *  Identifier for body-fixed reference frame
      */
     std::string fixedReferenceFrame_;
+
+    //! Cache object for potential calculations.
+    boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache > sphericalHarmonicsCache_;
 };
 
 } // namespace gravitation
diff --git a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.cpp b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.cpp
index 88cbd4a..391218c 100644
--- a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.cpp
+++ b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.cpp
@@ -64,7 +64,8 @@ Eigen::Vector3d computeGeodesyNormalizedGravitationalAccelerationSum(
         const double gravitationalParameter,
         const double equatorialRadius,
         const Eigen::MatrixXd& cosineHarmonicCoefficients,
-        const Eigen::MatrixXd& sineHarmonicCoefficients )
+        const Eigen::MatrixXd& sineHarmonicCoefficients,
+        boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache > sphericalHarmonicsCache )
 {
     // Set highest degree and order.
     const int highestDegree = cosineHarmonicCoefficients.rows( );
@@ -111,6 +112,13 @@ Eigen::Vector3d computeGeodesyNormalizedGravitationalAccelerationSum(
     // Compute longitude coordinate.
     sphericalpositionOfBodySubjectToAcceleration( 2 ) = cylindricalCoordinates( 1 );
 
+    double sineOfAngle = std::sin( sphericalpositionOfBodySubjectToAcceleration( 1 ) );
+    sphericalHarmonicsCache->update( sphericalpositionOfBodySubjectToAcceleration( 0 ),
+                                     sineOfAngle,
+                                     sphericalpositionOfBodySubjectToAcceleration( 2 ),
+                                     equatorialRadius );
+    basic_mathematics::LegendreCache& legendreCacheReference = *( sphericalHarmonicsCache->getLegendreCache( ) );
+
     // Compute gradient premultiplier.
     const double preMultiplier = gravitationalParameter / equatorialRadius;
 
@@ -121,35 +129,32 @@ Eigen::Vector3d computeGeodesyNormalizedGravitationalAccelerationSum(
     for ( int degree = 0; degree < highestDegree; degree++ )
     {
         // Loop through all orders.
-        for ( int order = 0; order <= degree && order < highestOrder; order++ )
+        for ( int order = 0; ( order <= degree ) && ( order < highestOrder ); order++ )
         {
             // Compute geodesy-normalized Legendre polynomials.
             const double legendrePolynomial = basic_mathematics::computeGeodesyLegendrePolynomial(
-                        degree, order,
-                        std::sin( sphericalpositionOfBodySubjectToAcceleration( 1 ) ) );
+                        degree, order, legendreCacheReference );
             const double incrementedLegendrePolynomial =
                     basic_mathematics::computeGeodesyLegendrePolynomial(
-                        degree, order + 1,
-                        std::sin( sphericalpositionOfBodySubjectToAcceleration( 1 ) ) );
+                        degree, order + 1, legendreCacheReference );
 
             // Compute geodesy-normalized Legendre polynomial derivative.
             const double legendrePolynomialDerivative =
                     basic_mathematics::computeGeodesyLegendrePolynomialDerivative(
                         degree, order,
-                        std::sin( sphericalpositionOfBodySubjectToAcceleration( 1 ) ),
+                        sineOfAngle,
                         legendrePolynomial, incrementedLegendrePolynomial );
 
             // Compute the potential gradient of a single spherical harmonic term.
             sphericalGradient += basic_mathematics::computePotentialGradient(
                         sphericalpositionOfBodySubjectToAcceleration,
-                        equatorialRadius,
                         preMultiplier,
                         degree,
                         order,
                         cosineHarmonicCoefficients( degree, order ),
                         sineHarmonicCoefficients( degree, order ),
                         legendrePolynomial,
-                        legendrePolynomialDerivative );
+                        legendrePolynomialDerivative, sphericalHarmonicsCache );
         }
     }
 
@@ -167,7 +172,8 @@ Eigen::Vector3d computeSingleGeodesyNormalizedGravitationalAcceleration(
         const int degree,
         const int order,
         const double cosineHarmonicCoefficient,
-        const double sineHarmonicCoefficient )
+        const double sineHarmonicCoefficient,
+        boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache > sphericalHarmonicsCache )
 {
     // Declare spherical position vector.
     Eigen::Vector3d sphericalpositionOfBodySubjectToAcceleration;
@@ -210,35 +216,41 @@ Eigen::Vector3d computeSingleGeodesyNormalizedGravitationalAcceleration(
     // Compute longitude coordinate.
     sphericalpositionOfBodySubjectToAcceleration( 2 ) = cylindricalCoordinates( 1 );
 
+
+    double sineOfAngle = std::sin( sphericalpositionOfBodySubjectToAcceleration( 1 ) );
+    sphericalHarmonicsCache->update( sphericalpositionOfBodySubjectToAcceleration( 0 ),
+                                     sineOfAngle,
+                                     sphericalpositionOfBodySubjectToAcceleration( 2 ),
+                                     equatorialRadius );
+    basic_mathematics::LegendreCache& legendreCacheReference = *( sphericalHarmonicsCache->getLegendreCache( ) );
+
     // Compute gradient premultiplier.
     const double preMultiplier = gravitationalParameter / equatorialRadius;
 
     // Compute geodesy-normalized Legendre polynomials.
     const double legendrePolynomial = basic_mathematics::computeGeodesyLegendrePolynomial(
-                degree, order, std::sin( sphericalpositionOfBodySubjectToAcceleration( 1 ) ) );
+                degree, order, legendreCacheReference );
     const double incrementedLegendrePolynomial =
             basic_mathematics::computeGeodesyLegendrePolynomial(
-                degree, order + 1,
-                std::sin( sphericalpositionOfBodySubjectToAcceleration( 1 ) ) );
+                degree, order + 1,  legendreCacheReference );
 
-    // Compute geodesy-normalized Legendre polynomial derivative.
+    // Compute geodesy-normalized Legendre polynomial derivative.x
     const double legendrePolynomialDerivative =
             basic_mathematics::computeGeodesyLegendrePolynomialDerivative(
                 degree, order,
-                std::sin( sphericalpositionOfBodySubjectToAcceleration( 1 ) ), legendrePolynomial,
+                sineOfAngle, legendrePolynomial,
                 incrementedLegendrePolynomial );
 
     // Compute the potential gradient resulting from the spherical harmonic term.
     const Eigen::Vector3d sphericalGradient = basic_mathematics::computePotentialGradient(
                 sphericalpositionOfBodySubjectToAcceleration,
-                equatorialRadius,
                 preMultiplier,
                 degree,
                 order,
                 cosineHarmonicCoefficient,
                 sineHarmonicCoefficient,
                 legendrePolynomial,
-                legendrePolynomialDerivative );
+                legendrePolynomialDerivative, sphericalHarmonicsCache );
 
     // Convert from spherical gradient to Cartesian gradient (which equals acceleration vector),
     // and return resulting acceleration vector.
diff --git a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h
index c965473..029cb87 100644
--- a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h
+++ b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h
@@ -44,17 +44,19 @@
 #ifndef TUDAT_SPHERICAL_HARMONICS_GRAVITY_MODEL_H
 #define TUDAT_SPHERICAL_HARMONICS_GRAVITY_MODEL_H
 
-#include <stdexcept>
+#include <iomanip>
 
 #include <boost/function.hpp>
 #include <boost/lambda/lambda.hpp>
 #include <boost/shared_ptr.hpp>
+#include <boost/make_shared.hpp>
 
 #include <Eigen/Core>
 #include <Eigen/Geometry>
 
 #include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
 #include "Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModelBase.h"
+#include "Tudat/Mathematics/BasicMathematics/sphericalHarmonics.h"
 
 namespace tudat
 {
@@ -88,15 +90,17 @@ namespace gravitation
  *          position( 0 ) = x coordinate [m],
  *          position( 1 ) = y coordinate [m],
  *          position( 2 ) = z coordinate [m].
+ * \param gravitationalParameter Gravitational parameter associated with the spherical harmonics
+ *          [m^3 s^-2].
+ * \param equatorialRadius Reference radius of the spherical harmonics [m].
  * \param cosineHarmonicCoefficients Matrix with <B>geodesy-normalized</B> cosine harmonic
  *          coefficients. The row index indicates the degree and the column index indicates the order
  *          of coefficients.
  * \param sineHarmonicCoefficients Matrix with <B>geodesy-normalized</B> sine harmonic coefficients.
  *          The row index indicates the degree and the column index indicates the order of
  *          coefficients. The matrix must be equal in size to cosineHarmonicCoefficients.
- * \param gravitationalParameter Gravitational parameter associated with the spherical harmonics
- *          [m^3 s^-2].
- * \param equatorialRadius Reference radius of the spherical harmonics [m].
+ * \param sphericalHarmonicsCache Cache object for computing/retrieving repeated terms in spherical harmonics potential
+ *          gradient calculation.
  * \return Cartesian acceleration vector resulting from the summation of all harmonic terms.
  *           The order is important!
  *           acceleration( 0 ) = x acceleration [m s^-2],
@@ -108,7 +112,8 @@ Eigen::Vector3d computeGeodesyNormalizedGravitationalAccelerationSum(
         const double gravitationalParameter,
         const double equatorialRadius,
         const Eigen::MatrixXd& cosineHarmonicCoefficients,
-        const Eigen::MatrixXd& sineHarmonicCoefficients );
+        const Eigen::MatrixXd& sineHarmonicCoefficients,
+        boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache > sphericalHarmonicsCache );
 
 //! Compute gravitational acceleration due to single spherical harmonics term.
 /*!
@@ -137,12 +142,14 @@ Eigen::Vector3d computeGeodesyNormalizedGravitationalAccelerationSum(
  *          position( 2 ) = z coordinate [m].
  * \param degree Degree of the harmonic term.
  * \param order Order of the harmonic term.
- * \param cosineHarmonicCoefficient <B>Geodesy-normalized</B> cosine harmonic
+ *  * \param cosineHarmonicCoefficient <B>Geodesy-normalized</B> cosine harmonic
  *          coefficient.
  * \param sineHarmonicCoefficient <B>Geodesy-normalized</B> sine harmonic coefficient.
  * \param gravitationalParameter Gravitational parameter associated with the spherical harmonic
  *          [m^3 s^-2].
  * \param equatorialRadius Reference radius of the spherical harmonic [m].
+ * \param sphericalHarmonicsCache Cache object for computing/retrieving repeated terms in spherical harmonics potential
+ *          gradient calculation.
  * \return Cartesian acceleration vector resulting from the spherical harmonic term.
  *           The order is important!
  *           acceleration( 0 ) = x acceleration [m s^-2],
@@ -156,7 +163,8 @@ Eigen::Vector3d computeSingleGeodesyNormalizedGravitationalAcceleration(
         const int degree,
         const int order,
         const double cosineHarmonicCoefficient,
-        const double sineHarmonicCoefficient );
+        const double sineHarmonicCoefficient,
+        boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache > sphericalHarmonicsCache );
 
 //! Template class for general spherical harmonics gravitational acceleration model.
 /*!
@@ -165,10 +173,7 @@ Eigen::Vector3d computeSingleGeodesyNormalizedGravitationalAcceleration(
  * (Heiskanen & Moritz, 1967), implemented in the
  * computeGeodesyNormalizedGravitationalAccelerationSum() function. The acceleration computed is a
  * sum, based on the matrix of coefficients of the model provided.
- * \tparam CoefficientMatrixType Data type for cosine and sine coefficients in spherical harmonics
- *         expansion; may be used for compile-time definition of maximum degree and order.
  */
-template< typename CoefficientMatrixType = Eigen::MatrixXd >
 class SphericalHarmonicsGravitationalAccelerationModel
         : public basic_astrodynamics::AccelerationModel< Eigen::Vector3d >,
         public SphericalHarmonicsGravitationalAccelerationModelBase< Eigen::Vector3d >
@@ -179,7 +184,7 @@ private:
     typedef SphericalHarmonicsGravitationalAccelerationModelBase< Eigen::Vector3d > Base;
 
     //! Typedef for coefficient-matrix-returning function.
-    typedef boost::function< CoefficientMatrixType( ) > CoefficientMatrixReturningFunction;
+    typedef boost::function< Eigen::MatrixXd( ) > CoefficientMatrixReturningFunction;
 
 public:
 
@@ -205,28 +210,43 @@ public:
      *          body exerting gravitational acceleration (default = (0,0,0)).
      * \param rotationFromBodyFixedToIntegrationFrameFunction Function providing the rotation from
      * body-fixes from to the frame in which the numerical integration is performed.
+     * \param isMutualAttractionUsed Variable denoting whether attraction from body undergoing acceleration on
+     * body exerting acceleration is included (i.e. whether aGravitationalParameter refers to the property
+     * of the body exerting the acceleration, if variable is false, or the sum of the gravitational parameters,
+     * if the variable is true.
+     * \param sphericalHarmonicsCache Cache object for computing/retrieving repeated terms in spherical harmonics potential
+     *          gradient calculation.
      */
     SphericalHarmonicsGravitationalAccelerationModel(
             const StateFunction positionOfBodySubjectToAccelerationFunction,
             const double aGravitationalParameter,
             const double anEquatorialRadius,
-            const CoefficientMatrixType aCosineHarmonicCoefficientMatrix,
-            const CoefficientMatrixType aSineHarmonicCoefficientMatrix,
+            const Eigen::MatrixXd aCosineHarmonicCoefficientMatrix,
+            const Eigen::MatrixXd aSineHarmonicCoefficientMatrix,
             const StateFunction positionOfBodyExertingAccelerationFunction
             = boost::lambda::constant( Eigen::Vector3d::Zero( ) ),
             const boost::function< Eigen::Quaterniond( ) >
             rotationFromBodyFixedToIntegrationFrameFunction =
-            boost::lambda::constant( Eigen::Quaterniond( Eigen::Matrix3d::Identity( ) ) ) )
+            boost::lambda::constant( Eigen::Quaterniond( Eigen::Matrix3d::Identity( ) ) ),
+            const bool isMutualAttractionUsed = 0,
+            boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache > sphericalHarmonicsCache =
+            boost::make_shared< basic_mathematics::SphericalHarmonicsCache >( ) )
         : Base( positionOfBodySubjectToAccelerationFunction,
                 aGravitationalParameter,
-                positionOfBodyExertingAccelerationFunction ),
+                positionOfBodyExertingAccelerationFunction,
+                isMutualAttractionUsed ),
           equatorialRadius( anEquatorialRadius ),
           getCosineHarmonicsCoefficients(
               boost::lambda::constant(aCosineHarmonicCoefficientMatrix ) ),
           getSineHarmonicsCoefficients( boost::lambda::constant(aSineHarmonicCoefficientMatrix ) ),
           rotationFromBodyFixedToIntegrationFrameFunction_(
-              rotationFromBodyFixedToIntegrationFrameFunction )
+              rotationFromBodyFixedToIntegrationFrameFunction ),
+          sphericalHarmonicsCache_( sphericalHarmonicsCache )
+
     {
+        sphericalHarmonicsCache_->resetMaximumDegreeAndOrder(
+                    std::max< int >( static_cast< int >( getCosineHarmonicsCoefficients( ).rows( ) ), sphericalHarmonicsCache_->getMaximumDegree( ) ),
+                    std::max< int >( static_cast< int >( getCosineHarmonicsCoefficients( ).cols( ) ), sphericalHarmonicsCache_->getMaximumOrder( ) ) );
         this->updateMembers( );
     }
 
@@ -251,6 +271,11 @@ public:
      *          body exerting gravitational acceleration (default = (0,0,0)).
      * \param rotationFromBodyFixedToIntegrationFrameFunction Function providing the rotation from
      * body-fixes from to the frame in which the numerical integration is performed.
+     * \param isMutualAttractionUsed Variable denoting whether attraction from body undergoing acceleration on
+     * body exerting acceleration is included (i.e. whether aGravitationalParameter refers to the property
+     * of the body exerting the acceleration, if variable is false, or the sum of the gravitational parameters,
+     * if the variable is true.
+     * \param sphericalHarmonicsCache Cache object for computing/retrieving repeated terms in spherical harmonics potential
      */
     SphericalHarmonicsGravitationalAccelerationModel(
             const StateFunction positionOfBodySubjectToAccelerationFunction,
@@ -262,15 +287,25 @@ public:
             = boost::lambda::constant( Eigen::Vector3d::Zero( ) ),
             const boost::function< Eigen::Quaterniond( ) >
             rotationFromBodyFixedToIntegrationFrameFunction =
-            boost::lambda::constant( Eigen::Quaterniond( Eigen::Matrix3d::Identity( ) ) ) )
+            boost::lambda::constant( Eigen::Quaterniond( Eigen::Matrix3d::Identity( ) ) ),
+            const bool isMutualAttractionUsed = 0,
+            boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache > sphericalHarmonicsCache
+            = boost::make_shared< basic_mathematics::SphericalHarmonicsCache >( ) )
         : Base( positionOfBodySubjectToAccelerationFunction,
                 aGravitationalParameterFunction,
-                positionOfBodyExertingAccelerationFunction ),
+                positionOfBodyExertingAccelerationFunction,
+                isMutualAttractionUsed ),
           equatorialRadius( anEquatorialRadius ),
           getCosineHarmonicsCoefficients( cosineHarmonicCoefficientsFunction ),
           getSineHarmonicsCoefficients( sineHarmonicCoefficientsFunction ),
-          rotationFromBodyFixedToIntegrationFrameFunction_( rotationFromBodyFixedToIntegrationFrameFunction )
+          rotationFromBodyFixedToIntegrationFrameFunction_( rotationFromBodyFixedToIntegrationFrameFunction ),
+          sphericalHarmonicsCache_( sphericalHarmonicsCache )
     {
+        sphericalHarmonicsCache_->resetMaximumDegreeAndOrder(
+                    std::max< int >( static_cast< int >( getCosineHarmonicsCoefficients( ).rows( ) ), sphericalHarmonicsCache_->getMaximumDegree( ) ),
+                    std::max< int >( static_cast< int >( getCosineHarmonicsCoefficients( ).cols( ) ), sphericalHarmonicsCache_->getMaximumOrder( ) ) );
+
+
         this->updateMembers( );
     }
 
@@ -281,7 +316,17 @@ public:
      * computeGeodesyNormalizedGravitationalAccelerationSum() function.
      * \return Computed gravitational acceleration vector.
      */
-    Eigen::Vector3d getAcceleration( );
+    Eigen::Vector3d getAcceleration( )
+    {
+        return rotationToIntegrationFrame_ *
+                computeGeodesyNormalizedGravitationalAccelerationSum(
+                    rotationToIntegrationFrame_.inverse( ) * (
+                        this->positionOfBodySubjectToAcceleration - this->positionOfBodyExertingAcceleration ),
+                    gravitationalParameter,
+                    equatorialRadius,
+                    cosineHarmonicCoefficients,
+                    sineHarmonicCoefficients, sphericalHarmonicsCache_ );
+    }
 
     //! Update class members.
     /*!
@@ -300,6 +345,16 @@ public:
         }
     }
 
+    //! Function to retrieve the spherical harmonics cache for this acceleration.
+    /*!
+     *  Function to retrieve the spherical harmonics cache for this acceleration.
+     *  \return Spherical harmonics cache for this acceleration
+     */
+    boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache > getSphericalHarmonicsCache( )
+    {
+        return sphericalHarmonicsCache_;
+    }
+
 protected:
 
 private:
@@ -314,13 +369,13 @@ private:
     /*!
      * Matrix containing coefficients of cosine terms for spherical harmonics expansion.
      */
-    CoefficientMatrixType cosineHarmonicCoefficients;
+    Eigen::MatrixXd cosineHarmonicCoefficients;
 
     //! Matrix of sine coefficients.
     /*!
      * Matrix containing coefficients of sine terms for spherical harmonics expansion.
      */
-    CoefficientMatrixType sineHarmonicCoefficients;
+    Eigen::MatrixXd sineHarmonicCoefficients;
 
     //! Pointer to function returning cosine harmonics coefficients matrix.
     /*!
@@ -342,32 +397,19 @@ private:
     //! Current rotation from body-fixed frame to integration frame.
     Eigen::Quaterniond rotationToIntegrationFrame_;
 
+    //!  Spherical harmonics cache for this acceleration
+    boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache > sphericalHarmonicsCache_;
+
 };
 
-//! Typedef for SphericalHarmonicsGravitationalAccelerationModelXd.
-typedef SphericalHarmonicsGravitationalAccelerationModel< >
-SphericalHarmonicsGravitationalAccelerationModelXd;
 
-//! Typedef for shared-pointer to SphericalHarmonicsGravitationalAccelerationModelXd.
-typedef boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModelXd >
-SphericalHarmonicsGravitationalAccelerationModelXdPointer;
+//! Typedef for shared-pointer to SphericalHarmonicsGravitationalAccelerationModel.
+typedef boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModel >
+SphericalHarmonicsGravitationalAccelerationModelPointer;
 
-// Template class source.
-// The code given below is effectively the ".cpp file" for the template class definition, so you
-// only need to look at the code below if you are interested in the source implementation.
-
-//! Get gravitational acceleration.
-template< typename CoefficientMatrixType >
-Eigen::Vector3d SphericalHarmonicsGravitationalAccelerationModel< CoefficientMatrixType >
-::getAcceleration( )
-{
-    return rotationToIntegrationFrame_ * computeGeodesyNormalizedGravitationalAccelerationSum(
-                rotationToIntegrationFrame_.inverse( ) *
-                ( this->positionOfBodySubjectToAcceleration - this->positionOfBodyExertingAcceleration ),
-                gravitationalParameter, equatorialRadius, cosineHarmonicCoefficients, sineHarmonicCoefficients );
-}
 
 } // namespace gravitation
+
 } // namespace tudat
 
 #endif // TUDAT_SPHERICAL_HARMONICS_GRAVITY_MODEL_H
diff --git a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModelBase.h b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModelBase.h
index ba07f8f..8c7efe2 100644
--- a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModelBase.h
+++ b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModelBase.h
@@ -75,14 +75,20 @@ public:
      * \param aGravitationalParameter Gravitational parameter of body exerting gravitational acceleration.
      * \param positionOfBodyExertingAccelerationFunction Pointer to function returning position of
      *          body exerting gravitational acceleration.
+     * \param isMutualAttractionUsed Variable denoting whether attraction from body undergoing acceleration on
+     * body exerting acceleration is included (i.e. whether aGravitationalParameter refers to the property
+     * of the body exerting the acceleration, if variable is false, or the sum of the gravitational parameters,
+     * if the variable is true.
      */
     SphericalHarmonicsGravitationalAccelerationModelBase(
             const StateFunction positionOfBodySubjectToAccelerationFunction,
             const double aGravitationalParameter,
-            const StateFunction positionOfBodyExertingAccelerationFunction )
+            const StateFunction positionOfBodyExertingAccelerationFunction,
+            const bool isMutualAttractionUsed )
         : subjectPositionFunction( positionOfBodySubjectToAccelerationFunction ),
           gravitationalParameterFunction( boost::lambda::constant( aGravitationalParameter ) ),
-          sourcePositionFunction( positionOfBodyExertingAccelerationFunction )
+          sourcePositionFunction( positionOfBodyExertingAccelerationFunction ),
+          isMutualAttractionUsed_( isMutualAttractionUsed )
     { }
 
     //! Default constructor taking position of body subject to acceleration, variable
@@ -99,14 +105,20 @@ public:
      *          of body exerting gravitational acceleration.
      * \param positionOfBodyExertingAccelerationFunction Pointer to function returning position of
      *          body exerting gravitational acceleration.
+     * \param isMutualAttractionUsed Variable denoting whether attraction from body undergoing acceleration on
+     * body exerting acceleration is included (i.e. whether aGravitationalParameter refers to the property
+     * of the body exerting the acceleration, if variable is false, or the sum of the gravitational parameters,
+     * if the variable is true.
      */
     SphericalHarmonicsGravitationalAccelerationModelBase(
             const StateFunction positionOfBodySubjectToAccelerationFunction,
             const boost::function< double( ) > aGravitationalParameterFunction,
-            const StateFunction positionOfBodyExertingAccelerationFunction )
+            const StateFunction positionOfBodyExertingAccelerationFunction,
+            const bool isMutualAttractionUsed )
         : subjectPositionFunction( positionOfBodySubjectToAccelerationFunction ),
           gravitationalParameterFunction( aGravitationalParameterFunction ),
-          sourcePositionFunction( positionOfBodyExertingAccelerationFunction )
+          sourcePositionFunction( positionOfBodyExertingAccelerationFunction ),
+          isMutualAttractionUsed_( isMutualAttractionUsed )
     { }
 
     //! Virtual destructor.
@@ -123,12 +135,45 @@ public:
      * \return True; this should be modified to return a flag indicating if the update was
      *          successful.
      */
-    bool updateBaseMembers( )
+    void updateBaseMembers( )
     {
         this->gravitationalParameter = this->gravitationalParameterFunction( );
         this->positionOfBodySubjectToAcceleration = this->subjectPositionFunction( );
         this->positionOfBodyExertingAcceleration  = this->sourcePositionFunction( );
-        return true;
+    }
+
+    //! Function to return the function returning the relevant gravitational parameter.
+    /*!
+     * Function to return the function returning the relevant gravitational parameter.
+     * \return Function returning the gravitational parameter used in the computations.
+     */
+    boost::function< double( ) > getGravitationalParameterFunction( )
+    { return gravitationalParameterFunction; }
+
+    //! Function to return the function returning position of body exerting acceleration.
+    /*!
+     * Function to return the function returning position of body exerting acceleration.
+     * \return Function returning position of body exerting acceleration.
+     */
+    boost::function< StateMatrix( ) > getStateFunctionOfBodyExertingAcceleration( )
+    { return sourcePositionFunction; }
+
+    //! Function to return the function returning position of body subject to acceleration.
+    /*!
+     * Function to return the function returning position of body subject to acceleration.
+     * \return Function returning position of body subject to acceleration.
+     */
+    boost::function< StateMatrix( ) > getStateFunctionOfBodyUndergoingAcceleration( )
+    { return subjectPositionFunction; }
+
+    //! Function to return whether the mutual attraction is used.
+    /*!
+     *  Function to return whether the mutual attraction is used.
+     * \return Boolean defining whether the mutual attraction is used.
+     */
+    bool getIsMutualAttractionUsed( )
+    {
+        return isMutualAttractionUsed_;
     }
 
 protected:
@@ -171,6 +216,16 @@ protected:
      */
     const StateFunction sourcePositionFunction;
 
+    //! Variable denoting whether mutual acceleration between bodies is included.
+    /*!
+     * Variable denoting whether attraction from body undergoing acceleration on
+     * body exerting acceleration is included (i.e. whether aGravitationalParameter refers to the property
+     * of the body exerting the acceleration, if variable is false, or the sum of the gravitational parameters,
+     * if the variable is true.
+     */
+    bool isMutualAttractionUsed_;
+
+
 private:
 };
 
diff --git a/Tudat/Astrodynamics/Gravitation/thirdBodyPerturbation.h b/Tudat/Astrodynamics/Gravitation/thirdBodyPerturbation.h
index fcccf55..5b1e7c4 100644
--- a/Tudat/Astrodynamics/Gravitation/thirdBodyPerturbation.h
+++ b/Tudat/Astrodynamics/Gravitation/thirdBodyPerturbation.h
@@ -42,6 +42,7 @@
 
 #include "Tudat/Astrodynamics/Gravitation/centralGravityModel.h"
 #include "Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h"
+#include "Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.h"
 
 namespace tudat
 {
@@ -144,11 +145,22 @@ public:
         if( !( this->currentTime_ == currentTime ) )
         {
             // Update two constituent acceleration models.
-            accelerationModelForBodyUndergoingAcceleration_->updateMembers( );
-            accelerationModelForCentralBody_->updateMembers( );
+            accelerationModelForBodyUndergoingAcceleration_->updateMembers( currentTime );
+            accelerationModelForCentralBody_->updateMembers( currentTime );
         }
     }
 
+    //! Function to reset the current time
+    /*!
+     * Function to reset the current time of the acceleration model.
+     * \param currentTime Current time (default NaN).
+     */
+    void resetTime( const double currentTime = TUDAT_NAN )
+    {
+        accelerationModelForBodyUndergoingAcceleration_->resetTime( currentTime );
+        accelerationModelForCentralBody_->resetTime( currentTime );
+    }
+
     //! Function to return the direct acceleration model on body undergoing acceleration.
     /*!
      *  Function to return the direct acceleration model on body undergoing acceleration.
@@ -207,9 +219,14 @@ typedef ThirdBodyAcceleration< CentralGravitationalAccelerationModel3d >
 ThirdBodyCentralGravityAcceleration;
 
 //! Typedef for third body spherical harmonic gravity acceleration.
-typedef ThirdBodyAcceleration< SphericalHarmonicsGravitationalAccelerationModelXd >
+typedef ThirdBodyAcceleration< SphericalHarmonicsGravitationalAccelerationModel >
 ThirdBodySphericalHarmonicsGravitationalAccelerationModel;
 
+//! Typedef for third body mutual spherical harmonic gravity acceleration.
+typedef ThirdBodyAcceleration< MutualSphericalHarmonicsGravitationalAccelerationModel >
+ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel;
+
+
 } // namespace gravitation
 
 } // namespace tudat
diff --git a/Tudat/Astrodynamics/MissionSegments/CMakeLists.txt b/Tudat/Astrodynamics/MissionSegments/CMakeLists.txt
index 9dca05a..e6beb53 100755
--- a/Tudat/Astrodynamics/MissionSegments/CMakeLists.txt
+++ b/Tudat/Astrodynamics/MissionSegments/CMakeLists.txt
@@ -108,7 +108,6 @@ add_executable(test_MultiRevolutionLambertTargeterIzzo "${SRCROOT}${MISSIONSEGME
 setup_custom_test_program(test_MultiRevolutionLambertTargeterIzzo "${SRCROOT}${MISSIONSEGMENTSDIR}")
 target_link_libraries(test_MultiRevolutionLambertTargeterIzzo tudat_mission_segments tudat_root_finders tudat_basic_astrodynamics tudat_basic_mathematics ${Boost_LIBRARIES})
 
-add_executable(test_MathematicalShapeFunctions
-"${SRCROOT}${MISSIONSEGMENTSDIR}/UnitTests/unitTestMathematicalShapeFunctions.cpp")
+add_executable(test_MathematicalShapeFunctions "${SRCROOT}${MISSIONSEGMENTSDIR}/UnitTests/unitTestMathematicalShapeFunctions.cpp")
 setup_custom_test_program(test_MathematicalShapeFunctions "${SRCROOT}${MISSIONSEGMENTSDIR}")
 target_link_libraries(test_MathematicalShapeFunctions tudat_mission_segments tudat_basic_mathematics ${Boost_LIBRARIES})
diff --git a/Tudat/Astrodynamics/ObservationModels/CMakeLists.txt b/Tudat/Astrodynamics/ObservationModels/CMakeLists.txt
index 08a4a6c..7945ad3 100644
--- a/Tudat/Astrodynamics/ObservationModels/CMakeLists.txt
+++ b/Tudat/Astrodynamics/ObservationModels/CMakeLists.txt
@@ -14,16 +14,36 @@
  #      130226    D. Dirkx          File created.
  #
 
+
+set(OBSERVABLECORRECTIONSDIR "${OBSERVATIONMODELSDIR}/ObservableCorrections")
+
+
 # Set the source files.
 set(OBSERVATION_MODELS_SOURCES
   "${SRCROOT}${OBSERVATIONMODELSDIR}/lightTimeSolution.cpp"
+  "${SRCROOT}${OBSERVATIONMODELSDIR}/observableTypes.cpp"
+  "${SRCROOT}${OBSERVABLECORRECTIONSDIR}/createLightTimeCorrection.cpp"
+  "${SRCROOT}${OBSERVABLECORRECTIONSDIR}/firstOrderRelativisticLightTimeCorrection.cpp"
 )
 
 # Set the header files.
 set(OBSERVATION_MODELS_HEADERS
+  "${SRCROOT}${OBSERVATIONMODELSDIR}/angularPositionObservationModel.h"
   "${SRCROOT}${OBSERVATIONMODELSDIR}/lightTimeSolution.h"
+  "${SRCROOT}${OBSERVATIONMODELSDIR}/linkTypeDefs.h"
+  "${SRCROOT}${OBSERVATIONMODELSDIR}/observableTypes.h"
+  "${SRCROOT}${OBSERVATIONMODELSDIR}/observationModel.h"
+  "${SRCROOT}${OBSERVATIONMODELSDIR}/observationBias.h"
+  "${SRCROOT}${OBSERVATIONMODELSDIR}/oneWayRangeObservationModel.h"
+  "${SRCROOT}${OBSERVATIONMODELSDIR}/positionObservationModel.h"
+  "${SRCROOT}${OBSERVATIONMODELSDIR}/createObservationModel.h"
+  "${SRCROOT}${OBSERVATIONMODELSDIR}/createLightTimeCalculator.h"
   "${SRCROOT}${OBSERVATIONMODELSDIR}/UnitTests/testLightTimeCorrections.h"
- )
+  "${SRCROOT}${OBSERVABLECORRECTIONSDIR}/createLightTimeCorrection.h"
+  "${SRCROOT}${OBSERVABLECORRECTIONSDIR}/lightTimeCorrection.h"
+  "${SRCROOT}${OBSERVABLECORRECTIONSDIR}/firstOrderRelativisticLightTimeCorrection.h"
+)
+
 
 # Add static libraries.
 add_library(tudat_observation_models STATIC ${OBSERVATION_MODELS_SOURCES} ${OBSERVATION_MODELS_HEADERS})
@@ -33,6 +53,18 @@ if(USE_CSPICE)
 
     add_executable(test_LightTime "${SRCROOT}${OBSERVATIONMODELSDIR}/UnitTests/unitTestLightTimeSolution.cpp")
     setup_custom_test_program(test_LightTime "${SRCROOT}${OBSERVATIONMODELSDIR}")
-    target_link_libraries(test_LightTime tudat_observation_models tudat_ephemerides tudat_spice_interface ${SPICE_LIBRARIES} ${Boost_LIBRARIES})
+    target_link_libraries(test_LightTime tudat_observation_models tudat_ephemerides tudat_basic_astrodynamics tudat_spice_interface ${SPICE_LIBRARIES} ${Boost_LIBRARIES})
+
+    add_executable(test_AngularPositionModel "${SRCROOT}${OBSERVATIONMODELSDIR}/UnitTests/unitTestAngularPositionModel.cpp")
+    setup_custom_test_program(test_AngularPositionModel "${SRCROOT}${OBSERVATIONMODELSDIR}")
+    target_link_libraries(test_AngularPositionModel ${TUDAT_ESTIMATION_LIBRARIES} ${Boost_LIBRARIES})
+
+    add_executable(test_OneWayRangeModel "${SRCROOT}${OBSERVATIONMODELSDIR}/UnitTests/unitTestOneWayRangeObservationModel.cpp")
+    setup_custom_test_program(test_OneWayRangeModel "${SRCROOT}${OBSERVATIONMODELSDIR}")
+    target_link_libraries(test_OneWayRangeModel ${TUDAT_ESTIMATION_LIBRARIES} ${Boost_LIBRARIES})
+
+    add_executable(test_PositionObservationModel "${SRCROOT}${OBSERVATIONMODELSDIR}/UnitTests/unitTestPositionObservationModel.cpp")
+    setup_custom_test_program(test_PositionObservationModel "${SRCROOT}${OBSERVATIONMODELSDIR}")
+    target_link_libraries(test_PositionObservationModel ${TUDAT_ESTIMATION_LIBRARIES} ${Boost_LIBRARIES})
 
 endif( )
diff --git a/Tudat/Astrodynamics/ObservationModels/ObservableCorrections/createLightTimeCorrection.cpp b/Tudat/Astrodynamics/ObservationModels/ObservableCorrections/createLightTimeCorrection.cpp
new file mode 100644
index 0000000..15daca5
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/ObservableCorrections/createLightTimeCorrection.cpp
@@ -0,0 +1,103 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#include "Tudat/SimulationSetup/body.h"
+#include "Tudat/Astrodynamics/ObservationModels/ObservableCorrections/createLightTimeCorrection.h"
+#include "Tudat/Astrodynamics/ObservationModels/ObservableCorrections/firstOrderRelativisticLightTimeCorrection.h"
+
+namespace tudat
+{
+
+namespace observation_models
+{
+
+//! Function to create object that computes a single (type of) correction to the light-time
+boost::shared_ptr< LightTimeCorrection > createLightTimeCorrections(
+        const boost::shared_ptr< LightTimeCorrectionSettings > correctionSettings,
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const std::pair< std::string, std::string >& transmitter,
+        const std::pair< std::string, std::string >& receiver )
+{
+
+    using namespace tudat::ephemerides;
+    using namespace tudat::gravitation;
+
+    boost::shared_ptr< LightTimeCorrection > lightTimeCorrection;
+
+    // Identify type of light time correction to be created.
+    switch( correctionSettings->getCorrectionType( ) )
+    {
+    case first_order_relativistic:
+    {
+        // Check input consistency
+        if( boost::dynamic_pointer_cast< FirstOrderRelativisticLightTimeCorrectionSettings >( correctionSettings ) != NULL )
+        {
+            // Retrieve list of bodies causing light time perturbation
+            std::vector< std::string > perturbingBodies =
+                    boost::dynamic_pointer_cast< FirstOrderRelativisticLightTimeCorrectionSettings >( correctionSettings )->
+                    getPerturbingBodies( );
+
+            std::vector< boost::function< basic_mathematics::Vector6d( const double ) > > perturbingBodyStateFunctions;
+            std::vector< boost::function< double( ) > > perturbingBodyGravitationalParameterFunctions;
+
+            // Retrieve mass and state functions for each perturbing body.
+            for( unsigned int i = 0; i < perturbingBodies.size( ); i++ )
+            {
+                if( bodyMap.count( perturbingBodies[ i ] ) == 0 )
+                {
+                    throw std::runtime_error(
+                                "Error when making 1st order relativistic light time correction, could not find body " +
+                                perturbingBodies.at( i ) );
+                }
+                else
+                {
+                    // Set state function.
+                    perturbingBodyStateFunctions.push_back(
+                                boost::bind( &simulation_setup::Body::getStateInBaseFrameFromEphemeris,
+                                                                         bodyMap.at( perturbingBodies[ i ] ), _1 ) );
+
+                    // Set gravitational parameter function.
+                    perturbingBodyGravitationalParameterFunctions.push_back(
+                                boost::bind( &gravitation::GravityFieldModel::getGravitationalParameter,
+                                             bodyMap.at( perturbingBodies[ i ] )->
+                                             getGravityFieldModel( ) ) );
+                }
+            }
+
+            // Create light-time correction function
+            lightTimeCorrection = boost::make_shared< FirstOrderLightTimeCorrectionCalculator >(
+                        perturbingBodyStateFunctions, perturbingBodyGravitationalParameterFunctions, perturbingBodies,
+                        transmitter.first, receiver.first );
+
+        }
+        else
+        {
+            throw std::runtime_error(
+                        "Error, correction settings type (1st order relativistic) does not coincide with data type." );
+        }
+
+        break;
+    }
+    default:
+    {
+        std::string errorMessage = "Error, light time correction type " +
+                boost::lexical_cast< std::string >( correctionSettings->getCorrectionType( ) ) + " not recognized.";
+        throw std::runtime_error( errorMessage );
+
+        break;
+    }
+
+    }
+    return lightTimeCorrection;
+}
+
+}
+
+}
diff --git a/Tudat/Astrodynamics/ObservationModels/ObservableCorrections/createLightTimeCorrection.h b/Tudat/Astrodynamics/ObservationModels/ObservableCorrections/createLightTimeCorrection.h
new file mode 100644
index 0000000..2f86d56
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/ObservableCorrections/createLightTimeCorrection.h
@@ -0,0 +1,122 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_CREATELIGHTTIMECORRECTION_H
+#define TUDAT_CREATELIGHTTIMECORRECTION_H
+
+#include <Eigen/Core>
+
+#include <boost/shared_ptr.hpp>
+#include <boost/function.hpp>
+
+#include "Tudat/SimulationSetup/body.h"
+#include "Tudat/Astrodynamics/ObservationModels/linkTypeDefs.h"
+#include "Tudat/Astrodynamics/ObservationModels/ObservableCorrections/lightTimeCorrection.h"
+
+namespace tudat
+{
+
+namespace observation_models
+{
+
+//! Typedef for function calculating light-time correction in light-time calculation loop.
+typedef boost::function< double(
+        const basic_mathematics::Vector6d&, const basic_mathematics::Vector6d&,
+        const double, const double ) > LightTimeCorrectionFunction;
+
+//! Base class for light-time correction settings.
+/*!
+ *  Base class for light-time correction settings. This class is not used for calculations of corrections,
+ *  but is used for the purpose of defining the light time correction properties.
+ *  The createLightTimeCorrections function produces the classes that calculate the actual corrections, based on settings
+ *  in instances of derived LightTimeCorrectionSettings classes.
+ */
+class LightTimeCorrectionSettings
+{
+public:
+
+    //! Constructor, takes light-time correction type.
+    /*!
+     *  \param correctionType Type of light-time correction that is to be created
+     */
+    LightTimeCorrectionSettings( const LightTimeCorrectionType correctionType ):
+        correctionType_( correctionType ){ }
+
+    //! Default destructor.
+    virtual ~LightTimeCorrectionSettings( ){ }
+
+    //! Function returning the type of light-time correction that is to be created
+    /*!
+     *  Function returning the type of light-time correction that is to be created
+     *  \return Type of light-time correction that is to be created
+     */
+    LightTimeCorrectionType getCorrectionType( )
+    {
+        return correctionType_;
+    }
+
+protected:
+
+    //! Type of light-time correction that is to be created
+    LightTimeCorrectionType correctionType_;
+};
+
+//! Class to defining settings for first-order relativistic light time correction (Shapiro time delay)  due to a
+//! set of point masses
+class FirstOrderRelativisticLightTimeCorrectionSettings: public LightTimeCorrectionSettings
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param perturbingBodies List of bodies for which the point masses are used to compute the light-time correction.
+     */
+    FirstOrderRelativisticLightTimeCorrectionSettings( const std::vector< std::string >& perturbingBodies ):
+        LightTimeCorrectionSettings( first_order_relativistic ), perturbingBodies_( perturbingBodies ){ }
+
+    //! Destructor
+    ~FirstOrderRelativisticLightTimeCorrectionSettings( ){ }
+
+    //! Function returning the list of bodies for which the point masses are used to compute the light-time correction.
+    /*!
+     *  Function returning the list of bodies for which the point masses are used to compute the light-time correction.
+     *  \return List of bodies for which the point masses are used to compute the light-time correction.
+     */
+    std::vector< std::string > getPerturbingBodies( ){ return perturbingBodies_; }
+
+private:
+
+    //! List of bodies for which the point masses are used to compute the light-time correction.
+    std::vector< std::string > perturbingBodies_;
+
+};
+
+//! Function to create object that computes a single (type of) correction to the light-time
+/*!
+ * Function to create object that computes a single (type of) correction to the light-time
+ * \param correctionSettings User-defined settings for the light-time correction that is to be created
+ * \param bodyMap List of body objects that constitutes the environment
+ * \param transmitter Id of transmitting body/reference point (first/second)
+ * \param receiver Id of receiving body/reference point (first/second)
+ * \return Object for computing required light-time correction
+ */
+boost::shared_ptr< LightTimeCorrection > createLightTimeCorrections(
+        const boost::shared_ptr< LightTimeCorrectionSettings > correctionSettings,
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const std::pair< std::string, std::string >& transmitter,
+        const std::pair< std::string, std::string >& receiver );
+
+}
+
+}
+
+
+#endif // TUDAT_CREATELIGHTTIMECORRECTION_H
diff --git a/Tudat/Astrodynamics/ObservationModels/ObservableCorrections/firstOrderRelativisticLightTimeCorrection.cpp b/Tudat/Astrodynamics/ObservationModels/ObservableCorrections/firstOrderRelativisticLightTimeCorrection.cpp
new file mode 100644
index 0000000..760b1c8
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/ObservableCorrections/firstOrderRelativisticLightTimeCorrection.cpp
@@ -0,0 +1,58 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#include <iostream>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+
+#include "Tudat/Astrodynamics/Relativity/relativisticLightTimeCorrection.h"
+#include "Tudat/Astrodynamics/ObservationModels/ObservableCorrections/firstOrderRelativisticLightTimeCorrection.h"
+
+
+namespace tudat
+{
+
+namespace observation_models
+{
+
+//! Function to calculate first order relativistic light time correction due to set of gravitating point masses.
+double FirstOrderLightTimeCorrectionCalculator::calculateLightTimeCorrection(
+        const basic_mathematics::Vector6d& transmitterState,
+        const basic_mathematics::Vector6d& receiverState,
+        const double transmissionTime,
+        const double receptionTime )
+{
+    // Retrieve ppn parameter gamma.
+    double ppnParameterGamma = ppnParameterGammaFunction_( );
+
+    // Initialize correction to zero.
+    currentTotalLightTimeCorrection_ = 0.0;
+
+    double evaluationTime = TUDAT_NAN;
+    // Iterate over all gravitating bodies.
+    for( unsigned int i = 0; i < perturbingBodyStateFunctions_.size( ); i++ )
+    {
+        evaluationTime = transmissionTime + lightTimeEvaluationContribution_.at( i ) * ( receptionTime - transmissionTime );
+        // Calculate correction due to current body and add to total.
+        currentLighTimeCorrectionComponents_[ i ] = relativity::calculateFirstOrderLightTimeCorrectionFromCentralBody(
+                    perturbingBodyGravitationalParameterFunctions_[ i ]( ),
+                    transmitterState.segment( 0, 3 ), receiverState.segment( 0, 3 ),
+                    perturbingBodyStateFunctions_[ i ]( evaluationTime ).segment( 0, 3 ),
+                    ppnParameterGamma );
+        currentTotalLightTimeCorrection_ += currentLighTimeCorrectionComponents_[ i ];
+    }
+
+    return currentTotalLightTimeCorrection_;
+}
+
+}
+
+}
+
diff --git a/Tudat/Astrodynamics/ObservationModels/ObservableCorrections/firstOrderRelativisticLightTimeCorrection.h b/Tudat/Astrodynamics/ObservationModels/ObservableCorrections/firstOrderRelativisticLightTimeCorrection.h
new file mode 100644
index 0000000..d43cde4
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/ObservableCorrections/firstOrderRelativisticLightTimeCorrection.h
@@ -0,0 +1,199 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_FIRSTORDERRELATIVISTICLIGHTTIMECORRECTION_H
+#define TUDAT_FIRSTORDERRELATIVISTICLIGHTTIMECORRECTION_H
+
+#include <cmath>
+#include <vector>
+#include <iostream>
+
+#include <boost/function.hpp>
+#include <boost/lambda/lambda.hpp>
+
+#include <Eigen/Core>
+
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+#include "Tudat/Astrodynamics/ObservationModels/ObservableCorrections/lightTimeCorrection.h"
+
+namespace tudat
+{
+
+namespace observation_models
+{
+
+//! Class to calculate first order relativistic light time correction (Shapiro time delay) due to a set of point masses.
+/*!
+ *  Class to calculate first order relativistic light time correction (Shapiro time delay) due to a set of point masses.
+ *  This class has the properties (mass and position) of the gravitating bodies as member variables. It receives the states
+ *  and times of  receiver and transmitter as input each time a light time is to be calculated.
+ *  NOTE: If the perturbing body is equal to the transmitting or receiving body, the transmission or reception time,
+ *  respectively, are used to evaluate this perturbing body's state when computing the correction. For all other bodies,
+ *  the mid-way point of the light time is used.
+ */
+class FirstOrderLightTimeCorrectionCalculator: public LightTimeCorrection
+{
+public:
+
+    //! Constructor, takes and sets gravitating body properties.
+    /*!
+     *  Constructor, takes and sets gravitating body properties.
+     *  \param perturbingBodyStateFunctions Set of function returning the state of the gravitating bodies as a function
+     *  of time.
+     *  \param perturbingBodyGravitationalParameterFunctions Set of functions returning the gravitational parameters of
+     *  the gravitating bodies.
+     *  \param perturbingBodyNames Names of bodies causing light-time correction.
+     *  \param transmittingBody Name of transmitting body
+     *  \param receivingBody Name of receiving body
+     *  \param ppnParameterGammaFunction Function returning the parametric post-Newtonian parameter gamma, a measure
+     *  for the space-time curvature due to a unit rest mass (default 1.0; value from GR)
+     */
+    FirstOrderLightTimeCorrectionCalculator(
+            const std::vector< boost::function< basic_mathematics::Vector6d( const double ) > >& perturbingBodyStateFunctions,
+            const std::vector< boost::function< double( ) > >& perturbingBodyGravitationalParameterFunctions,
+            const std::vector< std::string > perturbingBodyNames,
+            const std::string transmittingBody,
+            const std::string receivingBody,
+            const boost::function< double( ) >& ppnParameterGammaFunction = boost::lambda::constant( 1.0 ) ):
+        LightTimeCorrection( first_order_relativistic ),
+        perturbingBodyStateFunctions_( perturbingBodyStateFunctions ),
+        perturbingBodyGravitationalParameterFunctions_( perturbingBodyGravitationalParameterFunctions ),
+        perturbingBodyNames_( perturbingBodyNames ),
+        ppnParameterGammaFunction_( ppnParameterGammaFunction )
+    {
+        currentTotalLightTimeCorrection_ = 0.0;
+        currentLighTimeCorrectionComponents_.resize( perturbingBodyNames_.size( ) );
+
+        // Check if perturbing body is transmitting/receiving body, and set evaluation time settings accordingly
+        for( unsigned int i = 0; i < perturbingBodyNames.size( ); i++ )
+        {
+            if( perturbingBodyNames.at( i ) == transmittingBody )
+            {
+                lightTimeEvaluationContribution_.push_back( 0.0 );
+            }
+            else if( perturbingBodyNames.at( i ) == receivingBody )
+            {
+                lightTimeEvaluationContribution_.push_back( 1.0 );
+            }
+            else
+            {
+                lightTimeEvaluationContribution_.push_back( 0.5 );
+            }
+        }
+    }
+
+    //! Destructor
+    ~FirstOrderLightTimeCorrectionCalculator( ){ }
+
+    //! Function to calculate first-order relativistic light time correction due to set of gravitating point masses.
+    /*!
+     *  Function to calculate first order relativistic light time correction due to set of gravitating point masses,
+     *  according to Eq. (11.17) of 2010 IERS conventions. Calculation are performed by calling ca
+     *  calculateFirstOrderLightTimeCorrectionFromCentralBody function for each gravitating body.
+     *  \param transmitterState State of transmitter at transmission time.
+     *  \param receiverState State of receiver at reception time
+     *  \param transmissionTime Time of signal transmission
+     *  \param receptionTime Time of signal reception
+     *  \return Total light time correction due to gravitating masses defined by perturbingBodyStateFunctions_ and
+     *  perturbingBodyGravitationalParameterFunctions_ member variables.
+     */
+    double calculateLightTimeCorrection( const basic_mathematics::Vector6d& transmitterState,
+                                         const basic_mathematics::Vector6d& receiverState,
+                                         const double transmissionTime,
+                                         const double receptionTime );
+
+    //! Function to get the names of bodies causing light-time correction.
+    /*!
+     * Function to get the names of bodies causing light-time correction.
+     * \return Names of bodies causing light-time correction.
+     */
+    std::vector< std::string > getPerturbingBodyNames( )
+    {
+        return perturbingBodyNames_;
+    }
+
+    //! Function to get the set of functions returning the gravitational parameters of the gravitating bodies.
+    /*!
+     * Function to get the set of functions returning the gravitational parameters of the gravitating bodies.
+     * \return Set of functions returning the gravitational parameters of the gravitating bodies.
+     */
+    std::vector< boost::function< double( ) > > getPerturbingBodyGravitationalParameterFunctions( )
+    {
+        return perturbingBodyGravitationalParameterFunctions_;
+    }
+
+    //! Function to get the total light-time correction, as computed by last call to calculateLightTimeCorrection.
+    /*!
+     * Function to get the total light-time correction, as computed by last call to calculateLightTimeCorrection.
+     * \return Total light-time correction, as computed by last call to calculateLightTimeCorrection.
+     */
+    double getCurrentTotalLightTimeCorrection( )
+    {
+        return currentTotalLightTimeCorrection_;
+    }
+
+    //! Function to get the light-time correction of given perturbing body, as computed by last call to
+    //! calculateLightTimeCorrection.
+    /*!
+     * Function to get the light-time correction of given perturbing body, as computed by last call to
+     * calculateLightTimeCorrection.
+     * \param bodyIndex Index in list of bodies for which the correction is to be returbed
+     * \return Light-time correction of given perturbing body, as computed by last call to
+     * calculateLightTimeCorrection.
+     */
+    double getCurrentLightTimeCorrectionComponent( const int bodyIndex )
+    {
+        return currentLighTimeCorrectionComponents_.at( bodyIndex );
+    }
+
+    //! Function to get the function returning the parametric post-Newtonian parameter gamma
+    /*!
+     * Function to get the function returning the parametric post-Newtonian parameter gamma
+     * \return Function returning the parametric post-Newtonian parameter gamma
+     */
+    boost::function< double( ) > getPpnParameterGammaFunction_( )
+    {
+        return ppnParameterGammaFunction_;
+    }
+
+private:
+
+    //! Set of function returning the state of the gravitating bodies as a function of time.
+    std::vector< boost::function< basic_mathematics::Vector6d( const double ) > > perturbingBodyStateFunctions_;
+
+    //! Set of functions returning the gravitational parameters of the gravitating bodies.
+    std::vector< boost::function< double( ) > > perturbingBodyGravitationalParameterFunctions_;
+
+    //! Names of bodies causing light-time correction.
+    std::vector< std::string > perturbingBodyNames_;
+
+    //! Function returning the parametric post-Newtonian parameter gamma
+    /*!
+     *  Function returning the parametric post-Newtonian parameter gamma, a measure for the space-time curvature due to a
+     *  unit rest mass (1.0 in GR)
+     */
+    boost::function< double( ) > ppnParameterGammaFunction_;
+
+    //! List of values (between 0 and 1) of how far into the light-time the state of each perturbing body is to be evaluated.
+    std::vector< double > lightTimeEvaluationContribution_;
+
+    //! List of light-time correction due to each separate perturbing body, as computed by last call to
+    //! calculateLightTimeCorrection.
+    std::vector< double > currentLighTimeCorrectionComponents_;
+
+    //! Total light-time correction, as computed by last call to calculateLightTimeCorrection.
+    double currentTotalLightTimeCorrection_;
+};
+
+}
+
+}
+#endif // TUDAT_FIRSTORDERRELATIVISTICLIGHTTIMECORRECTION_H
diff --git a/Tudat/Astrodynamics/ObservationModels/ObservableCorrections/lightTimeCorrection.h b/Tudat/Astrodynamics/ObservationModels/ObservableCorrections/lightTimeCorrection.h
new file mode 100644
index 0000000..71d7eb3
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/ObservableCorrections/lightTimeCorrection.h
@@ -0,0 +1,88 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_LIGHTTIMECORRECTION_H
+#define TUDAT_LIGHTTIMECORRECTION_H
+
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+
+namespace tudat
+{
+
+namespace observation_models
+{
+
+//! Enum defining different types of light time corrections.
+enum LightTimeCorrectionType
+{
+    first_order_relativistic
+};
+
+
+//! Base class for computing deviations from the light-time w.r.t. straight-line propagation at constant velocity (c).
+/*!
+ *  Base class for computing deviations from the light-time w.r.t. straight-line propagation at constant velocity (c).
+ *  This base class is non-functional, and each time of light-time correction must be defined in a dedicated derived class
+ */
+class LightTimeCorrection
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param lightTimeCorrectionType Type of light-time correction represented by instance of class.
+     */
+    LightTimeCorrection( const LightTimeCorrectionType lightTimeCorrectionType ):
+        lightTimeCorrectionType_( lightTimeCorrectionType ){ }
+
+    //! Destructor
+    virtual ~LightTimeCorrection( ){ }
+
+    //! Pure virtual function to compute the light-time correction
+    /*!
+     * Pure virtual function to compute the light-time correction, function is to be implemented in derived class
+     * for specific correction model. The input is the states and times of the two link ends (at the current iteration of
+     * the solution of the implicit light-time equation), which is the information of the link already computed by the
+     * light time calculator, ensuring that no double computations are performed.
+     * \param transmitterState State of transmitted at transmission time
+     * \param receiverState State of receiver at reception time
+     * \param transmissionTime Time of signal transmission
+     * \param receptionTime Time of singal reception
+     * \return
+     */
+    virtual double calculateLightTimeCorrection(
+            const basic_mathematics::Vector6d& transmitterState,
+            const basic_mathematics::Vector6d& receiverState,
+            const double transmissionTime,
+            const double receptionTime ) = 0;
+
+    //! Function to retrieve the type of light-time correction represented by instance of class.
+    /*!
+     *  Function to retrieve the type of light-time correction represented by instance of class.
+     *  \return Type of light-time correction represented by instance of class.
+     */
+    LightTimeCorrectionType getLightTimeCorrectionType( )
+    {
+        return lightTimeCorrectionType_;
+    }
+
+protected:
+
+    //! Type of light-time correction represented by instance of class.
+    LightTimeCorrectionType lightTimeCorrectionType_;
+
+};
+
+}
+
+}
+
+#endif // TUDAT_LIGHTTIMECORRECTION_H
diff --git a/Tudat/Astrodynamics/ObservationModels/UnitTests/testLightTimeCorrections.h b/Tudat/Astrodynamics/ObservationModels/UnitTests/testLightTimeCorrections.h
index 309339c..a11609c 100644
--- a/Tudat/Astrodynamics/ObservationModels/UnitTests/testLightTimeCorrections.h
+++ b/Tudat/Astrodynamics/ObservationModels/UnitTests/testLightTimeCorrections.h
@@ -1,36 +1,11 @@
-/*    Copyright (c) 2010-2015, Delft University of Technology
- *    All rights reserved.
- *
- *    Redistribution and use in source and binary forms, with or without modification, are
- *    permitted provided that the following conditions are met:
- *      - Redistributions of source code must retain the above copyright notice, this list of
- *        conditions and the following disclaimer.
- *      - Redistributions in binary form must reproduce the above copyright notice, this list of
- *        conditions and the following disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *      - Neither the name of the Delft University of Technology nor the names of its contributors
- *        may be used to endorse or promote products derived from this software without specific
- *        prior written permission.
- *
- *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
- *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- *    OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *    Changelog
- *      YYMMDD    Author            Comment
- *      130226    D. Dirkx          File created.
- *      130522    E.D. Brandon      Minor changes during code check.
- *
- *    References
- *
- *    Notes
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
  *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
  */
 
 #ifndef TUDAT_TEST_LIGHT_TIME_CORRECTIONS_H
diff --git a/Tudat/Astrodynamics/ObservationModels/UnitTests/unitTestAngularPositionModel.cpp b/Tudat/Astrodynamics/ObservationModels/UnitTests/unitTestAngularPositionModel.cpp
new file mode 100644
index 0000000..603a47e
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/UnitTests/unitTestAngularPositionModel.cpp
@@ -0,0 +1,187 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#define BOOST_TEST_MAIN
+
+#include <limits>
+#include <string>
+
+#include <boost/format.hpp>
+#include <boost/test/unit_test.hpp>
+#include <boost/make_shared.hpp>
+
+#include "Tudat/Basics/testMacros.h"
+
+#include "Tudat/InputOutput/basicInputOutput.h"
+
+#include "Tudat/SimulationSetup/body.h"
+#include "Tudat/Astrodynamics/ObservationModels/angularPositionObservationModel.h"
+#include "Tudat/Astrodynamics/ObservationModels/createObservationModel.h"
+#include "Tudat/SimulationSetup/defaultBodies.h"
+#include "Tudat/SimulationSetup/createBodies.h"
+
+namespace tudat
+{
+namespace unit_tests
+{
+
+using namespace tudat::observation_models;
+using namespace tudat::spice_interface;
+using namespace tudat::ephemerides;
+using namespace tudat::simulation_setup;
+
+
+BOOST_AUTO_TEST_SUITE( test_angular_position_model )
+
+
+BOOST_AUTO_TEST_CASE( testAngularPositionModel )
+{
+    std::string kernelsPath = input_output::getSpiceKernelPath( );
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de-403-masses.tpc");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "naif0009.tls");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "pck00009.tpc");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de421.bsp");
+
+    // Define bodies to use.
+    std::vector< std::string > bodiesToCreate;
+    bodiesToCreate.push_back( "Earth" );
+    bodiesToCreate.push_back( "Sun" );
+    bodiesToCreate.push_back( "Mars" );
+
+    // Specify initial time
+    double initialEphemerisTime = 0.0;
+    double finalEphemerisTime = initialEphemerisTime + 7.0 * 86400.0;
+    double maximumTimeStep = 3600.0;
+    double buffer = 10.0 * maximumTimeStep;
+
+    // Create bodies settings needed in simulation
+    std::map< std::string, boost::shared_ptr< BodySettings > > defaultBodySettings =
+            getDefaultBodySettings(
+                bodiesToCreate, initialEphemerisTime - buffer, finalEphemerisTime + buffer );
+
+    // Create bodies
+    NamedBodyMap bodyMap = createBodies( defaultBodySettings );
+
+    setGlobalFrameBodyEphemerides( bodyMap, "SSB", "ECLIPJ2000" );
+
+    // Define link ends for observations.
+    LinkEnds linkEnds;
+    linkEnds[ transmitter ] = std::make_pair( "Earth" , ""  );
+    linkEnds[ receiver ] = std::make_pair( "Mars" , ""  );
+
+    // Create observation model.
+    boost::shared_ptr< ObservationBias< 2 > > observationBias =
+            boost::make_shared< ConstantObservationBias< 2 > >(
+                ( Eigen::Vector2d( ) << 3.2E-9, -1.5E-8 ).finished( ) );
+    std::vector< std::string > lightTimePerturbingBodies = boost::assign::list_of( "Sun" );
+    std::vector< boost::shared_ptr< LightTimeCorrectionSettings > > lightTimeCorrectionSettings;
+    lightTimeCorrectionSettings.push_back( boost::make_shared< FirstOrderRelativisticLightTimeCorrectionSettings >(
+                                                lightTimePerturbingBodies ) );
+    boost::shared_ptr< ObservationModel< 2, double, double, double > > observationModel =
+           ObservationModelCreator< 2, double, double, double >::createObservationModel(
+                angular_position, linkEnds, bodyMap, lightTimeCorrectionSettings, observationBias );
+
+    // Compute observation separately with two functions.
+    double receiverObservationTime = ( finalEphemerisTime + initialEphemerisTime ) / 2.0;
+    std::vector< double > linkEndTimes;
+    std::vector< basic_mathematics::Vector6d > linkEndStates;
+    Eigen::Vector2d observationFromReceptionTime = observationModel->computeObservations(
+                receiverObservationTime, receiver );
+    Eigen::Vector2d observationFromReceptionTime2 = observationModel->computeObservationsWithLinkEndData(
+                receiverObservationTime, receiver, linkEndTimes, linkEndStates );
+    BOOST_CHECK_EQUAL( linkEndTimes.size( ), 2 );
+    BOOST_CHECK_EQUAL( linkEndStates.size( ), 2 );
+
+    // Manually create and compute light time corrections
+    boost::shared_ptr< LightTimeCorrection > lightTimeCorrectionCalculator =
+            createLightTimeCorrections(
+                lightTimeCorrectionSettings.at( 0 ), bodyMap, linkEnds[ transmitter ], linkEnds[ receiver ] );
+    double lightTimeCorrection = lightTimeCorrectionCalculator->calculateLightTimeCorrection(
+                linkEndStates.at( 0 ), linkEndStates.at( 1 ), linkEndTimes.at( 0 ), linkEndTimes.at( 1 ) );
+
+    // Check equality of computed observations.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                observationFromReceptionTime, observationFromReceptionTime2, std::numeric_limits< double >::epsilon( ) );
+
+    // Check consistency of link end states and time.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                linkEndStates.at( 0 ), bodyMap.at( "Earth" )->getStateInBaseFrameFromEphemeris( linkEndTimes.at( 0 ) ),
+                std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                linkEndStates.at( 1 ), bodyMap.at( "Mars" )->getStateInBaseFrameFromEphemeris( linkEndTimes.at( 1 ) ),
+                std::numeric_limits< double >::epsilon( ) );
+
+    // Check that reception time is kept fixed.
+    BOOST_CHECK_CLOSE_FRACTION( static_cast< double >( receiverObservationTime ),
+                                linkEndTimes[ 1 ], std::numeric_limits< double >::epsilon( ) );
+
+    // Manually compute light time
+    Eigen::Vector3d positionDifference = ( linkEndStates[ 0 ] - linkEndStates[ 1 ] ).segment( 0, 3 );
+    BOOST_CHECK_CLOSE_FRACTION(
+                positionDifference.norm( ) / physical_constants::SPEED_OF_LIGHT + lightTimeCorrection,
+                linkEndTimes[ 1 ] - linkEndTimes[ 0 ],
+                std::numeric_limits< double >::epsilon( ) * 1000.0 );
+                        // Poor tolerance due to rounding errors when subtracting times
+
+    // Check computed right ascension/declination from link end states
+    Eigen::Vector3d sphericalRelativeCoordinates = coordinate_conversions::convertCartesianToSpherical(
+                positionDifference );
+    BOOST_CHECK_CLOSE_FRACTION(
+                sphericalRelativeCoordinates.z( ) + observationBias->getObservationBias(
+                    std::vector< double >( ), std::vector< basic_mathematics::Vector6d >( ) ).x( ),
+                observationFromReceptionTime( 0 ),
+                std::numeric_limits< double >::epsilon( ) );
+    BOOST_CHECK_CLOSE_FRACTION(
+                mathematical_constants::PI / 2.0 - sphericalRelativeCoordinates.y( ) +
+                observationBias->getObservationBias(
+                    std::vector< double >( ), std::vector< basic_mathematics::Vector6d>( ) ).y( ),
+                observationFromReceptionTime( 1 ),
+                std::numeric_limits< double >::epsilon( ) );
+
+    // Compute transmission time from light time.
+    double transmitterObservationTime = receiverObservationTime - ( linkEndTimes[ 1 ] - linkEndTimes[ 0 ] );
+
+    // Compare computed against returned transmission time.
+    BOOST_CHECK_CLOSE_FRACTION(
+                static_cast< double >( transmitterObservationTime ), linkEndTimes[ 0 ],
+            std::numeric_limits< double >::epsilon( ) );
+
+    // Recompute observable while fixing transmission time.
+    std::vector< double > linkEndTimes2;
+    std::vector< basic_mathematics::Vector6d > linkEndStates2;
+    Eigen::Vector2d observationFromTransmissionTime = observationModel->computeObservations(
+                transmitterObservationTime, transmitter );
+    Eigen::Vector2d observationFromTransmissionTime2 = observationModel->computeObservationsWithLinkEndData(
+                transmitterObservationTime, transmitter, linkEndTimes2, linkEndStates2 );
+
+    // Compare results against those obtained when keeping reception fixed.
+    for( unsigned int i = 0; i < 2; i++ )
+    {
+        BOOST_CHECK_SMALL( observationFromTransmissionTime( i ) - observationFromTransmissionTime2( i ), 1.0E-15 );
+        BOOST_CHECK_SMALL( observationFromTransmissionTime( i ) - observationFromReceptionTime( i ), 1.0E-15 );
+        BOOST_CHECK_CLOSE_FRACTION( linkEndTimes2.at( i ), linkEndTimes2.at( i ), 1.0E-15 );
+    }
+
+
+    // Check consistency of link end states and time.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                linkEndStates2.at( 0 ), bodyMap.at( "Earth" )->getStateInBaseFrameFromEphemeris( linkEndTimes2.at( 0 ) ),
+                std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                linkEndStates2.at( 1 ), bodyMap.at( "Mars" )->getStateInBaseFrameFromEphemeris( linkEndTimes2.at( 1 ) ),
+                std::numeric_limits< double >::epsilon( ) );
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+}
+
+}
+
diff --git a/Tudat/Astrodynamics/ObservationModels/UnitTests/unitTestLightTimeSolution.cpp b/Tudat/Astrodynamics/ObservationModels/UnitTests/unitTestLightTimeSolution.cpp
index 4855643..9d8a0a0 100644
--- a/Tudat/Astrodynamics/ObservationModels/UnitTests/unitTestLightTimeSolution.cpp
+++ b/Tudat/Astrodynamics/ObservationModels/UnitTests/unitTestLightTimeSolution.cpp
@@ -1,37 +1,11 @@
-/*    Copyright (c) 2010-2015, Delft University of Technology
- *    All rights reserved.
- *
- *    Redistribution and use in source and binary forms, with or without modification, are
- *    permitted provided that the following conditions are met:
- *      - Redistributions of source code must retain the above copyright notice, this list of
- *        conditions and the following disclaimer.
- *      - Redistributions in binary form must reproduce the above copyright notice, this list of
- *        conditions and the following disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *      - Neither the name of the Delft University of Technology nor the names of its contributors
- *        may be used to endorse or promote products derived from this software without specific
- *        prior written permission.
- *
- *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
- *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- *    OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *    Changelog
- *      YYMMDD    Author            Comment
- *      130226    D. Dirkx          Migrated from personal code.
- *      130521    E. Brandon        Minor changes during code check.
- *      140127    D. Dirkx          Adapted for custom Spice kernel folder.
- *
- *    References
- *
- *    Notes
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
  *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
  */
 
 #define BOOST_TEST_MAIN
@@ -88,8 +62,8 @@ BOOST_AUTO_TEST_CASE( testLightWithSpice )
                 moon, "SSB", false, false, false, frame );
 
     // Create light-time calculator, Earth center transmitter, Moon center receiver.
-    boost::shared_ptr< LightTimeCalculator > lightTimeEarthToMoon =
-            boost::make_shared< LightTimeCalculator >
+    boost::shared_ptr< LightTimeCalculator< > > lightTimeEarthToMoon =
+            boost::make_shared< LightTimeCalculator< > >
             ( boost::bind( &Ephemeris::getCartesianStateFromEphemeris, earthEphemeris, _1,
                            basic_astrodynamics::JULIAN_DAY_ON_J2000 ),
               boost::bind( &Ephemeris::getCartesianStateFromEphemeris, moonEphemeris, _1,
@@ -182,8 +156,8 @@ BOOST_AUTO_TEST_CASE( testLightWithSpice )
     lightTimeCorrections.push_back( &getTimeDifferenceLightTimeCorrection );
 
     // Create light-time object with correction.
-    boost::shared_ptr< LightTimeCalculator > lightTimeEarthToMoonWithCorrection =
-            boost::make_shared< LightTimeCalculator >
+    boost::shared_ptr< LightTimeCalculator< > > lightTimeEarthToMoonWithCorrection =
+            boost::make_shared< LightTimeCalculator< > >
             ( boost::bind( &Ephemeris::getCartesianStateFromEphemeris, earthEphemeris, _1,
                            basic_astrodynamics::JULIAN_DAY_ON_J2000 ),
               boost::bind( &Ephemeris::getCartesianStateFromEphemeris, moonEphemeris, _1,
@@ -209,7 +183,7 @@ BOOST_AUTO_TEST_CASE( testLightWithSpice )
 
     // Create light-time object with correction, without iterating light-time corrections.
     lightTimeEarthToMoonWithCorrection =
-            boost::make_shared< LightTimeCalculator >
+            boost::make_shared< LightTimeCalculator< > >
             ( boost::bind( &Ephemeris::getCartesianStateFromEphemeris, earthEphemeris, _1,
                            basic_astrodynamics::JULIAN_DAY_ON_J2000 ),
               boost::bind( &Ephemeris::getCartesianStateFromEphemeris, moonEphemeris, _1,
@@ -239,7 +213,7 @@ BOOST_AUTO_TEST_CASE( testLightWithSpice )
 
     // Create light-time object with multiple corrections.
     lightTimeEarthToMoonWithCorrection =
-            boost::make_shared< LightTimeCalculator >
+            boost::make_shared< LightTimeCalculator< > >
             ( boost::bind( &Ephemeris::getCartesianStateFromEphemeris, earthEphemeris, _1,
                            basic_astrodynamics::JULIAN_DAY_ON_J2000 ),
               boost::bind( &Ephemeris::getCartesianStateFromEphemeris, moonEphemeris, _1,
diff --git a/Tudat/Astrodynamics/ObservationModels/UnitTests/unitTestOneWayRangeObservationModel.cpp b/Tudat/Astrodynamics/ObservationModels/UnitTests/unitTestOneWayRangeObservationModel.cpp
new file mode 100644
index 0000000..1be29e2
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/UnitTests/unitTestOneWayRangeObservationModel.cpp
@@ -0,0 +1,181 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#define BOOST_TEST_MAIN
+
+#include <limits>
+#include <string>
+
+#include <boost/format.hpp>
+#include <boost/test/unit_test.hpp>
+#include <boost/make_shared.hpp>
+
+#include "Tudat/Basics/testMacros.h"
+
+#include "Tudat/InputOutput/basicInputOutput.h"
+
+#include "Tudat/SimulationSetup/body.h"
+#include "Tudat/Astrodynamics/ObservationModels/oneWayRangeObservationModel.h"
+#include "Tudat/Astrodynamics/ObservationModels/createObservationModel.h"
+#include "Tudat/SimulationSetup/defaultBodies.h"
+#include "Tudat/SimulationSetup/createBodies.h"
+
+namespace tudat
+{
+namespace unit_tests
+{
+
+using namespace tudat::observation_models;
+using namespace tudat::spice_interface;
+using namespace tudat::ephemerides;
+using namespace tudat::simulation_setup;
+
+
+BOOST_AUTO_TEST_SUITE( test_one_way_range_model )
+
+
+BOOST_AUTO_TEST_CASE( testOneWayRangeModel )
+{
+    std::string kernelsPath = input_output::getSpiceKernelPath( );
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de-403-masses.tpc");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "naif0009.tls");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "pck00009.tpc");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de421.bsp");
+
+    // Define bodies to use.
+    std::vector< std::string > bodiesToCreate;
+    bodiesToCreate.push_back( "Earth" );
+    bodiesToCreate.push_back( "Sun" );
+    bodiesToCreate.push_back( "Mars" );
+
+    // Specify initial time
+    double initialEphemerisTime = 0.0;
+    double finalEphemerisTime = initialEphemerisTime + 7.0 * 86400.0;
+    double maximumTimeStep = 3600.0;
+    double buffer = 10.0 * maximumTimeStep;
+
+    // Create bodies settings needed in simulation
+    std::map< std::string, boost::shared_ptr< BodySettings > > defaultBodySettings =
+            getDefaultBodySettings(
+                bodiesToCreate, initialEphemerisTime - buffer, finalEphemerisTime + buffer );
+
+    // Create bodies
+    NamedBodyMap bodyMap = createBodies( defaultBodySettings );
+
+    setGlobalFrameBodyEphemerides( bodyMap, "SSB", "ECLIPJ2000" );
+
+    // Define link ends for observations.
+    LinkEnds linkEnds;
+    linkEnds[ transmitter ] = std::make_pair( "Earth" , ""  );
+    linkEnds[ receiver ] = std::make_pair( "Mars" , ""  );
+
+    // Create observation model.
+    boost::shared_ptr< ObservationBias< 1 > > observationBias =
+            boost::make_shared< ConstantObservationBias< 1 > >(
+                ( Eigen::Matrix< double, 1, 1 >( ) <<2.56294 ).finished( ) );
+    std::vector< std::string > lightTimePerturbingBodies = boost::assign::list_of( "Sun" );
+    std::vector< boost::shared_ptr< LightTimeCorrectionSettings > > lightTimeCorrectionSettings;
+    lightTimeCorrectionSettings.push_back( boost::make_shared< FirstOrderRelativisticLightTimeCorrectionSettings >(
+                                                lightTimePerturbingBodies ) );
+    boost::shared_ptr< ObservationModel< 1, double, double, double > > observationModel =
+           ObservationModelCreator< 1, double, double, double >::createObservationModel(
+                oneWayRange, linkEnds, bodyMap, lightTimeCorrectionSettings, observationBias );
+
+    // Compute observation separately with two functions.
+    double receiverObservationTime = ( finalEphemerisTime + initialEphemerisTime ) / 2.0;
+    std::vector< double > linkEndTimes;
+    std::vector< basic_mathematics::Vector6d > linkEndStates;
+    double observationFromReceptionTime = observationModel->computeObservations(
+                receiverObservationTime, receiver )( 0 );
+    double observationFromReceptionTime2 = observationModel->computeObservationsWithLinkEndData(
+                receiverObservationTime, receiver, linkEndTimes, linkEndStates )( 0 );
+    BOOST_CHECK_EQUAL( linkEndTimes.size( ), 2 );
+    BOOST_CHECK_EQUAL( linkEndStates.size( ), 2 );
+
+    // Manually create and compute light time corrections
+    boost::shared_ptr< LightTimeCorrection > lightTimeCorrectionCalculator =
+            createLightTimeCorrections(
+                lightTimeCorrectionSettings.at( 0 ), bodyMap, linkEnds[ transmitter ], linkEnds[ receiver ] );
+    double lightTimeCorrection = lightTimeCorrectionCalculator->calculateLightTimeCorrection(
+                linkEndStates.at( 0 ), linkEndStates.at( 1 ), linkEndTimes.at( 0 ), linkEndTimes.at( 1 ) );
+
+    // Check equality of computed observations.
+    BOOST_CHECK_CLOSE_FRACTION(
+                observationFromReceptionTime, observationFromReceptionTime2, std::numeric_limits< double >::epsilon( ) );
+
+    // Check consistency of link end states and time.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                linkEndStates.at( 0 ), bodyMap.at( "Earth" )->getStateInBaseFrameFromEphemeris( linkEndTimes.at( 0 ) ),
+                std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                linkEndStates.at( 1 ), bodyMap.at( "Mars" )->getStateInBaseFrameFromEphemeris( linkEndTimes.at( 1 ) ),
+                std::numeric_limits< double >::epsilon( ) );
+
+    // Check that reception time is kept fixed.
+    BOOST_CHECK_CLOSE_FRACTION( static_cast< double >( receiverObservationTime ),
+                                linkEndTimes[ 1 ], std::numeric_limits< double >::epsilon( ) );
+
+    // Manually compute light time
+    Eigen::Vector3d positionDifference = ( linkEndStates[ 0 ] - linkEndStates[ 1 ] ).segment( 0, 3 );
+    BOOST_CHECK_CLOSE_FRACTION(
+                positionDifference.norm( ) / physical_constants::SPEED_OF_LIGHT + lightTimeCorrection,
+                linkEndTimes[ 1 ] - linkEndTimes[ 0 ],
+                std::numeric_limits< double >::epsilon( ) * 1000.0 );
+                        // Poor tolerance due to rounding errors when subtracting times
+
+    // Check computed range from link end states
+    BOOST_CHECK_CLOSE_FRACTION(
+                positionDifference.norm( ) + lightTimeCorrection * physical_constants::SPEED_OF_LIGHT +
+                observationBias->getObservationBias(
+                    std::vector< double >( ), std::vector< basic_mathematics::Vector6d >( ) )( 0 ),
+                observationFromReceptionTime,
+                std::numeric_limits< double >::epsilon( ) );
+
+    // Compute transmission time from light time.
+    double transmitterObservationTime = receiverObservationTime - ( linkEndTimes[ 1 ] - linkEndTimes[ 0 ] );
+
+    // Compare computed against returned transmission time.
+    BOOST_CHECK_CLOSE_FRACTION(
+                static_cast< double >( transmitterObservationTime ), linkEndTimes[ 0 ],
+            std::numeric_limits< double >::epsilon( ) );
+
+    // Recompute observable while fixing transmission time.
+    std::vector< double > linkEndTimes2;
+    std::vector< basic_mathematics::Vector6d > linkEndStates2;
+    double observationFromTransmissionTime = observationModel->computeObservations(
+                transmitterObservationTime, transmitter )( 0 );
+    double observationFromTransmissionTime2 = observationModel->computeObservationsWithLinkEndData(
+                transmitterObservationTime, transmitter, linkEndTimes2, linkEndStates2 )( 0 );
+
+    // Compare results against those obtained when keeping reception fixed.
+    BOOST_CHECK_SMALL( observationFromTransmissionTime - observationFromTransmissionTime2, 1.0E-15 );
+    BOOST_CHECK_SMALL( observationFromTransmissionTime - observationFromReceptionTime, 1.0E-15 );
+
+    for( unsigned int i = 0; i < 2; i++ )
+    {
+        BOOST_CHECK_CLOSE_FRACTION( linkEndTimes2.at( i ), linkEndTimes2.at( i ), 1.0E-15 );
+    }
+
+
+    // Check consistency of link end states and time.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                linkEndStates2.at( 0 ), bodyMap.at( "Earth" )->getStateInBaseFrameFromEphemeris( linkEndTimes2.at( 0 ) ),
+                std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                linkEndStates2.at( 1 ), bodyMap.at( "Mars" )->getStateInBaseFrameFromEphemeris( linkEndTimes2.at( 1 ) ),
+                std::numeric_limits< double >::epsilon( ) );
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+}
+
+}
+
diff --git a/Tudat/Astrodynamics/ObservationModels/UnitTests/unitTestPositionObservationModel.cpp b/Tudat/Astrodynamics/ObservationModels/UnitTests/unitTestPositionObservationModel.cpp
new file mode 100644
index 0000000..502c5dc
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/UnitTests/unitTestPositionObservationModel.cpp
@@ -0,0 +1,137 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#define BOOST_TEST_MAIN
+
+#include <limits>
+#include <string>
+
+#include <boost/format.hpp>
+#include <boost/test/unit_test.hpp>
+#include <boost/make_shared.hpp>
+
+#include "Tudat/Basics/testMacros.h"
+
+#include "Tudat/InputOutput/basicInputOutput.h"
+
+#include "Tudat/SimulationSetup/body.h"
+#include "Tudat/Astrodynamics/ObservationModels/angularPositionObservationModel.h"
+#include "Tudat/Astrodynamics/ObservationModels/createObservationModel.h"
+#include "Tudat/SimulationSetup/defaultBodies.h"
+#include "Tudat/SimulationSetup/createBodies.h"
+
+namespace tudat
+{
+namespace unit_tests
+{
+
+using namespace tudat::observation_models;
+using namespace tudat::spice_interface;
+using namespace tudat::ephemerides;
+using namespace tudat::simulation_setup;
+
+
+BOOST_AUTO_TEST_SUITE( test_position_obsevable_model )
+
+
+BOOST_AUTO_TEST_CASE( testPositionObsevableModel )
+{
+    std::string kernelsPath = input_output::getSpiceKernelPath( );
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de-403-masses.tpc");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "naif0009.tls");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "pck00009.tpc");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de421.bsp");
+
+    // Define bodies to use.
+    std::vector< std::string > bodiesToCreate;
+    bodiesToCreate.push_back( "Earth" );
+    bodiesToCreate.push_back( "Sun" );
+
+    // Specify initial time
+    double initialEphemerisTime = 0.0;
+    double finalEphemerisTime = initialEphemerisTime + 7.0 * 86400.0;
+    double maximumTimeStep = 3600.0;
+    double buffer = 10.0 * maximumTimeStep;
+
+    // Create bodies settings needed in simulation
+    std::map< std::string, boost::shared_ptr< BodySettings > > defaultBodySettings =
+            getDefaultBodySettings(
+                bodiesToCreate, initialEphemerisTime - buffer, finalEphemerisTime + buffer );
+
+    // Create bodies
+    NamedBodyMap bodyMap = createBodies( defaultBodySettings );
+
+    setGlobalFrameBodyEphemerides( bodyMap, "SSB", "ECLIPJ2000" );
+
+    // Define link ends for observations.
+    LinkEnds linkEnds;
+    linkEnds[ observed_body ] = std::make_pair( "Earth" , ""  );
+
+    // Create observation model.
+    boost::shared_ptr< ObservationBias< 3 > > observationBias =
+            boost::make_shared< ConstantObservationBias< 3 > >(
+                ( Eigen::Vector3d( ) << 543.2454, -34.244, 3431.24345 ).finished( ) );
+
+    boost::shared_ptr< ObservationModel< 3, double, double, double > > observationModel =
+           ObservationModelCreator< 3, double, double, double >::createObservationModel(
+                position_observable, linkEnds, bodyMap,
+                std::vector< boost::shared_ptr< LightTimeCorrectionSettings > >( ), observationBias );
+
+    // Compute observation separately with two functions.
+    double observationTime = ( finalEphemerisTime + initialEphemerisTime ) / 2.0;
+    std::vector< double > linkEndTimes;
+    std::vector< basic_mathematics::Vector6d > linkEndStates;
+    Eigen::Vector3d observation = observationModel->computeObservations(
+                observationTime, observed_body );
+    Eigen::Vector3d observation2 = observationModel->computeObservationsWithLinkEndData(
+                observationTime, observed_body, linkEndTimes, linkEndStates );
+
+    // Check size of link end state/time.
+    BOOST_CHECK_EQUAL( linkEndTimes.size( ), 1 );
+    BOOST_CHECK_EQUAL( linkEndStates.size( ), 1 );
+
+    // Check link end state/time.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                bodyMap.at( "Earth" )->getStateInBaseFrameFromEphemeris( observationTime ),
+                linkEndStates[ 0 ], std::numeric_limits< double >::epsilon( ) );
+    BOOST_CHECK_CLOSE_FRACTION( observationTime, linkEndTimes[ 0 ], std::numeric_limits< double >::epsilon( ) );
+
+    // Check biased observable
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                ( bodyMap.at( "Earth" )->getStateInBaseFrameFromEphemeris( observationTime ).segment( 0, 3 ) +
+                observationBias->getObservationBias(
+                      std::vector< double >( ), std::vector< basic_mathematics::Vector6d>( ) ) ),
+                observation, std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                observation, observation2, std::numeric_limits< double >::epsilon( ) );
+
+    // Check ideal observable
+    observation = observationModel->computeIdealObservations(
+                observationTime, observed_body );
+    observation2 = observationModel->computeIdealObservationsWithLinkEndData(
+                observationTime, observed_body, linkEndTimes, linkEndStates );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                bodyMap.at( "Earth" )->getStateInBaseFrameFromEphemeris( observationTime ),
+                linkEndStates[ 0 ], std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                bodyMap.at( "Earth" )->getStateInBaseFrameFromEphemeris( observationTime ).segment( 0, 3 ),
+                observation, std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                observation, observation2, std::numeric_limits< double >::epsilon( ) );
+    BOOST_CHECK_CLOSE_FRACTION( observationTime, linkEndTimes[ 0 ], std::numeric_limits< double >::epsilon( ) );
+
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+}
+
+}
+
diff --git a/Tudat/Astrodynamics/ObservationModels/angularPositionObservationModel.h b/Tudat/Astrodynamics/ObservationModels/angularPositionObservationModel.h
new file mode 100644
index 0000000..d277cb4
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/angularPositionObservationModel.h
@@ -0,0 +1,156 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_ANGULARPOSITIONOBSERVATIONMODEL_H
+#define TUDAT_ANGULARPOSITIONOBSERVATIONMODEL_H
+
+#include <map>
+#include <string>
+
+#include <Eigen/Core>
+
+#include "Tudat/Mathematics/BasicMathematics/coordinateConversions.h"
+#include "Tudat/Astrodynamics/ObservationModels/createLightTimeCalculator.h"
+#include "Tudat/Astrodynamics/ObservationModels/lightTimeSolution.h"
+#include "Tudat/Astrodynamics/ObservationModels/observationModel.h"
+
+namespace tudat
+{
+
+namespace observation_models
+{
+
+//! Class for simulating angular position (right ascension/declination) observables.
+/*!
+ *  Class for simulating angular position (right ascension/declination), using light-time (with light-time corrections)
+ *  to determine the states of the link ends (source and receiver).
+ *  The user may add observation biases to model system-dependent deviations between measured and true observation.
+ */
+template< typename ObservationScalarType = double, typename TimeType = double, typename StateScalarType = ObservationScalarType >
+class AngularPositionObservationModel: public ObservationModel< 2, ObservationScalarType, TimeType, StateScalarType >
+{
+public:
+
+    typedef Eigen::Matrix< StateScalarType, 6, 1 > StateType;
+    typedef Eigen::Matrix< StateScalarType, 6, 1 > PositionType;
+
+    //! Constructor.
+    /*!
+     *  Constructor,
+     *  \param lightTimeCalculator Object to compute the light-time (including any corrections w.r.t. Euclidean case)
+     *  between source and receiver
+     *  \param observationBiasCalculator Object for calculating system-dependent errors in the
+     *  observable, i.e. deviations from the physically ideal observable between reference points (default none).
+     */
+    AngularPositionObservationModel(
+            const boost::shared_ptr< observation_models::LightTimeCalculator< ObservationScalarType, TimeType, StateScalarType > > lightTimeCalculator,
+            const boost::shared_ptr< ObservationBias< 2 > > observationBiasCalculator = NULL ):
+        ObservationModel< 2, ObservationScalarType, TimeType, StateScalarType >( angular_position, observationBiasCalculator ),
+        lightTimeCalculator_( lightTimeCalculator ) { }
+
+    //! Destructor
+    ~AngularPositionObservationModel( ){ }
+
+    //! Function to compute ideal angular position observation at given time.
+    /*!
+     *  This function compute ideal angular position observation at a given time. The time argument can be either the
+     *  reception or transmission time (defined by linkEndAssociatedWithTime input).
+     *  Note that this observable does include e.g. light-time corrections, which represent physically true corrections.
+     *  It does not include e.g. system-dependent measurement.
+     *  The times and states of the link ends are also returned in full precision (determined by class template
+     *  arguments). These states and times are returned by reference.
+     *  \param time Time at which observation is to be simulated
+     *  \param linkEndAssociatedWithTime Link end at which given time is valid, i.e. link end for which associated time
+     *  is kept constant (to input value)
+     *  \param linkEndTimes List of times at each link end during observation (returned by reference).
+     *  \param linkEndStates List of states at each link end during observation (returned by reference).
+     *  \return Calculated angular position observable values.
+     */
+    Eigen::Matrix< ObservationScalarType, 2, 1 > computeIdealObservationsWithLinkEndData(
+                    const TimeType time,
+                    const LinkEndType linkEndAssociatedWithTime,
+                    std::vector< TimeType >& linkEndTimes,
+                    std::vector< Eigen::Matrix< StateScalarType, 6, 1 > >& linkEndStates )
+
+    {
+        // Check link end associated with input time and compute observable
+        bool isTimeAtReception;
+        if( linkEndAssociatedWithTime == receiver )
+        {
+            isTimeAtReception = 1;
+        }
+        else if( linkEndAssociatedWithTime == transmitter )
+        {
+            isTimeAtReception = 0;
+        }
+        else
+        {
+            isTimeAtReception = -1;
+            std::cerr<<"Error when calculating angular position observation, link end is not transmitter or receiver"<<std::endl;
+        }
+
+        Eigen::Matrix< StateScalarType, 6, 1 > receiverState;
+        Eigen::Matrix< StateScalarType, 6, 1 > transmitterState;
+
+        // Compute light-time and receiver/transmitter states.
+        ObservationScalarType lightTime = lightTimeCalculator_->calculateLightTimeWithLinkEndsStates(
+                    receiverState, transmitterState, time, isTimeAtReception );
+
+        // Compute spherical relative position
+        Eigen::Matrix< ObservationScalarType, 3, 1 > sphericalRelativeCoordinates =
+                coordinate_conversions::convertCartesianToSpherical< StateScalarType >(
+                    transmitterState.segment( 0, 3 ) - receiverState.segment( 0, 3 ) ).
+                template cast< ObservationScalarType >( );
+
+        // Set link end times and states.
+        linkEndTimes.clear( );
+        linkEndStates.clear( );
+        linkEndStates.push_back( transmitterState );
+        linkEndStates.push_back( receiverState );
+
+        if( isTimeAtReception )
+        {
+            linkEndTimes.push_back( time - lightTime );
+            linkEndTimes.push_back( time );
+        }
+        else
+        {
+            linkEndTimes.push_back( time );
+            linkEndTimes.push_back( time + lightTime );
+        }
+
+        // Return observable
+        return ( Eigen::Matrix< ObservationScalarType, 2, 1 >( ) << sphericalRelativeCoordinates.z( ),
+                 mathematical_constants::PI / 2.0 - sphericalRelativeCoordinates.y( ) ).finished( );
+    }
+
+    //! Function to get the object to calculate light time.
+    /*!
+     * Function to get the object to calculate light time.
+     * \return Object to calculate light time.
+     */    boost::shared_ptr< observation_models::LightTimeCalculator< ObservationScalarType, TimeType, StateScalarType > > getLightTimeCalculator( )
+    {
+        return lightTimeCalculator_;
+    }
+
+private:
+
+    //! Object to calculate light time.
+    /*!
+     *  Object to calculate light time, including possible corrections from troposphere, relativistic corrections, etc.
+     */
+    boost::shared_ptr< observation_models::LightTimeCalculator< ObservationScalarType, TimeType, StateScalarType > > lightTimeCalculator_;
+};
+
+}
+
+}
+
+#endif // TUDAT_ANGULARPOSITIONOBSERVATIONMODEL_H
diff --git a/Tudat/Astrodynamics/ObservationModels/createLightTimeCalculator.h b/Tudat/Astrodynamics/ObservationModels/createLightTimeCalculator.h
new file mode 100644
index 0000000..23b14f4
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/createLightTimeCalculator.h
@@ -0,0 +1,92 @@
+
+#ifndef TUDAT_CREATELIGHTTIMECALCULATOR_H
+#define TUDAT_CREATELIGHTTIMECALCULATOR_H
+
+#include "Tudat/Astrodynamics/ObservationModels/lightTimeSolution.h"
+#include "Tudat/Astrodynamics/ObservationModels/linkTypeDefs.h"
+#include "Tudat/Astrodynamics/ObservationModels/ObservableCorrections/createLightTimeCorrection.h"
+#include "Tudat/SimulationSetup/body.h"
+
+namespace tudat
+{
+namespace observation_models
+{
+
+//! Function to create a light-time calculation object
+/*!
+ *  Function to create a light-time calculation object from light time correction settings environment and link end
+ *  state functions.
+ *  \param transmitterCompleteEphemeris Function returning the transmitter Cartesian state as a function of time.
+ *  \param receiverCompleteEphemeris Function returning the receiver Cartesian state as a function of time.
+ *  \param bodyMap List of body objects that comprises the environment
+ *  \param lightTimeCorrections List of light time corrections (w.r.t. Euclidean distance) that are applied when computing
+ *  light time.
+ *  \param transmittingLinkEnd Identifier for transmitting link end.
+ *  \param receivingLinkEnd Identifier for receiving link end.
+ */
+template< typename ObservationScalarType = double, typename TimeType = double,
+          typename StateScalarType = ObservationScalarType >
+boost::shared_ptr< observation_models::LightTimeCalculator< ObservationScalarType, TimeType, StateScalarType > >
+createLightTimeCalculator(
+        const boost::function< Eigen::Matrix< StateScalarType, 6, 1 >( const TimeType ) >& transmitterCompleteEphemeris,
+        const boost::function< Eigen::Matrix< StateScalarType, 6, 1 >( const TimeType ) >& receiverCompleteEphemeris,
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const std::vector< boost::shared_ptr< LightTimeCorrectionSettings > >& lightTimeCorrections,
+        const LinkEndId& transmittingLinkEnd,
+        const LinkEndId& receivingLinkEnd )
+{
+    std::vector< LightTimeCorrectionFunction > lightTimeCorrectionFunctions;
+
+    // Create lighttime correction functions from lightTimeCorrections
+    for( unsigned int i = 0; i < lightTimeCorrections.size( ); i++ )
+    {
+        LightTimeCorrectionFunction correctionFunction =
+                boost::bind( &LightTimeCorrection::calculateLightTimeCorrection, createLightTimeCorrections(
+                                        lightTimeCorrections[ i ], bodyMap, transmittingLinkEnd, receivingLinkEnd ),
+                             _1, _2, _3, _4 );
+        lightTimeCorrectionFunctions.push_back(  correctionFunction );
+    }
+
+    // Create light time calculator.
+    return boost::make_shared< LightTimeCalculator< ObservationScalarType, TimeType, StateScalarType > >
+            ( transmitterCompleteEphemeris, receiverCompleteEphemeris, lightTimeCorrectionFunctions );
+}
+
+//! Function to create a light-time calculation object
+/*!
+ *  Function to create a light-time calculation object from light time correction settings environment and link end
+ *  identifiers.
+ *  \param transmittingLinkEnd Identifier for transmitting link end.
+ *  \param receivingLinkEnd Identifier for receiving link end.
+ *  \param bodyMap List of body objects that comprises the environment
+ *  \param lightTimeCorrections List of light time corrections (w.r.t. Euclidean distance) that are applied when computing
+ *  light time.
+ */
+template< typename ObservationScalarType = double, typename TimeType = double,
+          typename StateScalarType = ObservationScalarType >
+boost::shared_ptr< observation_models::LightTimeCalculator< ObservationScalarType, TimeType, StateScalarType > >
+createLightTimeCalculator(
+        const LinkEndId& transmittingLinkEnd,
+        const LinkEndId& receivingLinkEnd,
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const std::vector< boost::shared_ptr< LightTimeCorrectionSettings > >& lightTimeCorrections )
+{
+    // Check input consistency
+   if( transmittingLinkEnd.second != "" || receivingLinkEnd.second != "" )
+   {
+       throw std::runtime_error( "Error, body reference points not yet supported when creating light time calculator" );
+   }
+
+   // Get link end state functions and create light time calculator.
+   return createLightTimeCalculator< ObservationScalarType, TimeType, StateScalarType >(
+               boost::bind( &simulation_setup::Body::getTemplatedStateInBaseFrameFromEphemeris< StateScalarType, TimeType >,
+                            bodyMap.at( transmittingLinkEnd.first ), _1 ),
+               boost::bind( &simulation_setup::Body::getTemplatedStateInBaseFrameFromEphemeris< StateScalarType, TimeType >,
+                            bodyMap.at( receivingLinkEnd.first ), _1 ),
+               bodyMap, lightTimeCorrections, transmittingLinkEnd, receivingLinkEnd );
+}
+
+}
+
+}
+#endif // TUDAT_CREATELIGHTTIMECALCULATOR_H
diff --git a/Tudat/Astrodynamics/ObservationModels/createObservationModel.h b/Tudat/Astrodynamics/ObservationModels/createObservationModel.h
new file mode 100644
index 0000000..ed19360
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/createObservationModel.h
@@ -0,0 +1,289 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_CREATEOBSERVATIONMODEL_H
+#define TUDAT_CREATEOBSERVATIONMODEL_H
+
+#include <map>
+
+#include <boost/function.hpp>
+#include <boost/make_shared.hpp>
+
+
+#include "Tudat/Astrodynamics/ObservationModels/observationModel.h"
+#include "Tudat/Astrodynamics/ObservationModels/linkTypeDefs.h"
+#include "Tudat/Astrodynamics/ObservationModels/ObservableCorrections/createLightTimeCorrection.h"
+#include "Tudat/Astrodynamics/ObservationModels/oneWayRangeObservationModel.h"
+#include "Tudat/Astrodynamics/ObservationModels/angularPositionObservationModel.h"
+#include "Tudat/Astrodynamics/ObservationModels/positionObservationModel.h"
+#include "Tudat/SimulationSetup/body.h"
+
+
+namespace tudat
+{
+
+namespace observation_models
+{
+
+//! Interface class for creating observation models
+/*!
+ *  Interface class for creating observation models. This class is used instead of a single templated free function to
+ *  allow ObservationModel deroved classed with different ObservationSize template arguments to be created using the same
+ *  interface. This class has template specializations for each value of ObservationSize, and contains a single
+ *  createObservationModel function that performs the required operation.
+ */
+template< int ObservationSize = 1, typename ObservationScalarType = double,
+          typename TimeType = double, typename StateScalarType = ObservationScalarType >
+class ObservationModelCreator
+{
+public:
+
+    //! Function to create an observation model.
+    /*!
+     * Function to create an observation model.
+     * \param observableType Type of observation model that is to be created.
+     * \param linkEnds Link ends for observation model that is to be created
+     * \param bodyMap List of body objects that comprises the environment
+     * \param singleObservableCorrections List of light time corrections that are used when computing the observable.
+     * \param observationBiasCalculator
+     * \return Observation model of required settings.
+     */
+    static boost::shared_ptr< observation_models::ObservationModel<
+    ObservationSize, ObservationScalarType, TimeType, StateScalarType > > createObservationModel(
+            const ObservableType observableType,
+            const LinkEnds& linkEnds,
+            const simulation_setup::NamedBodyMap &bodyMap,
+            const std::vector< boost::shared_ptr< LightTimeCorrectionSettings > >& singleObservableCorrections =
+            std::vector< boost::shared_ptr< LightTimeCorrectionSettings > >( ),
+            const boost::shared_ptr< ObservationBias< ObservationSize > > observationBiasCalculator = NULL );
+};
+
+//! Interface class for creating observation models of size 1.
+template< typename ObservationScalarType, typename TimeType, typename StateScalarType >
+class ObservationModelCreator< 1, ObservationScalarType, TimeType, StateScalarType >
+{
+public:
+
+    //! Function to create an observation model of size 1.
+    /*!
+     * Function to create an observation model of size 1.
+     * \param observableType Type of observation model that is to be created.
+     * \param linkEnds Link ends for observation model that is to be created
+     * \param bodyMap List of body objects that comprises the environment
+     * \param singleObservableCorrections List of light time corrections that are used when computing the observable.
+     * \param observationBiasCalculator
+     * \return Observation model of required settings.
+     */
+    static boost::shared_ptr< observation_models::ObservationModel<
+    1, ObservationScalarType, TimeType, StateScalarType > > createObservationModel(
+            const ObservableType observableType,
+            const LinkEnds& linkEnds,
+            const simulation_setup::NamedBodyMap &bodyMap,
+            const std::vector< boost::shared_ptr< LightTimeCorrectionSettings > >& singleObservableCorrections =
+            std::vector< boost::shared_ptr< LightTimeCorrectionSettings > >( ),
+            const boost::shared_ptr< ObservationBias< 1 > > observationBiasCalculator = NULL )
+    {
+        using namespace observation_models;
+
+        boost::shared_ptr< observation_models::ObservationModel<
+                1, ObservationScalarType, TimeType, StateScalarType > > observationModel;
+
+        // Check type of observation model.
+        switch( observableType )
+        {
+        case oneWayRange:
+        {
+            // Check consistency input.
+            if( linkEnds.size( ) != 2 )
+            {
+                std::string errorMessage =
+                        "Error when making 1 way range model, " +
+                        boost::lexical_cast< std::string >( linkEnds.size( ) ) + " link ends found";
+                throw std::runtime_error( errorMessage );
+            }
+            if( linkEnds.count( receiver ) == 0 )
+            {
+                throw std::runtime_error( "Error when making 1 way range model, no receiver found" );
+            }
+            if( linkEnds.count( transmitter ) == 0 )
+            {
+                throw std::runtime_error( "Error when making 1 way range model, no transmitter found" );
+            }
+
+            // Create observation model
+            observationModel = boost::make_shared< OneWayRangeObservationModel<
+                    ObservationScalarType, TimeType, StateScalarType > >(
+                        createLightTimeCalculator< ObservationScalarType, TimeType, StateScalarType >(
+                        linkEnds.at( transmitter ), linkEnds.at( receiver ),
+                        bodyMap, singleObservableCorrections ), observationBiasCalculator );
+
+            break;
+        }
+        default:
+            std::string errorMessage = "Error, observable " + boost::lexical_cast< std::string >( observableType ) +
+                    "  not recognized when making size 1 observation model.";
+            throw std::runtime_error( errorMessage );
+        }
+        return observationModel;
+    }
+};
+
+//! Interface class for creating observation models of size 2.
+template< typename ObservationScalarType, typename TimeType, typename StateScalarType >
+class ObservationModelCreator< 2, ObservationScalarType, TimeType, StateScalarType >
+{
+public:
+
+    //! Function to create an observation model of size 2.
+    /*!
+     * Function to create an observation model of size 2.
+     * \param observableType Type of observation model that is to be created.
+     * \param linkEnds Link ends for observation model that is to be created
+     * \param bodyMap List of body objects that comprises the environment
+     * \param singleObservableCorrections List of light time corrections that are used when computing the observable.
+     * \param observationBiasCalculator
+     * \return Observation model of required settings.
+     */
+    static boost::shared_ptr< observation_models::ObservationModel<
+    2, ObservationScalarType, TimeType, StateScalarType > > createObservationModel(
+            const ObservableType observableType,
+            const LinkEnds& linkEnds,
+            const simulation_setup::NamedBodyMap &bodyMap,
+            const std::vector< boost::shared_ptr< LightTimeCorrectionSettings > >& singleObservableCorrections =
+            std::vector< boost::shared_ptr< LightTimeCorrectionSettings > >( ),
+            const boost::shared_ptr< ObservationBias< 2 > > observationBiasCalculator = NULL )
+    {
+        using namespace observation_models;
+        boost::shared_ptr< observation_models::ObservationModel<
+                2, ObservationScalarType, TimeType, StateScalarType > > observationModel;
+
+        // Check type of observation model.
+        switch( observableType )
+        {
+        case angular_position:
+        {
+            // Check consistency input.
+            if( linkEnds.size( ) != 2 )
+            {
+                std::string errorMessage =
+                        "Error when making angular position model, " +
+                        boost::lexical_cast< std::string >( linkEnds.size( ) ) + " link ends found";
+                throw std::runtime_error( errorMessage );
+            }
+            if( linkEnds.count( receiver ) == 0 )
+            {
+                throw std::runtime_error( "Error when making angular position model, no receiver found" );
+            }
+            if( linkEnds.count( transmitter ) == 0 )
+            {
+                throw std::runtime_error( "Error when making angular position model, no transmitter found" );
+            }
+
+            // Create observation model
+            observationModel = boost::make_shared< AngularPositionObservationModel<
+                    ObservationScalarType, TimeType, StateScalarType > >(
+                        createLightTimeCalculator< ObservationScalarType, TimeType, StateScalarType >(
+                            linkEnds.at( transmitter ), linkEnds.at( receiver ),
+                            bodyMap, singleObservableCorrections ), observationBiasCalculator );
+
+            break;
+        }
+        default:
+            std::string errorMessage = "Error, observable " + boost::lexical_cast< std::string >( observableType ) +
+                    "  not recognized when making size 2 observation model.";
+            throw std::runtime_error( errorMessage );
+            break;
+        }
+
+        return observationModel;
+    }
+};
+
+//! Interface class for creating observation models of size 3.
+template< typename ObservationScalarType, typename TimeType, typename StateScalarType >
+class ObservationModelCreator< 3, ObservationScalarType, TimeType, StateScalarType >
+{
+public:
+
+    //! Function to create an observation model of size 3.
+    /*!
+     * Function to create an observation model of size 3.
+     * \param observableType Type of observation model that is to be created.
+     * \param linkEnds Link ends for observation model that is to be created
+     * \param bodyMap List of body objects that comprises the environment
+     * \param singleObservableCorrections List of light time corrections that are used when computing the observable.
+     * \param observationBiasCalculator
+     * \return Observation model of required settings.
+     */
+    static boost::shared_ptr< observation_models::ObservationModel<
+    3, ObservationScalarType, TimeType, StateScalarType > > createObservationModel(
+            const ObservableType observableType,
+            const LinkEnds& linkEnds,
+            const simulation_setup::NamedBodyMap &bodyMap,
+            const std::vector< boost::shared_ptr< LightTimeCorrectionSettings > >& singleObservableCorrections =
+            std::vector< boost::shared_ptr< LightTimeCorrectionSettings > >( ),
+           const boost::shared_ptr< ObservationBias < 3 > > observationBiasCalculator = NULL )
+    {
+        using namespace observation_models;
+        boost::shared_ptr< observation_models::ObservationModel<
+                3, ObservationScalarType, TimeType, StateScalarType > > observationModel;
+
+        // Check type of observation model.
+        switch( observableType )
+        {
+        case position_observable:
+        {
+            // Check consistency input.
+            if( linkEnds.size( ) != 1 )
+            {
+                std::string errorMessage =
+                        "Error when making position observable model, " +
+                        boost::lexical_cast< std::string >( linkEnds.size( ) ) + " link ends found";
+                throw std::runtime_error( errorMessage );
+            }
+
+            if( linkEnds.count( observed_body ) == 0 )
+            {
+                throw std::runtime_error( "Error when making position observable model, no observed_body found" );
+            }
+
+            if( singleObservableCorrections.size( ) > 0 )
+            {
+                throw std::runtime_error( "Error when making position observable model, found light time corrections" );
+            }
+            if( linkEnds.at( observed_body ).second != "" )
+            {
+                throw std::runtime_error( "Error, cannot yet create position function for reference point" );
+            }
+
+            // Create observation model
+            observationModel = boost::make_shared< PositionObservationModel<
+                    ObservationScalarType, TimeType, StateScalarType > >(
+                        boost::bind( &simulation_setup::Body::getTemplatedStateInBaseFrameFromEphemeris<
+                                     StateScalarType, TimeType >,
+                                     bodyMap.at( linkEnds.at( observed_body ).first ), _1 ), observationBiasCalculator );
+
+            break;
+        }
+        default:
+            std::string errorMessage = "Error, observable " + boost::lexical_cast< std::string >( observableType ) +
+                    "  not recognized when making size 3 observation model.";
+            throw std::runtime_error( errorMessage );
+            break;
+        }
+        return observationModel;
+    }
+};
+
+}
+
+}
+
+#endif // TUDAT_CREATEOBSERVATIONMODEL_H
diff --git a/Tudat/Astrodynamics/ObservationModels/lightTimeSolution.cpp b/Tudat/Astrodynamics/ObservationModels/lightTimeSolution.cpp
index a5453ca..ce7ae97 100644
--- a/Tudat/Astrodynamics/ObservationModels/lightTimeSolution.cpp
+++ b/Tudat/Astrodynamics/ObservationModels/lightTimeSolution.cpp
@@ -1,38 +1,14 @@
-/*    Copyright (c) 2010-2015, Delft University of Technology
- *    All rights reserved.
- *
- *    Redistribution and use in source and binary forms, with or without modification, are
- *    permitted provided that the following conditions are met:
- *      - Redistributions of source code must retain the above copyright notice, this list of
- *        conditions and the following disclaimer.
- *      - Redistributions in binary form must reproduce the above copyright notice, this list of
- *        conditions and the following disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *      - Neither the name of the Delft University of Technology nor the names of its contributors
- *        may be used to endorse or promote products derived from this software without specific
- *        prior written permission.
- *
- *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
- *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- *    OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *    Changelog
- *      YYMMDD    Author            Comment
- *      130226    D. Dirkx          Migrated from personal code.
- *      130522    E.D. Brandon      Minor changes during code check.
- *
- *    References
- *
- *    Notes
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
  *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
  */
 
+
 #include <iostream>
 
 #include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
@@ -44,165 +20,33 @@ namespace tudat
 namespace observation_models
 {
 
-//! Function to calculate the light time.
-double LightTimeCalculator::calculateLightTime( const double ephemerisTime,
-                                                const bool isTimeAtReception,
-                                                const double tolerance )
-{
-    // Declare and initialize variables for receiver and transmitter state (returned by reference).
-    basic_mathematics::Vector6d receiverState = basic_mathematics::Vector6d::Zero( );
-    basic_mathematics::Vector6d transmitterState = basic_mathematics::Vector6d::Zero( );
-
-    // Calculate light time.
-    const double lightTime = calculateLightTimeWithLinkEndsStates(
-                receiverState, transmitterState, ephemerisTime, isTimeAtReception, tolerance );
-    return lightTime;
-}
 
-//! Function to calculate the 'measured' vector from transmitter to receiver.
-Eigen::Vector3d LightTimeCalculator::calculateRelativeRangeVector( const double ephemerisTime,
-                                                                   const bool isTimeAtReception,
-                                                                   const double tolerance )
+//! Function to retrieve the default tolerance for the light-time equation solution.
+template< >
+double getDefaultLightTimeTolerance< double, double >( )
 {
-    // Declare and initialize variables for receiver and transmitter state (returned by reference).
-    basic_mathematics::Vector6d receiverState = basic_mathematics::Vector6d::Zero( );
-    basic_mathematics::Vector6d transmitterState = basic_mathematics::Vector6d::Zero( );
-
-    // Calculate link end states and the determine range vector.
-    calculateLightTimeWithLinkEndsStates( receiverState, transmitterState,
-                                          ephemerisTime, isTimeAtReception, tolerance );
-    return ( receiverState - transmitterState ).segment( 0, 3 );
+    return 1.0E-12;
 }
 
-//! Function to calculate the light time and link-ends states.
-double LightTimeCalculator::calculateLightTimeWithLinkEndsStates(
-        basic_mathematics::Vector6d& receiverStateOutput,
-        basic_mathematics::Vector6d& transmitterStateOutput,
-        const double ephemerisTime,
-        const bool isTimeAtReception,
-        const double tolerance )
+//! Function to retrieve the default tolerance for the light-time equation solution.
+template< >
+long double getDefaultLightTimeTolerance< long double, long double >( )
 {
-    using physical_constants::SPEED_OF_LIGHT;
-    using std::fabs;
-
-    // Initialize reception and transmission times and states to initial guess (zero light time)
-    double receptionTime = ephemerisTime;
-    double transmissionTime = ephemerisTime;
-    basic_mathematics::Vector6d receiverState = stateFunctionOfReceivingBody_( receptionTime );
-    basic_mathematics::Vector6d transmitterState =
-            stateFunctionOfTransmittingBody_( transmissionTime );
-
-    // Set initial light-time correction.
-    setTotalLightTimeCorrection(
-                transmitterState, receiverState, transmissionTime, receptionTime );
-
-    // Calculate light-time solution assuming infinte speed of signal as initial estimate.
-    double previousLightTimeCalculation =
-            calculateNewLightTimeEstime( receiverState, transmitterState );
-
-    // Set variables for iteration
-    double newLightTimeCalculation = 0.0;
-    bool isToleranceReached = false;
-
-    // Recalculate light-time solution until tolerance is reached.
-    int counter = 0;
-
-    // Set variable determining whether to update the light time each iteration.
-    bool updateLightTimeCorrections = false;
-    if( iterateCorrections_ )
-    {
-        updateLightTimeCorrections = true;
-    }
-
-    // Iterate until tolerance reached.
-    while( !isToleranceReached )
-    {
-        // Update light-time corrections, if necessary.
-        if( updateLightTimeCorrections )
-        {
-            setTotalLightTimeCorrection(
-                        transmitterState, receiverState, transmissionTime, receptionTime );
-        }
-
-        // Update light-time estimate for this iteration.
-        if( isTimeAtReception )
-        {
-            receptionTime = ephemerisTime;
-            transmissionTime = ephemerisTime - previousLightTimeCalculation;
-            transmitterState = ( stateFunctionOfTransmittingBody_( transmissionTime ) );
-        }
-        else
-        {
-            receptionTime = ephemerisTime + previousLightTimeCalculation;
-            transmissionTime = ephemerisTime;
-            receiverState = ( stateFunctionOfReceivingBody_( receptionTime ) );
-        }
-        newLightTimeCalculation = calculateNewLightTimeEstime( receiverState, transmitterState );
-
-        // Check for convergence.
-        if( fabs( newLightTimeCalculation - previousLightTimeCalculation ) < tolerance )
-        {
-            // If convergence reached, but light-time corrections not iterated,
-            // perform 1 more iteration to check for change in correction.
-            if( !updateLightTimeCorrections )
-            {
-                updateLightTimeCorrections = true;
-            }
-            else
-            {
-                isToleranceReached = true;
-            }
-        }
-        else
-        {
-            // Get out of infinite loop (for instance due to low accuracy state functions,
-            // to stringent tolerance or limit case for trop. corrections).
-            if( counter == 20 )
-            {
-                isToleranceReached = true;
-                std::cerr << "Warning, light time unconverged at level " <<
-                             fabs( newLightTimeCalculation - previousLightTimeCalculation )
-                          << std::endl << "Current light-time corrections are: " <<
-                           currentCorrection_<< " and input time was " << ephemerisTime
-                          << std::endl;
-            }
-
-            // Update light time for new iteration.
-            previousLightTimeCalculation = newLightTimeCalculation;
-        }
-
-        counter++;
-    }
-
-    // Set output variables and return the light time.
-    receiverStateOutput = receiverState;
-    transmitterStateOutput = transmitterState;
-    return newLightTimeCalculation;
+    return 1.0E-15L;
 }
 
-//! Function to reset the currentCorrection_ variable during current iteration.
-void LightTimeCalculator::setTotalLightTimeCorrection(
-        const basic_mathematics::Vector6d& transmitterState,
-        const basic_mathematics::Vector6d& receiverState,
-        const double transmissionTime,
-        const double receptionTime )
+//! Function to retrieve the default tolerance for the light-time equation solution.
+template< >
+double getDefaultLightTimeTolerance< double, long double >( )
 {
-    double totalLightTimeCorrections = 0.0;
-    for( unsigned int i = 0; i < correctionFunctions_.size( ); i++ )
-    {
-        totalLightTimeCorrections += correctionFunctions_[ i ]
-                ( transmitterState, receiverState, transmissionTime, receptionTime );
-    }
-    currentCorrection_ = totalLightTimeCorrections;
+    return 1.0E-12;
 }
 
-//! Function to calculate a new light-time estimate from the link-ends states.
-double LightTimeCalculator::calculateNewLightTimeEstime(
-        basic_mathematics::Vector6d receiverState,
-        basic_mathematics::Vector6d transmitterState ) const
+//! Function to retrieve the default tolerance for the light-time equation solution.
+template< >
+long double getDefaultLightTimeTolerance< long double, double >( )
 {
-    return ( receiverState - transmitterState ).segment( 0, 3 ).norm( ) /
-            physical_constants::SPEED_OF_LIGHT + currentCorrection_;
+    return 1.0E-12L;
 }
 
 } // namespace observation_models
diff --git a/Tudat/Astrodynamics/ObservationModels/lightTimeSolution.h b/Tudat/Astrodynamics/ObservationModels/lightTimeSolution.h
index 88905d0..5290d73 100644
--- a/Tudat/Astrodynamics/ObservationModels/lightTimeSolution.h
+++ b/Tudat/Astrodynamics/ObservationModels/lightTimeSolution.h
@@ -1,36 +1,11 @@
-/*    Copyright (c) 2010-2015, Delft University of Technology
- *    All rights reserved.
- *
- *    Redistribution and use in source and binary forms, with or without modification, are
- *    permitted provided that the following conditions are met:
- *      - Redistributions of source code must retain the above copyright notice, this list of
- *        conditions and the following disclaimer.
- *      - Redistributions in binary form must reproduce the above copyright notice, this list of
- *        conditions and the following disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *      - Neither the name of the Delft University of Technology nor the names of its contributors
- *        may be used to endorse or promote products derived from this software without specific
- *        prior written permission.
- *
- *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
- *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- *    OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *    Changelog
- *      YYMMDD    Author            Comment
- *      130226    D. Dirkx          Migrated from personal code.
- *      130522    E.D. Brandon      Minor changes during code check.
- *
- *    References
- *
- *    Notes
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
  *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
  */
 
 #ifndef TUDAT_LIGHT_TIME_SOLUTIONS_H
@@ -38,20 +13,33 @@
 
 
 #include <boost/function.hpp>
+#include <boost/lexical_cast.hpp>
 
+#include <iostream>
 #include <map>
 #include <vector>
 
 #include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
 
 namespace tudat
 {
 namespace observation_models
 {
 
+//! Function to retrieve the default tolerance for the light-time equation solution.
+/*!
+ *  Function to retrieve the default tolerance for the light-time equation solution. This tolerance denotes the
+ *  difference between two subsequent light time solutions (in s) that is deemed acceptable for convergence/
+ *  \return Default light-time tolerance for given template arguments.
+ */
+template< typename ObservationScalarType = double, typename StateScalarType = ObservationScalarType >
+ObservationScalarType getDefaultLightTimeTolerance( );
+
+
 //! Typedef for function calculating light-time correction in light-time calculation loop.
 typedef boost::function< double(
-        const basic_mathematics::Vector6d, const basic_mathematics::Vector6d,
+        const basic_mathematics::Vector6d&, const basic_mathematics::Vector6d&,
         const double, const double ) > LightTimeCorrectionFunction;
 
 //! Class to calculate the light time between two points.
@@ -61,10 +49,16 @@ typedef boost::function< double(
  *  relatvistic corrections) can be applied. The motion of the ends of the link during the
  *  light time is taken into account in the calculations.
  */
+template< typename ObservationScalarType = double,
+          typename TimeType = double,
+          typename StateScalarType = ObservationScalarType >
 class LightTimeCalculator
 {
 public:
 
+
+    typedef Eigen::Matrix< StateScalarType, 6, 1 > StateType;
+    typedef Eigen::Matrix< StateScalarType, 3, 1 > PositionType;
     //! Class constructor.
     /*!
      *  This constructor is used to initialize the state functions and light-time correction
@@ -76,10 +70,8 @@ public:
      *  correction during each iteration.
      */
     LightTimeCalculator(
-            const boost::function< basic_mathematics::Vector6d( const double ) >
-            positionFunctionOfTransmittingBody,
-            const boost::function< basic_mathematics::Vector6d( const double ) >
-            positionFunctionOfReceivingBody,
+            const boost::function< StateType( const TimeType ) > positionFunctionOfTransmittingBody,
+            const boost::function< StateType( const TimeType ) > positionFunctionOfReceivingBody,
             const std::vector< LightTimeCorrectionFunction > correctionFunctions =
             std::vector< LightTimeCorrectionFunction >( ),
             const bool iterateCorrections = false ):
@@ -93,30 +85,52 @@ public:
     /*!
      *  This function calculates the light time between the link ends defined in the constructor.
      *  The input time can be either at transmission or at reception (default) time.
-     *  \param ephemerisTime Time at reception or transmission.
+     *  \param time Time at reception or transmission.
      *  \param isTimeAtReception True if input time is at reception, false if at transmission.
      *  \param tolerance Maximum allowed light-time difference between two subsequent iterations
      *  for which solution is accepted.
      *  \return The value of the light time between the link ends.
      */
-    double calculateLightTime( const double ephemerisTime,
+    ObservationScalarType calculateLightTime( const TimeType time,
                                const bool isTimeAtReception = true,
-                               const double tolerance = 1.0E-12 );
+                               const ObservationScalarType tolerance =
+            getDefaultLightTimeTolerance< ObservationScalarType, StateScalarType >( ) )
+    {
+        // Declare and initialize variables for receiver and transmitter state (returned by reference).
+        StateType receiverState;
+        StateType transmitterState;
+
+        // Calculate light time.
+        ObservationScalarType lightTime = calculateLightTimeWithLinkEndsStates(
+                    receiverState, transmitterState, time, isTimeAtReception, tolerance );
+        return lightTime;
+    }
 
     //! Function to calculate the 'measured' vector from transmitter to receiver.
     /*!
      *  Function to calculate the vector from transmitter at transmitter time to receiver at
      *  reception time.
      *  The input time can be either at transmission or reception (default) time.
-     *  \param ephemerisTime Time at reception or transmission.
+     *  \param time Time at reception or transmission.
      *  \param isTimeAtReception True if input time is at reception, false if at transmission.
      *  \param tolerance Maximum allowed light-time difference between two subsequent iterations
      *  for which solution is accepted.
      *  \return The vector from the transmitter to the reciever.
      */
-    Eigen::Vector3d calculateRelativeRangeVector( const double ephemerisTime,
-                                                  const bool isTimeAtReception = true,
-                                                  const double tolerance = 1.0E-12 );
+    PositionType calculateRelativeRangeVector( const TimeType time,
+                                               const bool isTimeAtReception = 1 ,
+                                               const ObservationScalarType tolerance =
+            getDefaultLightTimeTolerance< ObservationScalarType, StateScalarType >( ) )
+    {
+        // Declare and initialize variables for receiver and transmitter state (returned by reference).
+        StateType receiverState;
+        StateType transmitterState;
+
+        // Calculate link end states and the determine range vector.
+        calculateLightTimeWithLinkEndsStates( receiverState, transmitterState,
+                                              time, isTimeAtReception, tolerance );
+        return ( receiverState - transmitterState ).segment( 0, 3 );
+    }
 
     //! Function to calculate the light time and link-ends states.
     /*!
@@ -125,18 +139,121 @@ public:
      *  The input time can be either at transmission or reception (default) time.
      *  \param receiverStateOutput Output by reference of receiver state.
      *  \param transmitterStateOutput Output by reference of transmitter state.
-     *  \param ephemerisTime Time at reception or transmission.
+     *  \param time Time at reception or transmission.
      *  \param isTimeAtReception True if input time is at reception, false if at transmission.
      *  \param tolerance Maximum allowed light-time difference between two subsequent iterations
      *  for which solution is accepted.
      *  \return The value of the light time between the reciever state and the transmitter state.
      */
-    double calculateLightTimeWithLinkEndsStates(
-            basic_mathematics::Vector6d& receiverStateOutput,
-            basic_mathematics::Vector6d& transmitterStateOutput,
-            const double ephemerisTime,
-            const bool isTimeAtReception = true,
-            const double tolerance = 1.0E-12 );
+    ObservationScalarType calculateLightTimeWithLinkEndsStates(
+            StateType& receiverStateOutput,
+            StateType& transmitterStateOutput,
+            const TimeType time,
+            const bool isTimeAtReception = 1,
+            const ObservationScalarType tolerance =
+            ( getDefaultLightTimeTolerance< ObservationScalarType, StateScalarType >( ) ) )
+    {
+        using physical_constants::SPEED_OF_LIGHT;
+        using std::fabs;
+
+        // Initialize reception and transmission times and states to initial guess (zero light time)
+        TimeType receptionTime = time;
+        TimeType transmissionTime = time;
+        StateType receiverState = stateFunctionOfReceivingBody_( receptionTime );
+        StateType transmitterState =
+                stateFunctionOfTransmittingBody_( transmissionTime );
+
+        // Set initial light-time correction.
+        setTotalLightTimeCorrection(
+                    transmitterState, receiverState, transmissionTime, receptionTime );
+
+        // Calculate light-time solution assuming infinte speed of signal as initial estimate.
+        ObservationScalarType previousLightTimeCalculation =
+                calculateNewLightTimeEstime( receiverState, transmitterState );
+
+        // Set variables for iteration
+        ObservationScalarType newLightTimeCalculation = 0.0;
+        bool isToleranceReached = false;
+
+        // Recalculate light-time solution until tolerance is reached.
+        int counter = 0;
+
+        // Set variable determining whether to update the light time each iteration.
+        bool updateLightTimeCorrections = false;
+        if( iterateCorrections_ )
+        {
+            updateLightTimeCorrections = true;
+        }
+
+        // Iterate until tolerance reached.
+        while( !isToleranceReached )
+        {
+            // Update light-time corrections, if necessary.
+            if( updateLightTimeCorrections )
+            {
+                setTotalLightTimeCorrection(
+                            transmitterState, receiverState, transmissionTime, receptionTime );
+            }
+
+            // Update light-time estimate for this iteration.
+            if( isTimeAtReception )
+            {
+                receptionTime = time;
+                transmissionTime = time - previousLightTimeCalculation;
+                transmitterState = ( stateFunctionOfTransmittingBody_( transmissionTime ) );
+            }
+            else
+            {
+                receptionTime = time + previousLightTimeCalculation;
+                transmissionTime = time;
+                receiverState = ( stateFunctionOfReceivingBody_( receptionTime ) );
+            }
+            newLightTimeCalculation = calculateNewLightTimeEstime( receiverState, transmitterState );
+
+            // Check for convergence.
+            if( fabs( newLightTimeCalculation - previousLightTimeCalculation ) < tolerance )
+            {
+                // If convergence reached, but light-time corrections not iterated,
+                // perform 1 more iteration to check for change in correction.
+                if( !updateLightTimeCorrections )
+                {
+                    updateLightTimeCorrections = true;
+                }
+                else
+                {
+                    isToleranceReached = true;
+                }
+            }
+            else
+            {
+                // Get out of infinite loop (for instance due to low accuracy state functions,
+                // to stringent tolerance or limit case for trop. corrections).
+                if( counter == 20 )
+                {
+                    isToleranceReached = true;
+                    std::string errorMessage  =
+                            "Warning, light time unconverged at level " +
+                            boost::lexical_cast< std::string >(
+                                fabs( newLightTimeCalculation - previousLightTimeCalculation ) ) +
+                            "; current light-time corrections are: "  +
+                            boost::lexical_cast< std::string >( currentCorrection_ ) + " and input time was " +
+                            boost::lexical_cast< std::string >( time );
+                    std::cerr<<errorMessage<<std::endl;
+                }
+
+                // Update light time for new iteration.
+                previousLightTimeCalculation = newLightTimeCalculation;
+            }
+
+            counter++;
+        }
+
+        // Set output variables and return the light time.
+        receiverStateOutput = receiverState;
+        transmitterStateOutput = transmitterState;
+
+        return newLightTimeCalculation;
+    }
 
 protected:
 
@@ -172,9 +289,6 @@ protected:
     bool iterateCorrections_;
 
     //! Current light-time correction.
-    /*!
-     *  Current light-time correction.
-     */
     double currentCorrection_;
 
     //! Function to calculate a new light-time estimate from the link-ends states.
@@ -186,8 +300,14 @@ protected:
      *  \param transmitterState Assumed state of transmitter.
      *  \return New value of the light-time estimate.
      */
-    double calculateNewLightTimeEstime( basic_mathematics::Vector6d receiverState,
-                                        basic_mathematics::Vector6d transmitterState ) const;
+    ObservationScalarType calculateNewLightTimeEstime(
+            const StateType& receiverState,
+            const StateType& transmitterState ) const
+    {
+        return ( ( ( receiverState - transmitterState ).segment( 0, 3 ) ).
+                 template cast< ObservationScalarType >( ) ).norm( ) /
+                physical_constants::getSpeedOfLight< ObservationScalarType >( ) + currentCorrection_;
+    }
 
     //! Function to reset the currentCorrection_ variable during current iteration.
     /*!
@@ -198,10 +318,21 @@ protected:
      *  \param transmissionTime Time at transmission.
      *  \param receptionTime Time at reception.
      */
-    void setTotalLightTimeCorrection( const basic_mathematics::Vector6d& transmitterState,
-                                      const basic_mathematics::Vector6d& receiverState,
-                                      const double transmissionTime,
-                                      const double receptionTime );
+    void setTotalLightTimeCorrection( const StateType& transmitterState,
+                                      const StateType& receiverState,
+                                      const TimeType transmissionTime ,
+                                      const TimeType receptionTime )
+    {
+        ObservationScalarType totalLightTimeCorrections = mathematical_constants::getFloatingInteger< ObservationScalarType >( 0 );
+        for( unsigned int i = 0; i < correctionFunctions_.size( ); i++ )
+        {
+            totalLightTimeCorrections += static_cast< ObservationScalarType >(
+                        correctionFunctions_[ i ](
+                            transmitterState.template cast< double >( ), receiverState.template cast< double >( ),
+                            static_cast< double >( transmissionTime ), static_cast< double >( receptionTime ) ) );
+        }
+        currentCorrection_ = totalLightTimeCorrections;
+    }
 private:
 };
 
diff --git a/Tudat/Astrodynamics/ObservationModels/linkTypeDefs.cpp b/Tudat/Astrodynamics/ObservationModels/linkTypeDefs.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/Tudat/Astrodynamics/ObservationModels/linkTypeDefs.h b/Tudat/Astrodynamics/ObservationModels/linkTypeDefs.h
new file mode 100644
index 0000000..6b8a84b
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/linkTypeDefs.h
@@ -0,0 +1,46 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_LINKTYPEDEFS_H
+#define TUDAT_LINKTYPEDEFS_H
+
+#include <map>
+#include <string>
+#include <vector>
+
+namespace tudat
+{
+
+namespace observation_models
+{
+
+//! Enum defining different link end types.
+/*!
+ *  Enum defining different roles that a given link end can play in an observation model.
+ */
+enum LinkEndType
+{
+    transmitter = 0,
+    reflector = 1,
+    receiver = 2,
+    observed_body = 3
+};
+
+//! Typedef for the identifier of a given link-end (body and reference points)
+typedef std::pair< std::string, std::string > LinkEndId;
+
+//! Typedef for list of link ends, with associated role, used for a single observation (model).
+typedef std::map< LinkEndType, LinkEndId > LinkEnds;
+
+}
+
+}
+
+#endif // TUDAT_LINKTYPEDEFS_H
diff --git a/Tudat/Astrodynamics/ObservationModels/observableTypes.cpp b/Tudat/Astrodynamics/ObservationModels/observableTypes.cpp
new file mode 100644
index 0000000..470b4d4
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/observableTypes.cpp
@@ -0,0 +1,77 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#include <iostream>
+
+#include <boost/lexical_cast.hpp>
+
+#include "Tudat/Astrodynamics/ObservationModels/observableTypes.h"
+
+namespace tudat
+{
+
+namespace observation_models
+{
+
+//! Function to get the name (string) associated with a given observable type.
+std::string getObservableName( const ObservableType observableType )
+{
+    std::string observableName;
+    switch( observableType )
+    {
+    case oneWayRange:
+        observableName = "OneWayRange";
+        break;
+    case angular_position:
+        observableName = "AngularPosition";
+        break;
+    case position_observable:
+        observableName = "CartesianPosition";
+        break;
+    default:
+        std::string errorMessage =
+                "Error, could not find observable type "+ boost::lexical_cast< std::string >( observableType ) +
+                " when getting name from type";
+        throw std::runtime_error( errorMessage );
+    }
+    return observableName;
+}
+
+//! Function to get the observable type.ssociated with the name (string) of observable.
+ObservableType getObservableType( const std::string& observableName )
+{
+    ObservableType observableType;
+
+    if( observableName == "OneWayRange" )
+    {
+        observableType = oneWayRange;
+    }
+    else if( observableName == "AngularPosition" )
+    {
+        observableType = angular_position;
+    }
+    else if( observableName == "CartesianPosition" )
+    {
+        observableType = position_observable;
+    }
+    else
+    {
+        std::string errorMessage =
+                "Error, could not find observable name "+ observableName +
+                " when getting type from name";
+        throw std::runtime_error( errorMessage );
+    }
+
+    return observableType;
+}
+
+}
+
+}
diff --git a/Tudat/Astrodynamics/ObservationModels/observableTypes.h b/Tudat/Astrodynamics/ObservationModels/observableTypes.h
new file mode 100644
index 0000000..fedf6f0
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/observableTypes.h
@@ -0,0 +1,54 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_OBSERVABLETYPES_H
+#define TUDAT_OBSERVABLETYPES_H
+
+#include <string>
+
+#include "Tudat/Astrodynamics/ObservationModels/linkTypeDefs.h"
+
+namespace tudat
+{
+
+namespace observation_models
+{
+
+
+//! Enum for types of observations
+enum ObservableType
+{
+    oneWayRange = 0,
+    angular_position = 1,
+    position_observable = 2
+
+};
+
+//! Function to get the name (string) associated with a given observable type.
+/*!
+ * Function to get the name (string) associated with a given observable type.
+ * \param observableType Type of observable.
+ * \return Name of observable
+ */
+std::string getObservableName( const ObservableType observableType );
+
+//! Function to get the observable type.ssociated with the name (string) of observable.
+/*!
+ * Function to get the observable type.ssociated with the name (string) of observable.
+ * \param observableName of observable
+ * \return observableType Type of observable.
+ */
+ObservableType getObservableType( const std::string& observableName );
+
+}
+
+}
+
+#endif // TUDAT_OBSERVABLETYPES_H
diff --git a/Tudat/Astrodynamics/ObservationModels/observationBias.h b/Tudat/Astrodynamics/ObservationModels/observationBias.h
new file mode 100644
index 0000000..b339c24
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/observationBias.h
@@ -0,0 +1,119 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_OBSERVATIONBIAS_H
+#define TUDAT_OBSERVATIONBIAS_H
+
+#include <iostream>
+#include <vector>
+
+#include <boost/shared_ptr.hpp>
+#include <boost/make_shared.hpp>
+#include <boost/function.hpp>
+
+#include <Eigen/Core>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+
+#include "Tudat/Astrodynamics/ObservationModels/linkTypeDefs.h"
+#include "Tudat/Astrodynamics/ObservationModels/observableTypes.h"
+
+namespace tudat
+{
+
+namespace observation_models
+{
+
+
+//! Base class (non-functional) for describing observation biases
+/*!
+ * Base class (non-functional) for describing observation biases. In this context, an observation bias denotes any deviation
+ * from the ideal observable between two reference points.
+ */
+template< int ObservationSize = 1 >
+class ObservationBias
+{
+public:
+
+    //! Constructor
+    ObservationBias( ){ }
+
+    //! Destructor
+    virtual ~ObservationBias( ){ }
+
+    //! Pure virtual function to retrieve the observation bias.
+    /*!
+     * Pure virtual function to retrieve the observation bias as a function of the observation times and states (which are
+     * typically computed by the ObservationModel)
+     * \param linkEndTimes List of times at each link end during observation.
+     * \param linkEndStates List of states at each link end during observation.
+     * \return Observation bias at given times and states.
+     */
+    virtual Eigen::Matrix< double, ObservationSize, 1 > getObservationBias(
+            const std::vector< double >& linkEndTimes,
+            const std::vector< Eigen::Matrix< double, 6, 1 > >& linkEndStates ) = 0;
+
+    //! Function to return the size of the associated observation
+    /*!
+     * Function to return the size of the associated observation
+     * \return Size of the associated observation
+     */
+    int getObservationSize( )
+    {
+        return ObservationSize;
+    }
+};
+
+//! Class for a constant observation bias of a given size
+template< int ObservationSize = 1 >
+class ConstantObservationBias: public ObservationBias< ObservationSize >
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param observationBias Constant (entry-wise) observation bias.
+     */
+    ConstantObservationBias( const Eigen::Matrix< double, ObservationSize, 1 > observationBias ):
+        observationBias_( observationBias ){ }
+
+    //! Destructor
+    ~ConstantObservationBias( ){ }
+
+    //! Function to retrieve the constant observation bias.
+    /*!
+     * Function to retrieve the constant observation bias.
+     * \param linkEndTimes List of times at each link end during observation (unused).
+     * \param linkEndStates List of states at each link end during observation (unused).
+     * \return Constant observation bias.
+     */
+    Eigen::Matrix< double, ObservationSize, 1 > getObservationBias(
+            const std::vector< double >& linkEndTimes,
+            const std::vector< Eigen::Matrix< double, 6, 1 > >& linkEndStates )
+    {
+        return observationBias_;
+    }
+
+
+private:
+
+    //! Constant (entry-wise) observation bias.
+    Eigen::Matrix< double, ObservationSize, 1 > observationBias_;
+
+};
+
+}
+
+}
+
+#endif // TUDAT_OBSERVATIONMODEL_H
diff --git a/Tudat/Astrodynamics/ObservationModels/observationModel.h b/Tudat/Astrodynamics/ObservationModels/observationModel.h
new file mode 100644
index 0000000..ed9c313
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/observationModel.h
@@ -0,0 +1,239 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_OBSERVATIONMODEL_H
+#define TUDAT_OBSERVATIONMODEL_H
+
+#include <vector>
+
+#include <boost/shared_ptr.hpp>
+#include <boost/function.hpp>
+
+#include <Eigen/Core>
+
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+
+#include "Tudat/Astrodynamics/ObservationModels/linkTypeDefs.h"
+#include "Tudat/Astrodynamics/ObservationModels/observableTypes.h"
+#include "Tudat/Astrodynamics/ObservationModels/observationBias.h"
+
+namespace tudat
+{
+
+namespace observation_models
+{
+
+//! Base class for models of observables (i.e. range, range-rate, etc.).
+/*!
+ *  Base class for models of observables to be used in (for instance) orbit determination.
+ *  Each type of observables (1-way range, 2-way range, Doppler, VLBI, etc.) has its own
+ *  derived class capable of simulating observables of the given type using given link ends.
+ *  The functions to be used for computing the observables can be called with/without deviations from ideal observable
+ *  (see base class member functions). Corrections are computed from an observationBiasCalculator member object, which is
+ *  empty by default. Also, the observable may be a with/without returning (by reference) the times and states
+ *  at each of the link ends. Returning these times/states prevents recomputations of these quantities in later calculations.
+ */
+template< int ObservationSize = Eigen::Dynamic, typename ObservationScalarType = double, typename TimeType = double,
+          typename StateScalarType = ObservationScalarType >
+class ObservationModel
+{
+public:
+
+    //! Constructor
+    /*!
+     * Base class constructor.
+     * \param observableType Type of observable, used for derived class type identification without
+     * explicit casts.
+     * \param observationBiasCalculator Object for calculating system-dependent errors in the
+     * observable, i.e. deviations from the physically ideal observable between reference points (default none).
+     */
+    ObservationModel(
+            const ObservableType observableType ,
+            const boost::shared_ptr< ObservationBias< ObservationSize > > observationBiasCalculator = NULL ):
+        observableType_( observableType ),
+        observationBiasCalculator_( observationBiasCalculator )
+    {
+        // Check if bias is empty
+        if( observationBiasCalculator_ != NULL )
+        {
+            isBiasNull_ = 0;
+            if( observationBiasCalculator_->getObservationSize( ) != ObservationSize )
+            {
+                throw std::runtime_error( "Error when making observation model, bias size is inconsistent" );
+            }
+        }
+        else
+        {
+            isBiasNull_ = 1;
+        }
+    }
+
+    //! Virtual destructor
+    virtual ~ObservationModel( ) { }
+
+    //! Function to return the type of observable.
+    /*!
+     *  Function to return the type of observable.
+     *  \return Type of observable.
+     */
+    ObservableType getObservableType( )
+    {
+        return observableType_;
+    }
+
+    //! Function to compute the observable without any corrections
+    /*!
+     * Function to compute the observable without any corrections, i.e. the ideal physical observable as computed
+     *  from the defined link ends (in the derived class). Note that this observable does include e.g. light-time
+     *  corrections, which represent physically true corrections. It does not include e.g. system-dependent measurement
+     *  errors, such as biases or clock errors.
+     *  The times and states of the link ends are also returned in full precision (determined by class template
+     *  arguments). These states and times are returned by reference.
+     *  \param time Time at which observable is to be evaluated.
+     *  \param linkEndAssociatedWithTime Link end at which given time is valid, i.e. link end for which associated time
+     *  is kept constant (to input value)
+     *  \param linkEndTimes List of times at each link end during observation (returned by reference).
+     *  \param linkEndStates List of states at each link end during observation (returned by reference).
+     *  \return Ideal observable.
+     */
+    virtual Eigen::Matrix< ObservationScalarType, ObservationSize, 1 > computeIdealObservationsWithLinkEndData(
+                const TimeType time,
+                const LinkEndType linkEndAssociatedWithTime,
+                std::vector< TimeType >& linkEndTimes,
+                std::vector< Eigen::Matrix< StateScalarType, 6, 1 > >& linkEndStates ) = 0;
+
+    //! Function to compute full observation at given time.
+    /*!
+     *  Function to compute observation at given time (include any defined non-ideal corrections). The
+     *  times and states of the link ends are given in full precision (determined by class template
+     *  arguments). These states and times are returned by reference.
+     *  \param time Time at which observation is to be simulated
+     *  \param linkEndAssociatedWithTime Link end at which current time is measured, i.e. reference
+     *  link end for observable.
+     *  \param linkEndTimes List of times at each link end during observation (returned by reference).
+     *  \param linkEndStates List of states at each link end during observation (returned by reference).
+     *  \return Calculated observable value.
+     */
+    Eigen::Matrix< ObservationScalarType, ObservationSize, 1 > computeObservationsWithLinkEndData(
+                const TimeType time,
+                const LinkEndType linkEndAssociatedWithTime,
+                std::vector< TimeType >& linkEndTimes ,
+                std::vector< Eigen::Matrix< StateScalarType, 6, 1 > >& linkEndStates )
+    {
+        // Check if any non-ideal models are set.
+        if( isBiasNull_ )
+        {
+            return computeIdealObservationsWithLinkEndData(
+                        time, linkEndAssociatedWithTime, linkEndTimes, linkEndStates );
+        }
+        else
+        {
+            // Compute ideal observable
+            Eigen::Matrix< ObservationScalarType, ObservationSize, 1 > currentObservation =
+                    computeIdealObservationsWithLinkEndData(
+                                            time, linkEndAssociatedWithTime, linkEndTimes, linkEndStates );
+
+            // Add correction
+            return currentObservation +
+                    this->observationBiasCalculator_->getObservationBias( linkEndTimes, linkEndStates ).
+                    template cast< ObservationScalarType >( );
+        }
+    }
+
+    //! Function to compute the observable without any corrections.
+    /*!
+     * Function to compute the observable without any corrections, i.e. the ideal physical observable as computed
+     * from the defined link ends (in the derived class). Note that this observable does include e.g. light-time
+     * corrections, which represent physically true corrections. It does not include e.g. system-dependent measurement
+     * errors, such as biases or clock errors. This function may be redefined in derived class for improved efficiency.
+     * \param time Time at which observable is to be evaluated.
+     * \param linkEndAssociatedWithTime Link end at which given time is valid, i.e. link end for which associated time
+     * is kept constant (to input value)
+     * \return Ideal observable.
+     */
+    virtual Eigen::Matrix< ObservationScalarType, ObservationSize, 1 > computeIdealObservations(
+            const TimeType time,
+            const LinkEndType linkEndAssociatedWithTime )
+    {
+        // Compute ideal observable from derived class.
+        return this->computeIdealObservationsWithLinkEndData(
+                    time, linkEndAssociatedWithTime, this->linkEndTimes_, this->linkEndStates_ );
+    }
+
+    //! Function to compute full observation at given time.
+    /*!
+     *  Function to compute observation at given time (include any defined non-ideal corrections).
+     * \param time Time at which observable is to be evaluated.
+     * \param linkEndAssociatedWithTime Link end at which given time is valid, i.e. link end for which associated time
+     * is kept constant (to input value)
+     *  \return Calculated (non-ideal) observable value.
+     */
+    Eigen::Matrix< ObservationScalarType, ObservationSize, 1 > computeObservations(
+            const TimeType time,
+            const LinkEndType linkEndAssociatedWithTime )
+    {
+        // Check if any non-ideal models are set.
+        if( isBiasNull_ )
+        {
+            return computeObservations( time, linkEndAssociatedWithTime );
+        }
+        else
+        {
+            // Compute ideal observable
+            Eigen::Matrix< ObservationScalarType, ObservationSize, 1 > currentObservation =
+                    computeIdealObservationsWithLinkEndData(
+                                            time, linkEndAssociatedWithTime, linkEndTimes_, linkEndStates_ );
+
+            // Add correction
+            return currentObservation +
+                    this->observationBiasCalculator_->getObservationBias( linkEndTimes_, linkEndStates_ ).
+                    template cast< ObservationScalarType >( );
+        }
+    }
+
+    //! Function to return the size of the observable
+    /*!
+     *  Function to return the size of the observable
+     *  \return Size of the observable
+     */
+    int getObservationSize( )
+    {
+        return ObservationSize;
+    }
+
+protected:
+
+    //! Type of observable, used for derived class type identification without explicit casts.
+    ObservableType observableType_;
+
+    //! Object for calculating system-dependent errors in the observable.
+    /*!
+     *  Object for calculating system-dependent errors in the observable, i.e. deviations from the
+     *  physically true observable
+     */
+    boost::shared_ptr< ObservationBias< ObservationSize > > observationBiasCalculator_;
+
+    //! Boolean set by constructor to denote whether observationBiasCalculator_ is NULL.
+    bool isBiasNull_;
+
+
+    //! Pre-define list of times used when calling function returning link-end states/times from interface function.
+    std::vector< TimeType > linkEndTimes_;
+
+    //! Pre-define list of states used when calling function returning link-end states/times from interface function.
+    std::vector< Eigen::Matrix< StateScalarType, 6, 1 > > linkEndStates_;
+
+};
+
+
+}
+
+}
+#endif // TUDAT_OBSERVATIONMODEL_H
diff --git a/Tudat/Astrodynamics/ObservationModels/oneWayRangeObservationModel.h b/Tudat/Astrodynamics/ObservationModels/oneWayRangeObservationModel.h
new file mode 100644
index 0000000..2d5a5a6
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/oneWayRangeObservationModel.h
@@ -0,0 +1,196 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_ONEWAYRANGEOBSERVATIONMODEL_H
+#define TUDAT_ONEWAYRANGEOBSERVATIONMODEL_H
+
+#include <map>
+
+#include <boost/function.hpp>
+#include <boost/make_shared.hpp>
+
+#include <Eigen/Geometry>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+
+#include "Tudat/Astrodynamics/ObservationModels/createLightTimeCalculator.h"
+#include "Tudat/Astrodynamics/Ephemerides/simpleRotationalEphemeris.h"
+#include "Tudat/Astrodynamics/ObservationModels/observationModel.h"
+#include "Tudat/Astrodynamics/ObservationModels/lightTimeSolution.h"
+#include "Tudat/Astrodynamics/ObservationModels/ObservableCorrections/createLightTimeCorrection.h"
+
+namespace tudat
+{
+
+namespace observation_models
+{
+
+//! Class for simulating one-way range observables.
+/*!
+ *  Class for simulating one-way range, based on light-time and light-time corrections.
+ *  The one-way range is defined as the light time multiplied by speed of light.
+ *  The user may add observation biases to model system-dependent deviations between measured and true observation.
+ */
+template< typename ObservationScalarType = double,
+          typename TimeType = double,
+          typename StateScalarType = ObservationScalarType >
+class OneWayRangeObservationModel: public ObservationModel< 1, ObservationScalarType, TimeType, StateScalarType >
+{
+public:    
+    typedef Eigen::Matrix< StateScalarType, 6, 1 > StateType;
+    typedef Eigen::Matrix< StateScalarType, 3, 1 > PositionType;
+
+    //! Constructor.
+    /*!
+     *  Constructor,
+     *  \param lightTimeCalculator Object to compute the light-time (including any corrections w.r.t. Euclidean case)
+     *  \param observationBiasCalculator Object for calculating system-dependent errors in the
+     *  observable, i.e. deviations from the physically ideal observable between reference points (default none).
+     */
+    OneWayRangeObservationModel(
+            const boost::shared_ptr< observation_models::LightTimeCalculator
+            < ObservationScalarType, TimeType, StateScalarType > > lightTimeCalculator,
+            const boost::shared_ptr< ObservationBias< 1 > > observationBiasCalculator = NULL ):
+        ObservationModel< 1, ObservationScalarType, TimeType, StateScalarType >( oneWayRange, observationBiasCalculator ),
+      lightTimeCalculator_( lightTimeCalculator ){ }
+
+    //! Destructor
+    ~OneWayRangeObservationModel( ){ }
+
+    //! Function to compute ideal one-way range observation at given time.
+    /*!
+     *  This function compute ideal the one-way observation at a given time. The time argument can be either the reception
+     *  or transmission time (defined by linkEndAssociatedWithTime input) Note that this observable does include e.g.
+     *  light-time corrections, which represent physically true corrections.
+     *  It does not include e.g. system-dependent measurement.
+     *  \param time Time at which observation is to be simulated
+     *  \param linkEndAssociatedWithTime Link end at which given time is valid, i.e. link end for which associated time
+     *  is kept constant (to input value)
+     *  \return Calculated observed one-way range value.
+     */
+    Eigen::Matrix< ObservationScalarType, 1, 1 > computeIdealObservations(
+            const TimeType time,
+            const LinkEndType linkEndAssociatedWithTime )
+
+    {
+        // Check link end associated with input time.
+        bool isTimeAtReception = -1;
+        if( linkEndAssociatedWithTime == receiver )
+        {
+            isTimeAtReception = 1;
+        }
+        else if( linkEndAssociatedWithTime == transmitter )
+        {
+            isTimeAtReception = 0;
+        }
+        else
+        {
+            throw std::runtime_error(
+                        "Error when calculating one way range observation, link end is not transmitter or receiver" );
+        }
+
+        // Calculate light-time and multiply by speed of light in vacuum.
+        return ( Eigen::Matrix< ObservationScalarType, 1, 1 >( ) <<
+                 lightTimeCalculator_->calculateLightTime( time, isTimeAtReception ) *
+                 physical_constants::getSpeedOfLight< ObservationScalarType >( ) ).finished( );
+    }
+
+    //! Function to compute one-way range observable without any corrections.
+    /*!
+     *  Function to compute one-way range  observable without any corrections, i.e. the true physical range as computed
+     *  from the defined link ends. Note that this observable does include light-time
+     *  corrections, which represent physically true corrections. It does not include e.g. system-dependent measurement
+     *  errors, such as biases or clock errors.
+     *  The times and states of the link ends are also returned in full precision (determined by class template
+     *  arguments). These states and times are returned by reference.
+     *  \param time Time at which observable is to be evaluated.
+     *  \param linkEndAssociatedWithTime Link end at which given time is valid, i.e. link end for which associated time
+     *  is kept constant (to input value)
+     *  \param linkEndTimes List of times at each link end during observation.
+     *  \param linkEndStates List of states at each link end during observation.
+     *  \return Ideal one-way range observable.
+     */
+    Eigen::Matrix< ObservationScalarType, 1, 1 > computeIdealObservationsWithLinkEndData(
+                    const TimeType time,
+                    const LinkEndType linkEndAssociatedWithTime,
+                    std::vector< TimeType >& linkEndTimes,
+                    std::vector< Eigen::Matrix< StateScalarType, 6, 1 > >& linkEndStates )
+    {
+        ObservationScalarType observation = TUDAT_NAN;
+        TimeType transmissionTime = TUDAT_NAN, receptionTime = TUDAT_NAN;
+
+        // Check link end associated with input time and compute observable
+        switch( linkEndAssociatedWithTime )
+        {
+        case receiver:
+            observation = lightTimeCalculator_->calculateLightTimeWithLinkEndsStates(
+                        receiverState, transmitterState, time, 1 );
+            transmissionTime = time - observation;
+            receptionTime = time;
+            break;
+
+        case transmitter:
+            observation = lightTimeCalculator_->calculateLightTimeWithLinkEndsStates(
+                        receiverState, transmitterState, time, 0 );
+            transmissionTime = time;
+            receptionTime = time + observation;
+            break;
+        default:
+            std::string errorMessage = "Error, cannot have link end type: " +
+                    boost::lexical_cast< std::string >( linkEndAssociatedWithTime ) + "for one-way range";
+            throw std::runtime_error( errorMessage );
+        }
+
+        // Convert light time to range.
+        observation *= physical_constants::getSpeedOfLight< ObservationScalarType >( );
+
+        // Set link end states and times.
+        linkEndTimes.push_back( transmissionTime );
+        linkEndTimes.push_back( receptionTime );
+
+        linkEndStates.push_back( transmitterState);
+        linkEndStates.push_back( receiverState );
+
+        return ( Eigen::Matrix< ObservationScalarType, 1, 1 >( ) << observation ).finished( );
+    }
+
+    //! Function to get the object to calculate light time.
+    /*!
+     * Function to get the object to calculate light time.
+     * \return Object to calculate light time.
+     */
+    boost::shared_ptr< observation_models::LightTimeCalculator< ObservationScalarType, TimeType, StateScalarType > >
+    getLightTimeCalculator( )
+    {
+        return lightTimeCalculator_;
+    }
+
+private:
+
+    //! Object to calculate light time.
+    /*!
+     *  Object to calculate light time, including possible corrections from troposphere, relativistic corrections, etc.
+     */
+    boost::shared_ptr< observation_models::LightTimeCalculator< ObservationScalarType, TimeType, StateScalarType > >
+    lightTimeCalculator_;
+
+    //! Pre-declared receiver state, to prevent many (de-)allocations
+    StateType receiverState;
+
+    //! Pre-declared transmitter state, to prevent many (de-)allocations
+    StateType transmitterState;
+
+};
+
+}
+
+}
+
+#endif // TUDAT_ONEWAYRANGEOBSERVATIONMODEL_H
diff --git a/Tudat/Astrodynamics/ObservationModels/positionObservationModel.h b/Tudat/Astrodynamics/ObservationModels/positionObservationModel.h
new file mode 100644
index 0000000..88ef9e0
--- /dev/null
+++ b/Tudat/Astrodynamics/ObservationModels/positionObservationModel.h
@@ -0,0 +1,113 @@
+#ifndef POSITIONOBSERVATIONMODEL_H
+#define POSITIONOBSERVATIONMODEL_H
+
+#include <boost/bind.hpp>
+#include <boost/function.hpp>
+
+#include "Tudat/Astrodynamics/Ephemerides/ephemeris.h"
+
+#include "Tudat/Astrodynamics/ObservationModels/observationModel.h"
+
+namespace tudat
+{
+
+namespace observation_models
+{
+
+//! Class for simulating observations of three-dimensional position.
+/*!
+ *  Class for simulating observations of three-dimensional position. This observable is typically not realized in
+ *  practice, but its use can be very valuable in simulation studies
+ */
+template< typename ObservationScalarType = double, typename TimeType = double, typename StateScalarType = ObservationScalarType >
+class PositionObservationModel: public ObservationModel< 3, ObservationScalarType, TimeType, StateScalarType >
+{
+public:
+
+    //! Constructor.
+    /*!
+     *  Constructor,
+     *  \param stateFunction Function that returns the Cartesian state of the observed body as a function of time.
+     *  \param observationBiasCalculator Object for calculating system-dependent errors in the
+     *  observable, i.e. deviations from the physically ideal observable (default none).
+     */
+    PositionObservationModel(
+            const boost::function<  Eigen::Matrix< StateScalarType, 6, 1 >( const TimeType& ) > stateFunction,
+            const boost::shared_ptr< ObservationBias< 3 > > observationBiasCalculator = NULL ):
+        ObservationModel< 3, ObservationScalarType, TimeType, StateScalarType >(
+            position_observable, observationBiasCalculator ), stateFunction_( stateFunction ){ }
+
+    //! Destructor
+    ~PositionObservationModel( ) { }
+
+    //! Function to compute ideal position observation at given time.
+    /*!
+     *  This function computes the ideal position observation at a given time (without biases).
+     *  \param time Time at which observation is to be simulated
+     *  \param linkEndAssociatedWithTime Link end at which given time is valid (must be observed_body for this derived class)
+     *  \return Calculated observed position of body.
+     */
+    Eigen::Matrix< ObservationScalarType, 3, 1 > computeIdealObservations(
+            const TimeType time,
+            const LinkEndType linkEndAssociatedWithTime = observed_body )
+    {
+        // Check link end
+        if( linkEndAssociatedWithTime != observed_body )
+        {
+            throw std::runtime_error(
+                        "Error when computing position observable, associated link end must be observed_body " );
+        }
+
+        // Compute and return state.
+        return stateFunction_( time ).segment( 0, 3 );
+    }
+
+    //! Function to compute ideal position observation at given time.
+    /*!
+     *  This function computes the ideal position observation at a given time (without biases).
+     *  The times and states of the link ends are also returned in full precision (determined by class template
+     *  arguments). These states and times are returned by reference.
+     * \param time Time at which observable is to be evaluated.
+     *  \param linkEndAssociatedWithTime Link end at which given time is valid (must be observed_body for this derived class)
+     *  \param linkEndTimes List of times at each link end during observation.
+     *  \param linkEndStates List of states at each link end during observation.
+     *  \return Ideal position observable.
+     */
+    Eigen::Matrix< StateScalarType, 3, 1 > computeIdealObservationsWithLinkEndData(
+                const TimeType time,
+                const LinkEndType linkEndAssociatedWithTime,
+                std::vector< TimeType >& linkEndTimes,
+                std::vector< Eigen::Matrix< StateScalarType, 6, 1 > >& linkEndStates )
+    {
+        // Check link end
+        if( linkEndAssociatedWithTime != observed_body )
+        {
+            throw std::runtime_error(
+                        "Error when computing position observable, associated link end must be observed_body " );
+        }
+
+        // Set link end times and states.
+        linkEndTimes.clear( );
+        linkEndTimes.push_back( static_cast< TimeType >( time ) );
+
+        linkEndStates.clear( );
+        linkEndStates.push_back( stateFunction_( time ).template cast< StateScalarType >( ) );
+
+        // Retrieve position
+        Eigen::Matrix< ObservationScalarType, 3, 1 >  observation = linkEndStates.at( 0 ).segment( 0, 3 );
+
+        return observation;
+    }
+
+
+private:
+
+    //! Function that returns the Cartesian state of the observed body as a function of time.
+    boost::function< Eigen::Matrix< ObservationScalarType, 6, 1 >( const TimeType& ) > stateFunction_;
+};
+
+}
+
+}
+
+#endif // POSITIONOBSERVATIONMODEL_H
diff --git a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/CMakeLists.txt b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/CMakeLists.txt
new file mode 100644
index 0000000..8c51cfb
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/CMakeLists.txt
@@ -0,0 +1,75 @@
+# \file CMakeLists.txt
+ #    This is the CMake file for the MissionSegments sub-directory.
+ #
+ #    Path              : /Astrodynamics/MissionSegments/
+ #    Version           : 3
+ #    Check status      : Checked
+ #
+ #    Author            : S.M. Persson
+ #    Affiliation       : McGill University, Department of Mechanical Engineering
+ #    E-mail address    : mikael.s.persson@gmail.com
+ #
+ #    Author            : K. Kumar
+ #    Affiliation       : Delft University of Technology
+ #    E-mail address    : K.Kumar@tudelft.nl
+ #
+ #    Author            : S.M. Persson
+ #    Affiliation       : McGill University, Department of Mechanical Engineering
+ #    E-mail address    : mikael.s.persson@gmail.com
+ #
+ #    Date created      : 20 August, 2011
+ #    Last modified     : 26 October, 2011
+ #
+ #    References
+ #
+ #    Notes
+ #
+ #    Copyright (c) 2010-2011 Delft University of Technology.
+ #
+ #    This software is protected by national and international copyright.
+ #    Any unauthorized use, reproduction or modification is unlawful and
+ #    will be prosecuted. Commercial and non-private application of the
+ #    software in any form is strictly prohibited unless otherwise granted
+ #    by the authors.
+ #
+ #    The code is provided without any warranty; without even the implied
+ #    warranty of merchantibility or fitness for a particular purpose.
+ #
+ #    Changelog
+ #      YYMMDD    Author            Comment
+ #      110820    S.M. Persson      File created.
+ #      111025    K. Kumar          Adapted file to work with Revision 194.
+ #      111026    K. Kumar          Adapted file so all headers show in project tree in Qt Creator.
+ #/
+
+# Set the source files.
+set(ACCELERATION_PARTIALS_SOURCES
+  "${SRCROOT}${ACCELERATIONPARTIALSDIR}/accelerationPartial.cpp"
+  "${SRCROOT}${ACCELERATIONPARTIALSDIR}/centralGravityAccelerationPartial.cpp"
+  "${SRCROOT}${ACCELERATIONPARTIALSDIR}/numericalAccelerationPartial.cpp"
+  "${SRCROOT}${ACCELERATIONPARTIALSDIR}/radiationPressureAccelerationPartial.cpp"
+)
+
+# Set the header files.
+set(ACCELERATION_PARTIALS_HEADERS
+  "${SRCROOT}${ACCELERATIONPARTIALSDIR}/accelerationPartial.h"
+  "${SRCROOT}${ACCELERATIONPARTIALSDIR}/thirdBodyGravityPartial.h"
+  "${SRCROOT}${ACCELERATIONPARTIALSDIR}/centralGravityAccelerationPartial.h"
+  "${SRCROOT}${ACCELERATIONPARTIALSDIR}/numericalAccelerationPartial.h"
+  "${SRCROOT}${ACCELERATIONPARTIALSDIR}/radiationPressureAccelerationPartial.h"
+)
+
+# Add static libraries.
+add_library(tudat_acceleration_partials STATIC ${ACCELERATION_PARTIALS_SOURCES} ${ACCELERATION_PARTIALS_HEADERS})
+setup_tudat_library_target(tudat_acceleration_partials "${SRCROOT}{ACCELERATIONPARTIALSDIR}")
+
+if(USE_CSPICE)
+
+# Add unit tests
+add_executable(test_AccelerationPartials "${SRCROOT}${ACCELERATIONPARTIALSDIR}/UnitTests/unitTestAccelerationPartials.cpp")
+setup_custom_test_program(test_AccelerationPartials "${SRCROOT}${ACCELERATIONPARTIALSDIR}")
+target_link_libraries(test_AccelerationPartials ${TUDAT_ESTIMATION_LIBRARIES} ${Boost_LIBRARIES})
+
+endif( )
+
+
diff --git a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/UnitTests/unitTestAccelerationPartials.cpp b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/UnitTests/unitTestAccelerationPartials.cpp
new file mode 100644
index 0000000..be334f8
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/UnitTests/unitTestAccelerationPartials.cpp
@@ -0,0 +1,438 @@
+/*    Copyright (c) 2010-2012 Delft University of Technology./
+ *
+ *    This software is protected by national and international copyright.
+ *    Any unauthorized use, reproduction or modification is unlawful and
+ *    will be prosecuted. Commercial and non-private application of the
+ *    software in any form is strictly prohibited unless otherwise granted
+ *    by the authors.
+ *
+ *    The code is provided without any warranty; without even the implied
+ *    warranty of merchantibility or fitness for a particular purpose.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *
+ *    References
+ *
+ */
+
+#define BOOST_TEST_MAIN
+
+#include <limits>
+#include <string>
+#include "Tudat/Basics/testMacros.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/unitConversions.h"
+
+#include <boost/test/unit_test.hpp>
+#include <boost/make_shared.hpp>
+#include <boost/lambda/lambda.hpp>
+
+#include "Tudat/Astrodynamics/Aerodynamics/exponentialAtmosphere.h"
+#include "Tudat/Astrodynamics/Gravitation/centralGravityModel.h"
+#include "Tudat/External/SpiceInterface/spiceInterface.h"
+#include "Tudat/InputOutput/basicInputOutput.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/gravitationalParameter.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/initialTranslationalState.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/radiationPressureCoefficient.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/numericalAccelerationPartial.h"
+#include "Tudat/SimulationSetup/createAccelerationPartials.h"
+#include "Tudat/SimulationSetup/createBodies.h"
+#include "Tudat/SimulationSetup/createAccelerationModels.h"
+#include "Tudat/SimulationSetup/createEstimatableParameters.h"
+#include "Tudat/SimulationSetup/defaultBodies.h"
+
+namespace tudat
+{
+namespace unit_tests
+{
+
+using namespace tudat::aerodynamics;
+using namespace tudat::ephemerides;
+using namespace tudat::simulation_setup;
+using namespace tudat::orbital_element_conversions;
+using namespace tudat::unit_conversions;
+using namespace tudat::orbit_determination::partial_derivatives;
+using namespace tudat::spice_interface;
+using namespace tudat::orbit_determination;
+using namespace tudat::estimatable_parameters;
+using namespace tudat::electro_magnetism;
+
+BOOST_AUTO_TEST_SUITE( test_acceleration_partials )
+
+BOOST_AUTO_TEST_CASE( testCentralGravityPartials )
+{
+    // Create empty bodies, earth and sun.
+    boost::shared_ptr< Body > earth = boost::make_shared< Body >( );
+    boost::shared_ptr< Body > sun = boost::make_shared< Body >( );
+
+    NamedBodyMap bodyMap;
+    bodyMap[ "Earth" ] = earth;
+    bodyMap[ "Sun" ] = sun;
+
+    // Load spice kernels.
+    std::string kernelsPath = input_output::getSpiceKernelPath( );
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de-403-masses.tpc");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de421.bsp");
+
+    // Set current state of sun and earth.
+    sun->setState( getBodyCartesianStateAtEpoch( "Sun", "Sun", "J2000", "NONE", 1.0E6 ) );
+    earth->setState( getBodyCartesianStateAtEpoch(  "Earth", "Sun", "J2000", "NONE", 1.0E6 ) );
+
+    // Get sun gravitational parameter and set gravity field model.
+    double sunsGravitationalParameter = getBodyGravitationalParameter( "Sun" );
+    boost::shared_ptr< GravityFieldModel > sunGravityFieldModel =
+            boost::make_shared< GravityFieldModel >( sunsGravitationalParameter );
+    sun->setGravityFieldModel( sunGravityFieldModel );
+    double earthGravitationalParameter = getBodyGravitationalParameter( "Earth" );
+    boost::shared_ptr< GravityFieldModel > earthGravityFieldModel =
+            boost::make_shared< GravityFieldModel >( earthGravitationalParameter );
+    earth->setGravityFieldModel( earthGravityFieldModel );
+
+    // Create acceleration due to sun on earth.
+    boost::shared_ptr< CentralGravitationalAccelerationModel3d > gravitationalAcceleration =\
+            createCentralGravityAcceleratioModel( earth, sun, "Earth", "Sun", 1 );
+
+    // Create central gravity partial.
+    boost::shared_ptr< AccelerationPartial > centralGravitationPartial =
+            createAnalyticalAccelerationPartial( gravitationalAcceleration, std::make_pair( "Earth", earth ),
+                                                 std::make_pair( "Sun", sun ), bodyMap );
+
+    // Create gravitational parameter object.
+    boost::shared_ptr< EstimatableParameter< double > > sunGravitationalParameterParameter = boost::make_shared<
+            GravitationalParameter >( sunGravityFieldModel, "Sun" );
+    boost::shared_ptr< EstimatableParameter< double > > earthGravitationalParameterParameter = boost::make_shared<
+            GravitationalParameter >( earthGravityFieldModel, "Earth" );
+
+    // Calculate analytical partials.
+    centralGravitationPartial->update( 0.0 );
+    Eigen::MatrixXd partialWrtEarthPosition = Eigen::Matrix3d::Zero( );
+    centralGravitationPartial->wrtPositionOfAcceleratedBody( partialWrtEarthPosition.block( 0, 0, 3, 3 ) );
+    Eigen::MatrixXd partialWrtEarthVelocity = Eigen::Matrix3d::Zero( );
+    centralGravitationPartial->wrtVelocityOfAcceleratedBody( partialWrtEarthVelocity.block( 0, 0, 3, 3 ), 1, 0, 0 );
+    Eigen::MatrixXd partialWrtSunPosition = Eigen::Matrix3d::Zero( );
+    centralGravitationPartial->wrtPositionOfAcceleratingBody( partialWrtSunPosition.block( 0, 0, 3, 3 ) );
+    Eigen::MatrixXd partialWrtSunVelocity = Eigen::Matrix3d::Zero( );
+    centralGravitationPartial->wrtVelocityOfAcceleratingBody( partialWrtSunVelocity.block( 0, 0, 3, 3 ), 1, 0, 0 );
+    Eigen::Vector3d partialWrtSunGravitationalParameter = centralGravitationPartial->wrtParameter(
+                sunGravitationalParameterParameter );
+    Eigen::Vector3d partialWrtEarthGravitationalParameter = centralGravitationPartial->wrtParameter(
+                earthGravitationalParameterParameter );
+
+    // Declare numerical partials.
+    Eigen::Matrix3d testPartialWrtEarthPosition = Eigen::Matrix3d::Zero( );
+    Eigen::Matrix3d testPartialWrtEarthVelocity = Eigen::Matrix3d::Zero( );
+    Eigen::Matrix3d testPartialWrtSunPosition = Eigen::Matrix3d::Zero( );
+    Eigen::Matrix3d testPartialWrtSunVelocity = Eigen::Matrix3d::Zero( );
+
+    // Declare perturbations in position for numerical partial/
+    Eigen::Vector3d positionPerturbation;
+    positionPerturbation<< 10000.0, 10000.0, 10000.0;
+    Eigen::Vector3d velocityPerturbation;
+    velocityPerturbation<< 1.0, 1.0, 1.0;
+
+    // Create state access/modification functions for bodies.
+    boost::function< void( basic_mathematics::Vector6d ) > earthStateSetFunction =
+            boost::bind( &Body::setState, earth, _1  );
+    boost::function< void( basic_mathematics::Vector6d ) > sunStateSetFunction =
+            boost::bind( &Body::setState, sun, _1  );
+    boost::function< basic_mathematics::Vector6d ( ) > earthStateGetFunction =
+            boost::bind( &Body::getState, earth );
+    boost::function< basic_mathematics::Vector6d ( ) > sunStateGetFunction =
+            boost::bind( &Body::getState, sun );
+
+    // Calculate numerical partials.
+    testPartialWrtEarthPosition = calculateAccelerationWrtStatePartials(
+                earthStateSetFunction, gravitationalAcceleration, earth->getState( ), positionPerturbation, 0 );
+    testPartialWrtEarthVelocity = calculateAccelerationWrtStatePartials(
+                earthStateSetFunction, gravitationalAcceleration, earth->getState( ), velocityPerturbation, 3 );
+    testPartialWrtSunPosition = calculateAccelerationWrtStatePartials(
+                sunStateSetFunction, gravitationalAcceleration, sun->getState( ), positionPerturbation, 0 );
+    testPartialWrtSunVelocity = calculateAccelerationWrtStatePartials(
+                sunStateSetFunction, gravitationalAcceleration, sun->getState( ), velocityPerturbation, 3 );
+    Eigen::Vector3d testPartialWrtSunGravitationalParameter = calculateAccelerationWrtParameterPartials(
+                sunGravitationalParameterParameter, gravitationalAcceleration, 1.0E12 );
+    Eigen::Vector3d testPartialWrtEarthGravitationalParameter = calculateAccelerationWrtParameterPartials(
+                earthGravitationalParameterParameter, gravitationalAcceleration, 1.0E12 );
+
+    // Compare numerical and analytical results.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtEarthPosition,
+                                       partialWrtEarthPosition, 1.0E-9 );
+
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtEarthVelocity,
+                                       partialWrtEarthVelocity, std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtSunPosition,
+                                       partialWrtSunPosition, 1.0E-9 );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtSunVelocity,
+                                       partialWrtSunVelocity, std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtSunGravitationalParameter,
+                                       partialWrtSunGravitationalParameter, 1.0E-6 );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( partialWrtEarthGravitationalParameter,
+                                       testPartialWrtEarthGravitationalParameter, 1.0E-6 );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( partialWrtEarthGravitationalParameter,
+                                       partialWrtSunGravitationalParameter, std::numeric_limits< double >::epsilon(  ) );
+}
+
+BOOST_AUTO_TEST_CASE( testRadiationPressureAccelerationPartials )
+{
+    // Create empty bodies, earth and sun.
+    boost::shared_ptr< Body > vehicle = boost::make_shared< Body >( );
+    vehicle->setConstantBodyMass( 400.0 );
+    boost::shared_ptr< Body > sun = boost::make_shared< Body >( );
+
+    NamedBodyMap bodyMap;
+    bodyMap[ "Vehicle" ] = vehicle;
+    bodyMap[ "Sun" ] = sun;
+
+    // Load spice kernels.
+    std::string kernelsPath = input_output::getSpiceKernelPath( );
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de-403-masses.tpc");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de421.bsp");
+
+    // Set current state of sun and earth.
+    sun->setState( getBodyCartesianStateAtEpoch( "Sun", "SSB", "J2000", "NONE", 1.0E6 ) );
+    vehicle->setState( getBodyCartesianStateAtEpoch(  "Earth", "SSB", "J2000", "NONE", 1.0E6 ) );
+
+    // Create links to set and get state functions of bodies.
+    boost::function< void( basic_mathematics::Vector6d ) > sunStateSetFunction =
+            boost::bind( &Body::setState, sun, _1  );
+    boost::function< void( basic_mathematics::Vector6d ) > vehicleStateSetFunction =
+            boost::bind( &Body::setState, vehicle, _1  );
+    boost::function< basic_mathematics::Vector6d( ) > sunStateGetFunction =
+            boost::bind( &Body::getState, sun );
+    boost::function< basic_mathematics::Vector6d( ) > vehicleStateGetFunction =
+            boost::bind( &Body::getState, vehicle );
+
+    // Create radiation pressure properties of vehicle
+    boost::shared_ptr< RadiationPressureInterface > radiationPressureInterface =
+            createRadiationPressureInterface( boost::make_shared< CannonBallRadiationPressureInterfaceSettings >(
+                                                  "Sun", mathematical_constants::PI * 0.3 * 0.3, 1.2 ), "Vehicle", bodyMap );
+    radiationPressureInterface->updateInterface( 0.0 );
+    vehicle->setRadiationPressureInterface( "Sun", radiationPressureInterface );
+
+    // Create acceleration model.
+    boost::shared_ptr< CannonBallRadiationPressureAcceleration > accelerationModel =
+            boost::make_shared< CannonBallRadiationPressureAcceleration >(
+                boost::bind( &Body::getPosition, sun ),
+                boost::bind( &Body::getPosition, vehicle ),
+                boost::bind( &RadiationPressureInterface::getCurrentRadiationPressure,
+                             radiationPressureInterface ),
+                boost::bind( &RadiationPressureInterface::getRadiationPressureCoefficient, radiationPressureInterface ),
+                boost::bind( &RadiationPressureInterface::getArea, radiationPressureInterface ),
+                boost::bind( &Body::getBodyMass, vehicle ) );
+
+    // Create partial-calculating object.
+    boost::shared_ptr< AccelerationPartial > accelerationPartial =
+            createAnalyticalAccelerationPartial( accelerationModel, std::make_pair( "Vehicle", vehicle ),
+                                                 std::make_pair( "Sun", sun ), bodyMap );
+
+    // Create parameter object
+    std::string vehicleName = "Vehicle";
+    boost::shared_ptr< EstimatableParameter< double > > radiationPressureCoefficient =
+            boost::make_shared< RadiationPressureCoefficient >( radiationPressureInterface, vehicleName );
+
+    // Calculate analytical partials.
+    accelerationPartial->update( 0.0 );
+    Eigen::MatrixXd partialWrtSunPosition = Eigen::Matrix3d::Zero( );
+    accelerationPartial->wrtPositionOfAcceleratingBody( partialWrtSunPosition.block( 0, 0, 3, 3 ) );
+    Eigen::MatrixXd partialWrtSunVelocity = Eigen::Matrix3d::Zero( );
+    accelerationPartial->wrtVelocityOfAcceleratingBody( partialWrtSunVelocity.block( 0, 0, 3, 3 ), 1, 0, 0 );
+    Eigen::MatrixXd partialWrtVehiclePosition = Eigen::Matrix3d::Zero( );
+    accelerationPartial->wrtPositionOfAcceleratedBody( partialWrtVehiclePosition.block( 0, 0, 3, 3 ) );
+    Eigen::MatrixXd partialWrtVehicleVelocity = Eigen::Matrix3d::Zero( );
+    accelerationPartial->wrtVelocityOfAcceleratedBody( partialWrtVehicleVelocity.block( 0, 0, 3, 3 ), 1, 0, 0 );
+    Eigen::Vector3d partialWrtRadiationPressureCoefficient = accelerationPartial->wrtParameter(
+                radiationPressureCoefficient );
+
+    // Declare numerical partials.
+    Eigen::Matrix3d testPartialWrtVehiclePosition = Eigen::Matrix3d::Zero( );
+    Eigen::Matrix3d testPartialWrtVehicleVelocity = Eigen::Matrix3d::Zero( );
+    Eigen::Matrix3d testPartialWrtSunPosition = Eigen::Matrix3d::Zero( );
+    Eigen::Matrix3d testPartialWrtSunVelocity = Eigen::Matrix3d::Zero( );
+    Eigen::Vector3d testPartialWrtRadiationPressureCoefficient = Eigen::Vector3d::Zero( );
+
+    // Declare perturbations in position for numerical partial/
+    Eigen::Vector3d positionPerturbation;
+    positionPerturbation<< 10000.0, 10000.0, 10000.0;
+    Eigen::Vector3d velocityPerturbation;
+    velocityPerturbation<< 1.0, 1.0, 1.0;
+
+    // Calculate numerical partials.
+    boost::function< void( ) > updateFunction =
+            boost::bind( &RadiationPressureInterface::updateInterface, radiationPressureInterface, 0.0 );
+    testPartialWrtSunPosition = calculateAccelerationWrtStatePartials(
+                sunStateSetFunction, accelerationModel, sun->getState( ), positionPerturbation, 0, updateFunction );
+    testPartialWrtVehiclePosition = calculateAccelerationWrtStatePartials(
+                vehicleStateSetFunction, accelerationModel, vehicle->getState( ), positionPerturbation, 0, updateFunction );
+    testPartialWrtSunVelocity = calculateAccelerationWrtStatePartials(
+                sunStateSetFunction, accelerationModel, sun->getState( ),velocityPerturbation, 3, updateFunction );
+    testPartialWrtVehicleVelocity = calculateAccelerationWrtStatePartials(
+                vehicleStateSetFunction, accelerationModel, vehicle->getState( ), velocityPerturbation, 3, updateFunction );
+    testPartialWrtRadiationPressureCoefficient = calculateAccelerationWrtParameterPartials(
+                radiationPressureCoefficient, accelerationModel, 1.0E-2, updateFunction );
+
+
+    // Compare numerical and analytical results.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtSunPosition,
+                                       partialWrtSunPosition, 1.0E-8 );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtSunVelocity,
+                                       partialWrtSunVelocity, std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtVehiclePosition,
+                                       partialWrtVehiclePosition, 1.0E-8 );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtVehicleVelocity,
+                                       partialWrtVehicleVelocity, std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtRadiationPressureCoefficient,
+                                       partialWrtRadiationPressureCoefficient, 1.0E-12 );
+}
+
+
+BOOST_AUTO_TEST_CASE( testThirdBodyGravityPartials )
+{
+    // Create empty bodies, earth and sun.
+    boost::shared_ptr< Body > earth = boost::make_shared< Body >( );
+    boost::shared_ptr< Body > sun = boost::make_shared< Body >( );
+    boost::shared_ptr< Body > moon = boost::make_shared< Body >( );
+
+    NamedBodyMap bodyMap;
+    bodyMap[ "Earth" ] = earth;
+    bodyMap[ "Sun" ] = sun;
+    bodyMap[ "Moon" ] = moon;
+
+    // Load spice kernels.
+    std::string kernelsPath = input_output::getSpiceKernelPath( );
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de-403-masses.tpc");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de421.bsp");
+
+    // Set current state of sun and earth.
+    sun->setState( getBodyCartesianStateAtEpoch( "Sun", "Sun", "J2000", "NONE", 1.0E6 ) );
+    earth->setState( getBodyCartesianStateAtEpoch(  "Earth", "Sun", "J2000", "NONE", 1.0E6 ) );
+    moon->setState( getBodyCartesianStateAtEpoch(  "Moon", "Sun", "J2000", "NONE", 1.0E6 ) );
+
+    // Get sun gravitational parameter and set gravity field model.
+    double sunsGravitationalParameter = getBodyGravitationalParameter( "Sun" );
+    boost::shared_ptr< GravityFieldModel > sunGravityFieldModel =
+            boost::make_shared< GravityFieldModel >( sunsGravitationalParameter );
+    sun->setGravityFieldModel( sunGravityFieldModel );
+
+    double moonsGravitationalParameter = getBodyGravitationalParameter( "Moon" );
+    boost::shared_ptr< GravityFieldModel > moonGravityFieldModel =
+            boost::make_shared< GravityFieldModel >( moonsGravitationalParameter );
+    moon->setGravityFieldModel( moonGravityFieldModel );
+
+    double earthGravitationalParameter = getBodyGravitationalParameter( "Earth" );
+    boost::shared_ptr< GravityFieldModel > earthGravityFieldModel =
+            boost::make_shared< GravityFieldModel >( earthGravitationalParameter );
+    earth->setGravityFieldModel( earthGravityFieldModel );
+
+    // Create acceleration due to moon on earth.
+    boost::shared_ptr< ThirdBodyCentralGravityAcceleration > gravitationalAcceleration =
+            createThirdBodyCentralGravityAccelerationModel(
+                moon, sun, earth, "Moon", "Sun", "Earth" );
+
+    // Create central gravity partial.
+    boost::shared_ptr< AccelerationPartial > thirdBodyGravitationPartial =
+            createAnalyticalAccelerationPartial( gravitationalAcceleration, std::make_pair( "Moon", moon ),
+                                                 std::make_pair( "Sun", sun ), bodyMap );
+
+    // Create gravitational parameter object.
+    boost::shared_ptr< EstimatableParameter< double > > gravitationalParameterParameter = boost::make_shared<
+            GravitationalParameter >( sunGravityFieldModel, "Sun" );
+    boost::shared_ptr< EstimatableParameter< double > > moonGravitationalParameterParameter = boost::make_shared<
+            GravitationalParameter >( moonGravityFieldModel, "Moon" );
+    boost::shared_ptr< EstimatableParameter< double > > earthGravitationalParameterParameter = boost::make_shared<
+            GravitationalParameter >( earthGravityFieldModel, "Earth" );
+
+    // Calculate analytical partials.
+    thirdBodyGravitationPartial->update( 1.0E6 );
+    Eigen::MatrixXd partialWrtMoonPosition = Eigen::Matrix3d::Zero( );
+    thirdBodyGravitationPartial->wrtPositionOfAcceleratedBody( partialWrtMoonPosition.block( 0, 0, 3, 3 ) );
+    Eigen::MatrixXd partialWrtMoonVelocity = Eigen::Matrix3d::Zero( );
+    thirdBodyGravitationPartial->wrtVelocityOfAcceleratedBody( partialWrtMoonVelocity.block( 0, 0, 3, 3 ) );
+    Eigen::MatrixXd partialWrtSunPosition = Eigen::Matrix3d::Zero( );
+    thirdBodyGravitationPartial->wrtPositionOfAcceleratingBody( partialWrtSunPosition.block( 0, 0, 3, 3 ) );
+    Eigen::MatrixXd partialWrtSunVelocity = Eigen::Matrix3d::Zero( );
+    thirdBodyGravitationPartial->wrtVelocityOfAcceleratingBody( partialWrtSunVelocity.block( 0, 0, 3, 3 ) );
+    Eigen::MatrixXd partialWrtEarthPosition = Eigen::Matrix3d::Zero( );
+    thirdBodyGravitationPartial->wrtPositionOfAdditionalBody( "Earth", partialWrtEarthPosition.block( 0, 0, 3, 3 )  );
+    Eigen::MatrixXd partialWrtEarthVelocity = Eigen::Matrix3d::Zero( );
+    thirdBodyGravitationPartial->wrtVelocityOfAdditionalBody( "Earth", partialWrtEarthVelocity.block( 0, 0, 3, 3 )  );
+
+    Eigen::Vector3d partialWrtSunGravitationalParameter = thirdBodyGravitationPartial->wrtParameter(
+                gravitationalParameterParameter );
+    Eigen::Vector3d partialWrtMoonGravitationalParameter = thirdBodyGravitationPartial->wrtParameter(
+                moonGravitationalParameterParameter );
+    Eigen::Vector3d partialWrtEarthGravitationalParameter = thirdBodyGravitationPartial->wrtParameter(
+                earthGravitationalParameterParameter );
+
+    // Declare numerical partials.
+    Eigen::Matrix3d testPartialWrtMoonPosition = Eigen::Matrix3d::Zero( );
+    Eigen::Matrix3d testPartialWrtMoonVelocity = Eigen::Matrix3d::Zero( );
+    Eigen::Matrix3d testPartialWrtSunPosition = Eigen::Matrix3d::Zero( );
+    Eigen::Matrix3d testPartialWrtSunVelocity = Eigen::Matrix3d::Zero( );
+    Eigen::Matrix3d testPartialWrtEarthPosition = Eigen::Matrix3d::Zero( );
+    Eigen::Matrix3d testPartialWrtEarthVelocity = Eigen::Matrix3d::Zero( );
+
+    // Declare perturbations in position for numerical partial/
+    Eigen::Vector3d positionPerturbation;
+    positionPerturbation<< 10000.0, 10000.0, 10000.0;
+    Eigen::Vector3d velocityPerturbation;
+    velocityPerturbation<< 1.0, 1.0, 1.0;
+
+    // Create state access/modification functions for bodies.
+    boost::function< void( basic_mathematics::Vector6d ) > moonStateSetFunction =
+            boost::bind( &Body::setState, moon, _1  );
+    boost::function< void( basic_mathematics::Vector6d ) > sunStateSetFunction =
+            boost::bind( &Body::setState, sun, _1  );
+    boost::function< void( basic_mathematics::Vector6d ) > earthStateSetFunction =
+            boost::bind( &Body::setState, earth, _1  );
+
+    // Calculate numerical partials.
+    testPartialWrtMoonPosition = calculateAccelerationWrtStatePartials(
+                moonStateSetFunction, gravitationalAcceleration, moon->getState( ), positionPerturbation, 0 );
+    testPartialWrtMoonVelocity = calculateAccelerationWrtStatePartials(
+                moonStateSetFunction, gravitationalAcceleration, moon->getState( ), velocityPerturbation, 3 );
+    testPartialWrtSunPosition = calculateAccelerationWrtStatePartials(
+                sunStateSetFunction, gravitationalAcceleration, sun->getState( ), positionPerturbation, 0 );
+    testPartialWrtSunVelocity = calculateAccelerationWrtStatePartials(
+                sunStateSetFunction, gravitationalAcceleration, sun->getState( ), velocityPerturbation, 3 );
+    testPartialWrtEarthPosition = calculateAccelerationWrtStatePartials(
+                earthStateSetFunction, gravitationalAcceleration, earth->getState( ), positionPerturbation, 0 );
+    testPartialWrtEarthVelocity = calculateAccelerationWrtStatePartials(
+                earthStateSetFunction, gravitationalAcceleration, earth->getState( ), velocityPerturbation, 3 );
+    Eigen::Vector3d testPartialWrtSunGravitationalParameter = calculateAccelerationWrtParameterPartials(
+                gravitationalParameterParameter, gravitationalAcceleration, 1.0E16 );
+    Eigen::Vector3d testPartialWrtEarthGravitationalParameter = calculateAccelerationWrtParameterPartials(
+                earthGravitationalParameterParameter, gravitationalAcceleration, 1.0E16 );
+    Eigen::Vector3d testPartialWrtMoonGravitationalParameter = calculateAccelerationWrtParameterPartials(
+                moonGravitationalParameterParameter, gravitationalAcceleration, 1.0E16 );
+
+    // Compare numerical and analytical results.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtMoonPosition,
+                                       partialWrtMoonPosition, 1.0E-7 );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtMoonVelocity,
+                                       partialWrtMoonVelocity, std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtSunPosition,
+                                       partialWrtSunPosition, 1.0E-5 );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtSunVelocity,
+                                       partialWrtSunVelocity, std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtEarthPosition,
+                                       partialWrtEarthPosition, 1.0E-5 );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtEarthVelocity,
+                                       partialWrtEarthVelocity, std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtSunGravitationalParameter,
+                                       partialWrtSunGravitationalParameter, 1.0E-6 );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtMoonGravitationalParameter,
+                                       partialWrtMoonGravitationalParameter, std::numeric_limits< double >::epsilon(  ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPartialWrtEarthGravitationalParameter,
+                                       partialWrtEarthGravitationalParameter, std::numeric_limits< double >::epsilon(  ) );
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+} // namespace unit_tests
+
+} // namespace tudat
+
+
+
+
diff --git a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/accelerationPartial.cpp b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/accelerationPartial.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/accelerationPartial.h b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/accelerationPartial.h
new file mode 100644
index 0000000..51b9442
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/accelerationPartial.h
@@ -0,0 +1,380 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_ACCELERATIONPARTIALS_H
+#define TUDAT_ACCELERATIONPARTIALS_H
+
+#include <string>
+#include <map>
+#include <Eigen/Core>
+
+#include <boost/bind.hpp>
+#include <boost/assign/list_of.hpp>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/estimatableParameter.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/stateDerivativePartial.h"
+
+namespace tudat
+{
+
+namespace orbit_determination
+{
+
+namespace partial_derivatives
+{
+
+
+//! Base class for objects calculating partial derivatives of accelerations w.r.t. states, model parameters.
+/*!
+ *  Base class for objects calculating partial derivatives of accelerations  w.r.t. states, model parameters. Such
+ *  calculations are used in orbit determination, for the computation of the state transition; sensitivity matrices.
+ *  Derived classes implement derivative-calculating models for specific acceleration models, so that the calculation
+ *  of all partials of a single type acceleration model is encompassed in a single derived class.
+ */
+class AccelerationPartial: public StateDerivativePartial
+{
+
+public:
+    //! Base class constructor.
+    /*!
+     *  Constructor of base class, sets the base class member variables identifying the body undergoing and exerting the
+     *  acceleration.
+     *  \param acceleratedBody Body undergoing acceleration.
+     *  \param acceleratingBody Body exerting acceleration.
+     *  \param accelerationType Type of acceleration w.r.t. which partial is taken.
+     */
+    AccelerationPartial( const std::string& acceleratedBody, const std::string& acceleratingBody,
+                         const basic_astrodynamics::AvailableAcceleration accelerationType ):
+        StateDerivativePartial( propagators::transational_state, std::make_pair( acceleratedBody, "" ) ),
+        acceleratedBody_( acceleratedBody ), acceleratingBody_( acceleratingBody ),accelerationType_( accelerationType ) { }
+
+    //! Virtual destructor.
+    virtual ~AccelerationPartial( ) { }
+
+    //! Function to retrieve the function that returns the partial derivative w.r.t. a propagated state.
+    /*!
+     * Function to retrieve the function that returns the partial derivative w.r.t. a propagated state.
+     * \param stateReferencePoint Reference point (id) for propagated state (i.e. body name for translational dynamics).
+     * \param integratedStateType Type of propagated state.
+     * \return Pair with function, returning partial derivative, and number of columns in partial vector,
+     */
+    std::pair< boost::function< void( Eigen::Block< Eigen::MatrixXd > ) >, int >
+    getDerivativeFunctionWrtStateOfIntegratedBody(
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType )
+    {
+        // Initialize to empty function; 0 parameter size.
+        std::pair< boost::function< void( Eigen::Block< Eigen::MatrixXd > ) >, int >
+                partialFunction = std::make_pair( boost::function< void( Eigen::Block< Eigen::MatrixXd > ) >( ), 0 );
+
+        // Check if state dependency exists
+        switch( integratedStateType )
+        {
+        case propagators::transational_state:
+        {
+            // Check if reference id is consistent.
+            if( stateReferencePoint.second != "" )
+            {
+                throw std::runtime_error( "Error when getting state derivative partial acceleration model, cannot have reference point on body for dynamics" );
+            }
+            // Check if propagated body corresponds to accelerated, accelerating, ro relevant third body.
+            else if( stateReferencePoint.first == acceleratedBody_ )
+            {
+                partialFunction = std::make_pair( boost::bind( &AccelerationPartial::wrtStateOfAcceleratedBody, this, _1 ), 3 );
+            }
+            else if( stateReferencePoint.first == acceleratingBody_ )
+            {
+                partialFunction = std::make_pair( boost::bind( &AccelerationPartial::wrtStateOfAcceleratingBody, this, _1 ), 3 );
+            }
+            else if( isAccelerationPartialWrtAdditionalBodyNonNull( stateReferencePoint.first ) )
+            {
+                partialFunction = std::make_pair( boost::bind( &AccelerationPartial::wrtStateOfAdditionalBody,
+                                                               this, _1, stateReferencePoint.first ), 3 );
+            }
+            break;
+        }
+        case propagators::body_mass_state:
+        {
+            // Check if reference id is consistent.
+            if( stateReferencePoint.second != "" )
+            {
+                throw std::runtime_error( "Error when getting state derivative partial acceleration model, cannot have reference point on body for body mass" );
+            }
+            else if( isStateDerivativeDependentOnIntegratedNonTranslationalState( stateReferencePoint, integratedStateType ) )
+            {
+                partialFunction = std::make_pair( boost::bind( &AccelerationPartial::wrtNonTranslationalStateOfAdditionalBody,
+                                                               this, _1, stateReferencePoint, integratedStateType ), 1 );
+            }
+        }
+        default:
+            std::string errorMessage =
+                    "Error when getting state derivative partial acceleration model, dynamics type " +
+                    boost::lexical_cast< std::string >( integratedStateType ) + "not recognized" ;
+            throw std::runtime_error( errorMessage );
+            break;
+        }
+
+
+        return partialFunction;
+    }
+
+    //! Function for determining if the acceleration is dependent on a non-translational integrated state (default none).
+    /*!
+     *  Function for determining if the acceleration is dependent on a non-translational integrated state.
+     *  No dependency is implemented is returned in this base class function, but may be overriden by derived class.
+     *  \param stateReferencePoint Reference point id of propagated state
+     *  \param integratedStateType Type of propagated state for which dependency is to be determined.
+     *  \return True if dependency exists (non-zero partial), false otherwise.
+     */
+    virtual bool isStateDerivativeDependentOnIntegratedNonTranslationalState(
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType )
+    {
+        return false;
+    }
+
+    //! Function to check whether a partial w.r.t. some integrated state is non-zero.
+    /*!
+     * Function to check whether a partial w.r.t. some integrated state is non-zero.
+     * \param stateReferencePoint Reference point (id) for propagated state (i.e. body name for translational dynamics).
+     * \param integratedStateType Type of propagated state.
+     * \return True if dependency exists, false otherwise.
+     */
+    bool isStateDerivativeDependentOnIntegratedState(
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType )
+    {
+        bool isDependent = 0;
+
+        // Check if state is translational.
+        switch( integratedStateType )
+        {
+        case propagators::transational_state:
+        {
+            // Check if reference id is consistent.
+            if( stateReferencePoint.second != "" )
+            {
+                throw std::runtime_error( "Error when checking state derivative partial dependency of acceleration model, cannot have reference point on body for dynamics" );
+            }
+
+            // Check if propagated body corresponds to accelerated, accelerating, ro relevant third body.
+            else if( stateReferencePoint.first == acceleratedBody_ || stateReferencePoint.first == acceleratingBody_ ||
+                     isAccelerationPartialWrtAdditionalBodyNonNull( stateReferencePoint.first ) )
+            {
+                isDependent = 1;
+            }
+            break;
+        }
+        default:
+            isDependent = isStateDerivativeDependentOnIntegratedNonTranslationalState( stateReferencePoint, integratedStateType );
+            break;
+        }
+        return isDependent;
+    }
+
+    //! Pure virtual function for calculating the partial of the acceleration w.r.t. the position of the accelerated body.
+    /*!
+     *  Pure virtual function for calculating the partial of the acceleration w.r.t. the position of the accelerated body and
+     *  adding it to the existing partial block.
+     *  \param partialMatrix Block of partial derivatives of acceleration w.r.t. Cartesian position of body
+     *  undergoing acceleration where current partial is to be added.
+     *  \param addContribution Variable denoting whether to return the partial itself (true) or the negative partial (false).
+     *  \param startRow First row in partialMatrix block where the computed partial is to be added.
+     *  \param startColumn First column in partialMatrix block where the computed partial is to be added.
+     */
+    virtual void wrtPositionOfAcceleratedBody(
+            Eigen::Block< Eigen::MatrixXd > partialMatrix,
+            const bool addContribution = 1, const int startRow = 0, const int startColumn = 0 ) = 0;
+
+    //! Function for calculating the partial of the acceleration w.r.t. the velocity of the accelerated body.
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the velocity of the accelerated body and
+     *  adding it to the existing partial block. Function may be overridden in derived class, default dependency is none.
+     *  \param partialMatrix Block of partial derivatives of acceleration w.r.t. Cartesian velocity of body
+     *  undergoing acceleration where current partial is to be added.
+     *  \param addContribution Variable denoting whether to return the partial itself (true) or the negative partial (false).
+     *  \param startRow First row in partialMatrix block where the computed partial is to be added.
+     *  \param startColumn First column in partialMatrix block where the computed partial is to be added.
+     */
+    virtual void wrtVelocityOfAcceleratedBody(
+            Eigen::Block< Eigen::MatrixXd > partialMatrix,
+            const bool addContribution = 1, const int startRow = 0, const int startColumn = 3 )
+    { }
+
+    //! Function for calculating the partial of the acceleration w.r.t. the Cartesian state of the body undergoing acceleration.
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the Cartesian state of the body
+     *  undergoing acceleration  and adding it to the existing partial block.
+     *  \param partialMatrix Block of partial derivatives of acceleration w.r.t. Cartesian state of body
+     *  undergoing acceleration where current partial is to be added.
+     */
+    void wrtStateOfAcceleratedBody( Eigen::Block< Eigen::MatrixXd > partialMatrix )
+    {
+        wrtPositionOfAcceleratedBody( partialMatrix, true, 0, 0 );
+        wrtVelocityOfAcceleratedBody( partialMatrix, true, 0, 3 );
+    }
+
+    //! Pure virtual function for calculating the partial of the acceleration w.r.t. the position of the body exerting acceleration.
+    /*!
+     *  Pure virtual function for calculating the partial of the acceleration w.r.t. the position of the body exerting
+     *  acceleration and adding it to the existing partial block.
+     *  \param partialMatrix Block of partial derivatives of acceleration w.r.t. Cartesian position of body
+     *  exerting acceleration where current partial is to be added.
+     *  \param addContribution Variable denoting whether to return the partial itself (true) or the negative partial (false).
+     *  \param startRow First row in partialMatrix block where the computed partial is to be added.
+     *  \param startColumn First column in partialMatrix block where the computed partial is to be added.
+     */
+    virtual void wrtPositionOfAcceleratingBody(
+            Eigen::Block< Eigen::MatrixXd > partialMatrix,
+            const bool addContribution = 1, const int startRow = 0, const int startColumn = 0 ) = 0;
+
+    //! Function for calculating the partial of the acceleration w.r.t. the velocity of the body exerting acceleration.
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the velocity of the body exerting a
+     *  acceleration. . Function may be overridden in derived class, default dependency is none.
+     *  \param addContribution Variable denoting whether to return the partial itself (true) or the negative partial (false).
+     *  \param startRow First row in partialMatrix block where the computed partial is to be added.
+     *  \param startColumn First column in partialMatrix block where the computed partial is to be added.
+     *  \param partialMatrix Block of partial derivatives of acceleration w.r.t. Cartesian velocity of body
+     *  exerting acceleration where current partial is to be added.
+     */
+    virtual void wrtVelocityOfAcceleratingBody(
+            Eigen::Block< Eigen::MatrixXd > partialMatrix,
+            const bool addContribution = 1, const int startRow = 0, const int startColumn = 3 ){ }
+
+    //! Function for calculating the partial of the acceleration w.r.t. the Cartesian state of the body exerting acceleration.
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the Cartesian state of the body exerting
+     *  acceleration and adding it to the existing partial block.
+     *  \param partialMatrix Block of partial derivatives of acceleration w.r.t. Cartesian state of body
+     *  exerting acceleration where current partial is to be added.
+     */
+    void wrtStateOfAcceleratingBody( Eigen::Block< Eigen::MatrixXd > partialMatrix )
+    {
+        wrtPositionOfAcceleratingBody( partialMatrix, true, 0, 0 );
+        wrtVelocityOfAcceleratingBody( partialMatrix, true, 0, 3 );
+    }
+
+    //! Function for calculating the partial of the acceleration w.r.t. the position of the third body.
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the position of the third body
+     *  and adding it to the existing partial block. Function may be overridden in derived class, default dependency is none.
+     *  \param bodyName Name of third body.
+     *  \param partialMatrix Block of partial derivatives of acceleration w.r.t. Cartesian position of third body where
+     *  current partial is to be added.
+     *  \param addContribution Variable denoting whether to return the partial itself (true) or the negative partial (false).
+     *  \param startRow First row in partialMatrix block where the computed partial is to be added.
+     *  \param startColumn First column in partialMatrix block where the computed partial is to be added.
+     */
+    virtual void wrtPositionOfAdditionalBody(
+            const std::string& bodyName, Eigen::Block< Eigen::MatrixXd > partialMatrix,
+            const bool addContribution = 1, const int startRow = 0, const int startColumn = 0 ){ }
+
+    //! Function for calculating the partial of the acceleration w.r.t. the velocity of the third body.
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the velocity of the third body
+     *  and adding it to the existing partial block. . Function may be overridden in derived class, default dependency is
+     *  none.
+     *  \param bodyName Name of third body.
+     *  \param partialMatrix Block of partial derivatives of acceleration w.r.t. Cartesian velocity of third body where
+     *  current partial is to be added.
+     *  \param addContribution Variable denoting whether to return the partial itself (true) or the negative partial (false).
+     *  \param startRow First row in partialMatrix block where the computed partial is to be added.
+     *  \param startColumn First column in partialMatrix block where the computed partial is to be added.
+     */
+    virtual void wrtVelocityOfAdditionalBody(
+            const std::string& bodyName, Eigen::Block< Eigen::MatrixXd > partialMatrix,
+            const bool addContribution = 1, const int startRow = 0, const int startColumn = 3 ){ }
+
+    //! Function for calculating the partial of the acceleration w.r.t. the Cartesian state of the third body.
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the Cartesian state of the third body
+     *  and adding it to the existing partial block.
+     *  \param bodyName Name of third body.
+     *  \param partialMatrix Block of partial derivatives of acceleration w.r.t. Cartesian state of third body where
+     *  current partial is to be added.
+     */
+    void wrtStateOfAdditionalBody( Eigen::Block< Eigen::MatrixXd > partialMatrix, const std::string& bodyName )
+    {
+        wrtPositionOfAdditionalBody( bodyName, partialMatrix, true, 0, 0 );
+        wrtVelocityOfAdditionalBody( bodyName, partialMatrix, true, 0, 3 );
+    }
+
+    //! Function for calculating the partial of the acceleration w.r.t. a non-translational integrated state
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. a non-translational integrated state
+     *  and adding it to the existing partial block. Function may be overridden in derived class, default dependency is
+     *  none.
+     *  \param partialMatrix Block of partial derivatives of where current partial is to be added.
+     *  \param stateReferencePoint Reference point id of propagated state
+     *  \param integratedStateType Type of propagated state for which partial is to be computed.
+     */
+    virtual void wrtNonTranslationalStateOfAdditionalBody(
+            Eigen::Block< Eigen::MatrixXd > partialMatrix,
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType ){ }
+
+    //! Function to check whether the partial derivative w.r.t. the translational state of a third body is non-zero.
+    /*!
+     * Function to check whether the partial derivative w.r.t. the translational state of a third body is non-zero. This
+     * function returns false by default, should be redefined in derived class if any third-bodyd dependencies exist.
+     * \param bodyName Name of third body.
+     * \return True if third body dependency exists, false otherwise.
+     */
+    virtual bool isAccelerationPartialWrtAdditionalBodyNonNull( const std::string& bodyName )
+    {
+        return 0;
+    }
+
+    //! Function to retrieve the name of the body undergoing acceleration.
+    /*!
+     *  Function to retrieve the name of the body undergoing acceleration.
+     *  \return Name of the body undergoing acceleration.
+     */
+    std::string getAcceleratedBody( ) { return acceleratedBody_; }
+
+    //! Function to retrieve the name of the body exerting acceleration.
+    /*!
+     *  Function to retrieve the name of the body exerting acceleration.
+     *  \return Name of the body exerting acceleration.
+     */
+    std::string getAcceleratingBody( ) { return acceleratingBody_; }
+
+    //! Function to retrieve the type of acceleration w.r.t. which partial is taken..
+    /*!
+     *  Function to retrieve the type of acceleration w.r.t. which partial is taken..
+     *  \return Type of acceleration w.r.t. which partial is taken..
+     */
+    basic_astrodynamics::AvailableAcceleration getAccelerationType( )
+    {
+        return accelerationType_;
+    }
+
+protected:    
+    //! Name of the body undergoing acceleration.
+    std::string acceleratedBody_;
+
+    //! Name of the body exerting acceleration.
+    std::string acceleratingBody_;
+
+    //! Type of acceleration w.r.t. which partial is taken..
+    basic_astrodynamics::AvailableAcceleration accelerationType_;
+};
+
+
+}
+
+}
+
+}
+#endif // TUDAT_ACCELERATIONPARTIALS_H
diff --git a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/centralGravityAccelerationPartial.cpp b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/centralGravityAccelerationPartial.cpp
new file mode 100644
index 0000000..9f585b2
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/centralGravityAccelerationPartial.cpp
@@ -0,0 +1,149 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#include "Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/centralGravityAccelerationPartial.h"
+
+
+namespace tudat
+{
+
+namespace orbit_determination
+{
+
+namespace partial_derivatives
+{
+
+//! Calculates partial derivative of point mass gravitational acceleration wrt the position of body undergoing acceleration.
+Eigen::Matrix3d calculatePartialOfPointMassGravityWrtPositionOfAcceleratedBody(
+        const Eigen::Vector3d& acceleratedBodyPosition,
+        const Eigen::Vector3d& acceleratingBodyPositions,
+        double gravitationalParameter )
+{
+    // Calculate relative position
+    Eigen::Vector3d relativePosition = acceleratedBodyPosition - acceleratingBodyPositions;
+
+    // Calculate partial (Montenbruck & Gill, Eq. 7.56)
+    double relativePositionNorm = relativePosition.norm( );
+    double invSquareOfPositionNorm = 1.0 / ( relativePositionNorm * relativePositionNorm );
+    double invCubeOfPositionNorm = invSquareOfPositionNorm / relativePositionNorm;
+    Eigen::Matrix3d partialMatrix = -gravitationalParameter *
+            ( Eigen::Matrix3d::Identity( ) * invCubeOfPositionNorm -
+              ( 3.0 * invSquareOfPositionNorm * invCubeOfPositionNorm ) * relativePosition * relativePosition.transpose( ) );
+
+    return partialMatrix;
+}
+
+//! Calculates partial derivative of point mass gravitational acceleration wrt gravitational parameter of the central body.
+Eigen::Vector3d computePartialOfCentralGravityWrtGravitationalParameter( const Eigen::Vector3d& acceleratedBodyPosition,
+                                                                         const Eigen::Vector3d& acceleratingBodyPosition)
+{
+    // Calculate relative position
+    Eigen::Vector3d relativePosition = acceleratingBodyPosition - acceleratedBodyPosition;
+
+    // Calculate partial (Montenbruck & Gill, Eq. 7.76)
+    double positionNorm = relativePosition.norm( );
+    Eigen::Vector3d partialMatrix = relativePosition / ( positionNorm * positionNorm * positionNorm );
+    return partialMatrix;
+}
+
+//! Calculates partial derivative of point mass gravitational acceleration wrt gravitational parameter of the central body.
+Eigen::Vector3d computePartialOfCentralGravityWrtGravitationalParameter( const Eigen::Vector3d& gravitationalAcceleration,
+                                                                         const double gravitationalParameter )
+{
+    return gravitationalAcceleration / gravitationalParameter;
+}
+
+//! Constructor
+CentralGravitationPartial::CentralGravitationPartial(
+        const boost::shared_ptr< gravitation::CentralGravitationalAccelerationModel3d > gravitationalAcceleration,
+        const std::string acceleratedBody,
+        const std::string acceleratingBody ):
+    AccelerationPartial( acceleratedBody, acceleratingBody, basic_astrodynamics::central_gravity )
+{
+    accelerationUpdateFunction_ =
+            boost::bind( &basic_astrodynamics::AccelerationModel< Eigen::Vector3d>::updateMembers, gravitationalAcceleration, _1 );
+
+    gravitationalParameterFunction_ = gravitationalAcceleration->getGravitationalParameterFunction( );
+    centralBodyState_ = gravitationalAcceleration->getStateFunctionOfBodyExertingAcceleration( );
+    acceleratedBodyState_ = gravitationalAcceleration->getStateFunctionOfBodyUndergoingAcceleration( );
+    accelerationUsesMutualAttraction_ = gravitationalAcceleration->getIsMutualAttractionUsed( );
+}
+
+//! Function for setting up and retrieving a function returning a partial w.r.t. a double parameter.
+std::pair< boost::function< void( Eigen::MatrixXd& ) >, int >
+CentralGravitationPartial::getParameterPartialFunction(
+        boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > parameter )
+
+{
+    std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > partialFunctionPair;
+
+    // Check dependencies.
+    if( parameter->getParameterName( ).first ==  estimatable_parameters::gravitational_parameter )
+    {
+        // If parameter is gravitational parameter, check and create dependency function .
+        partialFunctionPair = getGravitationalParameterPartialFunction( parameter->getParameterName( ) );
+    }
+    else
+    {
+        partialFunctionPair = std::make_pair( boost::function< void( Eigen::MatrixXd& ) >( ), 0 );
+    }
+
+    return partialFunctionPair;
+}
+
+//! Function to create a function returning the current partial w.r.t. a gravitational parameter.
+std::pair< boost::function< void( Eigen::MatrixXd& ) >, int >
+CentralGravitationPartial::getGravitationalParameterPartialFunction(
+        const estimatable_parameters::EstimatebleParameterIdentifier& parameterId )
+{
+    boost::function< void( Eigen::MatrixXd& ) > partialFunction;
+    int numberOfColumns = 0;
+
+    // Check if parameter is gravitational parameter.
+    if( parameterId.first ==  estimatable_parameters::gravitational_parameter )
+    {
+        // Check if parameter body is central body.
+        if( parameterId.second.first == acceleratingBody_ )
+        {
+            partialFunction = boost::bind( &CentralGravitationPartial::wrtGravitationalParameterOfCentralBody,
+                                           this, _1 );
+            numberOfColumns = 1;
+
+        }
+
+        // Check if parameter body is accelerated body, and if the mutual acceleration is used.
+        if( parameterId.second.first == acceleratedBody_ )
+        {
+            if( accelerationUsesMutualAttraction_ )
+            {
+                partialFunction = boost::bind( &CentralGravitationPartial::wrtGravitationalParameterOfCentralBody,
+                                               this, _1 );
+                numberOfColumns = 1;
+            }
+        }
+    }
+
+    return std::make_pair( partialFunction, numberOfColumns );
+}
+
+//! Function to calculate central gravity partial w.r.t. central body gravitational parameter
+void CentralGravitationPartial::wrtGravitationalParameterOfCentralBody( Eigen::MatrixXd& gravitationalParameterPartial )
+{
+    gravitationalParameterPartial = computePartialOfCentralGravityWrtGravitationalParameter(
+                currentAcceleratedBodyState_, currentCentralBodyState_ );
+}
+
+
+
+}
+
+}
+
+}
diff --git a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/centralGravityAccelerationPartial.h b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/centralGravityAccelerationPartial.h
new file mode 100644
index 0000000..6f26a1f
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/centralGravityAccelerationPartial.h
@@ -0,0 +1,258 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_CENTRALGRAVITYACCELERATIONPARTIALS_H
+#define TUDAT_CENTRALGRAVITYACCELERATIONPARTIALS_H
+
+#include <iostream>
+
+#include "Tudat/Astrodynamics/Gravitation/centralGravityModel.h"
+
+#include "Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/accelerationPartial.h"
+
+namespace tudat
+{
+
+namespace orbit_determination
+{
+
+namespace partial_derivatives
+{
+
+using namespace gravitation;
+
+//! Calculates partial derivative of point mass gravitational acceleration wrt the position of body undergoing acceleration.
+/*!
+ *  Calculates partial derivative of point mass gravitational acceleration wrt the position of body undergoing acceleration.
+ *  \param acceleratedBodyPosition Cartesian state of body being accelerated.
+ *  \param acceleratingBodyPosition Cartesian state of body exerting acceleration.
+ *  \param gravitationalParameter Gravitational parameter of gravitating body.
+ *  \return Matrix with the Jacobian of the acceleration vector w.r.t. the position vector.
+ */
+Eigen::Matrix3d calculatePartialOfPointMassGravityWrtPositionOfAcceleratedBody(
+        const Eigen::Vector3d& acceleratedBodyPosition,
+        const Eigen::Vector3d& acceleratingBodyPosition,
+        const double gravitationalParameter );
+
+//! Calculates partial derivative of point mass gravitational acceleration wrt gravitational parameter of the central body.
+/*!
+ *  Calculates partial derivative of point mass gravitational acceleration wrt gravitational parameter of the central body.
+ *  \param acceleratedBodyPosition Cartesian state of body being accelerated.
+ *  \param acceleratingBodyPosition Cartesian state of body exerting acceleration.
+ *  \return Vector with the partial of the acceleration vector w.r.t. ational parameter of the central body.
+ */
+Eigen::Vector3d computePartialOfCentralGravityWrtGravitationalParameter( const Eigen::Vector3d& acceleratedBodyPosition,
+                                                                         const Eigen::Vector3d& acceleratingBodyPosition);
+
+
+//! Calculates partial derivative of point mass gravitational acceleration wrt gravitational parameter of the central body.
+/*!
+ *  Calculates partial derivative of point mass gravitational acceleration wrt gravitational parameter of the central body.
+ *  \param gravitationalAcceleration Gravitational acceleration vector for which partial is to be computed.
+ *  \param gravitationalParameter Gravitational parameter of gravitating body.
+ *  \return Vector with the partial of the acceleration vector w.r.t. ational parameter of the central body.
+ */
+Eigen::Vector3d computePartialOfCentralGravityWrtGravitationalParameter( const Eigen::Vector3d& gravitationalAcceleration,
+                                                                         const double gravitationalParameter );
+
+
+//! Class to calculate the partials of the central gravitational acceleration w.r.t. parameters and states.
+class CentralGravitationPartial: public AccelerationPartial
+{
+public:
+
+    //! Default constructor.
+    /*!
+     *  Default constructor.
+     *  \param gravitationalAcceleration Central gravitational acceleration w.r.t. which partials are to be taken.
+     *  \param acceleratedBody Body undergoing acceleration.
+     *  \param acceleratingBody Body exerting acceleration.
+     */
+    CentralGravitationPartial(
+            const boost::shared_ptr< gravitation::CentralGravitationalAccelerationModel3d > gravitationalAcceleration,
+            const std::string acceleratedBody,
+            const std::string acceleratingBody );
+
+    //! Function for calculating the partial of the acceleration w.r.t. the position of body undergoing acceleration..
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the position of body undergoing acceleration
+     *  and adding it to the existing partial block
+     *  Update( ) function must have been called during current time step before calling this function.
+     *  \param partialMatrix Block of partial derivatives of acceleration w.r.t. Cartesian position of body
+     *  undergoing acceleration where current partial is to be added.
+     *  \param addContribution Variable denoting whether to return the partial itself (true) or the negative partial (false).
+     *  \param startRow First row in partialMatrix block where the computed partial is to be added.
+     *  \param startColumn First column in partialMatrix block where the computed partial is to be added.
+     */
+    void wrtPositionOfAcceleratedBody(
+            Eigen::Block< Eigen::MatrixXd > partialMatrix,
+            const bool addContribution = 1, const int startRow = 0, const int startColumn = 0 )
+    {
+        if( addContribution )
+        {
+            partialMatrix.block( startRow, startColumn, 3, 3 ) += currentPartialWrtPosition_;
+        }
+        else
+        {
+            partialMatrix.block( startRow, startColumn, 3, 3 ) -= currentPartialWrtPosition_;
+        }
+    }
+
+    //! Function for calculating the partial of the acceleration w.r.t. the velocity of body undergoing acceleration..
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the velocity of body undergoing acceleration and
+     *  adding it to the existing partial block.
+     *  The update( ) function must have been called during current time step before calling this function.
+     *  \param partialMatrix Block of partial derivatives of acceleration w.r.t. Cartesian position of body
+     *  exerting acceleration where current partial is to be added.
+     *  \param addContribution Variable denoting whether to return the partial itself (true) or the negative partial (false).
+     *  \param startRow First row in partialMatrix block where the computed partial is to be added.
+     *  \param startColumn First column in partialMatrix block where the computed partial is to be added.
+     */
+    void wrtPositionOfAcceleratingBody( Eigen::Block< Eigen::MatrixXd > partialMatrix,
+                                        const bool addContribution = 1, const int startRow = 0, const int startColumn = 0 )
+    {
+        if( addContribution )
+        {
+            partialMatrix.block( startRow, startColumn, 3, 3 ) -= currentPartialWrtPosition_;
+        }
+        else
+        {
+            partialMatrix.block( startRow, startColumn, 3, 3 ) += currentPartialWrtPosition_;
+        }
+    }
+
+    //! Function for determining if the acceleration is dependent on a non-translational integrated state.
+    /*!
+     *  Function for determining if the acceleration is dependent on a non-translational integrated state.
+     *  No dependency is implemented, but a warning is provided if partial w.r.t. mass of body exerting acceleration
+     *  (and undergoing acceleration if mutual attraction is used) is requested.
+     *  \param stateReferencePoint Reference point id of propagated state
+     *  \param integratedStateType Type of propagated state for which dependency is to be determined.
+     *  \return True if dependency exists (non-zero partial), false otherwise.
+     */
+    bool isStateDerivativeDependentOnIntegratedNonTranslationalState(
+                const std::pair< std::string, std::string >& stateReferencePoint,
+                const propagators::IntegratedStateType integratedStateType )
+    {
+        if( ( ( stateReferencePoint.first == acceleratingBody_ ||
+              ( stateReferencePoint.first == acceleratedBody_  && accelerationUsesMutualAttraction_ ) )
+              && integratedStateType == propagators::body_mass_state ) )
+        {
+            std::cerr<<"Warning, dependency of central gravity on body masses not yet implemented"<<std::endl;
+        }
+        return 0;
+    }
+
+    //! Function for setting up and retrieving a function returning a partial w.r.t. a double parameter.
+    /*!
+     *  Function for setting up and retrieving a function returning a partial w.r.t. a double parameter.
+     *  Function returns empty function and zero size indicator for parameters with no dependency for current acceleration.
+     *  \param parameter Parameter w.r.t. which partial is to be taken.
+     *  \return Pair of parameter partial function and number of columns in partial (0 for no dependency, 1 otherwise).
+     */
+    virtual std::pair< boost::function< void( Eigen::MatrixXd& ) >, int >
+    getParameterPartialFunction( boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > parameter );
+
+    //! Function for setting up and retrieving a function returning a partial w.r.t. a vector parameter.
+    /*!
+     *  Function for setting up and retrieving a function returning a partial w.r.t. a vector parameter.
+     *  Function returns empty function and zero size indicator for parameters with no dependency for current acceleration.
+     *  \param parameter Parameter w.r.t. which partial is to be taken.
+     *  \return Pair of parameter partial function and number of columns in partial (0 for no dependency).
+     */
+    virtual std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > getParameterPartialFunction(
+            boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > parameter )
+    {
+        boost::function< void( Eigen::MatrixXd& ) > partialFunction;
+        return std::make_pair( partialFunction, 0 );
+    }
+
+    //! Function for updating partial w.r.t. the bodies' positions
+    /*!
+     *  Function for updating common blocks of partial to current state. For the central gravitational acceleration,
+     *  position partial is computed and set.
+     *  \param currentTime Time at which partials are to be calculated
+     */
+    void update( const double currentTime = TUDAT_NAN )
+    {
+        accelerationUpdateFunction_( currentTime );
+
+        if( !( currentTime_ == currentTime ) )
+        {
+            currentAcceleratedBodyState_ = acceleratedBodyState_( );
+            currentCentralBodyState_ = centralBodyState_( );
+            currentGravitationalParameter_ = gravitationalParameterFunction_( );
+
+            currentPartialWrtPosition_ = calculatePartialOfPointMassGravityWrtPositionOfAcceleratedBody(
+                        currentAcceleratedBodyState_,
+                        currentCentralBodyState_,
+                        currentGravitationalParameter_ );
+
+            currentTime_ = currentTime;
+        }
+    }
+
+protected:
+
+    //! Function to create a function returning the current partial w.r.t. a gravitational parameter.
+    /*!
+     * Function to create a function returning the current partial w.r.t. a gravitational parameter.
+     * \param parameterId Identified of parameter for which the partial is to be created.
+     * \return Pair with partial function and paramater partial size. The partial function is non-empty only
+     * if the parameterId input represents the gravitational parameter of acceleratingBody_ (or acceleratedBody_ if
+     * accelerationUsesMutualAttraction_ is true).
+     */
+    std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > getGravitationalParameterPartialFunction(
+            const estimatable_parameters::EstimatebleParameterIdentifier& parameterId );
+
+    //! Function to calculate central gravity partial w.r.t. central body gravitational parameter.
+    void wrtGravitationalParameterOfCentralBody( Eigen::MatrixXd& gravitationalParameterPartial );
+
+    //! Function to retrieve current gravitational parameter of central body.
+    boost::function< double( ) > gravitationalParameterFunction_;
+
+    //! Function to retrieve current state of body exerting acceleration.
+    boost::function< Eigen::Vector3d( ) > centralBodyState_;
+
+    //! Function to retrieve current state of body undergoing acceleration.
+    boost::function< Eigen::Vector3d( ) > acceleratedBodyState_;
+
+    //! Boolean denoting whether the gravitational attraction of the central body on the accelerated body is included.
+    bool accelerationUsesMutualAttraction_;
+
+    //! Current state of the body undergoing the acceleration (as set by update function).
+    Eigen::Vector3d currentAcceleratedBodyState_;
+
+    //! Current state of the body exerting the acceleration (as set by update function).
+    Eigen::Vector3d currentCentralBodyState_;
+
+    //! Current gravitational parameetr of the body exerting the acceleration (as set by update function).
+    double currentGravitationalParameter_;
+
+    //! Current partial of central gravity acceleration w.r.t. position of body undergoing acceleration
+    /*!
+     *  Current partial of central gravity acceleration w.r.t. position of body undergoing acceleration
+     * ( = -partial of central gravity acceleration w.r.t. position of body exerting acceleration),
+     *  calculated and set by update( ) function.
+     */
+    Eigen::Matrix3d currentPartialWrtPosition_;
+
+    //! Function to update the gravitational acceleration model.
+    boost::function< void( const double ) > accelerationUpdateFunction_;
+
+};
+
+}
+
+}
+
+}
+#endif // TUDAT_CENTRALGRAVITYACCELERATIONPARTIALS_H
diff --git a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/numericalAccelerationPartial.cpp b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/numericalAccelerationPartial.cpp
new file mode 100644
index 0000000..d7b4d29
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/numericalAccelerationPartial.cpp
@@ -0,0 +1,191 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#include "Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/numericalAccelerationPartial.h"
+
+namespace tudat
+{
+
+namespace orbit_determination
+{
+
+namespace partial_derivatives
+{
+
+//! Dummy function used for update, performs no calculations.
+void emptyFunction( ){ }
+
+//! Dummy function used for update, performs no calculations.
+void emptyTimeFunction( const double time ){ }
+
+//! Function to numerical compute the partial derivative of an acceleration w.r.t. a body state.
+Eigen::Matrix3d calculateAccelerationWrtStatePartials(
+        boost::function< void( basic_mathematics::Vector6d ) > setBodyState,
+        boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > accelerationModel,
+        basic_mathematics::Vector6d originalState,
+        Eigen::Vector3d statePerturbation,
+        int startIndex,
+        boost::function< void( ) > updateFunction )
+{
+    Eigen::Matrix3d upAccelerations = Eigen::Matrix3d::Zero( );
+    Eigen::Matrix3d downAccelerations = Eigen::Matrix3d::Zero( );
+
+    basic_mathematics::Vector6d perturbedState = originalState;
+
+    // Calculate perturbed accelerations for up-perturbed state entries.
+    for( int i = 0; i < 3; i++ )
+    {
+        perturbedState( i + startIndex ) += statePerturbation( i );
+        setBodyState( perturbedState );
+        updateFunction( );
+        upAccelerations.block( 0, i, 3, 1 ) = basic_astrodynamics::updateAndGetAcceleration< Eigen::Vector3d >(
+                    accelerationModel );
+        accelerationModel->resetTime( TUDAT_NAN );
+        perturbedState = originalState;
+    }
+
+    // Calculate perturbed accelerations for down-perturbed state entries.
+    for( int i = 0; i < 3; i++ )
+    {
+        perturbedState( i + startIndex ) -= statePerturbation( i );
+        setBodyState( perturbedState );
+        updateFunction( );
+        downAccelerations.block( 0, i, 3, 1 ) = basic_astrodynamics::updateAndGetAcceleration< Eigen::Vector3d >(
+                    accelerationModel );
+        accelerationModel->resetTime( TUDAT_NAN );
+        perturbedState = originalState;
+    }
+
+    // Reset state/environment to original state.
+    setBodyState( perturbedState );
+    updateFunction( );
+
+    // Numerically compute partial derivatives.
+    Eigen::Matrix3d accelerationPartials = upAccelerations - downAccelerations;
+    for( int i = 0; i < 3; i++ )
+    {
+        accelerationPartials.block( 0, i, 3, 1 ) /= ( 2.0 * statePerturbation( i ) );
+    }
+
+    return accelerationPartials;
+}
+
+//! Function to numerical compute the partial derivative of an acceleration w.r.t. a double parameter
+Eigen::Vector3d calculateAccelerationWrtParameterPartials(
+        boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > parameter,
+        boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > accelerationModel,
+        double parameterPerturbation,
+        boost::function< void( ) > updateDependentVariables,
+        const double currentTime,
+        boost::function< void( const double ) > timeDependentUpdateDependentVariables )
+{
+    // Store uperturbed value.
+    double unperturbedParameterValue = parameter->getParameterValue( );
+
+    // Calculate up-perturbation
+    parameter->setParameterValue(
+                unperturbedParameterValue + parameterPerturbation );
+    updateDependentVariables( );
+    timeDependentUpdateDependentVariables( currentTime );
+
+    Eigen::Vector3d upPerturbedAcceleration = basic_astrodynamics::updateAndGetAcceleration< Eigen::Vector3d >(
+                accelerationModel, currentTime );
+    accelerationModel->resetTime( TUDAT_NAN );
+
+    // Calculate down-perturbation.
+    parameter->setParameterValue(
+                unperturbedParameterValue - parameterPerturbation );
+    updateDependentVariables( );
+    timeDependentUpdateDependentVariables( currentTime );
+
+    Eigen::Vector3d downPerturbedAcceleration = basic_astrodynamics::updateAndGetAcceleration< Eigen::Vector3d >(
+                accelerationModel, currentTime );
+    accelerationModel->resetTime( TUDAT_NAN );
+
+    // Reset to original value.
+    parameter->setParameterValue(
+                unperturbedParameterValue ) ;
+    updateDependentVariables( );
+    timeDependentUpdateDependentVariables( currentTime );
+
+    // Calculate partial using central difference.
+    return ( upPerturbedAcceleration - downPerturbedAcceleration ) / ( 2.0 * parameterPerturbation );
+
+}
+
+//! Function to numerical compute the partial derivative of an acceleration w.r.t. a vector parameter
+Eigen::Matrix< double, 3, Eigen::Dynamic > calculateAccelerationWrtParameterPartials(
+        boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > parameter,
+        boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > accelerationModel,
+        Eigen::VectorXd parameterPerturbation,
+        boost::function< void( ) > updateDependentVariables,
+        const double currentTime,
+        boost::function< void( const double ) > timeDependentUpdateDependentVariables )
+{
+    // Store uperturbed value.
+
+    Eigen::VectorXd unperturbedParameterValue = parameter->getParameterValue( );
+
+
+    if( unperturbedParameterValue.size( ) != parameterPerturbation.size( ) )
+    {
+        throw std::runtime_error( "Error when calculating numerical parameter partial of acceleration, parameter and perturbations are not the same size" );
+    }
+
+    Eigen::Matrix< double, 3, Eigen::Dynamic > partialMatrix = Eigen::MatrixXd::Zero( 3, unperturbedParameterValue.size( ) );
+
+    Eigen::VectorXd perturbedParameterValue;
+    for( int i = 0; i < unperturbedParameterValue.size( ); i++ )
+    {
+
+        perturbedParameterValue = unperturbedParameterValue;
+        perturbedParameterValue( i ) += parameterPerturbation( i );
+
+        // Calculate up-perturbation
+        parameter->setParameterValue( perturbedParameterValue );
+        updateDependentVariables( );
+        timeDependentUpdateDependentVariables( currentTime );
+        Eigen::Vector3d upPerturbedAcceleration = basic_astrodynamics::updateAndGetAcceleration< Eigen::Vector3d >(
+                    accelerationModel, currentTime );
+        accelerationModel->resetTime( TUDAT_NAN );
+
+        // Calculate down-perturbation.
+        perturbedParameterValue = unperturbedParameterValue;
+        perturbedParameterValue( i ) -= parameterPerturbation( i );
+        parameter->setParameterValue( perturbedParameterValue );
+        updateDependentVariables( );
+        timeDependentUpdateDependentVariables( currentTime );
+        Eigen::Vector3d downPerturbedAcceleration = basic_astrodynamics::updateAndGetAcceleration< Eigen::Vector3d >(
+                    accelerationModel, currentTime );
+        accelerationModel->resetTime( TUDAT_NAN );
+
+        // Compute partial entry.
+        partialMatrix.block( 0, i, 3, 1 ) =
+                ( upPerturbedAcceleration - downPerturbedAcceleration ) / ( 2.0 * parameterPerturbation( i ) );
+
+    }
+
+    // Reset to original value.
+    parameter->setParameterValue(
+                unperturbedParameterValue ) ;
+    updateDependentVariables( );
+    timeDependentUpdateDependentVariables( currentTime );
+
+    // Calculate partial using central difference.
+    return partialMatrix;
+}
+
+
+}
+
+}
+
+}
+
diff --git a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/numericalAccelerationPartial.h b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/numericalAccelerationPartial.h
new file mode 100644
index 0000000..3a8acef
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/numericalAccelerationPartial.h
@@ -0,0 +1,116 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef NUMERICALACCELERATIONPARTIAL_H
+#define NUMERICALACCELERATIONPARTIAL_H
+
+#include <boost/function.hpp>
+
+#include <Eigen/Core>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/estimatableParameter.h"
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+
+namespace tudat
+{
+
+namespace orbit_determination
+{
+
+namespace partial_derivatives
+{
+
+//! Dummy function used for update, performs no calculations.
+/*!
+ *  Dummy function used for update, performs no calculations.
+ */
+void emptyFunction( );
+
+//! Dummy function used for update, performs no calculations.
+/*!
+ *  Dummy function used for update, performs no calculations.
+ *  \param time Input parameter, not used by function.
+ */
+void emptyTimeFunction( const double time );
+
+//! Function to numerical compute the partial derivative of an acceleration w.r.t. a body state.
+/*!
+ * Function to numerical compute the partial derivative of an acceleration w.r.t. a body state (position or velocity),
+ * using a first-order central difference method.
+ * \param setBodyState Function to reset the current state w.r.t. which the partial is to be computed.
+ * \param accelerationModel Acceleration model for which the partial derivative is to be computed.
+ * \param originalState Nominal state at which the partial derivative is to be computed.
+ * \param statePerturbation Perturbation to the position or velocity that is to be used
+ * \param startIndex Start index in the state vector from where the statePerturbation is to be added (i.e. 0 if
+ * function is to compute partial w.r.t. position, 3 if w.r.t velocity).
+ * \param updateFunction Function to update the required environment models following the change of the body state.
+ * \return Numerical partial of the acceleration w.r.t. position or velocity (depending on function input).
+ */
+Eigen::Matrix3d calculateAccelerationWrtStatePartials(
+        boost::function< void( basic_mathematics::Vector6d ) > setBodyState,
+        boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > accelerationModel,
+        basic_mathematics::Vector6d originalState,
+        Eigen::Vector3d statePerturbation,
+        int startIndex,
+        boost::function< void( ) > updateFunction = emptyFunction );
+
+//! Function to numerical compute the partial derivative of an acceleration w.r.t. a double parameter
+/*!
+ * Function to numerical compute the partial derivative of an acceleration w.r.t. a double parameter,
+ * using a first-order central difference method.
+ * \param parameter Object describing the parameter w.r.t. which teh partial is to be taken.
+ * \param accelerationModel Acceleration model for which the partial derivative is to be computed.
+ * \param parameterPerturbation Perturbation to be used for parameter value.
+ * \param updateDependentVariables  Function to update the required environment models following the change in parameter,
+ * for models that do not explicitly depend on the current time.
+ * \param currentTime Time at which partial is to be computed.
+ * \param timeDependentUpdateDependentVariables Function to update the required environment models following the change in
+ * parameters for models that do  explicitly depend on the current time.
+ * \return Numerical partial of the acceleration w.r.t. given parameter.
+ */
+Eigen::Vector3d calculateAccelerationWrtParameterPartials(
+        boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > parameter,
+        boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > accelerationModel,
+        double parameterPerturbation,
+        boost::function< void( ) > updateDependentVariables = emptyFunction,
+        const double currentTime = 0.0,
+        boost::function< void( const double ) > timeDependentUpdateDependentVariables = emptyTimeFunction );
+
+//! Function to numerical compute the partial derivative of an acceleration w.r.t. a vector parameter
+/*!
+ * Function to numerical compute the partial derivative of an acceleration w.r.t. a vector parameter,
+ * using a first-order central difference method.
+ * \param parameter Object describing the parameter w.r.t. which teh partial is to be taken.
+ * \param accelerationModel Acceleration model for which the partial derivative is to be computed.
+ * \param parameterPerturbation Perturbations to be used for parameter value.
+ * \param updateDependentVariables  Function to update the required environment models following the change in parameter,
+ * for models that do not explicitly depend on the current time.
+ * \param currentTime Time at which partial is to be computed.
+ * \param timeDependentUpdateDependentVariables Function to update the required environment models following the change in
+ * parameters for models that do  explicitly depend on the current time.
+ * \return Numerical partial of the acceleration w.r.t. given parameter.
+ */
+Eigen::Matrix< double, 3, Eigen::Dynamic > calculateAccelerationWrtParameterPartials(
+        boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > parameter,
+        boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > accelerationModel,
+        Eigen::VectorXd parameterPerturbation,
+        boost::function< void( ) > updateDependentVariables = emptyFunction,
+        const double currentTime = 0.0,
+        boost::function< void( const double ) > timeDependentUpdateDependentVariables = emptyTimeFunction );
+
+
+}
+
+}
+
+}
+
+#endif // NUMERICALACCELERATIONPARTIAL_H
diff --git a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/radiationPressureAccelerationPartial.cpp b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/radiationPressureAccelerationPartial.cpp
new file mode 100644
index 0000000..6e886e4
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/radiationPressureAccelerationPartial.cpp
@@ -0,0 +1,90 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#include <iostream>
+
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/radiationPressureCoefficient.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/radiationPressureAccelerationPartial.h"
+
+namespace tudat
+{
+
+namespace orbit_determination
+{
+
+namespace partial_derivatives
+{
+
+//! Calculates partial derivative of cannon ball radiation pressure acceleration wrt radiation pressure coefficient.
+Eigen::Vector3d computePartialOfCannonBallRadiationPressureAccelerationWrtRadiationPressureCoefficient(
+        const double radiationPressure,
+        const double area,
+        const double bodyMass,
+        const Eigen::Vector3d& vectorToSource )
+{
+    return -radiationPressure * area / bodyMass * vectorToSource;
+}
+
+//! Function for setting up and retrieving a function returning a partial w.r.t. a double parameter.
+std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > CannonBallRadiationPressurePartial::getParameterPartialFunction(
+        boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > parameter )
+{
+    boost::function< void( Eigen::MatrixXd& ) > partialFunction;
+    int numberOfRows = 0;
+
+    // Check if parameter dependency exists.
+    if( parameter->getParameterName( ).second.first == acceleratedBody_ )
+    {
+        switch( parameter->getParameterName( ).first )
+        {
+        // Set function returning partial w.r.t. radiation pressure coefficient.
+        case estimatable_parameters::radiation_pressure_coefficient:
+
+            partialFunction = boost::bind( &CannonBallRadiationPressurePartial::wrtRadiationPressureCoefficient,
+                                           this, _1 );
+            numberOfRows = 1;
+
+            break;
+        default:
+            break;
+        }
+    }
+    return std::make_pair( partialFunction, numberOfRows );
+}
+
+
+//! Function for setting up and retrieving a function returning a partial w.r.t. a vector parameter.
+std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > CannonBallRadiationPressurePartial::getParameterPartialFunction(
+        boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > parameter )
+{
+    boost::function< void( Eigen::MatrixXd& ) > partialFunction;
+    int numberOfRows = 0;
+
+    // Check if parameter dependency exists.
+    if( parameter->getParameterName( ).second.first == acceleratedBody_ )
+    {
+        switch( parameter->getParameterName( ).first )
+        {
+
+        default:
+            break;
+        }
+    }
+    return std::make_pair( partialFunction, numberOfRows );
+}
+
+
+}
+
+}
+
+}
+
+
diff --git a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/radiationPressureAccelerationPartial.h b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/radiationPressureAccelerationPartial.h
new file mode 100644
index 0000000..3b88792
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/radiationPressureAccelerationPartial.h
@@ -0,0 +1,251 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_RADIATIONPRESSUREACCELERATIONPARTIAL_H
+#define TUDAT_RADIATIONPRESSUREACCELERATIONPARTIAL_H
+
+#include <boost/shared_ptr.hpp>
+
+#include "Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/accelerationPartial.h"
+#include "Tudat/Astrodynamics/ElectroMagnetism/radiationPressureInterface.h"
+
+namespace tudat
+{
+
+namespace orbit_determination
+{
+
+namespace partial_derivatives
+{
+
+//! Calculates partial derivative of cannon ball radiation pressure acceleration wrt radiation pressure coefficient.
+/*!
+ * Calculates partial derivative of cannon ball radiation pressure acceleration wrt radiation pressure coefficient.
+ * \param radiationPressure Current radiation pressure (in N/m^2)
+ * \param area (Reference) area for radiation pressure acceleration.
+ * \param bodyMass Mass of body undergoing acceleration.
+ * \param vectorToSource Vector from body undergoing acceleration to source of radiation.
+ * \return Partial derivative of cannon ball radiation pressure acceleration wrt radiation pressure coefficient.
+ */
+Eigen::Vector3d computePartialOfCannonBallRadiationPressureAccelerationWrtRadiationPressureCoefficient(
+        const double radiationPressure,
+        const double area,
+        const double bodyMass,
+        const Eigen::Vector3d& vectorToSource );
+
+//! Class to calculate the partials of the cannnonball radiation pressure acceleration w.r.t. parameters and states.
+class CannonBallRadiationPressurePartial: public AccelerationPartial
+{
+public:
+
+    //! Constructor.
+    /*!
+     * Constructor.
+     * \param radiationPressureInterface Interface object for properties of radiation pressure computation (i.e. reference
+     * area, pressure magnitude, etc.)
+     * \param massFunction Function returning the mass of the body undergoing the acceleration.
+     * \param acceleratedBody Name of the body undergoing acceleration.
+     * \param acceleratingBody Name of the body exerting acceleration.
+     */
+    CannonBallRadiationPressurePartial(
+            const boost::shared_ptr< electro_magnetism::RadiationPressureInterface > radiationPressureInterface,
+            const boost::function< double( ) > massFunction,
+            const std::string& acceleratedBody, const std::string& acceleratingBody ):
+        AccelerationPartial( acceleratedBody, acceleratingBody,
+                             basic_astrodynamics::cannon_ball_radiation_pressure ),
+        sourceBodyState_( radiationPressureInterface->getSourcePositionFunction( ) ),
+        acceleratedBodyState_( radiationPressureInterface->getTargetPositionFunction( ) ),
+        areaFunction_( boost::bind( &electro_magnetism::RadiationPressureInterface::getArea, radiationPressureInterface ) ),
+        radiationPressureCoefficientFunction_(
+            boost::bind( &electro_magnetism::RadiationPressureInterface::getRadiationPressureCoefficient,
+                         radiationPressureInterface ) ),
+        radiationPressureFunction_( boost::bind( &electro_magnetism::RadiationPressureInterface::getCurrentRadiationPressure,
+                                                 radiationPressureInterface ) ),
+        acceleratedBodyMassFunction_( massFunction ){ }
+
+    //! Destructor.
+    ~CannonBallRadiationPressurePartial( ){ }
+
+    //! Function for calculating the partial of the acceleration w.r.t. the position of body undergoing acceleration..
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the position of body undergoing acceleration
+     *  and adding it to exting partial block.
+     *  Update( ) function must have been called during current time step before calling this function.
+     *  \param partialMatrix Block of partial derivatives of acceleration w.r.t. Cartesian position of body
+     *  undergoing acceleration where current partial is to be added.
+     *  \param addContribution Variable denoting whether to return the partial itself (true) or the negative partial (false).
+     *  \param startRow First row in partialMatrix block where the computed partial is to be added.
+     *  \param startColumn First column in partialMatrix block where the computed partial is to be added.
+     */
+    void wrtPositionOfAcceleratedBody( Eigen::Block< Eigen::MatrixXd > partialMatrix,
+                                       const bool addContribution = 1, const int startRow = 0, const int startColumn = 0 )
+    {
+        if( addContribution )
+        {
+            partialMatrix.block( startRow, startColumn, 3, 3 ) += currentPartialWrtPosition_;
+        }
+        else
+        {
+            partialMatrix.block( startRow, startColumn, 3, 3 ) -= currentPartialWrtPosition_;
+        }
+    }
+
+    //! Function for calculating the partial of the acceleration w.r.t. the velocity of body undergoing acceleration..
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the velocity of body undergoing acceleration and
+     *  adding it to exting partial block.
+     *  The update( ) function must have been called during current time step before calling this function.
+     *  \param partialMatrix Block of partial derivatives of acceleration w.r.t. Cartesian position of body
+     *  exerting acceleration where current partial is to be added.
+     *  \param addContribution Variable denoting whether to return the partial itself (true) or the negative partial (false).
+     *  \param startRow First row in partialMatrix block where the computed partial is to be added.
+     *  \param startColumn First column in partialMatrix block where the computed partial is to be added.
+     */
+    void wrtPositionOfAcceleratingBody( Eigen::Block< Eigen::MatrixXd > partialMatrix,
+                                        const bool addContribution = 1, const int startRow = 0, const int startColumn = 0 )
+    {
+        if( addContribution )
+        {
+            partialMatrix.block( startRow, startColumn, 3, 3 ) -= currentPartialWrtPosition_;
+        }
+        else
+        {
+            partialMatrix.block( startRow, startColumn, 3, 3 ) += currentPartialWrtPosition_;
+        }
+    }
+
+    //! Function for calculating the partial of the acceleration w.r.t. a non-translational integrated state
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. a non-translational integrated state
+     *  and adding it to the existing partial block.
+     *  \param partialMatrix Block of partial derivatives of where current partial is to be added.
+     *  \param stateReferencePoint Reference point id of propagated state
+     *  \param integratedStateType Type of propagated state for which partial is to be computed.
+     */
+    void wrtNonTranslationalStateOfAdditionalBody(
+            Eigen::Block< Eigen::MatrixXd > partialMatrix,
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType )
+    {
+        if( stateReferencePoint.first == acceleratedBody_ && integratedStateType == propagators::body_mass_state )
+        {
+            partialMatrix.block( 0, 0, 3, 1 ) +=
+                    radiationPressureFunction_( ) * areaFunction_( ) * radiationPressureCoefficientFunction_( ) *
+                    ( sourceBodyState_( ) - acceleratedBodyState_( ) ).normalized( ) /
+                    ( acceleratedBodyMassFunction_( ) * acceleratedBodyMassFunction_( ) );
+        }
+    }
+
+    //! Function for determining if the acceleration is dependent on a non-translational integrated state.
+    /*!
+     *  Function for determining if the acceleration is dependent on a non-translational integrated state.
+     *  \param stateReferencePoint Reference point id of propagated state
+     *  \param integratedStateType Type of propagated state for which dependency is to be determined.
+     *  \return True if dependency exists (non-zero partial), false otherwise.
+     */
+    bool isStateDerivativeDependentOnIntegratedNonTranslationalState(
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType )
+    {
+        bool isDependent = 0;
+
+        // Acceleration is dependent on mass of body undergoing acceleration.
+        if( stateReferencePoint.first == acceleratedBody_ && integratedStateType == propagators::body_mass_state )
+        {
+            isDependent = 1;
+        }
+        return isDependent;
+    }
+
+    //! Function for setting up and retrieving a function returning a partial w.r.t. a double parameter.
+    /*!
+     *  Function for setting up and retrieving a function returning a partial w.r.t. a double parameter.
+     *  Function returns empty function and zero size indicator for parameters with no dependency for current acceleration.
+     *  \param parameter Parameter w.r.t. which partial is to be taken.
+     *  \return Pair of parameter partial function and number of columns in partial (0 for no dependency, 1 otherwise).
+     */
+    std::pair< boost::function< void( Eigen::MatrixXd& ) >, int >
+    getParameterPartialFunction(
+            boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > parameter );
+
+    //! Function for setting up and retrieving a function returning a partial w.r.t. a vector parameter.
+    /*!
+     *  Function for setting up and retrieving a function returning a partial w.r.t. a vector parameter.
+     *  Function returns empty function and zero size indicator for parameters with no dependency for current acceleration.
+     *  \param parameter Parameter w.r.t. which partial is to be taken.
+     *  \return Pair of parameter partial function and number of columns in partial (0 for no dependency).
+     */
+    std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > getParameterPartialFunction(
+            boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > parameter );
+
+    void wrtRadiationPressureCoefficient( Eigen::MatrixXd& partial )
+    {
+        partial = computePartialOfCannonBallRadiationPressureAccelerationWrtRadiationPressureCoefficient(
+                    radiationPressureFunction_( ), areaFunction_( ), acceleratedBodyMassFunction_( ),
+                    ( sourceBodyState_( ) - acceleratedBodyState_( ) ).normalized( ) );
+    }
+
+    //! Function for updating partial w.r.t. the bodies' positions
+    /*!
+     *  Function for updating common blocks of partial to current state. For the radiation pressure acceleration,
+     *  position partial is computed and set.
+     *  \param currentTime Time at which partials are to be calculated
+     */
+    void update( const double currentTime = 0.0 )
+    {
+        if( !( currentTime_ == currentTime ) )
+        {
+            // Compute helper quantities.
+            Eigen::Vector3d rangeVector = ( acceleratedBodyState_( ) - sourceBodyState_( ) );
+            double range = rangeVector.norm( );
+            double rangeInverse = 1.0 / ( range );
+
+            // Compute position partial.
+            currentPartialWrtPosition_ =
+                    ( radiationPressureCoefficientFunction_( ) * areaFunction_( ) * radiationPressureFunction_( ) /
+                      acceleratedBodyMassFunction_( ) ) * ( Eigen::Matrix3d::Identity( ) * rangeInverse - 3.0 *
+                                                            rangeVector * rangeVector.transpose( ) * rangeInverse / (
+                                                                range * range ) );
+            currentTime_ = currentTime;
+        }
+    }
+
+private:
+
+    //! Function returning position of radiation source.
+    boost::function< Eigen::Vector3d( ) > sourceBodyState_;
+
+    //! Function returning position of body undergoing acceleration.
+    boost::function< Eigen::Vector3d( )> acceleratedBodyState_;
+
+    //! Function returning reflecting (or reference) area of radiation pressure on acceleratedBody_
+    boost::function< double( ) > areaFunction_;
+
+    //! Function returning current radiation pressure coefficient (usually denoted C_{r}).
+    boost::function< double( ) > radiationPressureCoefficientFunction_;
+
+    //! Function returning current radiation pressure (in N/m^{2})
+    boost::function< double( ) > radiationPressureFunction_;
+
+    //! Function returning the mass of the body undergoing the acceleration.
+    boost::function< double( ) > acceleratedBodyMassFunction_;
+
+    //! Current partial of acceleration w.r.t. position of body undergoing acceleration (equal to minus partial w.r.t.
+    //! position of body exerting acceleration).
+    Eigen::Matrix3d currentPartialWrtPosition_;
+};
+
+}
+
+}
+
+}
+
+#endif // TUDAT_RADIATIONPRESSUREACCELERATIONPARTIAL_H
diff --git a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/thirdBodyGravityPartial.h b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/thirdBodyGravityPartial.h
new file mode 100644
index 0000000..ac60a98
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/thirdBodyGravityPartial.h
@@ -0,0 +1,505 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_THIRDBODYGRAVITYPARTIAL_H
+#define TUDAT_THIRDBODYGRAVITYPARTIAL_H
+
+#include <boost/shared_ptr.hpp>
+
+#include "Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/centralGravityAccelerationPartial.h"
+
+#include "Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/accelerationPartial.h"
+
+namespace tudat
+{
+
+namespace orbit_determination
+{
+
+namespace partial_derivatives
+{
+
+//! Function to get the third body acceleration type from the direct acceleration partial object.
+/*!
+ *  Function to get the third body acceleration type from the direct acceleration partial object.
+ *  \param directGravityPartial Partial derivative of direct acceleration.
+ *  \return Type of acceleration for third body acceleration for which direct acceleration partial is given by
+ *  directGravityPartial (i.e. third_body_central_gravity if input is of type CentralGravitationPartial).
+ */
+template< typename DirectGravityPartial >
+basic_astrodynamics::AvailableAcceleration getAccelerationTypeOfThirdBodyGravity(
+        const boost::shared_ptr< DirectGravityPartial > directGravityPartial )
+{
+    using namespace basic_astrodynamics;
+    AvailableAcceleration accelerationType;
+
+    // Check type of direct partial derivative.
+    if( boost::dynamic_pointer_cast< CentralGravitationPartial >( directGravityPartial ) != NULL )
+    {
+        accelerationType = third_body_central_gravity;
+    }
+    else
+    {
+        throw std::runtime_error( "Error when getting third body partial type, type not identified" );
+    }
+    return accelerationType;
+}
+
+//! Class to calculate the partials of a third-body gravitational acceleration w.r.t. parameters and states.
+/*!
+ *  Class to calculate the partials of a third-body gravitational acceleration w.r.t. parameters and states. This class may
+ *  be used for any direct gravitational acceleration (central, spherical harmonic, mutual spherical harmonic, etc.),
+ *  providin a generic third-body partial interface. The template parameter is the derived class of AccelerationPartial
+ *  for the associated direct acceleration partial.
+ */
+template< typename DirectGravityPartial >
+class ThirdBodyGravityPartial: public AccelerationPartial
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param partialOfDirectGravityOnBodyUndergoingAcceleration Partial derivative of direct acceleration from
+     * acceleratingBody on acceleratedBody.
+     * \param partialOfDirectGravityOnCentralBody Partial derivative of direct acceleration from
+     * centralBodyName on acceleratedBody.
+     * \param acceleratedBody Name of body undergoing acceleration
+     * \param acceleratingBody Name of body exerting acceleration (third-body)
+     * \param centralBodyName Name of central body w.r.t. which the acceleration is computed.
+     */
+    ThirdBodyGravityPartial(
+            const boost::shared_ptr< DirectGravityPartial > partialOfDirectGravityOnBodyUndergoingAcceleration,
+            const boost::shared_ptr< DirectGravityPartial > partialOfDirectGravityOnCentralBody,
+            const std::string& acceleratedBody, const std::string& acceleratingBody,
+            const std::string& centralBodyName ):
+        AccelerationPartial( acceleratedBody, acceleratingBody, getAccelerationTypeOfThirdBodyGravity(
+                                 partialOfDirectGravityOnBodyUndergoingAcceleration ) ),
+        partialOfDirectGravityOnBodyUndergoingAcceleration_( partialOfDirectGravityOnBodyUndergoingAcceleration ),
+        partialOfDirectGravityOnCentralBody_( partialOfDirectGravityOnCentralBody ), centralBodyName_( centralBodyName ){ }
+
+    //! Function for calculating the partial of the acceleration w.r.t. the position of body undergoing acceleration..
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the position of body undergoing acceleration.
+     *  Update( ) function must have been called during current time step before calling this function.
+     *  \return Partial derivative of acceleration w.r.t. position of body undergoing acceleration.
+     */
+    void wrtPositionOfAcceleratedBody( Eigen::Block< Eigen::MatrixXd > partialMatrix,
+                                       const bool addContribution = 1, const int startRow = 0, const int startColumn = 0 )
+    {
+        partialOfDirectGravityOnBodyUndergoingAcceleration_->wrtPositionOfAcceleratedBody(
+                    partialMatrix, addContribution, startRow, startColumn );
+
+        // Check if acceleration on central body is dependent on acceleratedBody_
+        if( partialOfDirectGravityOnCentralBody_->isAccelerationPartialWrtAdditionalBodyNonNull( acceleratedBody_ ) == 1 )
+        {
+            partialOfDirectGravityOnCentralBody_->wrtPositionOfAdditionalBody(
+                        acceleratedBody_, partialMatrix, addContribution, startRow, startColumn   );
+        }
+    }
+
+    //! Function for calculating the partial of the acceleration w.r.t. the velocity of body undergoing acceleration..
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the velocity of body undergoing acceleration.
+     *  Update( ) function must have been called during current time step before calling this function.
+     *  \return Partial derivative of acceleration w.r.t. velocity of body undergoing acceleration.
+     */
+    void wrtVelocityOfAcceleratedBody( Eigen::Block< Eigen::MatrixXd > partialMatrix,
+                                       const bool addContribution = 1, const int startRow = 0, const int startColumn = 3 )
+    {
+        partialOfDirectGravityOnBodyUndergoingAcceleration_->wrtVelocityOfAcceleratedBody(
+                    partialMatrix, addContribution, startRow, startColumn  );
+
+        // Check if acceleration on central body is dependent on acceleratedBody_
+        if( partialOfDirectGravityOnCentralBody_->isAccelerationPartialWrtAdditionalBodyNonNull( acceleratedBody_ ) == 1 )
+        {
+            partialOfDirectGravityOnCentralBody_->wrtVelocityOfAdditionalBody(
+                        acceleratedBody_, partialMatrix, addContribution, startRow, startColumn  );
+        }
+    }
+
+    //! Function for calculating the partial of the acceleration w.r.t. the position of body exerting acceleration..
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the position of body exerting acceleration.
+     *  Update( ) function must have been called during current time step before calling this function.
+     *  \return Partial derivative of acceleration w.r.t. position of body exerting acceleration.
+     */
+    void wrtPositionOfAcceleratingBody( Eigen::Block< Eigen::MatrixXd > partialMatrix,
+                                        const bool addContribution = 1, const int startRow = 0, const int startColumn = 0 )
+
+    {
+        // Add partials for both direct acceleration and acceleration on central body.
+        partialOfDirectGravityOnBodyUndergoingAcceleration_->wrtPositionOfAcceleratingBody(
+                    partialMatrix, addContribution, startRow, startColumn  );
+        partialOfDirectGravityOnCentralBody_->wrtPositionOfAcceleratingBody(
+                    partialMatrix, ( ( addContribution == true ) ? ( false ) : ( true ) ), startRow, startColumn  );
+
+    }
+
+
+    //! Function for calculating the partial of the acceleration w.r.t. the velocity of body exerting acceleration..
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the velocity of body exerting acceleration.
+     *  Update( ) function must have been called during current time step before calling this function.
+     *  \return Partial derivative of acceleration w.r.t. velocity of body exerting acceleration.
+     */
+    void wrtVelocityOfAcceleratingBody( Eigen::Block< Eigen::MatrixXd > partialMatrix,
+                                        const bool addContribution = 1, const int startRow = 0, const int startColumn = 3 )
+    {
+        // Add partials for both direct acceleration and acceleration on central body.
+        partialOfDirectGravityOnBodyUndergoingAcceleration_->wrtVelocityOfAcceleratingBody(
+                    partialMatrix, addContribution, startRow, startColumn );
+        partialOfDirectGravityOnCentralBody_->wrtVelocityOfAcceleratingBody(
+                    partialMatrix, ( ( addContribution == true ) ? ( false ) : ( true ) ), startRow, startColumn );
+    }
+
+    //! Function for calculating the partial of the acceleration w.r.t. the position of an additiona body.
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the position of an additional body (in addition
+     *  to the body undergoing and exerting the acceleration) and adding it to the existing partial block.
+     *  This function check if the requested additional body equals the central body name. Also, it checks whether either
+     *  the direct or indirect acceleration depend on this additional body. The partial computation is then updated
+     *  accordingly
+     *  \param bodyName Name of additional body.
+     *  \param partialMatrix Block of partial derivatives of acceleration w.r.t. Cartesian position of third body where
+     *  current partial is to be added.
+     *  \param addContribution Variable denoting whether to return the partial itself (true) or the negative partial (false).
+     *  \param startRow First row in partialMatrix block where the computed partial is to be added.
+     *  \param startColumn First column in partialMatrix block where the computed partial is to be added.
+     */
+    void wrtPositionOfAdditionalBody( const std::string& bodyName, Eigen::Block< Eigen::MatrixXd > partialMatrix,
+                                      const bool addContribution = 1, const int startRow = 0, const int startColumn = 0 )
+    {
+        if( bodyName == centralBodyName_ )
+        {
+            partialOfDirectGravityOnCentralBody_->wrtPositionOfAcceleratedBody(
+                        partialMatrix, ( ( addContribution == true ) ? ( false ) : ( true ) ), startRow, startColumn  );
+        }
+
+        if( partialOfDirectGravityOnBodyUndergoingAcceleration_->isAccelerationPartialWrtAdditionalBodyNonNull( bodyName ) )
+        {
+            partialOfDirectGravityOnBodyUndergoingAcceleration_->wrtPositionOfAdditionalBody(
+                        bodyName, partialMatrix, addContribution, startRow, startColumn  );
+        }
+
+        if( partialOfDirectGravityOnCentralBody_->isAccelerationPartialWrtAdditionalBodyNonNull( bodyName ) )
+        {
+            partialOfDirectGravityOnCentralBody_->wrtPositionOfAdditionalBody(
+                        bodyName, partialMatrix, ( ( addContribution == true ) ? ( false ) : ( true ) ), startRow, startColumn );
+        }
+    }
+
+    //! Function for calculating the partial of the acceleration w.r.t. the velocity of an additiona body.
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. the velocity of an additional body (in addition
+     *  to the body undergoing and exerting the acceleration) and adding it to the existing partial block.
+     *  This function check if the requested additional body equals the central body name. Also, it checks whether either
+     *  the direct or indirect acceleration depend on this additional body. The partial computation is then updated
+     *  accordingly
+     *  \param bodyName Name of additional body.
+     *  \param partialMatrix Block of partial derivatives of acceleration w.r.t. Cartesian position of third body where
+     *  current partial is to be added.
+     *  \param addContribution Variable denoting whether to return the partial itself (true) or the negative partial (false).
+     *  \param startRow First row in partialMatrix block where the computed partial is to be added.
+     *  \param startColumn First column in partialMatrix block where the computed partial is to be added.
+     */
+    void wrtVelocityOfAdditionalBody( const std::string& bodyName, Eigen::Block< Eigen::MatrixXd > partialMatrix,
+                                      const bool addContribution = 1, const int startRow = 0, const int startColumn = 3 )
+    {
+        if( bodyName == centralBodyName_ )
+        {
+            partialOfDirectGravityOnCentralBody_->wrtVelocityOfAcceleratedBody(
+                        partialMatrix, ( ( addContribution == true ) ? ( false ) : ( true ) ), startRow, startColumn  );
+        }
+
+        if( partialOfDirectGravityOnBodyUndergoingAcceleration_->isAccelerationPartialWrtAdditionalBodyNonNull( bodyName ) )
+        {
+            partialOfDirectGravityOnBodyUndergoingAcceleration_->wrtVelocityOfAdditionalBody(
+                        bodyName, partialMatrix, addContribution, startRow, startColumn );
+        }
+
+        if( partialOfDirectGravityOnCentralBody_->isAccelerationPartialWrtAdditionalBodyNonNull( bodyName ) )
+        {
+            partialOfDirectGravityOnCentralBody_->wrtVelocityOfAdditionalBody(
+                        bodyName, partialMatrix, ( ( addContribution == true ) ? ( false ) : ( true ) ), startRow, startColumn );
+        }
+    }
+
+    //! Function for checking whether the partial of the acceleration w.r.t. the state of an additional body is non-zero.
+    /*!
+     *  Function for checking whether the partial of the acceleration w.r.t. the state of an additional body is non-zero
+     *  \param bodyName Name of additional body.
+     *  \return True if dependency exists
+     */
+    bool isAccelerationPartialWrtAdditionalBodyNonNull( const std::string& bodyName )
+    {
+        bool isAccelerationDependentOnBody = 0;
+        if( bodyName == centralBodyName_ )
+        {
+            isAccelerationDependentOnBody = 1;
+        }
+
+        if( ( partialOfDirectGravityOnCentralBody_->isAccelerationPartialWrtAdditionalBodyNonNull( bodyName ) == 1 ) ||
+                ( partialOfDirectGravityOnBodyUndergoingAcceleration_->isAccelerationPartialWrtAdditionalBodyNonNull( bodyName ) == 1 ) )
+        {
+            isAccelerationDependentOnBody = 1;
+        }
+
+        return isAccelerationDependentOnBody;
+    }
+
+    //! Function for calculating the partial of the acceleration w.r.t. a non-translational integrated state
+    /*!
+     *  Function for calculating the partial of the acceleration w.r.t. a non-translational integrated state
+     *  and adding it to the existing partial block.
+     *  \param partialMatrix Block of partial derivatives of where current partial is to be added.
+     *  \param stateReferencePoint Reference point id of propagated state
+     *  \param integratedStateType Type of propagated state for which partial is to be computed.
+     */
+    void wrtNonTranslationalStateOfAdditionalBody(
+            Eigen::Block< Eigen::MatrixXd > partialMatrix,
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType )
+    {
+        partialOfDirectGravityOnCentralBody_->
+                        wrtNonTranslationalStateOfAdditionalBody(
+                            partialMatrix, stateReferencePoint, integratedStateType );
+        partialOfDirectGravityOnBodyUndergoingAcceleration_->
+                        wrtNonTranslationalStateOfAdditionalBody(
+                            partialMatrix, stateReferencePoint, integratedStateType );
+    }
+
+    //! Function for determining if the acceleration is dependent on a non-translational integrated state.
+    /*!
+     *  Function for determining if the acceleration is dependent on a non-translational integrated state.
+     *  \param stateReferencePoint Reference point id of propagated state
+     *  \param integratedStateType Type of propagated state for which dependency is to be determined.
+     *  \return True if dependency exists (non-zero partial), false otherwise.
+     */
+    bool isStateDerivativeDependentOnIntegratedNonTranslationalState(
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType )
+    {
+        if( partialOfDirectGravityOnCentralBody_->
+                isStateDerivativeDependentOnIntegratedNonTranslationalState(
+                    stateReferencePoint, integratedStateType ) ||
+                partialOfDirectGravityOnBodyUndergoingAcceleration_->
+                isStateDerivativeDependentOnIntegratedNonTranslationalState(
+                    stateReferencePoint, integratedStateType ) )
+        {
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+
+
+    //! Function for setting up and retrieving a function returning a partial w.r.t. a double parameter.
+    /*!
+     *  Function for setting up and retrieving a function returning a partial w.r.t. a double parameter.
+     *  Function returns empty function and zero size indicator for parameters with no dependency for current acceleration.
+     *  \param parameter Parameter w.r.t. which partial is to be taken.
+     *  \return Pair of parameter partial function and number of columns in partial (0 for no dependency, 1 otherwise).
+     */
+    std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > getParameterPartialFunction(
+            boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > parameter )
+    {
+        std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > partialFunctionFromDirectGravity =
+                partialOfDirectGravityOnBodyUndergoingAcceleration_->getParameterPartialFunction( parameter );
+        std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > partialFunctionFromCentralGravity =
+                partialOfDirectGravityOnCentralBody_->getParameterPartialFunction( parameter );
+
+        return createMergedParameterPartialFunction( partialFunctionFromDirectGravity,
+                                                     partialFunctionFromCentralGravity );
+    }
+
+    //! Function for setting up and retrieving a function returning a partial w.r.t. a vector parameter.
+    /*!
+     *  Function for setting up and retrieving a function returning a partial w.r.t. a vector parameter.
+     *  Function returns empty function and zero size indicator for parameters with no dependency for current acceleration.
+     *  \param parameter Parameter w.r.t. which partial is to be taken.
+     *  \return Pair of parameter partial function and number of columns in partial (0 for no dependency).
+     */
+    std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > getParameterPartialFunction(
+            boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > parameter )
+    {
+        std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > partialFunctionFromDirectGravity =
+                partialOfDirectGravityOnBodyUndergoingAcceleration_->getParameterPartialFunction( parameter );
+        std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > partialFunctionFromCentralGravity =
+                partialOfDirectGravityOnCentralBody_->getParameterPartialFunction( parameter );
+
+        return createMergedParameterPartialFunction( partialFunctionFromDirectGravity,
+                                                     partialFunctionFromCentralGravity );
+    }
+
+    //! Function to set a dependency of this partial object w.r.t. a given double parameter.
+    /*!
+     * Function to set a dependency of this partial object w.r.t. a given double parameter. If a dependency exists, the given
+     * partial is recomputed on every call of updateParameterPartials.
+     * \param parameter Partial w.r.t. which dependency is to be checked and set.
+     * \return Size (number of columns) of parameter partial. Zero if no dependency, 1 otherwise.
+     */
+    int setParameterPartialUpdateFunction(
+            boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > parameter )
+    {
+        // Check parameter dependency of direct acceleration.
+        std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > partialFunctionFromDirectGravity =
+                partialOfDirectGravityOnBodyUndergoingAcceleration_->getParameterPartialFunction( parameter );
+        if( partialFunctionFromDirectGravity.second > 0 )
+        {
+            partialOfDirectGravityOnBodyUndergoingAcceleration_->setParameterPartialUpdateFunction( parameter );
+        }
+
+        // Check parameter dependency of indirect acceleration.
+        std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > partialFunctionFromCentralGravity =
+                partialOfDirectGravityOnCentralBody_->getParameterPartialFunction( parameter );
+        if( partialFunctionFromCentralGravity.second > 0 )
+        {
+            partialOfDirectGravityOnCentralBody_->setParameterPartialUpdateFunction( parameter );
+        }
+
+        // If either dependency exists, create combined partial.
+        if( partialFunctionFromCentralGravity.second > 0 || partialFunctionFromDirectGravity.second > 0 )
+        {
+            parameterDoublePartialFunctions_[ parameter ] =
+                    getCombinedCurrentDoubleParameterFunction(
+                        partialOfDirectGravityOnBodyUndergoingAcceleration_,
+                        partialOfDirectGravityOnCentralBody_,
+                        parameter, partialFunctionFromDirectGravity.second, partialFunctionFromCentralGravity.second, 1 );
+            isCurrentDoubleParameterPartialSet_[ parameter ] = 0;
+            currentDoubleParameterPartials_[ parameter ] = Eigen::MatrixXd( accelerationSize_, 1 );
+        }
+        return std::max( partialFunctionFromDirectGravity.second, partialFunctionFromCentralGravity.second );
+    }
+
+    //! Function to set a dependency of this partial object w.r.t. a given vector parameter.
+    /*!
+     * Function to set a dependency of this partial object w.r.t. a given vector parameter. If a dependency exists, the given
+     * partial is recomputed on every call of updateParameterPartials.
+     * \param parameter Partial w.r.t. which dependency is to be checked and set.
+     * \return Size (number of columns) of parameter partial. Zero if no dependency, size of parameter otherwise.
+     */
+    int setParameterPartialUpdateFunction(
+            boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > parameter )
+    {
+        // Check parameter dependency of direct acceleration.
+        std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > partialFunctionFromDirectGravity =
+                partialOfDirectGravityOnBodyUndergoingAcceleration_->getParameterPartialFunction( parameter );
+        if( partialFunctionFromDirectGravity.second > 0 )
+        {
+            partialOfDirectGravityOnBodyUndergoingAcceleration_->setParameterPartialUpdateFunction( parameter );
+        }
+
+        // Check parameter dependency of indirect acceleration.
+        std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > partialFunctionFromCentralGravity =
+                partialOfDirectGravityOnCentralBody_->getParameterPartialFunction( parameter );
+        if( partialFunctionFromCentralGravity.second > 0 )
+        {
+            partialOfDirectGravityOnCentralBody_->setParameterPartialUpdateFunction( parameter );
+        }
+
+        // If either dependency exists, create combined partial.
+        if( partialFunctionFromCentralGravity.second > 0 || partialFunctionFromDirectGravity.second > 0 )
+        {
+            parameterVectorPartialFunctions_[ parameter ] =
+                    getCombinedCurrentVectorParameterFunction(
+                        partialOfDirectGravityOnBodyUndergoingAcceleration_,
+                        partialOfDirectGravityOnCentralBody_,
+                        parameter, partialFunctionFromDirectGravity.second, partialFunctionFromCentralGravity.second, 1 );
+            isCurrentVectorParameterPartialSet_[ parameter ] = 0;
+            currentVectorParameterPartials_[ parameter ] = Eigen::MatrixXd( accelerationSize_, parameter->getParameterSize( ) );
+
+        }
+        return std::max( partialFunctionFromDirectGravity.second, partialFunctionFromCentralGravity.second );
+    }
+
+    //! Function for updating partials  w.r.t. the bodies' positions
+    /*!
+     *  Function for updating common blocks of partial to current state. For the third body gravitational acceleration,
+     *  the update functions of both constituent accelerations are updated.
+     *  \param currentTime Time at which partials are to be calculated
+     */
+    void update( const double currentTime )
+    {
+        partialOfDirectGravityOnBodyUndergoingAcceleration_->update( currentTime );
+        partialOfDirectGravityOnCentralBody_->update( currentTime );
+
+        currentTime_ = currentTime;
+    }
+
+    //! Function to get partial derivative object of direct acceleration from centralBodyName on acceleratedBody.
+    /*!
+     * Function to get the partial derivative object of direct acceleration from centralBodyName on acceleratedBody.
+     * \return Partial derivative object of direct acceleration from centralBodyName on acceleratedBody.
+     */
+    boost::shared_ptr< DirectGravityPartial > getPartialOfDirectGravityOnBodyUndergoingAcceleration( )
+    {
+        return partialOfDirectGravityOnBodyUndergoingAcceleration_;
+    }
+
+    //! Function to get partial derivative object of direct acceleration from acceleratingBody on acceleratedBody.
+    /*!
+     * Function to get the partial derivative object of direct acceleration from acceleratingBody on acceleratedBody.
+     * \return Partial derivative object of direct acceleration from acceleratingBody on acceleratedBody.
+     */
+    boost::shared_ptr< DirectGravityPartial > getPartialOfDirectGravityOnCentralBody( )
+    {
+        return partialOfDirectGravityOnCentralBody_;
+    }
+
+    //! Function to get the name of central body w.r.t. which the acceleration is computed.
+    /*!
+     * Function to get the name of central body w.r.t. which the acceleration is computed.
+     * \return Name of central body w.r.t. which the acceleration is computed.
+     */
+    std::string getCentralBodyName( )
+    {
+        return centralBodyName_;
+    }
+
+
+protected:
+
+    //!! Function to reset the constituent DirectGravityPartial objects to the current time.
+    void resetTimeOfMemberObjects( )
+    {
+        partialOfDirectGravityOnBodyUndergoingAcceleration_->resetTime( currentTime_ );
+        partialOfDirectGravityOnCentralBody_->resetTime( currentTime_ );
+    }
+
+    //!! Function to update the parameter partials of the constituent DirectGravityPartial objects.
+    void updateParameterPartialsOfMemberObjects( )
+    {
+        partialOfDirectGravityOnBodyUndergoingAcceleration_->updateParameterPartials( );
+        partialOfDirectGravityOnCentralBody_->updateParameterPartials( );
+    }
+
+private:
+    //! Partial derivative object of direct acceleration from acceleratingBody on acceleratedBody.
+    boost::shared_ptr< DirectGravityPartial > partialOfDirectGravityOnBodyUndergoingAcceleration_;
+
+    //! Partial derivative object of direct acceleration from centralBodyName on acceleratedBody.
+    boost::shared_ptr< DirectGravityPartial > partialOfDirectGravityOnCentralBody_;
+
+    //! Name of central body w.r.t. which the acceleration is computed.
+    std::string centralBodyName_;
+
+};
+
+}
+
+}
+
+}
+
+#endif // TUDAT_THIRDBODYGRAVITYPARTIAL_H
diff --git a/Tudat/Astrodynamics/OrbitDetermination/CMakeLists.txt b/Tudat/Astrodynamics/OrbitDetermination/CMakeLists.txt
new file mode 100644
index 0000000..cf627a5
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/CMakeLists.txt
@@ -0,0 +1,72 @@
+# \file CMakeLists.txt
+ #    This is the CMake file for the MissionSegments sub-directory.
+ #
+ #    Path              : /Astrodynamics/MissionSegments/
+ #    Version           : 3
+ #    Check status      : Checked
+ #
+ #    Author            : S.M. Persson
+ #    Affiliation       : McGill University, Department of Mechanical Engineering
+ #    E-mail address    : mikael.s.persson@gmail.com
+ #
+ #    Author            : K. Kumar
+ #    Affiliation       : Delft University of Technology
+ #    E-mail address    : K.Kumar@tudelft.nl
+ #
+ #    Author            : S.M. Persson
+ #    Affiliation       : McGill University, Department of Mechanical Engineering
+ #    E-mail address    : mikael.s.persson@gmail.com
+ #
+ #    Date created      : 20 August, 2011
+ #    Last modified     : 26 October, 2011
+ #
+ #    References
+ #
+ #    Notes
+ #
+ #    Copyright (c) 2010-2011 Delft University of Technology.
+ #
+ #    This software is protected by national and international copyright.
+ #    Any unauthorized use, reproduction or modification is unlawful and
+ #    will be prosecuted. Commercial and non-private application of the
+ #    software in any form is strictly prohibited unless otherwise granted
+ #    by the authors.
+ #
+ #    The code is provided without any warranty; without even the implied
+ #    warranty of merchantibility or fitness for a particular purpose.
+ #
+ #    Changelog
+ #      YYMMDD    Author            Comment
+ #      110820    S.M. Persson      File created.
+ #      111025    K. Kumar          Adapted file to work with Revision 194.
+ #      111026    K. Kumar          Adapted file so all headers show in project tree in Qt Creator.
+ #/
+
+set(ACCELERATIONPARTIALSDIR "${ORBITDETERMINATIONDIR}/AccelerationPartials")
+set(ESTIMATABLEPARAMETERSDIR "${ORBITDETERMINATIONDIR}/EstimatableParameters")
+
+
+# Add subdirectories.
+add_subdirectory("${SRCROOT}${ACCELERATIONPARTIALSDIR}")
+add_subdirectory("${SRCROOT}${ESTIMATABLEPARAMETERSDIR}")
+
+# Get target properties for static libraries.
+get_target_property(ACCELERATIONPARTIALSSOURCES tudat_acceleration_partials SOURCES)
+get_target_property(ESTIMATABLEPARAMETERSOURCES tudat_estimatable_parameters SOURCES)
+
+# Set the source files.
+set(ORBIT_DETERMINATION_SOURCES
+  "${SRCROOT}${ORBITDETERMINATIONDIR}/stateDerivativePartial.cpp"
+)
+
+# Set the header files.
+set(ORBIT_DETERMINATION_HEADERS
+  "${SRCROOT}${ORBITDETERMINATIONDIR}/stateDerivativePartial.h"
+)
+
+
+# Add static libraries.
+add_library(tudat_orbit_determination STATIC ${ORBIT_DETERMINATION_SOURCES} ${ORBIT_DETERMINATION_HEADERS})
+setup_tudat_library_target(tudat_orbit_determination "${SRCROOT}{ORBITDETERMINATIONDIR}")
+
+
diff --git a/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/CMakeLists.txt b/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/CMakeLists.txt
new file mode 100644
index 0000000..8d50b7e
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/CMakeLists.txt
@@ -0,0 +1,62 @@
+# \file CMakeLists.txt
+ #    This is the CMake file for the MissionSegments sub-directory.
+ #
+ #    Path              : /Astrodynamics/MissionSegments/
+ #    Version           : 3
+ #    Check status      : Checked
+ #
+ #    Author            : S.M. Persson
+ #    Affiliation       : McGill University, Department of Mechanical Engineering
+ #    E-mail address    : mikael.s.persson@gmail.com
+ #
+ #    Author            : K. Kumar
+ #    Affiliation       : Delft University of Technology
+ #    E-mail address    : K.Kumar@tudelft.nl
+ #
+ #    Author            : S.M. Persson
+ #    Affiliation       : McGill University, Department of Mechanical Engineering
+ #    E-mail address    : mikael.s.persson@gmail.com
+ #
+ #    Date created      : 20 August, 2011
+ #    Last modified     : 26 October, 2011
+ #
+ #    References
+ #
+ #    Notes
+ #
+ #    Copyright (c) 2010-2011 Delft University of Technology.
+ #
+ #    This software is protected by national and international copyright.
+ #    Any unauthorized use, reproduction or modification is unlawful and
+ #    will be prosecuted. Commercial and non-private application of the
+ #    software in any form is strictly prohibited unless otherwise granted
+ #    by the authors.
+ #
+ #    The code is provided without any warranty; without even the implied
+ #    warranty of merchantibility or fitness for a particular purpose.
+ #
+ #    Changelog
+ #      YYMMDD    Author            Comment
+ #      110820    S.M. Persson      File created.
+ #      111025    K. Kumar          Adapted file to work with Revision 194.
+ #      111026    K. Kumar          Adapted file so all headers show in project tree in Qt Creator.
+ #/
+
+# Set the source files.
+set(ESTIMATABLE_PARAMETERS_SOURCES
+  "${SRCROOT}${ESTIMATABLEPARAMETERSDIR}/estimatableParameter.cpp"
+  "${SRCROOT}${ESTIMATABLEPARAMETERSDIR}/initialTranslationalState.cpp"
+)
+
+# Set the header files.
+set(ESTIMATABLE_PARAMETERS_HEADERS
+  "${SRCROOT}${ESTIMATABLEPARAMETERSDIR}/estimatableParameter.h"
+  "${SRCROOT}${ESTIMATABLEPARAMETERSDIR}/gravitationalParameter.h"
+  "${SRCROOT}${ESTIMATABLEPARAMETERSDIR}/initialTranslationalState.h"
+  "${SRCROOT}${ESTIMATABLEPARAMETERSDIR}/radiationPressureCoefficient.h"
+)
+
+# Add static libraries.
+add_library(tudat_estimatable_parameters STATIC ${ESTIMATABLE_PARAMETERS_SOURCES} ${ESTIMATABLE_PARAMETERS_HEADERS})
+setup_tudat_library_target(tudat_estimatable_parameters "${SRCROOT}{ESTIMATABLEPARAMETERSDIR}")
+
diff --git a/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/estimatableParameter.cpp b/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/estimatableParameter.cpp
new file mode 100644
index 0000000..b5decef
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/estimatableParameter.cpp
@@ -0,0 +1,53 @@
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/estimatableParameter.h"
+
+namespace tudat
+{
+
+namespace estimatable_parameters
+{
+
+//! Function to determine whether the given parameter represents an initial dynamical state, or a static parameter.
+bool isParameterDynamicalPropertyInitialState( const EstimatebleParametersEnum parameterType )
+{
+    bool flag;
+    switch( parameterType )
+    {
+    case initial_body_state:
+        flag = true;
+        break;
+    default:
+        flag = false;
+        break;
+    }
+    return flag;
+}
+
+//! Function to determine whether the given (non-dynamical) parameter is a double or vector parameter.
+bool isDoubleParameter( const EstimatebleParametersEnum parameterType )
+{
+    bool isDoubleParameter;
+    switch( parameterType )
+    {
+    case gravitational_parameter:
+        isDoubleParameter = true;
+        break;
+    case constant_drag_coefficient:
+        isDoubleParameter = true;
+        break;
+    case radiation_pressure_coefficient:
+        isDoubleParameter = true;
+        break;
+    default:
+        throw std::runtime_error( "Error, parameter type " + boost::lexical_cast< std::string >( parameterType ) +
+                                  " not found when getting parameter type" );
+    }
+    return isDoubleParameter;
+}
+
+
+
+
+}
+
+}
+
diff --git a/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/estimatableParameter.h b/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/estimatableParameter.h
new file mode 100644
index 0000000..4ca4778
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/estimatableParameter.h
@@ -0,0 +1,579 @@
+#ifndef TUDAT_ESTIMATABLEPARAMETERS_H
+#define TUDAT_ESTIMATABLEPARAMETERS_H
+
+#include <iomanip>
+#include <iostream>
+#include <string>
+#include <vector>
+
+#include <boost/shared_ptr.hpp>
+#include <boost/assign/list_of.hpp>
+
+#include <Eigen/Geometry>
+
+
+#include "Tudat/Astrodynamics/Propagators/propagationSettings.h"
+namespace tudat
+{
+
+namespace estimatable_parameters
+{
+
+//! List of parameters that can be estimated by the orbit determination code.
+enum EstimatebleParametersEnum
+{
+    initial_body_state,
+    gravitational_parameter,
+    constant_drag_coefficient,
+    radiation_pressure_coefficient
+
+};
+
+//! Function to determine whether the given parameter represents an initial dynamical state, or a static parameter.
+/*!
+ * Function to determine whether the given parameter represents an initial dynamical state, or a static parameter.
+ * \param parameterType Parameter identifier.
+ * \return True if parameter is an initial dynamical state.
+ */
+bool isParameterDynamicalPropertyInitialState( const EstimatebleParametersEnum parameterType );
+
+//! Function to determine whether the given (non-dynamical) parameter is a double or vector parameter.
+/*!
+ * Function to determine whether the given (non-dynamical) parameter is a double or vector parameter.
+ * \param parameterType Parameter identifier.
+ * \return True if parameter is a double parameter.
+ */
+bool isDoubleParameter( const EstimatebleParametersEnum parameterType );
+
+//! Typedef for full parameter identifier.
+typedef std::pair< EstimatebleParametersEnum, std::pair< std::string, std::string > > EstimatebleParameterIdentifier;
+
+
+
+//! Base class for a parameter that is to be estimated.
+/*!
+ *  Base class for a parameter that is to be estimated. A separate derived class is to be made for each type of parameter
+ *  (i.e. gravitational parameter, initial translational state, etc. ).
+ */
+template< typename ParameterType >
+class EstimatableParameter
+{
+
+public:
+    //! Constructor.
+    /*!
+     *  Constructor taking parameter name and associated body. All parameters are identified by a these two variables.
+     *  Any additional information that may be required for uniquely defining a parameter is to be defined in the derived class.
+     *  \param parameterName Enum value defining the type of the parameter.
+     *  \param associatedBody Name of body associated with patameters
+     *  \param pointOnBodyId Reference point on body associated with parameter (empty by default).
+     */
+    EstimatableParameter( const EstimatebleParametersEnum parameterName,
+                          const std::string& associatedBody,
+                          const std::string& pointOnBodyId = ""  ):
+        parameterName_( std::make_pair( parameterName, std::make_pair( associatedBody, pointOnBodyId ) ) ){ }
+
+    //! Virtual destructor.
+    virtual ~EstimatableParameter( ) { }
+
+    //! Pure virtual function to retrieve the value of the parameter
+    /*!
+     *  Pure virtual function to retrieve the value of the parameter
+     *  \return Current value of parameter.
+     */
+    virtual ParameterType getParameterValue( ) = 0;
+
+    //! Pure virtual function to (re)set the value of the parameter.
+    /*!
+     *  Pure virtual function to (re)set the value of the parameter.
+     *  \param parameterValue to which the parameter is to be set.
+     */
+    virtual void setParameterValue( ParameterType parameterValue ) = 0;
+
+    //! Function to retrieve the type and associated body of the parameter.
+    /*!
+     *  Function to retrieve the type and associated body of the parameter.
+     *  \return Identifier of parameter as a pair of parameter type and body of which parameter is a property.
+     */
+    EstimatebleParameterIdentifier getParameterName( ) { return parameterName_; }
+
+    //! Function to retrieve the size of the parameter
+    /*!
+     *  Pure virtual function to retrieve the size of the parameter (i.e. 1 for double parameters)
+     *  \return Size of parameter value.
+     */
+    virtual int getParameterSize( ) = 0;
+
+    //! Function to return additional identifier for parameter
+    /*!
+     *  Function to return additional identifier for parameter, beyond information stored in parameterName_, default
+     *  none.
+     *  \return Additional identifier for parameter (default empty string).
+     */
+    virtual std::string getSecondaryIdentifier( )
+    {
+        return "";
+    }
+
+protected:
+
+    //! Identifier of parameter.
+    EstimatebleParameterIdentifier parameterName_;
+};
+
+//! Container class for all parameters that are to be estimated.
+/*!
+ *  Container class for all parameters that are to be estimated. Class is templated with the scalar type used for the
+ *  estimation of any initial dynamical states that may be included
+ */
+template< typename InitialStateParameterType = double >
+class EstimatableParameterSet
+{
+public:
+
+    //! Constructor of parameter set.
+    /*!
+     *  Constructor of parameter set.
+     *  \param estimatedDoubleParameters List of double parameters that are estimated.
+     *  \param estimatedVectorParameters List of vector parameters that are estimated.
+     *  \param estimateInitialStateParameters List of initial dynamical states that are to be estimated.
+     */
+    EstimatableParameterSet(
+            const std::vector< boost::shared_ptr< EstimatableParameter< double > > >& estimatedDoubleParameters,
+            const std::vector< boost::shared_ptr< EstimatableParameter< Eigen::VectorXd > > >& estimatedVectorParameters,
+            const std::vector< boost::shared_ptr< EstimatableParameter< Eigen::Matrix
+            < InitialStateParameterType, Eigen::Dynamic, 1 > > > >& estimateInitialStateParameters =
+            ( std::vector< boost::shared_ptr< EstimatableParameter< Eigen::Matrix
+            < InitialStateParameterType, Eigen::Dynamic, 1 > > > >( ) ) ):
+        estimatedDoubleParameters_( estimatedDoubleParameters ), estimatedVectorParameters_( estimatedVectorParameters ),
+        estimateInitialStateParameters_( estimateInitialStateParameters )
+    {
+        // Initialize total number of parameters to 0.
+        estimatedParameterSetSize_ = 0;
+        initialDynamicalStateParameterSize_ = 0;
+
+        // Iterate over all double parameters and add to parameter size.
+        for( unsigned int i = 0; i < estimateInitialStateParameters_.size( ); i++ )
+        {
+            initialStateParameters_[ estimatedParameterSetSize_ ] = estimateInitialStateParameters_[ i ];
+            parameterIndices_.push_back( std::make_pair( estimatedParameterSetSize_,
+                                                         estimateInitialStateParameters_[ i ]->getParameterSize( ) ) );
+            estimatedParameterSetSize_ += estimateInitialStateParameters_[ i ]->getParameterSize( );
+            initialDynamicalStateParameterSize_ += estimateInitialStateParameters_[ i ]->getParameterSize( );
+        }
+
+        // Iterate over all double parameters and add to parameter size and set indices in parameterIndices_
+        for( unsigned int i = 0; i < estimatedDoubleParameters_.size( ); i++ )
+        {
+            doubleParameters_[ estimatedParameterSetSize_ ] = estimatedDoubleParameters_[ i ];
+            parameterIndices_.push_back( std::make_pair( estimatedParameterSetSize_, 1 ) );
+            estimatedParameterSetSize_++;
+        }
+
+        // Iterate over all vector parameter, add to total number of parameters and set indices in parameterIndices_
+        for( unsigned int i = 0; i < estimatedVectorParameters_.size( ); i++ )
+        {
+            vectorParameters_[ estimatedParameterSetSize_ ] = estimatedVectorParameters_[ i ];
+            parameterIndices_.push_back( std::make_pair( estimatedParameterSetSize_,
+                                                         estimatedVectorParameters_[ i ]->getParameterSize( ) ) );
+            estimatedParameterSetSize_ += estimatedVectorParameters_[ i ]->getParameterSize( );
+        }
+
+        totalParameterSetSize_ = estimatedParameterSetSize_;
+    }
+
+    //! Function to return the total number of parameter values (including consider parameters)
+    /*!
+     *  Function to return the total number of parameter values (including consider parameters)
+     *  \return Size of parameter vector (including consider parameters)
+     */
+    int getParameterSetSize( )
+    {
+        return totalParameterSetSize_;
+    }
+
+    //! Function to return the total number of parameter values (excluding consider parameters).
+    /*!
+     *  Function to return the total number of parameter values (excluding consider parameters)
+     *  \return Size of parameter vector (excluding consider parameters)
+     */
+    int getEstimatedParameterSetSize( )
+    {
+        return estimatedParameterSetSize_;
+    }
+
+    //! Function to return the total number of initial state values that are estimated.
+    /*!
+     *  Function to return the total number of initial state values that are estimated.
+     *  \return Function to return the total number of initial state values that are estimated.
+     */
+    int getInitialDynamicalStateParameterSize( )
+    {
+        return initialDynamicalStateParameterSize_;
+    }
+
+    //! Function that returns a vector containing all current parameter values
+    /*!
+     *  Function that returns a vector containing all current parameter values. The total vector starts with the initial
+     *  state parameters, followed by the double and vector parameters, respectively.
+     *  Initial state, double and vector parameter values are concatenated in the order in which they are set in the
+     *  estimateInitialStateParameters_, doubleParameters_ and vectorParameters_ members.
+     *  \return Vector containing all parameter values
+     */
+    template< typename ParameterScalar >
+    Eigen::Matrix< ParameterScalar, Eigen::Dynamic, 1 > getFullParameterValues( )
+    {
+        Eigen::Matrix< ParameterScalar, Eigen::Dynamic, 1 >  parameterValues =
+                Eigen::Matrix< ParameterScalar, Eigen::Dynamic, 1 >::Zero( totalParameterSetSize_ );
+
+        int currentStartIndex = 0;
+
+        // Retrieve initial state parameter values.
+        for( unsigned int i = 0; i < estimateInitialStateParameters_.size( ); i++ )
+        {
+            parameterValues.segment( currentStartIndex, estimateInitialStateParameters_[ i ]->getParameterSize( ) ) =
+                    estimateInitialStateParameters_[ i ]->getParameterValue( ).template cast< ParameterScalar >( );
+            currentStartIndex += estimateInitialStateParameters_[ i ]->getParameterSize( );
+        }
+
+        // Retrieve double parameter values.
+        for( unsigned int i = 0; i < estimatedDoubleParameters_.size( ); i++ )
+        {
+            parameterValues( currentStartIndex ) = static_cast< ParameterScalar >(
+                        estimatedDoubleParameters_[ i ]->getParameterValue( ) );
+            currentStartIndex++;
+        }
+
+        // Retrieve vector parameter values.
+        for( unsigned int i = 0; i < estimatedVectorParameters_.size( ); i++ )
+        {
+            parameterValues.segment( currentStartIndex, estimatedVectorParameters_[ i ]->getParameterSize( ) ) =
+                    estimatedVectorParameters_[ i ]->getParameterValue( ).template cast< ParameterScalar >( );
+            currentStartIndex += estimatedVectorParameters_[ i ]->getParameterSize( );
+        }
+
+        return parameterValues;
+    }
+
+    //! Function to reset all parameter values.
+    /*!
+     *  Function to reset all parameter values.
+     *  \param newParameterValues New parameter values. Order of values in vector must be same order as return vector of getFullParameterValues
+     */
+    template< typename ParameterScalar >
+    void resetParameterValues( const Eigen::Matrix< ParameterScalar, Eigen::Dynamic, 1 >& newParameterValues )
+    {
+        // Check input consistency
+        if( newParameterValues.rows( ) != totalParameterSetSize_ )
+        {
+            throw std::runtime_error( "Error when resetting parameters of parameter set, given vector has size " +
+                                      boost::lexical_cast< std::string >( newParameterValues.rows( ) ) +
+                                       ", while internal size is " + boost::lexical_cast< std::string >( totalParameterSetSize_ ) );
+        }
+        else
+        {
+            int currentStartIndex = 0;
+
+            for( unsigned int i = 0; i < estimateInitialStateParameters_.size( ); i++ )
+            {
+                estimateInitialStateParameters_[ i ]->setParameterValue(
+                            newParameterValues.segment( currentStartIndex, estimateInitialStateParameters_[ i ]->getParameterSize( ) ).
+                            template cast< InitialStateParameterType >( ) );
+                currentStartIndex += estimateInitialStateParameters_[ i ]->getParameterSize( );
+            }
+
+            // Set double parameter values.
+            for( unsigned int i = 0; i < estimatedDoubleParameters_.size( ); i++ )
+            {
+                estimatedDoubleParameters_[ i ]->setParameterValue( static_cast< double >( newParameterValues( currentStartIndex ) ) );
+                currentStartIndex++;
+            }
+
+            // Set vector parameter values.
+
+            for( unsigned int i = 0; i < estimatedVectorParameters_.size( ); i++ )
+            {
+                estimatedVectorParameters_[ i ]->setParameterValue(
+                            newParameterValues.segment( currentStartIndex, estimatedVectorParameters_[ i ]->getParameterSize( ) ).
+                            template cast< double >( ) );
+
+                currentStartIndex += estimatedVectorParameters_[ i ]->getParameterSize( );
+            }
+        }
+    }
+
+    //! Function to retrieve double parameter objects.
+    /*!
+     *  Function to retrieve double parameter objects.
+     *  \return Vector containing all double parameter objects
+     */
+    std::map< int, boost::shared_ptr< EstimatableParameter< double > > > getDoubleParameters( )
+    {
+        return doubleParameters_;
+    }
+
+    //! Function to retrieve vector parameter objects.
+    /*!
+     *  Function to retrieve vector parameter objects.
+     *  \return Vector containing all vector parameter objects
+     */
+    std::map< int, boost::shared_ptr< EstimatableParameter< Eigen::VectorXd > > > getVectorParameters( )
+    {
+        return vectorParameters_;
+    }
+
+    //! Function to get list of initial dynamical states that are to be estimated.
+    //!
+    /*!
+     *  Function to get list of initial dynamical states that are to be estimated.
+     *  \return List of initial dynamical states that are to be estimated.
+     */
+    std::vector< boost::shared_ptr< EstimatableParameter< Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > > > >
+    getEstimatedInitialStateParameters( )
+    {
+        return estimateInitialStateParameters_;
+    }
+
+    //! Function to retrieve list of start indices and sizes (map keys) of estimated parameters.
+    /*!
+     *  Function to retrieve list of start indices and sizes (map keys) of estimated parameters.
+     *  \return List of start indices and sizes (map keys) of estimated parameters.
+     */
+    std::vector< std::pair< int, int > > getParametersIndices( )
+    {
+        return parameterIndices_;
+    }
+
+
+protected:
+
+    //! Total size of all initial dynamical states that is to be estimated.
+    int initialDynamicalStateParameterSize_;
+
+    //! Total number of parameter values (including currently non yet implemented consider parameters).
+    int totalParameterSetSize_;
+
+    //! Total number of estimated parameter values (excluding currently non yet implemented consider parameters).
+    int estimatedParameterSetSize_;
+
+    //! List of start indices and sizes (map keys) of estimated parameters.
+    /*!
+     * List of start indices and sizes (map keys) of estimated parameters, in order of vector
+     * estimateInitialStateParameters_, followed by estimatedDoubleParameters_, followed by estimatedVectorParameters_.
+     */
+    std::vector< std::pair< int, int > > parameterIndices_;
+
+    //! List of double parameters that are to be estimated.
+    std::vector< boost::shared_ptr< EstimatableParameter< double > > > estimatedDoubleParameters_;
+
+    //! List of vector parameters that are to be estimated.
+    std::vector< boost::shared_ptr< EstimatableParameter< Eigen::VectorXd > > > estimatedVectorParameters_;
+
+    //! List of initial dynamical states that are to be estimated.
+    std::vector< boost::shared_ptr< EstimatableParameter< Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > > > >
+    estimateInitialStateParameters_;
+
+    //! Map of double parameters that are to be estimated, with start index in total parameter vector as key.
+    std::map< int, boost::shared_ptr< EstimatableParameter< double > > > doubleParameters_;
+
+    //! Map of vector parameters that are to be estimated, with start index in total parameter vector as key.
+    std::map< int, boost::shared_ptr< EstimatableParameter< Eigen::VectorXd > > > vectorParameters_;
+
+    //! Map of initial dynamical states that are to be estimated, with start index in total parameter vector as key.
+    std::map< int, boost::shared_ptr<
+    EstimatableParameter< Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > > > > initialStateParameters_;
+
+};
+
+//! Class for providing settings for parameters to estimate
+/*!
+ *  Class for providing settings for parameters to estimate. This class is a functional base class for parameters that
+ *  require no information in addition to their type.
+ *  This class can be used for the easy setup of parameter objects (see createEstimatableParameters.h), but users may also
+ *  chose to do so manually. (Derived) Class members are all public, for ease of access and modification.
+ */
+class EstimatableParameterSettings
+{
+public:
+
+    //! Constructor.
+    /*!
+     *  Constructor, takes parameter type and body of which it is a property.
+     *  \param associatedBody Body of which parameter is a property.
+     *  \param parameterType Type of parameter.
+     *  \param pointOnBodyId Reference point on body associated with parameter (empty by default).
+     */
+    EstimatableParameterSettings( const std::string associatedBody ,
+                                  const EstimatebleParametersEnum parameterType,
+                                  const std::string pointOnBodyId = "" ):
+        parameterType_( std::make_pair( parameterType, std::make_pair( associatedBody, pointOnBodyId ) ) ){ }
+
+    //! Virtual destructor
+    /*!
+     *  Virtual destructor
+     */
+    virtual ~EstimatableParameterSettings( ){ }
+
+
+    //! Identifier for parameter.
+    /*!
+     *  Identifier for parameter, contains type of parameter and body of which parameter is a property.
+     */
+    EstimatebleParameterIdentifier parameterType_;
+
+};
+
+//! Class to define settings for estimating an initial translational state.
+template< typename InitialStateParameterType >
+class InitialTranslationalStateEstimatableParameterSettings: public EstimatableParameterSettings
+{
+public:
+
+    //! Constructor, sets initial value of translational state.
+    /*!
+     * Constructor, sets initial value of translational state.
+     * \param associatedBody Body for which initial state is to be estimated.
+     * \param initialStateValue Current value of initial state (w.r.t. centralBody)
+     * \param centralBody Body w.r.t. which the initial state is to be estimated.
+     * \param frameOrientation Orientation of the frame in which the state is defined.
+     */
+    InitialTranslationalStateEstimatableParameterSettings(
+            const std::string& associatedBody,
+            const Eigen::Matrix< InitialStateParameterType, 6, 1 > initialStateValue,
+            const std::string& centralBody = "SSB", const std::string& frameOrientation = "ECLIPJ2000" ):
+        EstimatableParameterSettings( associatedBody, initial_body_state ), initialTime_( TUDAT_NAN ),
+        initialStateValue_( initialStateValue ),
+        centralBody_( centralBody ), frameOrientation_( frameOrientation ){ }
+
+    //! Constructor, without initial value of translational state.
+    /*!
+     * Constructor, without initial value of translational state. Current initial state is retrieved from environment
+     * (ephemeris objects) during creation of parameter object.
+     * \param associatedBody Body for which initial state is to be estimated.
+     * \param initialTime Time at which initial state is defined.
+     * \param centralBody Body w.r.t. which the initial state is to be estimated.
+     * \param frameOrientation Orientation of the frame in which the state is defined.
+     */
+    InitialTranslationalStateEstimatableParameterSettings(
+            const std::string& associatedBody,
+            const double initialTime,
+            const std::string& centralBody = "SSB", const std::string& frameOrientation = "ECLIPJ2000" ):
+        EstimatableParameterSettings( associatedBody, initial_body_state ), initialTime_( initialTime ),
+        centralBody_( centralBody ), frameOrientation_( frameOrientation ){ }
+
+    //! Time at which initial state is defined (NaN for user-defined initial state value).
+    double initialTime_;
+
+    //! Current value of initial state (w.r.t. centralBody), set manually by used.
+    Eigen::Matrix< InitialStateParameterType, 6, 1 > initialStateValue_;
+
+    //! Body w.r.t. which the initial state is to be estimated.
+    std::string centralBody_;
+
+    //! Orientation of the frame in which the state is defined.
+    std::string frameOrientation_;
+
+};
+
+//! Function to get the list of names of bodies for which initial translational dynamical state is estimated.
+/*!
+ *  Function to get the list of names of bodies for which initial translational dynamical state is estimated.
+ *  \param estimatableParameters Object containing all parameters that are to be estimated.
+ *  \return List of names of bodies for which initial state is estimated.
+ */
+template< typename InitialStateParameterType >
+std::vector< std::string > getListOfBodiesWithTranslationalStateToEstimate(
+        const boost::shared_ptr< EstimatableParameterSet< InitialStateParameterType > > estimatableParameters )
+{
+    std::vector< std::string > bodiesToEstimate;
+
+    // Retrieve initial dynamical parameters.
+    std::vector< boost::shared_ptr< EstimatableParameter<
+            Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > > > > initialDynamicalParameters =
+            estimatableParameters->getEstimatedInitialStateParameters( );
+
+    // Iterate over list of bodies of which the partials of the accelerations acting on them are required.
+    for( unsigned int i = 0; i < initialDynamicalParameters.size( ); i++ )
+    {
+        if( initialDynamicalParameters.at( i )->getParameterName( ).first == initial_body_state )
+        {
+            bodiesToEstimate.push_back(  initialDynamicalParameters.at( i )->getParameterName( ).second.first );
+        }
+    }
+
+    return bodiesToEstimate;
+}
+
+//! Function to get the complete list of initial dynamical states that are to be estimated, sorted by dynamics type.
+/*!
+ *  Function to get the complete list of initial dynamical states that are to be estimated, sorted by dynamics type.
+ *  \param estimatableParameters Object containing all parameters that are to be estimated.
+ *  \return Map containing dynamics type (key) and vector of pairs: list of bodies (first in pair) with reference point
+ *  identifier (second in pair; empty if not relevant) for which given dynamics type is estimated.
+ */
+template< typename InitialStateParameterType >
+std::map< propagators::IntegratedStateType, std::vector< std::pair< std::string, std::string > > >
+getListOfInitialDynamicalStateParametersEstimate(
+        const boost::shared_ptr< EstimatableParameterSet< InitialStateParameterType > > estimatableParameters )
+{
+    // Retrieve initial dynamical parameters.
+    std::vector< boost::shared_ptr< EstimatableParameter<
+            Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > > > > initialDynamicalParameters =
+            estimatableParameters->getEstimatedInitialStateParameters( );
+
+    std::map< propagators::IntegratedStateType, std::vector< std::pair< std::string, std::string > > > initialDynamicalStateParametersEstimate;
+    // Iterate over list of bodies of which the partials of the accelerations acting on them are required.
+    for( unsigned int i = 0; i < initialDynamicalParameters.size( ); i++ )
+    {
+        if( initialDynamicalParameters.at( i )->getParameterName( ).first == initial_body_state )
+        {
+            initialDynamicalStateParametersEstimate[ propagators::transational_state ].push_back(
+                        initialDynamicalParameters.at( i )->getParameterName( ).second );
+        }       
+    }
+
+    return initialDynamicalStateParametersEstimate;
+}
+
+//! Function to get initial state vector of estimated dynamical states.
+/*!
+ *  Function to get initial state vector of estimated dynamical states (i.e. presently estimated state at propagation
+ *  start time.
+ *  \param estimatableParameters Object containing all parameters that are to be estimated.
+ *  \return State vector of estimated dynamics at propagation start time.
+ */
+template< typename InitialStateParameterType = double >
+Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > getInitialStateVectorOfBodiesToEstimate(
+        const boost::shared_ptr< EstimatableParameterSet< InitialStateParameterType > > estimatableParameters )
+{
+    // Retrieve initial dynamical parameters.
+    std::vector< boost::shared_ptr< EstimatableParameter<
+            Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > > > > initialDynamicalParameters =
+            estimatableParameters->getEstimatedInitialStateParameters( );
+
+    // Initialize state vector.
+    Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > initialStateVector =
+            Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 >::Zero(
+                estimatableParameters->getInitialDynamicalStateParameterSize( ), 1 );
+
+    int vectorSize = 0;
+    // Iterate over list of bodies of which the partials of the accelerations acting on them are required.
+    for( unsigned int i = 0; i < initialDynamicalParameters.size( ); i++ )
+    {
+        if( isParameterDynamicalPropertyInitialState( initialDynamicalParameters.at( i )->getParameterName( ).first ) )
+        {
+            int currentParameterSize = initialDynamicalParameters.at( i )->getParameterSize( );
+            initialStateVector.block( vectorSize, 0, currentParameterSize, 1 ) = initialDynamicalParameters.at( i )->getParameterValue( );
+
+            vectorSize += currentParameterSize;
+        }
+    }
+
+    return initialStateVector.block( 0, 0, vectorSize, 1 );
+}
+
+}
+
+}
+
+#endif // TUDAT_ESTIMATABLEPARAMETERS_H
diff --git a/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/gravitationalParameter.h b/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/gravitationalParameter.h
new file mode 100644
index 0000000..735510e
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/gravitationalParameter.h
@@ -0,0 +1,79 @@
+#ifndef TUDAT_GRAVITATIONALPARAMETER_H
+#define TUDAT_GRAVITATIONALPARAMETER_H
+
+#include "Tudat/Astrodynamics/Gravitation/gravityFieldModel.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/estimatableParameter.h"
+
+using std::string;
+
+namespace tudat
+{
+
+namespace estimatable_parameters
+{
+
+//! Interface class for the estimation of a gravitational parameter
+class GravitationalParameter: public EstimatableParameter< double >
+{
+
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param gravityFieldModel Gravity field object containing the gravitational parameter to be estimated.
+     * \param associatedBody Name of body containing the gravityFieldModel object
+     */
+    GravitationalParameter(
+            const boost::shared_ptr< gravitation::GravityFieldModel > gravityFieldModel, const std::string& associatedBody ):
+        EstimatableParameter< double >( gravitational_parameter, associatedBody ),
+        gravityFieldModel_( gravityFieldModel ){ }
+
+    //! Destructor
+    ~GravitationalParameter( ) { }
+
+    //! Function to get the current value of the gravitational parameter that is to be estimated.
+    /*!
+     * Function to get the current value of the gravitational parameter that is to be estimated.
+     * \return Current value of the gravitational parameter that is to be estimated.
+     */
+    double getParameterValue( )
+    {
+        return gravityFieldModel_->getGravitationalParameter( );
+    }
+
+    //! Function to reset the value of the gravitational parameter that is to be estimated.
+    /*!
+     * Function to reset the value of the gravitational parameter that is to be estimated.
+     * \param parameterValue New value of the gravitational parameter that is to be estimated.
+     */
+    void setParameterValue( double parameterValue )
+    {
+        gravityFieldModel_->resetGravitationalParameter( parameterValue );
+    }
+
+    //! Function to retrieve the size of the parameter (always 1).
+    /*!
+     *  Function to retrieve the size of the parameter (always 1).
+     *  \return Size of parameter value (always 1).
+     */
+    int getParameterSize( )
+    {
+        return 1;
+    }
+
+protected:
+
+private:
+
+    //! Gravity field object containing the gravitational parameter to be estimated.
+    boost::shared_ptr< gravitation::GravityFieldModel > gravityFieldModel_;
+
+};
+
+}
+
+}
+
+
+#endif // TUDAT_GRAVITATIONALPARAMETER_H
diff --git a/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/initialTranslationalState.cpp b/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/initialTranslationalState.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/initialTranslationalState.h b/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/initialTranslationalState.h
new file mode 100644
index 0000000..a57c253
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/initialTranslationalState.h
@@ -0,0 +1,119 @@
+#ifndef TUDAT_INITIALTRANSLATIONALSTATE_H
+#define TUDAT_INITIALTRANSLATIONALSTATE_H
+
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/estimatableParameter.h"
+
+namespace tudat
+{
+
+namespace estimatable_parameters
+{
+
+//! Interface class for the estimation of an initial translational state.
+template< typename InitialStateParameterType = double >
+class InitialTranslationalStateParameter: public EstimatableParameter< Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > >
+{
+public:
+
+    //! Constructor, sets initial value of translational state.
+    /*!
+     * Constructor, sets initial value of translational state.
+     * \param associatedBody Body for which initial state is to be estimated.
+     * \param initialTranslationalState Current value of initial state (w.r.t. centralBody)
+     * \param centralBody Body w.r.t. which the initial state is to be estimated.
+     * \param frameOrientation Orientation of the frame in which the state is defined.
+     */
+    InitialTranslationalStateParameter(
+            const std::string& associatedBody,
+            const Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 >& initialTranslationalState,
+            const std::string& centralBody = "SSB", const std::string& frameOrientation = "ECLIPJ2000" ):
+        EstimatableParameter< Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > >( initial_body_state, associatedBody ),
+        initialTranslationalState_( initialTranslationalState ), centralBody_( centralBody ), frameOrientation_( frameOrientation )
+    { }
+
+    //! Function to get the current value of initial state w.r.t. centralBody.
+    /*!
+     * Function to get the current value of initial state w.r.t. centralBody.
+     * \return The current value of initial state w.r.t. centralBody.
+     */
+    Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > getParameterValue( )
+    {
+        return initialTranslationalState_;
+    }
+
+    //! Function to reset the current value of initial state w.r.t. centralBody.
+    /*!
+     * Function to reset the current value of initial state w.r.t. centralBody.
+     * \param parameterValue The new value of initial state w.r.t. centralBody.
+     */
+    void setParameterValue( Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 >  parameterValue )
+    {
+        initialTranslationalState_ = parameterValue;
+    }
+
+    //! Function to retrieve the size of the parameter (always 6).
+    /*!
+     *  Function to retrieve the size of the parameter (always 6).
+     *  \return Size of parameter value (always 6).
+     */
+    int getParameterSize( )
+    {
+        return 6;
+    }
+
+    //! Function to get the name of the body w.r.t. which the initial state is to be estimated.
+    /*!
+     * Function to get the name of the body w.r.t. which the initial state is to be estimated.
+     * \return Name of the body w.r.t. which the initial state is to be estimated.
+     */
+    std::string getCentralBody( )
+    {
+        return centralBody_;
+    }
+
+private:
+
+    //! Current value of initial state (w.r.t. centralBody)
+    Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > initialTranslationalState_;
+
+    //!  Body w.r.t. which the initial state is to be estimated.
+    std::string centralBody_;
+
+    //! Orientation of the frame in which the state is defined.
+    std::string frameOrientation_;
+
+};
+
+template< typename InitialStateParameterType = double >
+int getSingleArcParameterSetSize(
+        boost::shared_ptr< EstimatableParameterSet< InitialStateParameterType > > estimatableParameterSet )
+{
+    int totalParameterSetSize = estimatableParameterSet->getEstimatedParameterSetSize( );
+    std::vector< boost::shared_ptr< EstimatableParameter< Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > > > >
+            initialStateParameters = estimatableParameterSet->getEstimatedInitialStateParameters( );
+
+    for( unsigned int i = 0; i < initialStateParameters.size( ); i++ )
+    {
+        if( ( initialStateParameters.at( i )->getParameterName( ).first != initial_body_state ) )
+        {
+            throw std::runtime_error( "Error when getting single arc paramater vector, did not recognize initial state parameter " +
+                        boost::lexical_cast< std::string >( initialStateParameters.at( i )->getParameterName( ).first ) );
+        }
+    }
+    return totalParameterSetSize;
+}
+
+template< typename InitialStateParameterType = double >
+int getSingleArcInitialDynamicalStateParameterSetSize(
+        boost::shared_ptr< EstimatableParameterSet< InitialStateParameterType > > estimatableParameterSet )
+{
+    return getSingleArcParameterSetSize( estimatableParameterSet ) -
+            ( estimatableParameterSet->getEstimatedParameterSetSize( ) - estimatableParameterSet->getInitialDynamicalStateParameterSize( ) );
+}
+
+
+}
+
+}
+
+#endif // TUDAT_INITIALTRANSLATIONALSTATE_H
diff --git a/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/radiationPressureCoefficient.h b/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/radiationPressureCoefficient.h
new file mode 100644
index 0000000..d4cdb85
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/radiationPressureCoefficient.h
@@ -0,0 +1,75 @@
+#ifndef RADIATIONPRESSURECOEFFICIENT_H
+#define RADIATIONPRESSURECOEFFICIENT_H
+
+#include <Eigen/Core>
+
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/estimatableParameter.h"
+#include "Tudat/Astrodynamics/ElectroMagnetism/radiationPressureInterface.h"
+
+namespace tudat
+{
+
+namespace estimatable_parameters
+{
+
+//! Interface class for the estimation of a radiation pressure coefficient
+class RadiationPressureCoefficient: public EstimatableParameter< double >
+{
+
+public:
+    //! Constructor.
+    /*!
+     * Constructor
+     * \param radiationPressureInterface Object containing the radiation pressure coefficient to be estimated.
+     * \param associatedBody Name of body containing the radiationPressureInterface object
+     */
+    RadiationPressureCoefficient(
+            boost::shared_ptr< electro_magnetism::RadiationPressureInterface > radiationPressureInterface,
+            std::string& associatedBody ):
+        EstimatableParameter< double >( radiation_pressure_coefficient, associatedBody ),
+        radiationPressureInterface_( radiationPressureInterface )
+    { }
+
+    //! Destructor.
+    ~RadiationPressureCoefficient( ) { }
+
+    //! Function to get the current value of the radiation pressure coefficient that is to be estimated.
+    /*!
+     * Function to get the current value of the radiation pressure coefficient that is to be estimated.
+     * \return Current value of the radiation pressure coefficient that is to be estimated.
+     */
+    double getParameterValue( )
+    {
+        return radiationPressureInterface_->getRadiationPressureCoefficient( );
+    }
+
+    //! Function to reset the value of the radiation pressure coefficient that is to be estimated.
+    /*!
+     * Function to reset the value of the radiation pressure coefficient that is to be estimated.
+     * \param parameterValue New value of the radiation pressure coefficient that is to be estimated.
+     */
+    void setParameterValue( double parameterValue )
+    {
+        radiationPressureInterface_->resetRadiationPressureCoefficient( parameterValue );
+    }
+
+    //! Function to retrieve the size of the parameter (always 1).
+    /*!
+     *  Function to retrieve the size of the parameter (always 1).
+     *  \return Size of parameter value (always 1).
+     */
+    int getParameterSize( ){ return 1; }
+
+protected:
+
+private:
+
+    //! Object containing the radiation pressure coefficient to be estimated.
+    boost::shared_ptr< electro_magnetism::RadiationPressureInterface > radiationPressureInterface_;
+};
+
+}
+
+}
+
+#endif // RADIATIONPRESSURECOEFFICIENT_H
diff --git a/Tudat/Astrodynamics/OrbitDetermination/stateDerivativePartial.cpp b/Tudat/Astrodynamics/OrbitDetermination/stateDerivativePartial.cpp
new file mode 100644
index 0000000..ad00ddf
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/stateDerivativePartial.cpp
@@ -0,0 +1,224 @@
+#include "Tudat/Astrodynamics/OrbitDetermination/stateDerivativePartial.h"
+
+namespace tudat
+{
+
+namespace orbit_determination
+{
+
+namespace partial_derivatives
+{
+
+//! Function to evaluate the negative value of a parameter partial.
+void evaluateNegativeParameterPartialFunction(
+        const boost::function< void( Eigen::MatrixXd& ) > parameterPartialFunction,
+        Eigen::MatrixXd& partial )
+{
+    parameterPartialFunction( partial );
+    partial *= -1.0;
+}
+
+//! Function to evaluate the subtraction of two parameter partials.
+void evaluateSubtractedParameterPartialFunction(
+        const boost::function< void( Eigen::MatrixXd& ) > firstParameterPartialFunction,
+        const boost::function< void( Eigen::MatrixXd& ) > parameterPartialFunctionToSubtract,
+        Eigen::MatrixXd& partial )
+{
+    firstParameterPartialFunction( partial );
+
+    Eigen::MatrixXd subtractedPartial = Eigen::MatrixXd::Zero( partial.rows( ), partial.cols( ) );
+    parameterPartialFunctionToSubtract( subtractedPartial );
+
+    partial -= subtractedPartial;
+}
+
+//! Function to evaluate the addition of two parameter partials.
+void evaluateAddedParameterPartialFunction(
+        const boost::function< void( Eigen::MatrixXd& ) > firstParameterPartialFunction,
+        const boost::function< void( Eigen::MatrixXd& ) > parameterPartialFunctionToAdd,
+        Eigen::MatrixXd& partial )
+{
+    firstParameterPartialFunction( partial );
+
+    Eigen::MatrixXd addedPartial = Eigen::MatrixXd::Zero( partial.rows( ), partial.cols( ) );
+    parameterPartialFunctionToAdd( addedPartial );
+
+    partial += addedPartial;
+}
+
+//! Create a parameter partial function obtained from the subtraction of two such function results.
+std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > createMergedParameterPartialFunction(
+        const std::pair< boost::function< void( Eigen::MatrixXd& ) >, int >& partialFunctionOfAccelerationToAdd,
+        const std::pair< boost::function< void( Eigen::MatrixXd& ) >, int >& partialFunctionOfAccelerationToSubtract )
+{
+    std::pair< boost::function< void( Eigen::MatrixXd& ) >, int >  parameterPartialFunction;
+
+    // Check partial size and act accordingly.
+    if( ( partialFunctionOfAccelerationToAdd.second == 0 ) &&
+            ( partialFunctionOfAccelerationToSubtract.second == 0 ) )
+    {
+        parameterPartialFunction = std::make_pair( boost::function< void( Eigen::MatrixXd& ) >( ), 0 );
+    }
+    else if( partialFunctionOfAccelerationToSubtract.second == 0 )
+    {
+        parameterPartialFunction = partialFunctionOfAccelerationToAdd;
+    }
+    else if( partialFunctionOfAccelerationToAdd.second == 0 )
+    {
+        parameterPartialFunction = std::make_pair( boost::bind(
+                                                       &evaluateNegativeParameterPartialFunction,
+                                                       partialFunctionOfAccelerationToSubtract.first, _1 ),
+                                                   partialFunctionOfAccelerationToSubtract.second );
+    }
+    // Partial size must be equal if both non-zero
+    else if( partialFunctionOfAccelerationToSubtract.second !=
+             partialFunctionOfAccelerationToAdd.second )
+    {
+        throw std::runtime_error( "Error when making merged parameter partial function, separate functions are incompatible" );
+    }
+    else
+    {
+        parameterPartialFunction = std::make_pair( boost::bind( &evaluateSubtractedParameterPartialFunction,
+                                                               partialFunctionOfAccelerationToAdd.first,
+                                                               partialFunctionOfAccelerationToSubtract.first, _1 ),
+                                                  partialFunctionOfAccelerationToSubtract.second );
+    }
+    return parameterPartialFunction;
+}
+
+//! Function to create a parameter partial evaluation function, obtained by adding or subtracting a given partial
+//! w.r.t. a double parameter from 2 state derivative partial models.
+boost::function< void( Eigen::MatrixXd& ) > getCombinedCurrentDoubleParameterFunction(
+        const boost::shared_ptr< StateDerivativePartial > firstPartial,
+        const boost::shared_ptr< StateDerivativePartial > secondPartial,
+        const boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > parameterObject,
+        const int firstPartialSize, const int secondPartialSize,
+        const bool subtractPartials )
+{
+    boost::function< void( Eigen::MatrixXd& ) > partialFunction;
+
+    // Get two partial functions.
+    boost::function< void( Eigen::MatrixXd& ) > firstPartialFunction =
+            boost::bind( &StateDerivativePartial::getCurrentDoubleParameterPartial, firstPartial, parameterObject, _1 );
+    boost::function< void( Eigen::MatrixXd& ) > secondPartialFunction =
+            boost::bind( &StateDerivativePartial::getCurrentDoubleParameterPartial, secondPartial, parameterObject, _1 );
+
+    // If both partial function sizes are zero, cannot create partial.
+    if( firstPartialSize == 0 && secondPartialSize == 0 )
+    {
+        throw std::runtime_error( "Error when getting combined current partial size, both partials have size zero " );
+    }
+    // Check other cases and combine partial functions accordingly
+    else if( secondPartialSize == 0 )
+    {
+        partialFunction = firstPartialFunction;
+    }
+    else if( firstPartialSize == 0 )
+    {
+        if( subtractPartials )
+        {
+            partialFunction = boost::bind( &evaluateNegativeParameterPartialFunction,
+                                           secondPartialFunction, _1 );
+        }
+        else
+        {
+            partialFunction = secondPartialFunction;
+
+        }
+    }
+    else if( firstPartialSize == secondPartialSize )
+    {
+        if( subtractPartials )
+        {
+            partialFunction = boost::bind( &evaluateSubtractedParameterPartialFunction,
+                                           firstPartialFunction,
+                                           secondPartialFunction, _1 );
+        }
+        else
+        {
+            partialFunction = boost::bind( &evaluateAddedParameterPartialFunction,
+                                           firstPartialFunction,
+                                           secondPartialFunction, _1 );
+        }
+
+    }
+    // Partial size must be equal if both non-zero
+    else
+    {
+        throw std::runtime_error(
+                    "Error when getting combined current partial size, both partials have different non-zero size." );
+    }
+    return partialFunction;
+}
+
+//! Function to create a parameter partial evaluation function, obtained by adding or subtracting a given partial
+//! w.r.t. a vector parameter from 2 state derivative partial models.
+boost::function< void( Eigen::MatrixXd& ) > getCombinedCurrentVectorParameterFunction(
+        const boost::shared_ptr< StateDerivativePartial > firstPartial,
+        const boost::shared_ptr< StateDerivativePartial > secondPartial,
+        const boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > parameterObject,
+        const int firstPartialSize, const int secondPartialSize,
+        const bool subtractPartials )
+{
+    boost::function< void( Eigen::MatrixXd& ) > partialFunction;
+
+    // Get two partial functions.
+    boost::function< void( Eigen::MatrixXd& ) > firstPartialFunction =
+            boost::bind( &StateDerivativePartial::getCurrentVectorParameterPartial, firstPartial, parameterObject, _1 );
+    boost::function< void( Eigen::MatrixXd& ) > secondPartialFunction =
+            boost::bind( &StateDerivativePartial::getCurrentVectorParameterPartial, secondPartial, parameterObject, _1 );
+
+
+    // If both partial function sizes are zero, cannot create partial.
+    if( firstPartialSize == 0 && secondPartialSize == 0 )
+    {
+        throw std::runtime_error( "Error when getting combined current partial size, both partials have size zero " );
+    }
+    // Check other cases and combine partial functions accordingly
+    else if( secondPartialSize == 0 )
+    {
+        partialFunction = firstPartialFunction;
+    }
+    else if( firstPartialSize == 0 )
+    {
+        if( subtractPartials )
+        {
+            partialFunction = boost::bind( &evaluateNegativeParameterPartialFunction,
+                                           secondPartialFunction, _1 );
+        }
+        else
+        {
+            partialFunction = secondPartialFunction;
+
+        }
+    }
+    else if( firstPartialSize == secondPartialSize )
+    {
+        if( subtractPartials )
+        {
+            partialFunction = boost::bind( &evaluateSubtractedParameterPartialFunction,
+                                           firstPartialFunction,
+                                           secondPartialFunction, _1 );
+        }
+        else
+        {
+            partialFunction = boost::bind( &evaluateAddedParameterPartialFunction,
+                                           firstPartialFunction,
+                                           secondPartialFunction, _1 );
+        }
+
+    }
+    // Partial size must be equal if both non-zero
+    else
+    {
+        throw std::runtime_error( "Error when getting combined current partial size, both partials have different non-zero size." );
+    }
+    return partialFunction;
+}
+
+}
+
+}
+
+}
+
diff --git a/Tudat/Astrodynamics/OrbitDetermination/stateDerivativePartial.h b/Tudat/Astrodynamics/OrbitDetermination/stateDerivativePartial.h
new file mode 100644
index 0000000..7598059
--- /dev/null
+++ b/Tudat/Astrodynamics/OrbitDetermination/stateDerivativePartial.h
@@ -0,0 +1,634 @@
+#ifndef TUDAT_STATEDERIVATIVEPARTIAL_H
+#define TUDAT_STATEDERIVATIVEPARTIAL_H
+
+#include <string>
+#include <map>
+#include <Eigen/Core>
+
+#include <boost/bind.hpp>
+#include <boost/assign/list_of.hpp>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.h"
+#include "Tudat/Astrodynamics/Propagators/propagationSettings.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/estimatableParameter.h"
+
+
+namespace tudat
+{
+
+namespace orbit_determination
+{
+
+namespace partial_derivatives
+{
+
+//! Base class for computing the partial derivatives of a state derivative model
+/*!
+ * Base class for computing the partial derivatives of a state derivative model (i.e. acceleration model for
+ * translational dynamics, torque model for rottional dynamics, etc.
+ * Typically, two levels of derived classes are required: one for the type of dynamics, and one for the type of model
+ * (e.g. one level for acceleration model, and one level for central gravitational, spherical harmonic, etc. model).
+ */
+class StateDerivativePartial
+{
+
+public:
+
+    //! Constructor.
+    /*!
+     * Constructor
+     * \param integratedStateType Type of dynamics for which partials are to be computed
+     * \param integrationReferencePoint Reference point (i.e. propagated body and point) for which the dynamics is
+     * propagated. First entry denotes the full body, second entry the reference point on the body that is propagated
+     * (empty for translational, rotational dynamics).
+     */
+    StateDerivativePartial( const propagators::IntegratedStateType integratedStateType,
+                            const std::pair< std::string, std::string >& integrationReferencePoint ):
+        integratedStateType_( integratedStateType ), integrationReferencePoint_( integrationReferencePoint )
+    {
+        currentTime_ = TUDAT_NAN;
+        accelerationSize_ = propagators::getSingleIntegrationSize( integratedStateType_ ) /
+                propagators::getSingleIntegrationDifferentialEquationOrder( integratedStateType_ );
+    }
+
+    //! Destructor.
+    virtual ~StateDerivativePartial( ) { }
+
+    //! Pure virtual function to retrieve the function that returns the partial derivative w.r.t. a propagated state.
+    /*!
+     * Pure virtual function to retrieve the function that returns the partial derivative w.r.t. a propagated state.
+     * \param stateReferencePoint Reference point (id) for propagated state (i.e. body name for translational dynamics).
+     * \param integratedStateType Type of propagated state.
+     * \return Pair with function, returning partial derivative, and number of columns in partial vector,
+     */
+    virtual std::pair< boost::function< void( Eigen::Block< Eigen::MatrixXd > ) >, int >
+    getDerivativeFunctionWrtStateOfIntegratedBody(
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType ) = 0;
+
+    //! Pure virtual function to check whether a partial w.r.t. some integrated state is non-zero.
+    /*!
+     * Pure virtual function to check whether a partial w.r.t. some integrated state is non-zero.
+     * \param stateReferencePoint Reference point (id) for propagated state (i.e. body name for translational dynamics).
+     * \param integratedStateType Type of propagated state.
+     * \return True if dependency exists, false otherwise.
+     */
+    virtual bool isStateDerivativeDependentOnIntegratedNonTranslationalState(
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType ) = 0;
+
+    //! Function to directly compute the partial of the state derivative w.r.t. a double parameter.
+    /*!
+     * Function to directly compute the partial of the state derivative w.r.t. a double parameter. NOTE: This function is
+     * incldued for testing purposes, and is not to be used during propagation (highly inefficient).
+     * \param parameter Parameter w.r.t. which partial is to be computed
+     * \return Partial of state derivative w.r.t. given parameter.
+     */
+    Eigen::MatrixXd wrtParameter(
+            const boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > parameter )
+    {
+        // Initialize partial
+        Eigen::MatrixXd partial = Eigen::MatrixXd( accelerationSize_, 1 );
+
+        // Get partial computation function.
+        std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > partialFunction =
+                getParameterPartialFunction( parameter );
+
+        // If parameter dependency exists, compute it, otherwise set partial to zero.
+        if( partialFunction.second > 0 )
+        {
+             partialFunction.first( partial );
+        }
+        else
+        {
+            partial = Eigen::MatrixXd::Zero( propagators::getSingleIntegrationSize( integratedStateType_ ), 1 );
+        }
+        return partial;
+    }
+
+    //! Function to retrieve the function that computes (by reference) a given double parameter partial.
+    /*!
+     *  Function to retrieve the function that computes (by reference) a given double parameter partial. NOTE: this function
+     *  is implemented in this base class with default no dependency. If any double parameter dependencioes exists, this
+     *  function should be overriden in derived class.
+     *  \param parameter Parameter w.r.t. which partial is to be computed
+     */
+    virtual std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > getParameterPartialFunction(
+            boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > parameter )
+    {
+        boost::function< void( Eigen::MatrixXd& ) > partialFunction;
+        return std::make_pair( partialFunction, 0 );
+    }
+
+    //! Function to directly compute the partial of the state derivative w.r.t. a vector parameter.
+    /*!
+     * Function to directly compute the partial of the state derivative w.r.t. a vector parameter. NOTE: This function is
+     * incldued for testing purposes, and is not to be used during propagation (highly inefficient).
+     * \param parameter Parameter w.r.t. which partial is to be computed
+     * \return Partial of state derivative w.r.t. given parameter.
+     */
+    Eigen::MatrixXd wrtParameter(
+            boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > parameter )
+    {
+        // Initialize partial
+        Eigen::MatrixXd partial = Eigen::MatrixXd( accelerationSize_, parameter->getParameterSize( ) );
+
+        // Get partial computation function.
+        std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > partialFunction =
+                getParameterPartialFunction( parameter );
+
+        // If parameter dependency exists, compute it, otherwise set partial to zero.
+        if( partialFunction.second > 0 )
+        {
+             partialFunction.first( partial );
+        }
+        else
+        {
+            partial = Eigen::MatrixXd::Zero( propagators::getSingleIntegrationSize( integratedStateType_ ),
+                                             parameter->getParameterSize( ) );
+        }
+        return partial;
+    }
+
+    //! Function to retrieve the function that computes (by reference) a given vector parameter partial.
+    /*!
+     *  Function to retrieve the function that computes (by reference) a given vector parameter partial. NOTE: this function
+     *  is implemented in this base class with default no dependency. If any double parameter dependencioes exists, this
+     *  function should be overriden in derived class.
+     *  \param parameter Parameter w.r.t. which partial is to be computed
+     */
+    virtual std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > getParameterPartialFunction(
+            boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > parameter )
+    {
+        boost::function< void( Eigen::MatrixXd& ) > partialFunction;
+        return std::make_pair( partialFunction, 0 );
+    }
+
+    //! Pure virtual for updating the common parts of the partial object to current state and time.
+    /*!
+     *  Pure virtual for updating the common parts of the partial object to current state and time. Note that this
+     *  function is distinct from the updateParameterPartials, which only updates the specific required partial
+     *  derivatives w.r.t. required parameters. This function computes variables that are always required when
+     *  the derived class partial is used.
+     *  \param currentTime Time to which partials are to be updated.
+     */
+    virtual void update( const double currentTime ) = 0;
+
+    //! Function to get the type of state for which partials are to be computed.
+    /*!
+     * Function to get the type of state for which partials are to be computed.
+     * \return Type of state for which partials are to be computed.
+     */
+    propagators::IntegratedStateType getIntegratedStateType( )
+    {
+        return integratedStateType_;
+    }
+
+    //! Function to get the identifier for body/reference point for which propagation is performed.
+    /*!
+     * Function to get the identifier for body/reference point for which propagation is performed.
+     * \return Identifier for body/reference point for which propagation is performed.
+     */
+    std::pair< std::string, std::string > getIntegrationReferencePoint( )
+    {
+        return integrationReferencePoint_;
+    }
+
+    //! Function to reset the  object to the current time
+    /*!
+     * Function to reset the  object to the current time, recomputing partials to current state.
+     *  \param currentTime Time to which partials are to be updated.
+     */
+    void resetTime( const double currentTime = TUDAT_NAN )
+    {
+        // Check if update is needed.
+        if( !( currentTime_ == currentTime  ) )
+        {
+            resetCurrentParameterValues( );
+            currentTime_ = currentTime;
+        }        
+
+        // Perform updates of member objects if needed.
+        resetTimeOfMemberObjects( );
+    }
+
+    //! Function to retrieve a partial w.r.t. a double parameter
+    /*!
+     * Function to retrieve a partial w.r.t. a double parameter. An error is thrown if there is no dependency w.r.t.
+     * the requested parameter. A warning is printed if the dependency exists, but has not yet been computed for the
+     * current time step.
+     * \param parameter Partial w.r.t. which a parameter is to be computed
+     * \param partialMatrix Partial of state derivative w.r.t. given parameter (return by 'reference', amking use of
+     * Eigen::Block architecture).
+     */
+    void getCurrentParameterPartial(
+            const boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > parameter,
+            Eigen::Block< Eigen::MatrixXd > partialMatrix )
+    {
+        // Check if dependecy is computed
+        if( currentDoubleParameterPartials_.count( parameter ) == 0 )
+        {
+            // Check if dependecy exists at all
+            if( parameterDoublePartialFunctions_.count( parameter ) == 0 )
+            {
+                throw std::runtime_error(
+                            "Parameter of type " +
+                            boost::lexical_cast< std::string >( parameter->getParameterName( ).first ) + ", " +
+                            parameter->getParameterName( ).second.first + ", " +
+                            parameter->getParameterName( ).second.second + ", " +
+                            " not found in list of existing partials" );
+            }
+            else
+            {
+                std::cerr<<"Warning, double partial should already be calculated"<<std::endl;
+                parameterDoublePartialFunctions_.at( parameter )( currentDoubleParameterPartials_[ parameter ] );
+            }
+        }
+        partialMatrix = currentDoubleParameterPartials_[ parameter ];
+    }
+
+    //! Function to retrieve a partial w.r.t. a double parameter
+    /*!
+     * Function to retrieve a partial w.r.t. a double parameter. An error is thrown if there is no dependency w.r.t.
+     * the requested parameter. A warning is printed if the dependency exists, but has not yet been computed for the
+     * current time step.
+     * \param parameter Partial w.r.t. which a parameter is to be computed
+     * \param parameterPartial Partial of state derivative w.r.t. given parameter (return by reference)
+     */
+    void getCurrentDoubleParameterPartial(
+            const boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > parameter,
+            Eigen::MatrixXd& parameterPartial )
+    {
+        getCurrentParameterPartial( parameter, parameterPartial.block( 0, 0, accelerationSize_, 1 ) );
+    }
+
+    //! Function to retrieve a partial w.r.t. a vector parameter
+    /*!
+     * Function to retrieve a partial w.r.t. a vector parameter. An error is thrown if there is no dependency w.r.t.
+     * the requested parameter. A warning is printed if the dependency exists, but has not yet been computed for the
+     * current time step.
+     * \param parameter Partial w.r.t. which a parameter is to be computed
+     * \param partialMatrix Partial of state derivative w.r.t. given parameter (return by 'reference', amking use of
+     * Eigen::Block architecture).
+     */
+    void getCurrentParameterPartial(
+            const boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > parameter,
+            Eigen::Block< Eigen::MatrixXd > partialMatrix )
+    {
+        if( currentVectorParameterPartials_.count( parameter ) == 0 )
+        {
+            if( parameterVectorPartialFunctions_.count( parameter ) == 0 )
+            {
+                std::cerr<<"Parameter of type "<<parameter->getParameterName( ).first<<", "<<
+                          parameter->getParameterName( ).second.first<<", "<<
+                          parameter->getParameterName( ).second.second<<" not found in list of existing partials"<<std::endl;
+            }
+            else
+            {
+                std::cerr<<"Warning, vector partial should already be calculated"<<std::endl;
+                parameterVectorPartialFunctions_.at( parameter )( currentVectorParameterPartials_[ parameter ] );
+            }
+        }
+        partialMatrix = currentVectorParameterPartials_[ parameter ];
+    }
+
+    //! Function to retrieve a partial w.r.t. a vector parameter
+    /*!
+     * Function to retrieve a partial w.r.t. a vector parameter. An error is thrown if there is no dependency w.r.t.
+     * the requested parameter. A warning is printed if the dependency exists, but has not yet been computed for the
+     * current time step.
+     * \param parameter Partial w.r.t. which a parameter is to be computed
+     * \param parameterPartial Partial of state derivative w.r.t. given parameter (return by reference)
+     */
+    void getCurrentVectorParameterPartial(
+            const boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > parameter,
+            Eigen::MatrixXd& parameterPartial )
+    {
+        getCurrentParameterPartial( parameter, parameterPartial.block(
+                                        0, 0, accelerationSize_, parameter->getParameterSize( ) ) );
+    }
+
+    //! Function to set a dependency of this partial object w.r.t. a given double parameter.
+    /*!
+     * Function to set a dependency of this partial object w.r.t. a given double parameter. If a dependency exists, the given
+     * partial is recomputed on every call of updateParameterPartials.
+     * \param parameter Partial w.r.t. which dependency is to be checked and set.
+     * \return Size (number of columns) of parameter partial. Zero if no dependency, 1 otherwise.
+     */
+    virtual int setParameterPartialUpdateFunction(
+                boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > parameter )
+    {
+        // Get partial function.
+        std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > parameterPartialFunction =
+                getParameterPartialFunction( parameter );
+
+        // If partial function found, add function to list of computations to be performed when calling
+        // updateParameterPartials.
+        if( parameterPartialFunction.second > 0 && parameterDoublePartialFunctions_.count( parameter ) == 0 )
+        {
+            if( parameterDoublePartialFunctions_.count( parameter ) == 0 )
+            {
+                parameterDoublePartialFunctions_[ parameter ] = parameterPartialFunction.first;
+                isCurrentDoubleParameterPartialSet_[ parameter ] = 0;
+                currentDoubleParameterPartials_[ parameter ] = Eigen::MatrixXd( accelerationSize_, 1 );
+            }
+        }
+
+        return parameterPartialFunction.second;
+    }
+
+    //! Function to set a dependency of this partial object w.r.t. a given vector parameter.
+    /*!
+     * Function to set a dependency of this partial object w.r.t. a given vector parameter. If a dependency exists, the given
+     * partial is recomputed on every call of updateParameterPartials.
+     * \param parameter Partial w.r.t. which dependency is to be checked and set.
+     * \return Size (number of columns) of parameter partial. Zero if no dependency, size of parameter otherwise.
+     */
+    virtual int setParameterPartialUpdateFunction(
+            boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > parameter )
+    {
+        // Get partial function.
+        std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > parameterPartialFunction =
+                getParameterPartialFunction( parameter );
+
+        // If partial function found, add function to list of computations to be performed when calling
+        // updateParameterPartials.
+        if( parameterPartialFunction.second > 0 && currentVectorParameterPartials_.count( parameter ) == 0 )
+        {
+            if( parameterVectorPartialFunctions_.count( parameter ) == 0 )
+            {
+                parameterVectorPartialFunctions_[ parameter ] = parameterPartialFunction.first;
+                isCurrentVectorParameterPartialSet_[ parameter ] = 0;
+                currentVectorParameterPartials_[ parameter ] =
+                        Eigen::MatrixXd( accelerationSize_, parameter->getParameterSize( ) );
+            }
+        }
+
+        return parameterPartialFunction.second;
+    }
+
+    //! Function to update the values partial derivatives to current state and time.
+    /*!
+     * Function to update the values partial derivatives to current state and time.
+     */
+    void updateParameterPartials( )
+    {
+        // Update member object partials.
+        updateParameterPartialsOfMemberObjects( );
+
+        // Update double parameter partials
+        for( parameterDoublePartialFunctionIterator_ = parameterDoublePartialFunctions_.begin( );
+             parameterDoublePartialFunctionIterator_ != parameterDoublePartialFunctions_.end( );
+             parameterDoublePartialFunctionIterator_++ )
+        {
+            if( isCurrentDoubleParameterPartialSet_.at( parameterDoublePartialFunctionIterator_->first ) == 0 )
+            {
+                parameterDoublePartialFunctionIterator_->second( currentDoubleParameterPartials_[ parameterDoublePartialFunctionIterator_->first ]  );
+                isCurrentDoubleParameterPartialSet_[ parameterDoublePartialFunctionIterator_->first ] = 1;
+            }
+        }
+
+        // Update vector parameter partials
+        for( parameterVectorPartialFunctionIterator_ = parameterVectorPartialFunctions_.begin( );
+             parameterVectorPartialFunctionIterator_ != parameterVectorPartialFunctions_.end( );
+             parameterVectorPartialFunctionIterator_++ )
+        {
+            if( isCurrentVectorParameterPartialSet_.at( parameterVectorPartialFunctionIterator_->first ) == 0 )
+            {
+                parameterVectorPartialFunctionIterator_->second( currentVectorParameterPartials_[ parameterVectorPartialFunctionIterator_->first ]  );
+                isCurrentVectorParameterPartialSet_[  parameterVectorPartialFunctionIterator_->first ] = 1;
+            }
+        }
+    }
+
+protected:
+
+    //! Function to compute parameter partials of member objects.
+    /*!
+     *  Function to  compute parameter partials of member objects. By default (implemented here) no computations are
+     *  performed. For certain derived classed (i.e. ThirdBodyGravityPartial), there are member StateDerivativePartial
+     *  objects that need to be updated when calling updateParameterPartials, for which this function should be redefined.
+     */
+    virtual void updateParameterPartialsOfMemberObjects( )
+    {
+
+    }
+
+    //! Function to reset the member object to the current time
+    /*!
+     *  Function to reset the member object to the current time. By default (implemented here) no computations are performed.
+     *  For certain derived classed (i.e. ThirdBodyGravityPartial), there are member StateDerivativePartial objects that
+     *  need to be updated when calling resetTime, for which this function should be redefined.
+     */
+    virtual void resetTimeOfMemberObjects( )
+    {
+
+    }
+
+    //! Function to define all current parameter partials as 'not computed'
+    void resetCurrentParameterValues( )
+    {
+        for( isCurrentDoubleParameterPartialSetIterator_ = isCurrentDoubleParameterPartialSet_.begin( );
+             isCurrentDoubleParameterPartialSetIterator_ !=  isCurrentDoubleParameterPartialSet_.end( );
+             isCurrentDoubleParameterPartialSetIterator_++ )
+        {
+            isCurrentDoubleParameterPartialSet_[ isCurrentDoubleParameterPartialSetIterator_->first ] = 0;
+        }
+
+        for( isCurrentVectorParameterPartialSetIterator_ = isCurrentVectorParameterPartialSet_.begin( );
+             isCurrentVectorParameterPartialSetIterator_ !=  isCurrentVectorParameterPartialSet_.end( );
+             isCurrentVectorParameterPartialSetIterator_++ )
+        {
+            isCurrentVectorParameterPartialSet_[ isCurrentVectorParameterPartialSetIterator_->first ] = 0;
+        }
+    }
+
+    //! Type of state for which partials are to be computed.
+    propagators::IntegratedStateType integratedStateType_;
+
+    //! Size of the single order state derivative model (i.e. 3 for translational dynamics).
+    int accelerationSize_;
+
+    //! Identifier for body/reference point for which propagation is performed.
+    /*!
+     *  Identifier for body/reference point for which propagation is performed. First entry represents the body being
+     *  propagated. Second entry is empty for propagation of entire bodies (translational, rotational), but must be
+     *  set for propagation of local dynamics (i.e. observer proper time).
+     */
+    std::pair< std::string, std::string > integrationReferencePoint_;
+
+
+    //! List of booleans defining whether the partial w.r.t. the current double parameter (key) has been computed.
+    std::map< boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > >, bool >
+    isCurrentDoubleParameterPartialSet_;
+
+    //! Iterator for list defining whether the partial w.r.t. the current double parameter (key) has been computed.
+    std::map< boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > >, bool >::iterator
+    isCurrentDoubleParameterPartialSetIterator_;
+
+
+
+    //! List of current values of partials w.r.t. double parameter values (emptied at beginning of every time step).
+    std::map< boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > >, Eigen::MatrixXd >
+    currentDoubleParameterPartials_;
+
+    //! List of functions to compute (return by reference) values of partials w.r.t. doule parameter partials
+    std::map< boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > >,
+    boost::function< void( Eigen::MatrixXd& ) > > parameterDoublePartialFunctions_;
+
+    //! Iterator over list of functions to compute values of partials w.r.t. double parameter partials
+    std::map< boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > >,
+    boost::function< void( Eigen::MatrixXd& ) > >::iterator parameterDoublePartialFunctionIterator_;
+
+
+
+    //! List of booleans defining whether the partial w.r.t. the current vector parameter (key) has been computed.
+    std::map< boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > >, bool >
+    isCurrentVectorParameterPartialSet_;
+
+    //! Iterator for list defining whether the partial w.r.t. the current vector parameter (key) has been computed.
+    std::map< boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > >, bool >::iterator
+    isCurrentVectorParameterPartialSetIterator_;
+
+
+
+    //! List of current values of partials w.r.t. double parameter values (emptied at beginning of every time step).
+    std::map< boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > >,
+    Eigen::MatrixXd > currentVectorParameterPartials_;
+
+    //! List of functions to compute (return by reference) values of partials w.r.t. vector parameter partials
+    std::map< boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > >,
+    boost::function< void( Eigen::MatrixXd&  ) > > parameterVectorPartialFunctions_;
+
+    //! Iterator over list of functions to compute values of partials w.r.t. vector parameter partials
+    std::map< boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > >,
+    boost::function< void( Eigen::MatrixXd& ) > >::iterator parameterVectorPartialFunctionIterator_;
+
+
+    double currentTime_;
+
+};
+
+//! Typedef for double vector of StateDerivativePartial objects.
+/*!
+ *  Typedef for double vector of StateDerivativePartial objects. First (outer) vector is typically the
+ *  bodies undergoing 'acceleration (and being estimated), the second (inner) vector is the list of partials
+ *  being exerted on a single body.
+ */
+typedef std::vector< std::vector< boost::shared_ptr< partial_derivatives::StateDerivativePartial > > >
+StateDerivativePartialsMap;
+
+//! Function to evaluate the negative value of a parameter partial.
+/*!
+ *  Function to evaluate the negative value of a parameter partial.
+ *  \param parameterPartialFunction Function to compute the regular paramater partial (by reference).
+ *  \param partial Negative value of partial computed by parameterPartialFunction (returned by reference).
+ */
+void evaluateNegativeParameterPartialFunction(
+        const boost::function< void( Eigen::MatrixXd& ) > parameterPartialFunction,
+        Eigen::MatrixXd& partial );
+
+//! Function to evaluate the subtraction of two parameter partials.
+/*!
+ *  Function to evaluate the subtraction of two parameter partials.
+ *  \param firstParameterPartialFunction Function to compute the first paramater partial (by reference), from which
+ *  the value computed by parameterPartialFunctionToSubtract is subtracted.
+ *  \param parameterPartialFunctionToSubtract Function to compute the paramater partial (by reference) that is to be
+ *  subtracted.
+ *  \param partial Value of partial returned by parameterPartialFunctionToSubtract, subtracted from value returned by
+ *  firstParameterPartialFunction (returned by reference).
+ */
+void evaluateSubtractedParameterPartialFunction(
+        const boost::function< void( Eigen::MatrixXd& ) > firstParameterPartialFunction,
+        const boost::function< void( Eigen::MatrixXd& ) > parameterPartialFunctionToSubtract,
+        Eigen::MatrixXd& partial );
+
+//! Function to evaluate the addition of two parameter partials.
+/*!
+ *  Function to evaluate the addition of two parameter partials.
+ *  \param firstParameterPartialFunction Function to compute the first paramater partial (by reference) that is to be
+ *  added.
+ *  \param parameterPartialFunctionToAdd Function to compute the second paramater partial (by reference) that is to be
+ *  added.
+ *  \param partial Value of partial returned by firstParameterPartialFunction, added to value returned by
+ *  parameterPartialFunctionToAdd (returned by reference).
+ */
+void evaluateAddedParameterPartialFunction(
+        const boost::function< void( Eigen::MatrixXd& ) > firstParameterPartialFunction,
+        const boost::function< void( Eigen::MatrixXd& ) > parameterPartialFunctionToAdd,
+        Eigen::MatrixXd& partial );
+
+//! Create a parameter partial function obtained from the subtraction of two such function results.
+/*!
+ * Create a parameter partial function, as returned by the StateDerivativePartial::getParameterPartialFunction function
+ * The partial created here is obtained from the subtraction of two such function results. The two input variables
+ * may be both empty, both define a function, or only one of them may define a function.
+ * \param partialFunctionOfAccelerationToAdd Function and associated parameter size (first and second of pair) that
+ * are to be added to the total partial.
+ * \param partialFunctionOfAccelerationToSubtract Function and associated parameter size (first and second of pair) that
+ * are to be subtracted from the total partial.
+ * \return Function and parameter size obtained from 'subtracting' partialFunctionOfAccelerationToSubtract from
+ * partialFunctionOfAccelerationToAdd
+ */
+std::pair< boost::function< void( Eigen::MatrixXd& ) >, int > createMergedParameterPartialFunction(
+        const std::pair< boost::function< void( Eigen::MatrixXd& ) >, int >& partialFunctionOfAccelerationToAdd,
+        const std::pair< boost::function< void( Eigen::MatrixXd& ) >, int >& partialFunctionOfAccelerationToSubtract );
+
+
+//! Function to create a parameter partial evaluation function, obtained by adding or subtracting a given partial
+//! w.r.t. a double parameter from 2 state derivative partial models.
+/*!
+ * Function to create a parameter partial evaluation function, obtained by adding or subtracting a given partial
+ * w.r.t. a double parameter from 2 state derivative partial models. Note that this function creates a merged
+ * function from two getCurrentDoubleParameterPartial functions of the two input partial objects. The automatic
+ * computation when updating the partial (done by call to setParameterPartialUpdateFunction) is not handled by
+ * this function.
+ * \param firstPartial First object for computing partial derivatives.
+ * \param secondPartial Second object for computing partial derivatives.
+ * \param parameterObject Parameter w.r.t. which a partial is to be taken.
+ * \param firstPartialSize Size of partial from firstPartial object (only 0 and 1 are valid).
+ * \param secondPartialSize Size of partial from secondPartial object (only 0 and 1 are valid).
+ * \param subtractPartials Boolean denoting whether the second parameter is to be subtracted or added to the
+ * total partial.
+ * \return Function computing and returning (by reference) the combined partial according to the required settings.
+ */
+boost::function< void( Eigen::MatrixXd& ) > getCombinedCurrentDoubleParameterFunction(
+        const boost::shared_ptr< StateDerivativePartial > firstPartial,
+        const boost::shared_ptr< StateDerivativePartial > secondPartial,
+        const boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > parameterObject,
+        const int firstPartialSize, const int secondPartialSize,
+        const bool subtractPartials = 0 );
+
+//! Function to create a parameter partial evaluation function, obtained by adding or subtracting a given partial
+//! w.r.t. a vector parameter from 2 state derivative partial models.
+/*!
+ * Function to create a parameter partial evaluation function, obtained by adding or subtracting a given partial
+ * w.r.t. a vector parameter from 2 state derivative partial models. Note that this function creates a merged
+ * function from two getCurrentVectorParameterPartial functions of the two input partial objects. The automatic
+ * computation when updating the partial (done by call to setParameterPartialUpdateFunction) is not handled by
+ * this function.
+ * \param firstPartial First object for computing partial derivatives.
+ * \param secondPartial Second object for computing partial derivatives.
+ * \param parameterObject Parameter w.r.t. which a partial is to be taken.
+ * \param firstPartialSize Size of partial from firstPartial object
+ * \param secondPartialSize Size of partial from secondPartial object
+ * \param subtractPartials Boolean denoting whether the second parameter is to be subtracted or added to the
+ * total partial.
+ * \return Function computing and returning (by reference) the combined partial according to the required settings.
+ */
+boost::function< void( Eigen::MatrixXd& ) > getCombinedCurrentVectorParameterFunction(
+        const boost::shared_ptr< StateDerivativePartial > firstPartial,
+        const boost::shared_ptr< StateDerivativePartial > secondPartial,
+        const boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > parameterObject,
+        const int firstPartialSize, const int secondPartialSize,
+        const bool subtractPartials = 0 );
+
+}
+
+}
+
+}
+
+#endif // TUDAT_STATEDERIVATIVEPARTIAL_H
diff --git a/Tudat/Astrodynamics/Propagators/CMakeLists.txt b/Tudat/Astrodynamics/Propagators/CMakeLists.txt
index e772e56..95b47a6 100644
--- a/Tudat/Astrodynamics/Propagators/CMakeLists.txt
+++ b/Tudat/Astrodynamics/Propagators/CMakeLists.txt
@@ -36,16 +36,25 @@
 # Add source files.
 set(PROPAGATORS_SOURCES
   "${SRCROOT}${PROPAGATORSDIR}/createEnvironmentUpdater.cpp"
+  "${SRCROOT}${PROPAGATORSDIR}/createStateDerivativeModel.cpp"
   "${SRCROOT}${PROPAGATORSDIR}/setNumericallyIntegratedStates.cpp"
+  "${SRCROOT}${PROPAGATORSDIR}/propagationSettings.cpp"
+  "${SRCROOT}${PROPAGATORSDIR}/nBodyEnckeStateDerivative.cpp"
+  "${SRCROOT}${PROPAGATORSDIR}/propagationTermination.cpp"
+  "${SRCROOT}${PROPAGATORSDIR}/propagationOutput.cpp"
+  "${SRCROOT}${PROPAGATORSDIR}/variationalEquations.cpp"
+  "${SRCROOT}${PROPAGATORSDIR}/variationalEquationsSolver.cpp"
+  "${SRCROOT}${PROPAGATORSDIR}/stateTransitionMatrixInterface.cpp"
 )
 
 # Add header files.
-set(PROPAGATORS_HEADERS
+set(PROPAGATORS_HEADERS 
   "${SRCROOT}${PROPAGATORSDIR}/createStateDerivativeModel.h"
   "${SRCROOT}${PROPAGATORSDIR}/createEnvironmentUpdater.h"
   "${SRCROOT}${PROPAGATORSDIR}/centralBodyData.h"
   "${SRCROOT}${PROPAGATORSDIR}/nBodyStateDerivative.h"
   "${SRCROOT}${PROPAGATORSDIR}/nBodyCowellStateDerivative.h"
+  "${SRCROOT}${PROPAGATORSDIR}/nBodyEnckeStateDerivative.h"
   "${SRCROOT}${PROPAGATORSDIR}/propagationSettings.h"
   "${SRCROOT}${PROPAGATORSDIR}/dynamicsStateDerivativeModel.h"
   "${SRCROOT}${PROPAGATORSDIR}/singleStateTypeDerivative.h"
@@ -53,6 +62,14 @@ set(PROPAGATORS_HEADERS
   "${SRCROOT}${PROPAGATORSDIR}/dynamicsSimulator.h"
   "${SRCROOT}${PROPAGATORSDIR}/environmentUpdater.h"
   "${SRCROOT}${PROPAGATORSDIR}/integrateEquations.h"
+  "${SRCROOT}${PROPAGATORSDIR}/bodyMassStateDerivative.h"
+  "${SRCROOT}${PROPAGATORSDIR}/propagationTermination.h"
+  "${SRCROOT}${PROPAGATORSDIR}/propagationOutput.h"
+  "${SRCROOT}${PROPAGATORSDIR}/propagationOutputSettings.h"
+  "${SRCROOT}${PROPAGATORSDIR}/propagationTerminationSettings.h"
+  "${SRCROOT}${PROPAGATORSDIR}/variationalEquations.h"
+  "${SRCROOT}${PROPAGATORSDIR}/variationalEquationsSolver.h"
+  "${SRCROOT}${PROPAGATORSDIR}/stateTransitionMatrixInterface.h"
 )
 
 # Add static libraries.
@@ -60,20 +77,51 @@ add_library(tudat_propagators STATIC ${PROPAGATORS_SOURCES} ${PROPAGATORS_HEADER
 setup_tudat_library_target(tudat_propagators "${SRCROOT}${PROPAGATORSDIR}")
 
 # Add unit tests.
-add_executable(test_CentralBodyData
-    "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestCentralBodyData.cpp")
+add_executable(test_CentralBodyData "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestCentralBodyData.cpp")
 setup_custom_test_program(test_CentralBodyData "${SRCROOT}${PROPAGATORSDIR}")
-target_link_libraries(test_CentralBodyData tudat_propagators tudat_basic_mathematics
-    ${Boost_LIBRARIES})
+target_link_libraries(test_CentralBodyData tudat_propagators tudat_basic_mathematics ${Boost_LIBRARIES})
 
 if(USE_CSPICE)
-add_executable(test_CowellStateDerivative
-    "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestCowellStateDerivative.cpp")
+
+add_executable(test_CowellStateDerivative "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestCowellStateDerivative.cpp")
 setup_custom_test_program(test_CowellStateDerivative "${SRCROOT}${PROPAGATORSDIR}")
 target_link_libraries(test_CowellStateDerivative ${TUDAT_PROPAGATION_LIBRARIES} ${Boost_LIBRARIES})
 
-add_executable(test_EnvironmentModelUpdater
-    "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestEnvironmentUpdater.cpp")
+add_executable(test_EnckeStateDerivative "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestEnckeStateDerivative.cpp")
+setup_custom_test_program(test_EnckeStateDerivative "${SRCROOT}${PROPAGATORSDIR}")
+target_link_libraries(test_EnckeStateDerivative ${TUDAT_PROPAGATION_LIBRARIES} ${Boost_LIBRARIES})
+
+
+
+add_executable(test_SequentialVariationEquationIntegration "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestSequentialVariationalEquationIntegration.cpp")
+setup_custom_test_program(test_SequentialVariationEquationIntegration "${SRCROOT}${PROPAGATORSDIR}")
+target_link_libraries(test_SequentialVariationEquationIntegration ${TUDAT_ESTIMATION_LIBRARIES} ${Boost_LIBRARIES})
+
+add_executable(test_VariationalEquations "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestVariationalEquationPropagation.cpp")
+setup_custom_test_program(test_VariationalEquations "${SRCROOT}${PROPAGATORSDIR}")
+target_link_libraries(test_VariationalEquations ${TUDAT_ESTIMATION_LIBRARIES} ${Boost_LIBRARIES})
+
+add_executable(test_EnvironmentModelUpdater "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestEnvironmentUpdater.cpp")
 setup_custom_test_program(test_EnvironmentModelUpdater "${SRCROOT}${PROPAGATORSDIR}")
-    target_link_libraries(test_EnvironmentModelUpdater ${TUDAT_PROPAGATION_LIBRARIES} ${Boost_LIBRARIES})
-endif()
+target_link_libraries(test_EnvironmentModelUpdater ${TUDAT_PROPAGATION_LIBRARIES} ${Boost_LIBRARIES})
+
+
+add_executable(test_BodyMassPropagation "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestBodyMassPropagation.cpp")
+setup_custom_test_program(test_BodyMassPropagation "${SRCROOT}${PROPAGATORSDIR}")
+target_link_libraries(test_BodyMassPropagation ${TUDAT_PROPAGATION_LIBRARIES} ${Boost_LIBRARIES})
+
+
+add_executable(test_MultiTypeStatePropagation "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestMultiTypeStatePropagation.cpp")
+setup_custom_test_program(test_MultiTypeStatePropagation "${SRCROOT}${PROPAGATORSDIR}")
+target_link_libraries(test_MultiTypeStatePropagation ${TUDAT_PROPAGATION_LIBRARIES} ${Boost_LIBRARIES})
+
+
+add_executable(test_DependentVariableOutput "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestDependentVariableOutput.cpp")
+setup_custom_test_program(test_DependentVariableOutput "${SRCROOT}${PROPAGATORSDIR}")
+target_link_libraries(test_DependentVariableOutput ${TUDAT_PROPAGATION_LIBRARIES} ${Boost_LIBRARIES})
+
+add_executable(test_StoppingConditions "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestStoppingConditions.cpp")
+setup_custom_test_program(test_StoppingConditions "${SRCROOT}${PROPAGATORSDIR}")
+target_link_libraries(test_StoppingConditions ${TUDAT_PROPAGATION_LIBRARIES} ${Boost_LIBRARIES})
+
+endif( )
diff --git a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestBodyMassPropagation.cpp b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestBodyMassPropagation.cpp
new file mode 100644
index 0000000..8ab9ae0
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestBodyMassPropagation.cpp
@@ -0,0 +1,155 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#define BOOST_TEST_MAIN
+
+#include <limits>
+
+#include <boost/test/unit_test.hpp>
+#include <boost/make_shared.hpp>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/massRateModel.h"
+#include "Tudat/Astrodynamics/Propagators/propagationSettings.h"
+#include "Tudat/SimulationSetup/body.h"
+#include "Tudat/Astrodynamics/Propagators/dynamicsSimulator.h"
+
+
+namespace tudat
+{
+
+namespace unit_tests
+{
+
+using namespace tudat::propagators;
+using namespace tudat::simulation_setup;
+using namespace tudat::numerical_integrators;
+
+BOOST_AUTO_TEST_SUITE( test_body_mass_propagation )
+
+double getDummyMassRate1(
+        const NamedBodyMap bodyMap )
+{
+    return ( bodyMap.at( "Vehicle1" )->getBodyMass( ) + 2.0 * bodyMap.at( "Vehicle2" )->getBodyMass( ) ) / 1.0E4;
+}
+
+double getDummyMassRate2(
+        const NamedBodyMap bodyMap )
+{
+    return ( 3.0 * bodyMap.at( "Vehicle1" )->getBodyMass( ) + 2.0 * bodyMap.at( "Vehicle2" )->getBodyMass( ) ) / 1.0E4;
+}
+
+// Test mass rate of single body, linearly decreasing with time
+BOOST_AUTO_TEST_CASE( testBodyMassPropagation )
+{
+    // Crate bodyMap
+    NamedBodyMap bodyMap;
+    bodyMap[ "Vehicle" ] = boost::make_shared< Body >( );
+
+    // Create mass rate model.
+    std::map< std::string, boost::shared_ptr< basic_astrodynamics::MassRateModel > > massRateModels;
+    massRateModels[ "Vehicle" ] = boost::make_shared< basic_astrodynamics::CustomMassRateModel >(
+                boost::lambda::constant( -0.01 ) );
+
+    // Create settings for propagation
+    Eigen::VectorXd initialMass = Eigen::VectorXd( 1 );
+    initialMass( 0 ) = 500.0;
+    boost::shared_ptr< PropagatorSettings< double > > propagatorSettings =
+            boost::make_shared< MassPropagatorSettings< double > >(
+                boost::assign::list_of( "Vehicle" ), massRateModels, initialMass,
+                boost::make_shared< PropagationTimeTerminationSettings >( 1000.0 ) );
+
+    // Define numerical integrator settings.
+    boost::shared_ptr< IntegratorSettings< > > integratorSettings =
+            boost::make_shared< IntegratorSettings< > >( rungeKutta4, 0.0, 1.0 );
+
+    // Create dynamics simulation object.
+    SingleArcDynamicsSimulator< double, double > dynamicsSimulator(
+                bodyMap, integratorSettings, propagatorSettings, true, false, false );
+
+    // Test propagated solution.
+    std::map< double, Eigen::VectorXd > integratedState = dynamicsSimulator.getEquationsOfMotionNumericalSolution( );
+    for( std::map< double, Eigen::VectorXd >::const_iterator stateIterator = integratedState.begin( );
+         stateIterator != integratedState.end( ); stateIterator++ )
+    {
+        BOOST_CHECK_CLOSE_FRACTION( stateIterator->second( 0 ), 500.0 - 0.01 * stateIterator->first, 1.0E-13 );
+    }
+}
+
+// Test coupled mass rate of two bodies. Model ius unphysical, but has an analytical solution, and allows the internal
+// workings of the mass propagation to be more rigorously tested.
+BOOST_AUTO_TEST_CASE( testTwoBodyMassPropagation )
+{
+    // Crate bodyMap
+    NamedBodyMap bodyMap;
+    bodyMap[ "Vehicle1" ] = boost::make_shared< Body >( );
+    bodyMap[ "Vehicle2" ] = boost::make_shared< Body >( );
+
+    // Create mass rate models.
+    std::map< std::string, boost::shared_ptr< basic_astrodynamics::MassRateModel > > massRateModels;
+    massRateModels[ "Vehicle1" ] = boost::make_shared< basic_astrodynamics::CustomMassRateModel >(
+                boost::bind( &getDummyMassRate1, bodyMap ) );
+    massRateModels[ "Vehicle2" ] = boost::make_shared< basic_astrodynamics::CustomMassRateModel >(
+                boost::bind( &getDummyMassRate2, bodyMap ) );
+    bodyMap[ "Earth" ] = boost::make_shared< Body >( );
+    bodyMap[ "Earth" ]->setEphemeris( boost::make_shared< ephemerides::ConstantEphemeris >(
+                                          boost::lambda::constant( basic_mathematics::Vector6d::Zero( ) ) ) );
+    bodyMap[ "Vehicle1" ]->setEphemeris( boost::make_shared< ephemerides::ConstantEphemeris >(
+                                          boost::lambda::constant( basic_mathematics::Vector6d::Zero( ) ), "Earth" ) );
+    bodyMap[ "Vehicle2" ]->setEphemeris( boost::make_shared< ephemerides::ConstantEphemeris >(
+                                          boost::lambda::constant( basic_mathematics::Vector6d::Zero( ) ), "Earth" ) );
+
+    // Create settings for propagation
+    Eigen::VectorXd initialMass = Eigen::VectorXd( 2 );
+    initialMass( 0 ) = 500.0;
+    initialMass( 1 ) = 1000.0;
+    boost::shared_ptr< PropagatorSettings< double > > propagatorSettings =
+            boost::make_shared< MassPropagatorSettings< double > >(
+                boost::assign::list_of( "Vehicle1" )( "Vehicle2" ), massRateModels, initialMass,
+                boost::make_shared< PropagationTimeTerminationSettings >( 1000.0 ) );
+
+    // Define numerical integrator settings.
+    boost::shared_ptr< IntegratorSettings< > > integratorSettings =
+            boost::make_shared< IntegratorSettings< > >( rungeKutta4, 0.0, 1.0 );
+
+    // Create dynamics simulation object.
+    SingleArcDynamicsSimulator< double, double > dynamicsSimulator(
+                bodyMap, integratorSettings, propagatorSettings, true, false, true );
+
+    // Test propagated solution.
+    std::map< double, Eigen::VectorXd > integratedState = dynamicsSimulator.getEquationsOfMotionNumericalSolution( );
+    for( std::map< double, Eigen::VectorXd >::const_iterator stateIterator = integratedState.begin( );
+         stateIterator != integratedState.end( ); stateIterator++ )
+    {
+        // Test directly
+        BOOST_CHECK_CLOSE_FRACTION(
+                    stateIterator->second( 0 ),
+                    100.0 * ( -std::exp( -stateIterator->first / 1E4 ) +
+                              6.0 * std::exp( 4.0 * stateIterator->first / 1E4 ) ), 1.0E-13 );
+        BOOST_CHECK_CLOSE_FRACTION(
+                    stateIterator->second( 1 ),
+                    100.0 * ( std::exp( -stateIterator->first / 1E4 ) +
+                              9.0 * std::exp( 4.0 * stateIterator->first / 1E4 ) ), 1.0E-13 );
+
+        // Test reset mass solution of vehicles.
+        bodyMap[ "Vehicle1" ]->updateMass( stateIterator->first );
+        bodyMap[ "Vehicle2" ]->updateMass( stateIterator->first );
+
+        BOOST_CHECK_CLOSE_FRACTION( stateIterator->second( 0 ), bodyMap[ "Vehicle1" ]->getBodyMass( ),
+                std::numeric_limits< double >::epsilon( ) );
+        BOOST_CHECK_CLOSE_FRACTION( stateIterator->second( 1 ), bodyMap[ "Vehicle2" ]->getBodyMass( ),
+                std::numeric_limits< double >::epsilon( ) );
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+} // namespace unit_tests
+
+} // namespace tudat
diff --git a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestCowellStateDerivative.cpp b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestCowellStateDerivative.cpp
index 5f17cfd..1e3d2e1 100644
--- a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestCowellStateDerivative.cpp
+++ b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestCowellStateDerivative.cpp
@@ -83,125 +83,130 @@ BOOST_AUTO_TEST_CASE( testCowellPopagatorCentralBodies )
 
     // Create bodies needed in simulation
     std::map< std::string, boost::shared_ptr< BodySettings > > bodySettings =
-            getDefaultBodySettings( bodyNames, initialEphemerisTime - buffer,
-                                    finalEphemerisTime + buffer );
+            getDefaultBodySettings( bodyNames, initialEphemerisTime - buffer, finalEphemerisTime + buffer );
     bodySettings[ "Mars" ]->ephemerisSettings->resetFrameOrigin( "Earth" );
     bodySettings[ "Earth" ]->ephemerisSettings->resetFrameOrigin( "Sun" );
     bodySettings[ "Moon" ]->ephemerisSettings->resetFrameOrigin( "Earth" );
 
 
-    std::map< std::string, boost::shared_ptr< Body > > bodyMap = createBodies( bodySettings );
+    NamedBodyMap bodyMap = createBodies( bodySettings );
 
     setGlobalFrameBodyEphemerides( bodyMap, "SSB", "ECLIPJ2000" );
 
-    // Set accelerations between bodies that are to be taken into account (mutual point mass gravity
-    // between all bodies).
+    // Set accelerations between bodies that are to be taken into account (mutual point mass gravity between all bodies).
     SelectedAccelerationMap accelerationMap;
-    std::map< std::string,
-              std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfEarth;
-    accelerationsOfEarth[ "Sun" ].push_back(
-        boost::make_shared< AccelerationSettings >( central_gravity ) );
-    accelerationsOfEarth[ "Moon" ].push_back(
-        boost::make_shared< AccelerationSettings >( central_gravity ) );
-    accelerationsOfEarth[ "Mars" ].push_back(
-        boost::make_shared< AccelerationSettings >( central_gravity ) );
+    std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfEarth;
+    accelerationsOfEarth[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationsOfEarth[ "Moon" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationsOfEarth[ "Mars" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
     accelerationMap[ "Earth" ] = accelerationsOfEarth;
 
-    std::map< std::string,
-              std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfSun;
-    accelerationsOfSun[ "Moon" ].push_back(
-        boost::make_shared< AccelerationSettings >( central_gravity ) );
-    accelerationsOfSun[ "Earth" ].push_back(
-        boost::make_shared< AccelerationSettings >( central_gravity ) );
-    accelerationsOfSun[ "Mars" ].push_back(
-        boost::make_shared< AccelerationSettings >( central_gravity ) );
+    std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfSun;
+    accelerationsOfSun[ "Moon" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationsOfSun[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationsOfSun[ "Mars" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
     accelerationMap[ "Sun" ] = accelerationsOfSun;
 
-    std::map< std::string,
-              std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfMoon;
-    accelerationsOfMoon[ "Sun" ].push_back(
-        boost::make_shared< AccelerationSettings >( central_gravity ) );
-    accelerationsOfMoon[ "Earth" ].push_back(
-        boost::make_shared< AccelerationSettings >( central_gravity ) );
-    accelerationsOfMoon[ "Mars" ].push_back(
-        boost::make_shared< AccelerationSettings >( central_gravity ) );
+    std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfMoon;
+    accelerationsOfMoon[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationsOfMoon[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationsOfMoon[ "Mars" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
     accelerationMap[ "Moon" ] = accelerationsOfMoon;
 
-    std::map< std::string,
-              std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfMars;
-    accelerationsOfMars[ "Sun" ].push_back(
-        boost::make_shared< AccelerationSettings >( central_gravity ) );
-    accelerationsOfMars[ "Earth" ].push_back(
-        boost::make_shared< AccelerationSettings >( central_gravity ) );
-    accelerationsOfMars[ "Moon" ].push_back(
-        boost::make_shared< AccelerationSettings >( central_gravity ) );
+    std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfMars;
+    accelerationsOfMars[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationsOfMars[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationsOfMars[ "Moon" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
     accelerationMap[ "Mars" ] = accelerationsOfMars;
 
     // Define list of bodies to propagate
-    std::vector< std::string > bodiesToPropagate;
-    bodiesToPropagate.push_back( "Earth" );
-    bodiesToPropagate.push_back( "Sun" );
-    bodiesToPropagate.push_back( "Moon" );
-    bodiesToPropagate.push_back( "Mars" );
-    unsigned int numberOfNumericalBodies = bodiesToPropagate.size( );
+    std::vector< std::string > bodiesToIntegrate;
+    bodiesToIntegrate.push_back( "Earth" );
+    bodiesToIntegrate.push_back( "Sun" );
+    bodiesToIntegrate.push_back( "Moon" );
+    bodiesToIntegrate.push_back( "Mars" );
+    unsigned int numberOfNumericalBodies = bodiesToIntegrate.size( );
 
     // Define numerical integrator settings.
     boost::shared_ptr< IntegratorSettings< > > integratorSettings =
             boost::make_shared< IntegratorSettings< > >
-            ( rungeKutta4, initialEphemerisTime, finalEphemerisTime, 240.0 );
+            ( rungeKutta4, initialEphemerisTime, 200.0 );
 
     // Define central bodies to use in propagation (all w.r.t SSB).
     std::vector< std::string > centralBodies;
+    std::map< std::string, std::string > centralBodyMap;
     centralBodies.resize( numberOfNumericalBodies );
     for( unsigned int i = 0; i < numberOfNumericalBodies; i++ )
     {
         centralBodies[ i ] = "SSB";
+        centralBodyMap[ bodiesToIntegrate[ i ] ] = centralBodies[ i ];
     }
 
     // Get initial state vector as input to integration.
     Eigen::VectorXd systemInitialState = getInitialStatesOfBodies(
-                bodiesToPropagate, centralBodies, bodyMap, initialEphemerisTime );
+                bodiesToIntegrate, centralBodies, bodyMap, initialEphemerisTime );
 
     // Create acceleration models and propagation settings.
     AccelerationMap accelerationModelMap = createAccelerationModelsMap(
-                bodyMap, accelerationMap, bodiesToPropagate, centralBodies );
+                bodyMap, accelerationMap, centralBodyMap );
     boost::shared_ptr< TranslationalStatePropagatorSettings< double > > propagatorSettings =
             boost::make_shared< TranslationalStatePropagatorSettings< double > >
-            ( centralBodies, accelerationModelMap, bodiesToPropagate, systemInitialState );
+            ( centralBodies, accelerationModelMap, bodiesToIntegrate, systemInitialState, finalEphemerisTime );
 
     // Create simulation object and propagate dynamics.
     SingleArcDynamicsSimulator< > dynamicsSimulator(
                 bodyMap, integratorSettings, propagatorSettings, true, false, false );
+    std::map< double, Eigen::VectorXd > solutionSet1 = dynamicsSimulator.getEquationsOfMotionNumericalSolution( );
 
     // Define new central bodies (hierarchical system)
     centralBodies[ 0 ] = "Sun";
     centralBodies[ 1 ] = "SSB";
     centralBodies[ 2 ] = "Earth";
     centralBodies[ 3 ] = "Sun";
+    for( unsigned int i = 0; i < numberOfNumericalBodies; i++ )
+    {
+        centralBodyMap[ bodiesToIntegrate[ i ] ] = centralBodies[ i ];
+    }
 
     systemInitialState = getInitialStatesOfBodies(
-                bodiesToPropagate, centralBodies, bodyMap, initialEphemerisTime );
+                bodiesToIntegrate, centralBodies, bodyMap, initialEphemerisTime );
 
     // Create new acceleration models and propagation settings.
     AccelerationMap accelerationModelMap2 = createAccelerationModelsMap(
-                bodyMap, accelerationMap, bodiesToPropagate, centralBodies );
+                bodyMap, accelerationMap, centralBodyMap );
     boost::shared_ptr< TranslationalStatePropagatorSettings< double > > propagatorSettings2 =
             boost::make_shared< TranslationalStatePropagatorSettings< double > >
-            ( centralBodies, accelerationModelMap2, bodiesToPropagate, systemInitialState );
+            ( centralBodies, accelerationModelMap2, bodiesToIntegrate, systemInitialState, finalEphemerisTime );
+
+
 
     // Create new simulation object and propagate dynamics.
     SingleArcDynamicsSimulator< > dynamicsSimulator2(
                 bodyMap, integratorSettings, propagatorSettings2, true, false );
+    std::map< double, Eigen::VectorXd > solutionSet2 = dynamicsSimulator2.getEquationsOfMotionNumericalSolution( );
+
+    // Create integration and propagation settings for reverse in time propagation
+    std::map< double, Eigen::VectorXd >::iterator solutionSetIterator = (--solutionSet2.end( ) );
+    Eigen::VectorXd systemFinalState = solutionSetIterator->second;
+    boost::shared_ptr< IntegratorSettings< > > integratorSettings2 =
+            boost::make_shared< IntegratorSettings< > >
+            ( rungeKutta4, solutionSetIterator->first, -200.0 );
+    boost::shared_ptr< TranslationalStatePropagatorSettings< double > > propagatorSettings3 =
+            boost::make_shared< TranslationalStatePropagatorSettings< double > >
+            ( centralBodies, accelerationModelMap2, bodiesToIntegrate, systemFinalState, initialEphemerisTime );
 
-    // Retrieve dynamics solution for the two different central body settings and create
-    // interpolators.
-    std::map< double, Eigen::VectorXd > solutionSet1
-        = dynamicsSimulator.getEquationsOfMotionNumericalSolution( );
-    std::map< double, Eigen::VectorXd > solutionSet2
-        = dynamicsSimulator2.getEquationsOfMotionNumericalSolution( );
+    // Create new simulation object and propagate dynamics backwards in time.
+    SingleArcDynamicsSimulator< > dynamicsSimulator3(
+               bodyMap, integratorSettings2, propagatorSettings3, true, false, false );
+    std::map< double, Eigen::VectorXd > solutionSet3 = dynamicsSimulator3.getEquationsOfMotionNumericalSolution( );
 
-    LagrangeInterpolator< double, Eigen::VectorXd > interpolator1( solutionSet1, 8 );
-    LagrangeInterpolator< double, Eigen::VectorXd > interpolator2( solutionSet2, 8 );
+    // Create interpolators from three numerical solutions (first one is inertial; second and third are non-inertial)
+    boost::shared_ptr< LagrangeInterpolator< double, Eigen::VectorXd > > interpolator1 =
+            boost::make_shared< LagrangeInterpolator< double, Eigen::VectorXd > >( solutionSet1, 8 );
+    boost::shared_ptr< LagrangeInterpolator< double, Eigen::VectorXd > > interpolator2 =
+            boost::make_shared< LagrangeInterpolator< double, Eigen::VectorXd > >( solutionSet2, 8 );
+    boost::shared_ptr< LagrangeInterpolator< double, Eigen::VectorXd > > interpolator3 =
+            boost::make_shared< LagrangeInterpolator< double, Eigen::VectorXd > >( solutionSet3, 8 );
 
     // Define step size to be out of sync with integration step size.
     double stepSize = 2001.1 + mathematical_constants::PI;
@@ -210,87 +215,97 @@ BOOST_AUTO_TEST_CASE( testCowellPopagatorCentralBodies )
     std::map< double, Eigen::VectorXd > analyticalSolutions;
 
     // Define maps to retrieve propagated orbits from interpolator.
-    Eigen::VectorXd currentInertialSolution
-        = Eigen::VectorXd::Zero( 6 * numberOfNumericalBodies );
-    Eigen::VectorXd currentNonInertialSolution
-        = Eigen::VectorXd::Zero( 6 * numberOfNumericalBodies );
+    Eigen::VectorXd currentInertialSolution = Eigen::VectorXd::Zero( 6 * numberOfNumericalBodies );
+    Eigen::VectorXd currentNonInertialSolution = Eigen::VectorXd::Zero( 6 * numberOfNumericalBodies );
 
     // Define map to put inertial orbit reconstructed from non-inertial orbits.
-    Eigen::VectorXd reconstructedInertialSolution
-        = Eigen::VectorXd::Zero( 6 * numberOfNumericalBodies );
+    Eigen::VectorXd reconstructedInertialSolution = Eigen::VectorXd::Zero( 6 * numberOfNumericalBodies );
 
     // Define error maps.
     Eigen::VectorXd stateDifference = Eigen::VectorXd::Zero( 6 * numberOfNumericalBodies );
 
     // Test numerical output against results with SSB as origin for ech body,
-    boost::shared_ptr< ephemerides::Ephemeris > sunEphemeris
-        = bodyMap[ "Sun" ]->getEphemeris( );
+    boost::shared_ptr< ephemerides::Ephemeris > sunEphemeris = bodyMap[ "Sun" ]->getEphemeris( );
+    boost::shared_ptr< ephemerides::Ephemeris > earthEphemeris = bodyMap[ "Earth" ]->getEphemeris( );
+    boost::shared_ptr< ephemerides::Ephemeris > marsEphemeris = bodyMap[ "Mars" ]->getEphemeris( );
+    boost::shared_ptr< ephemerides::Ephemeris > moonEphemeris = bodyMap[ "Moon" ]->getEphemeris( );
+
+    boost::shared_ptr< LagrangeInterpolator< double, Eigen::VectorXd > > currentInterpolator;
+
     while( currentTime < finalEphemerisTime - stepSize )
     {
         // Retrieve data from interpolators; transform to inertial frames and compare.
-        currentInertialSolution = interpolator1.interpolate( currentTime );
-        currentNonInertialSolution = interpolator2.interpolate( currentTime );
-        reconstructedInertialSolution.segment( 0, 6 ) = currentNonInertialSolution.segment( 0, 6 )
-            + sunEphemeris->getCartesianStateFromEphemeris( currentTime );
-        reconstructedInertialSolution.segment( 6, 6 ) = currentNonInertialSolution.segment( 6, 6 );
-        reconstructedInertialSolution.segment( 12, 6 )
-            = currentNonInertialSolution.segment( 12, 6 )
-            + reconstructedInertialSolution.segment( 0, 6 );
-        reconstructedInertialSolution.segment( 18, 6 )
-            = currentNonInertialSolution.segment( 18, 6 )
-            + sunEphemeris->getCartesianStateFromEphemeris( currentTime );
+        currentInertialSolution = interpolator1->interpolate( currentTime );
 
-        // Compare states.
-        stateDifference = reconstructedInertialSolution - currentInertialSolution;
-        for( unsigned j = 0; j < 4; j++ )
+
+        for( unsigned int k = 0; k < 2; k++ )
         {
-            if( j != 2 )
+            if( k == 0 )
             {
-                BOOST_CHECK_SMALL( std::fabs( stateDifference( 0 + 6 * j ) ), 1.0E-2 );
-                BOOST_CHECK_SMALL( std::fabs( stateDifference( 1 + 6 * j ) ), 1.0E-2 );
-                BOOST_CHECK_SMALL( std::fabs( stateDifference( 2 + 6 * j ) ), 1.0E-2 );
-
-                BOOST_CHECK_SMALL( std::fabs( stateDifference( 3 + 6 * j ) ), 5.0E-9 );
-                BOOST_CHECK_SMALL( std::fabs( stateDifference( 4 + 6 * j ) ), 5.0E-9 );
-                BOOST_CHECK_SMALL( std::fabs( stateDifference( 5 + 6 * j ) ), 5.0E-9 );
+                currentInterpolator = interpolator2;
             }
             else
             {
-                BOOST_CHECK_SMALL( std::fabs( stateDifference( 0 + 6 * j ) ), 1.0E-1 );
-                BOOST_CHECK_SMALL( std::fabs( stateDifference( 1 + 6 * j ) ), 1.0E-1 );
-                BOOST_CHECK_SMALL( std::fabs( stateDifference( 2 + 6 * j ) ), 1.0E-1 );
+                currentInterpolator = interpolator3;
+            }
 
-                BOOST_CHECK_SMALL( std::fabs( stateDifference( 3 + 6 * j ) ), 2.0E-7 );
-                BOOST_CHECK_SMALL( std::fabs( stateDifference( 4 + 6 * j ) ), 2.0E-7 );
-                BOOST_CHECK_SMALL( std::fabs( stateDifference( 5 + 6 * j ) ), 2.0E-7 );
+            currentNonInertialSolution = currentInterpolator->interpolate( currentTime );
+
+            reconstructedInertialSolution.segment( 0, 6 ) = currentNonInertialSolution.segment( 0, 6 ) +
+                    currentNonInertialSolution.segment( 6, 6 );
+            reconstructedInertialSolution.segment( 6, 6 ) = currentNonInertialSolution.segment( 6, 6 );
+            reconstructedInertialSolution.segment( 12, 6 )= currentNonInertialSolution.segment( 12, 6 ) +
+                    reconstructedInertialSolution.segment( 0, 6 );
+            reconstructedInertialSolution.segment( 18, 6 ) = currentNonInertialSolution.segment( 18, 6 ) +
+                    reconstructedInertialSolution.segment( 6, 6 );
+
+            // Compare states.
+            stateDifference = reconstructedInertialSolution - currentInertialSolution;
+
+            for( unsigned j = 0; j < 4; j++ )
+            {
+                if( j != 2 )
+                {
+                    BOOST_CHECK_SMALL( std::fabs( stateDifference( 0 + 6 * j ) ), 1.0E-2 );
+                    BOOST_CHECK_SMALL( std::fabs( stateDifference( 1 + 6 * j ) ), 1.0E-2 );
+                    BOOST_CHECK_SMALL( std::fabs( stateDifference( 2 + 6 * j ) ), 1.0E-2 );
+
+                    BOOST_CHECK_SMALL( std::fabs( stateDifference( 3 + 6 * j ) ), 5.0E-9 );
+                    BOOST_CHECK_SMALL( std::fabs( stateDifference( 4 + 6 * j ) ), 5.0E-9 );
+                    BOOST_CHECK_SMALL( std::fabs( stateDifference( 5 + 6 * j ) ), 5.0E-9 );
+                }
+                else
+                {
+                    BOOST_CHECK_SMALL( std::fabs( stateDifference( 0 + 6 * j ) ), 1.0E-1 );
+                    BOOST_CHECK_SMALL( std::fabs( stateDifference( 1 + 6 * j ) ), 1.0E-1 );
+                    BOOST_CHECK_SMALL( std::fabs( stateDifference( 2 + 6 * j ) ), 1.0E-1 );
+
+                    BOOST_CHECK_SMALL( std::fabs( stateDifference( 3 + 6 * j ) ), 2.0E-7 );
+                    BOOST_CHECK_SMALL( std::fabs( stateDifference( 4 + 6 * j ) ), 2.0E-7 );
+                    BOOST_CHECK_SMALL( std::fabs( stateDifference( 5 + 6 * j ) ), 2.0E-7 );
+                }
             }
         }
-        currentTime += stepSize;
-    }
 
-    // Test whether ephemeris objects have been properly reset, i.e. whether all states have been
-    // properly transformed to the ephemeris frame.
-    boost::shared_ptr< ephemerides::Ephemeris > earthEphemeris = bodyMap[ "Earth" ]->getEphemeris( );
-    boost::shared_ptr< ephemerides::Ephemeris > marsEphemeris = bodyMap[ "Mars" ]->getEphemeris( );
-    boost::shared_ptr< ephemerides::Ephemeris > moonEphemeris = bodyMap[ "Moon" ]->getEphemeris( );
 
-    while( currentTime < finalEphemerisTime - stepSize )
-    {
+
+        // Test whether ephemeris objects have been properly reset, i.e. whether all states have been properly transformed to the
+        // ephemeris frame.
+
         // Retrieve data from interpolators; transform to inertial frames and compare.
-        currentInertialSolution = interpolator1.interpolate( currentTime );
-
-        reconstructedInertialSolution.segment( 0, 6 )
-            = earthEphemeris->getCartesianStateFromEphemeris( currentTime )
-            + sunEphemeris->getCartesianStateFromEphemeris( currentTime );
-        reconstructedInertialSolution.segment( 6, 6 )
-            = sunEphemeris->getCartesianStateFromEphemeris( currentTime );
-        reconstructedInertialSolution.segment( 12, 6 )
-            = moonEphemeris->getCartesianStateFromEphemeris( currentTime )
-            + earthEphemeris->getCartesianStateFromEphemeris( currentTime )
-            + sunEphemeris->getCartesianStateFromEphemeris( currentTime );
-        reconstructedInertialSolution.segment( 18, 6 )
-            = marsEphemeris->getCartesianStateFromEphemeris( currentTime )
-            + sunEphemeris->getCartesianStateFromEphemeris( currentTime );
+        currentInertialSolution = interpolator1->interpolate( currentTime );
+
+        reconstructedInertialSolution.segment( 0, 6 ) = earthEphemeris->getCartesianStateFromEphemeris( currentTime ) +
+                sunEphemeris->getCartesianStateFromEphemeris( currentTime );
+        reconstructedInertialSolution.segment( 6, 6 ) = sunEphemeris->getCartesianStateFromEphemeris( currentTime );
+        reconstructedInertialSolution.segment( 12, 6 ) =
+                moonEphemeris->getCartesianStateFromEphemeris( currentTime ) +
+                earthEphemeris->getCartesianStateFromEphemeris( currentTime ) +
+                sunEphemeris->getCartesianStateFromEphemeris( currentTime );
+        reconstructedInertialSolution.segment( 18, 6 ) =
+                marsEphemeris->getCartesianStateFromEphemeris( currentTime ) +
+                earthEphemeris->getCartesianStateFromEphemeris( currentTime ) +
+                sunEphemeris->getCartesianStateFromEphemeris( currentTime );
 
         // Compare states.
         stateDifference = reconstructedInertialSolution - currentInertialSolution;
@@ -325,7 +340,8 @@ BOOST_AUTO_TEST_CASE( testCowellPopagatorCentralBodies )
 
 //! Test to ensure that a point-mass acceleration on a body produces a Kepler orbit (to within
 //! numerical error bounds).
-BOOST_AUTO_TEST_CASE( testCowellPopagatorKeplerCompare )
+template< typename TimeType, typename StateScalarType >
+void testCowellPropagationOfKeplerOrbit( )
 {
     //Load spice kernels.
     std::string kernelsPath = input_output::getSpiceKernelPath( );
@@ -348,46 +364,49 @@ BOOST_AUTO_TEST_CASE( testCowellPopagatorKeplerCompare )
 
     // Create bodies needed in simulation
     std::map< std::string, boost::shared_ptr< BodySettings > > bodySettings =
-            getDefaultBodySettings( bodyNames,
-                                    initialEphemerisTime - buffer, finalEphemerisTime + buffer );
+            getDefaultBodySettings( bodyNames, initialEphemerisTime - buffer, finalEphemerisTime + buffer );
+
+    if( std::is_same< long double, StateScalarType >::value )
+    {
+        boost::dynamic_pointer_cast< InterpolatedSpiceEphemerisSettings >(
+                    bodySettings[ "Moon" ]->ephemerisSettings )->setUseLongDoubleStates( 1 );
+    }
 
     // Change ephemeris settings of Moon and Earth to make test results analysis more transparent.
-    boost::dynamic_pointer_cast< InterpolatedSpiceEphemerisSettings >
-        ( bodySettings[ "Moon" ]->ephemerisSettings )->resetFrameOrigin( "Earth" );
+    boost::dynamic_pointer_cast< InterpolatedSpiceEphemerisSettings >( bodySettings[ "Moon" ]->ephemerisSettings )->
+            resetFrameOrigin( "Earth" );
     bodySettings[ "Earth" ]->ephemerisSettings = boost::make_shared< ConstantEphemerisSettings >(
                 basic_mathematics::Vector6d::Zero( ), "SSB", "ECLIPJ2000" );
 
-    std::map< std::string, boost::shared_ptr< Body > > bodyMap = createBodies( bodySettings );
+    NamedBodyMap bodyMap = createBodies( bodySettings );
     setGlobalFrameBodyEphemerides( bodyMap, "SSB", "ECLIPJ2000" );
 
     // Set accelerations between bodies that are to be taken into account.
     SelectedAccelerationMap accelerationMap;
-    std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > >
-        accelerationsOfMoon;
-    accelerationsOfMoon[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >
-                                              ( central_gravity ) );
+    std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfMoon;
+    accelerationsOfMoon[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
     accelerationMap[ "Moon" ] = accelerationsOfMoon;
 
     // Propagate the moon only
-    std::vector< std::string > bodiesToPropagate;
-    bodiesToPropagate.push_back( "Moon" );
-    unsigned int numberOfNumericalBodies = bodiesToPropagate.size( );
+    std::vector< std::string > bodiesToIntegrate;
+    bodiesToIntegrate.push_back( "Moon" );
+    unsigned int numberOfNumericalBodies = bodiesToIntegrate.size( );
 
     // Define settings for numerical integrator.
     boost::shared_ptr< IntegratorSettings< > > integratorSettings =
             boost::make_shared< IntegratorSettings< > >
-            ( rungeKutta4, initialEphemerisTime, finalEphemerisTime, 120.0 );
+            ( rungeKutta4, initialEphemerisTime, 120.0 );
 
     // Run test where Moon gravity is/is not taken into account.
     for( unsigned testCase = 0; testCase < 2; testCase++ )
     {
         // Get initial kepler elements
-        double effectiveGravitationalParameter;
+        StateScalarType effectiveGravitationalParameter;
         if( testCase == 0 )
         {
-            effectiveGravitationalParameter
-                = bodyMap.at( "Earth" )->getGravityFieldModel( )->getGravitationalParameter( )
-                + bodyMap.at( "Moon" )->getGravityFieldModel( )->getGravitationalParameter( );
+            effectiveGravitationalParameter =
+                    bodyMap.at( "Earth" )->getGravityFieldModel( )->getGravitationalParameter( ) +
+                    bodyMap.at( "Moon" )->getGravityFieldModel( )->getGravitationalParameter( );
         }
         else
         {
@@ -397,6 +416,7 @@ BOOST_AUTO_TEST_CASE( testCowellPopagatorKeplerCompare )
 
         // Define central bodies for integration.
         std::vector< std::string > centralBodies;
+        std::map< std::string, std::string > centralBodyMap;
 
         if( testCase == 0 )
         {
@@ -412,42 +432,50 @@ BOOST_AUTO_TEST_CASE( testCowellPopagatorKeplerCompare )
                     bodyMap.at( "Earth" )->getGravityFieldModel( )->getGravitationalParameter( );
             centralBodies.push_back( "SSB" );
         }
+        centralBodyMap[ bodiesToIntegrate[ 0 ] ] = centralBodies[ 0 ];
+
 
         // Create system initial state.
-        Eigen::VectorXd systemInitialState = Eigen::VectorXd( bodiesToPropagate.size( ) * 6 );
+        Eigen::Matrix< StateScalarType, 6, 1  > systemInitialState =
+                Eigen::Matrix< StateScalarType, 6, 1  >( bodiesToIntegrate.size( ) * 6 );
         for( unsigned int i = 0; i < numberOfNumericalBodies ; i++ )
         {
             systemInitialState.segment( i * 6 , 6 ) =
                     spice_interface::getBodyCartesianStateAtEpoch(
-                      bodiesToPropagate[ i ], "Earth", "ECLIPJ2000", "NONE", initialEphemerisTime );
+                      bodiesToIntegrate[ i ], "Earth", "ECLIPJ2000", "NONE", initialEphemerisTime ).
+                    template cast< StateScalarType >( );
         }
 
         // Create acceleration models and propagation settings.
         AccelerationMap accelerationModelMap = createAccelerationModelsMap(
-                    bodyMap, accelerationMap, bodiesToPropagate, centralBodies );
-        boost::shared_ptr< TranslationalStatePropagatorSettings< double > > propagatorSettings =
-                boost::make_shared< TranslationalStatePropagatorSettings< double > >
-                ( centralBodies, accelerationModelMap, bodiesToPropagate, systemInitialState );
+                    bodyMap, accelerationMap, bodiesToIntegrate, centralBodies );
+        boost::shared_ptr< TranslationalStatePropagatorSettings< StateScalarType > > propagatorSettings =
+                boost::make_shared< TranslationalStatePropagatorSettings< StateScalarType > >
+                ( centralBodies, accelerationModelMap, bodiesToIntegrate, systemInitialState, finalEphemerisTime );
 
         // Create dynamics simulation object.
-        SingleArcDynamicsSimulator< > dynamicsSimulator(
+        SingleArcDynamicsSimulator< StateScalarType, TimeType > dynamicsSimulator(
                     bodyMap, integratorSettings, propagatorSettings, true, false );
 
-        basic_mathematics::Vector6d initialKeplerElements =
-            orbital_element_conversions::convertCartesianToKeplerianElements(
-                basic_mathematics::Vector6d( systemInitialState ), effectiveGravitationalParameter );
+        Eigen::Matrix< StateScalarType, 6, 1  > initialKeplerElements =
+            orbital_element_conversions::convertCartesianToKeplerianElements< StateScalarType >(
+                Eigen::Matrix< StateScalarType, 6, 1  >( systemInitialState ), effectiveGravitationalParameter );
+
 
         // Compare numerical state and kepler orbit at each time step.
         boost::shared_ptr< Ephemeris > moonEphemeris = bodyMap.at( "Moon" )->getEphemeris( );
         double currentTime = initialEphemerisTime + buffer;
         while( currentTime < finalEphemerisTime - buffer )
         {
-            basic_mathematics::Vector6d stateDifference
-                = orbital_element_conversions::convertKeplerianToCartesianElements(
-                    propagateKeplerOrbit( initialKeplerElements, currentTime - initialEphemerisTime,
+
+            Eigen::VectorXd stateDifference
+                = ( orbital_element_conversions::convertKeplerianToCartesianElements(
+                    propagateKeplerOrbit< StateScalarType >( initialKeplerElements, currentTime - initialEphemerisTime,
                                           effectiveGravitationalParameter ),
                     effectiveGravitationalParameter )
-                - moonEphemeris->getCartesianStateFromEphemeris( currentTime );
+                - moonEphemeris->template getTemplatedStateFromEphemeris< StateScalarType >( currentTime ) ).
+                    template cast< double >( );
+
             for( int i = 0; i < 3; i++ )
             {
                 BOOST_CHECK_SMALL( stateDifference( i ), 1E-3 );
@@ -458,10 +486,16 @@ BOOST_AUTO_TEST_CASE( testCowellPopagatorKeplerCompare )
         }
     }
 }
+BOOST_AUTO_TEST_CASE( testCowellPopagatorKeplerCompare )
+{
+    testCowellPropagationOfKeplerOrbit< double, double >( );
+    testCowellPropagationOfKeplerOrbit< double, long double >( );
+
+}
 
 BOOST_AUTO_TEST_SUITE_END( )
 
 
-} // namespace unit_tests
+}
 
-} // namespace tudat
+}
diff --git a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestDependentVariableOutput.cpp b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestDependentVariableOutput.cpp
new file mode 100644
index 0000000..b0baf34
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestDependentVariableOutput.cpp
@@ -0,0 +1,279 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#define BOOST_TEST_MAIN
+
+#include <boost/test/unit_test.hpp>
+#include <boost/bind.hpp>
+#include <boost/make_shared.hpp>
+#include <boost/shared_ptr.hpp>
+
+#include <Tudat/Astrodynamics/Aerodynamics/UnitTests/testApolloCapsuleCoefficients.h>
+#include <Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h>
+#include <Tudat/Basics/testMacros.h>
+#include <Tudat/Astrodynamics/Propagators/dynamicsSimulator.h>
+#include <Tudat/Astrodynamics/BasicAstrodynamics/unitConversions.h>
+#include <Tudat/External/SpiceInterface/spiceInterface.h>
+#include <Tudat/SimulationSetup/body.h>
+#include <Tudat/SimulationSetup/createAccelerationModels.h>
+#include <Tudat/SimulationSetup/defaultBodies.h>
+#include <Tudat/InputOutput/basicInputOutput.h>
+
+#include <iostream>
+#include <limits>
+#include <string>
+
+#include <Eigen/Core>
+
+namespace tudat
+{
+
+namespace unit_tests
+{
+
+BOOST_AUTO_TEST_SUITE( test_dependent_variable_output )
+
+//! Propagate entry of Apollo capsule, and save a list of dependent variables during entry. The saved dependent variables
+//! are compred against theoretical/manual values in this test.
+BOOST_AUTO_TEST_CASE( testDependentVariableOutput )
+{
+    using namespace ephemerides;
+    using namespace interpolators;
+    using namespace numerical_integrators;
+    using namespace spice_interface;
+    using namespace simulation_setup;
+    using namespace basic_astrodynamics;
+    using namespace orbital_element_conversions;
+    using namespace propagators;
+    using namespace aerodynamics;
+    using namespace basic_mathematics;
+    using namespace input_output;
+
+    // Load Spice kernels.
+    spice_interface::loadSpiceKernelInTudat( input_output::getSpiceKernelPath( ) + "pck00009.tpc" );
+    spice_interface::loadSpiceKernelInTudat( input_output::getSpiceKernelPath( ) + "de-403-masses.tpc" );
+    spice_interface::loadSpiceKernelInTudat( input_output::getSpiceKernelPath( ) + "de421.bsp" );
+
+
+    // Set simulation start epoch.
+    const double simulationStartEpoch = 0.0;
+
+    // Set simulation end epoch.
+    const double simulationEndEpoch = 3300.0;
+
+    // Set numerical integration fixed step size.
+    const double fixedStepSize = 1.0;
+
+
+    // Set Keplerian elements for Capsule.
+    Vector6d apolloInitialStateInKeplerianElements;
+    apolloInitialStateInKeplerianElements( semiMajorAxisIndex ) = spice_interface::getAverageRadius( "Earth" ) + 120.0E3;
+    apolloInitialStateInKeplerianElements( eccentricityIndex ) = 0.005;
+    apolloInitialStateInKeplerianElements( inclinationIndex ) = unit_conversions::convertDegreesToRadians( 85.3 );
+    apolloInitialStateInKeplerianElements( argumentOfPeriapsisIndex )
+            = unit_conversions::convertDegreesToRadians( 235.7 );
+    apolloInitialStateInKeplerianElements( longitudeOfAscendingNodeIndex )
+            = unit_conversions::convertDegreesToRadians( 23.4 );
+    apolloInitialStateInKeplerianElements( trueAnomalyIndex ) = unit_conversions::convertDegreesToRadians( 139.87 );
+
+    // Convert apollo state from Keplerian elements to Cartesian elements.
+    const Vector6d apolloInitialState = convertKeplerianToCartesianElements(
+                apolloInitialStateInKeplerianElements,
+                getBodyGravitationalParameter( "Earth" ) );
+
+    // Define simulation body settings.
+    std::map< std::string, boost::shared_ptr< BodySettings > > bodySettings =
+            getDefaultBodySettings( { "Earth", "Moon" }, simulationStartEpoch - 10.0 * fixedStepSize,
+                                    simulationEndEpoch + 10.0 * fixedStepSize );
+    bodySettings[ "Earth" ]->gravityFieldSettings =
+            boost::make_shared< simulation_setup::GravityFieldSettings >( central_spice );
+
+    // Create Earth object
+    simulation_setup::NamedBodyMap bodyMap = simulation_setup::createBodies( bodySettings );
+
+    // Create vehicle objects.
+    bodyMap[ "Apollo" ] = boost::make_shared< simulation_setup::Body >( );
+
+    // Create vehicle aerodynamic coefficients
+    bodyMap[ "Apollo" ]->setAerodynamicCoefficientInterface(
+                unit_tests::getApolloCoefficientInterface( ) );
+    bodyMap[ "Apollo" ]->setConstantBodyMass( 5.0E3 );
+    bodyMap[ "Apollo" ]->setEphemeris(
+                boost::make_shared< ephemerides::TabulatedCartesianEphemeris< > >(
+                    boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, basic_mathematics::Vector6d  > >( ),
+                    "Earth" ) );
+
+    // Finalize body creation.
+    setGlobalFrameBodyEphemerides( bodyMap, "SSB", "ECLIPJ2000" );
+
+    // Define propagator settings variables.
+    SelectedAccelerationMap accelerationMap;
+    std::vector< std::string > bodiesToPropagate;
+    std::vector< std::string > centralBodies;
+
+    // Define acceleration model settings.
+    std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfApollo;
+    accelerationsOfApollo[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationsOfApollo[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( aerodynamic ) );
+    accelerationsOfApollo[ "Moon" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationMap[  "Apollo" ] = accelerationsOfApollo;
+
+    bodiesToPropagate.push_back( "Apollo" );
+    centralBodies.push_back( "Earth" );
+
+    // Set initial state
+    basic_mathematics::Vector6d systemInitialState = apolloInitialState;
+
+    // Define list of dependent variables to save.
+    std::vector< boost::shared_ptr< SingleDependentVariableSaveSettings > > dependentVariables;
+    dependentVariables.push_back(
+                boost::make_shared< SingleDependentVariableSaveSettings >( mach_number_dependent_variable, "Apollo" ) );
+    dependentVariables.push_back(
+                boost::make_shared< SingleDependentVariableSaveSettings >( altitude_dependent_variable,
+                                                                           "Apollo", "Earth" ) );
+    dependentVariables.push_back(
+                boost::make_shared< SingleDependentVariableSaveSettings >( relative_distance_dependent_variable,
+                                                                           "Apollo", "Earth" ) );
+    dependentVariables.push_back(
+                boost::make_shared< SingleDependentVariableSaveSettings >( relative_speed_dependent_variable,
+                                                                           "Apollo", "Earth" ) );
+    dependentVariables.push_back(
+                boost::make_shared< SingleAccelerationDependentVariableSaveSettings >(
+                    central_gravity, "Apollo", "Earth", 1 ) );
+
+
+    dependentVariables.push_back(
+                boost::make_shared< SingleDependentVariableSaveSettings >( relative_position_dependent_variable,
+                                                                           "Apollo", "Earth" ) );
+    dependentVariables.push_back(
+                boost::make_shared< SingleDependentVariableSaveSettings >( relative_velocity_dependent_variable,
+                                                                           "Apollo", "Earth" ) );
+    dependentVariables.push_back(
+                boost::make_shared< SingleAccelerationDependentVariableSaveSettings >(
+                    central_gravity, "Apollo", "Earth", 0 ) );
+    dependentVariables.push_back(
+                boost::make_shared< SingleDependentVariableSaveSettings >(
+                    total_acceleration_dependent_variable, "Apollo" ) );
+    dependentVariables.push_back(
+                boost::make_shared< SingleDependentVariableSaveSettings >(
+                    aerodynamic_moment_coefficients_dependent_variable, "Apollo" ) );
+
+    // Create acceleration models and propagation settings.
+    basic_astrodynamics::AccelerationMap accelerationModelMap = createAccelerationModelsMap(
+                bodyMap, accelerationMap, bodiesToPropagate, centralBodies );
+
+    setTrimmedConditions( bodyMap.at( "Apollo" )->getFlightConditions( ) );
+
+    boost::shared_ptr< TranslationalStatePropagatorSettings< double > > propagatorSettings =
+            boost::make_shared< TranslationalStatePropagatorSettings< double > >
+            ( centralBodies, accelerationModelMap, bodiesToPropagate, systemInitialState,
+              boost::make_shared< propagators::PropagationTimeTerminationSettings >( 3200.0 ), cowell,
+              boost::make_shared< DependentVariableSaveSettings >( dependentVariables ) );
+    boost::shared_ptr< IntegratorSettings< > > integratorSettings =
+            boost::make_shared< IntegratorSettings< > >
+            ( rungeKutta4, simulationStartEpoch, fixedStepSize );
+
+    // Create simulation object and propagate dynamics.
+    SingleArcDynamicsSimulator< > dynamicsSimulator(
+                bodyMap, integratorSettings, propagatorSettings, true, false, false );
+
+    // Retrieve numerical solutions for state and dependent variables
+    std::map< double, Eigen::Matrix< double, Eigen::Dynamic, 1 > > numericalSolution =
+            dynamicsSimulator.getEquationsOfMotionNumericalSolution( );
+    std::map< double, Eigen::VectorXd > dependentVariableSoution =
+            dynamicsSimulator.getDependentVariableHistory( );
+
+    // Iterate over results for dependent variables, and check against manually retrieved values.
+    basic_mathematics::Vector6d currentStateDerivative;
+    Eigen::Vector3d manualCentralGravity;
+    for( std::map< double, Eigen::VectorXd >::iterator variableIterator = dependentVariableSoution.begin( );
+         variableIterator != dependentVariableSoution.end( ); variableIterator++ )
+    {
+        currentStateDerivative = dynamicsSimulator.getDynamicsStateDerivative( )->computeStateDerivative(
+                    variableIterator->first, numericalSolution.at( variableIterator->first ) );
+
+        // Manually compute central gravity.
+        manualCentralGravity =
+                -bodyMap.at( "Earth" )->getGravityFieldModel( )->getGravitationalParameter( ) *
+                variableIterator->second.segment( 5, 3 ) /
+                std::pow( variableIterator->second.segment( 5, 3 ).norm( ), 3 );
+
+        // Check output time consistency
+        BOOST_CHECK_EQUAL( numericalSolution.count( variableIterator->first ), 1 );
+
+        // Check relative position and velocity against state
+        for( unsigned int i = 0; i < 3; i++ )
+        {
+            BOOST_CHECK_SMALL(
+                        std::fabs( numericalSolution.at( variableIterator->first )( i ) -
+                                   variableIterator->second( 5 + i ) ), 2.0E-5 );
+            BOOST_CHECK_SMALL(
+                        std::fabs( numericalSolution.at( variableIterator->first )( 3 + i ) -
+                                   variableIterator->second( 8 + i ) ), 5.0E-11 );
+        }
+
+        // Check central gravity acceleration
+        TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                    manualCentralGravity.segment( 0, 3 ),
+                    variableIterator->second.segment( 11, 3 ), ( 5.0 * std::numeric_limits< double >::epsilon( ) ) );
+
+        // Check total acceleration (tolerance is not epsilon due to numerical root finding for trim)
+        for( unsigned int i = 0; i < 3; i++ )
+        {
+            BOOST_CHECK_SMALL(
+                        std::fabs( currentStateDerivative( 3 + i ) -
+                                   variableIterator->second( 14 + i ) ), 1.0E-13 );
+        }
+
+        // Check relative position and velocity norm.
+        BOOST_CHECK_SMALL(
+                    std::fabs( ( numericalSolution.at( variableIterator->first ).segment( 0, 3 ) ).norm( ) -
+                               variableIterator->second( 2 ) ), 2.0E-5 );
+        BOOST_CHECK_SMALL(
+                    std::fabs( ( numericalSolution.at( variableIterator->first ).segment( 3, 3 ) ).norm( ) -
+                               variableIterator->second( 3 ) ), 2.0E-11 );
+
+        // Check central gravity acceleration norm
+        BOOST_CHECK_CLOSE_FRACTION(
+                    manualCentralGravity.norm( ),
+                    variableIterator->second( 4 ), 5.0 * std::numeric_limits< double >::epsilon( ) );
+
+        // Check Mach number
+        BOOST_CHECK_CLOSE_FRACTION(
+                    bodyMap.at( "Apollo" )->getFlightConditions( )->getCurrentAirspeed( ) /
+                    bodyMap.at( "Apollo" )->getFlightConditions( )->getCurrentSpeedOfSound( ),
+                    variableIterator->second( 0 ), std::numeric_limits< double >::epsilon( ) );
+
+        // Check altitude.
+        BOOST_CHECK_CLOSE_FRACTION(
+                    bodyMap.at( "Apollo" )->getFlightConditions( )->getCurrentAltitude( ),
+                    variableIterator->second( 1 ), std::numeric_limits< double >::epsilon( ) );
+
+        // Check trimmed condition (y-term)/symmetric vehicle shape (x- and z-term).
+        BOOST_CHECK_SMALL(
+                    std::fabs( variableIterator->second( 17 ) ), 1.0E-14 );
+        BOOST_CHECK_SMALL(
+                    std::fabs( variableIterator->second( 18 ) ), 1.0E-10 );
+        BOOST_CHECK_SMALL(
+                    std::fabs( variableIterator->second( 19 ) ), 1.0E-14 );
+
+
+    }
+
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+
+}
+
+}
+
+
diff --git a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestEnckeStateDerivative.cpp b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestEnckeStateDerivative.cpp
new file mode 100644
index 0000000..ac02036
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestEnckeStateDerivative.cpp
@@ -0,0 +1,438 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#define BOOST_TEST_MAIN
+
+#include <limits>
+#include <string>
+#include <thread>
+#include <omp.h>
+
+#include <boost/make_shared.hpp>
+#include <boost/format.hpp>
+#include <boost/test/unit_test.hpp>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/unitConversions.h"
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebra.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h"
+
+#include "Tudat/External/SpiceInterface/spiceInterface.h"
+#include "Tudat/Mathematics/NumericalIntegrators/rungeKuttaCoefficients.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
+#include "Tudat/InputOutput/basicInputOutput.h"
+#include "Tudat/Astrodynamics/Propagators/dynamicsSimulator.h"
+#include "Tudat/SimulationSetup/defaultBodies.h"
+#include "Tudat/SimulationSetup/createBodies.h"
+#include "Tudat/SimulationSetup/createAccelerationModels.h"
+#include "Tudat/Mathematics/NumericalIntegrators/createNumericalIntegrator.h"
+
+namespace tudat
+{
+namespace unit_tests
+{
+
+BOOST_AUTO_TEST_SUITE( test_encke_propagator )
+
+// Test Encke propagator for point mass central body.
+BOOST_AUTO_TEST_CASE( testEnckePopagatorForPointMassCentralBodies )
+{
+    // Test simulation for different central body cases
+    for( unsigned int simulationCase = 0; simulationCase < 2; simulationCase++ )
+    {
+        //Using declarations.
+        using namespace tudat::interpolators;
+        using namespace tudat::numerical_integrators;
+        using namespace tudat::spice_interface;
+        using namespace tudat::simulation_setup;
+        using namespace tudat::basic_astrodynamics;
+        using namespace tudat::orbital_element_conversions;
+        using namespace tudat::propagators;
+
+
+        //Load spice kernels.
+        std::string kernelsPath = input_output::getSpiceKernelPath( );
+        spice_interface::loadSpiceKernelInTudat( kernelsPath + "de-403-masses.tpc");
+        spice_interface::loadSpiceKernelInTudat( kernelsPath + "naif0009.tls");
+        spice_interface::loadSpiceKernelInTudat( kernelsPath + "pck00009.tpc");
+        spice_interface::loadSpiceKernelInTudat( kernelsPath + "de421.bsp");
+
+        // Define bodies in simulation.
+        unsigned int totalNumberOfBodies = 7;
+        std::vector< std::string > bodyNames;
+        bodyNames.resize( totalNumberOfBodies );
+        bodyNames[ 0 ] = "Earth";
+        bodyNames[ 1 ] = "Mars";
+        bodyNames[ 2 ] = "Sun";
+        bodyNames[ 3 ] = "Venus";
+        bodyNames[ 4 ] = "Moon";
+        bodyNames[ 5 ] = "Mercury";
+        bodyNames[ 6 ] = "Jupiter";
+
+        double initialEphemerisTime = 1.0E7;
+        double finalEphemerisTime = 2.0E7;
+        double maximumTimeStep = 3600.0;
+        double buffer = 5.0 * maximumTimeStep;
+
+        // Create bodies needed in simulation
+        NamedBodyMap bodyMap = createBodies(
+                    getDefaultBodySettings( bodyNames, initialEphemerisTime - buffer, finalEphemerisTime + buffer ) );
+        setGlobalFrameBodyEphemerides( bodyMap, "SSB", "ECLIPJ2000" );
+
+        // Set accelerations between bodies that are to be taken into account.
+        SelectedAccelerationMap accelerationMap;
+        std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfEarth;
+        accelerationsOfEarth[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationsOfEarth[ "Moon" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationsOfEarth[ "Jupiter" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationMap[ "Earth" ] = accelerationsOfEarth;
+
+        std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfMars;
+        accelerationsOfMars[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationsOfMars[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationsOfMars[ "Jupiter" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationMap[ "Mars" ] = accelerationsOfMars;
+
+        std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfMoon;
+        accelerationsOfMoon[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationsOfMoon[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationsOfMoon[ "Jupiter" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationMap[ "Moon" ] = accelerationsOfMoon;
+
+        // Propagate Earth, Mars and Moon
+        std::vector< std::string > bodiesToPropagate;
+        bodiesToPropagate.push_back( "Earth" );
+        bodiesToPropagate.push_back( "Mars" );
+        bodiesToPropagate.push_back( "Moon" );
+
+        unsigned int numberOfNumericalBodies = bodiesToPropagate.size( );
+
+        // Define central bodies: all Sun for simulationCase = 0, Earth and Mars: Sun, Moon: Earth for simulationCase = 1
+        std::vector< std::string > centralBodies;
+        std::map< std::string, std::string > centralBodyMap;
+        centralBodies.resize( numberOfNumericalBodies );
+        for( int i = 0; i < 3; i++ )
+        {
+            if( i == 2 && simulationCase == 1 )
+            {
+                centralBodies[ i ] = "Earth";
+            }
+            else
+            {
+                centralBodies[ i ] = "Sun";
+            }
+            centralBodyMap[ bodiesToPropagate[ i ] ] = centralBodies[ i ];
+        }
+
+
+        // Get initial states for bodies.
+        Eigen::VectorXd systemInitialState = Eigen::VectorXd( bodiesToPropagate.size( ) * 6 );
+        for( unsigned int i = 0; i < numberOfNumericalBodies ; i++ )
+        {
+            systemInitialState.segment( i * 6 , 6 ) =
+                    bodyMap[ bodiesToPropagate[ i ] ]->getStateInBaseFrameFromEphemeris( initialEphemerisTime ) -
+                    bodyMap[ centralBodies[ i ] ]->getStateInBaseFrameFromEphemeris( initialEphemerisTime );
+        }
+
+        // Create acceleratiuon models.
+        AccelerationMap accelerationModelMap = createAccelerationModelsMap(
+                    bodyMap, accelerationMap, centralBodyMap );
+
+        // Create integrator settings.
+        boost::shared_ptr< IntegratorSettings< > > integratorSettings =
+                boost::make_shared< IntegratorSettings< > >
+                ( rungeKutta4,
+                  initialEphemerisTime, 250.0 );
+
+        // Create propagation settings (Cowell)
+        boost::shared_ptr< TranslationalStatePropagatorSettings< double > > propagatorSettings =
+                boost::make_shared< TranslationalStatePropagatorSettings< double > >
+                ( centralBodies, accelerationModelMap, bodiesToPropagate, systemInitialState, finalEphemerisTime );
+
+        // Propagate orbit with Cowell method
+        SingleArcDynamicsSimulator< double > dynamicsSimulator2(
+                    bodyMap, integratorSettings, propagatorSettings, true );
+
+        // Define ephemeris interrogation settings.
+        double initialTestTime = initialEphemerisTime + 10.0 * maximumTimeStep;
+        double finalTestTime = finalEphemerisTime - 10.0 * maximumTimeStep;
+        double testTimeStep = 1.0E4;
+
+        // Get resutls of Cowell integration at given times.
+        double currentTestTime = initialTestTime;
+        std::map< double, Eigen::Matrix< double, 18, 1 > > cowellIntegrationResults;
+        while( currentTestTime < finalTestTime )
+        {
+            cowellIntegrationResults[ currentTestTime ].segment( 0, 6 ) =
+                    bodyMap[ "Earth" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
+            cowellIntegrationResults[ currentTestTime ].segment( 6, 6 ) =
+                    bodyMap[ "Mars" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
+            cowellIntegrationResults[ currentTestTime ].segment( 12, 6 ) =
+                    bodyMap[ "Moon" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
+
+            currentTestTime += testTimeStep;
+        }
+
+        // Create propagation settings (Encke)
+        propagatorSettings = boost::make_shared< TranslationalStatePropagatorSettings< double > >
+                ( centralBodies, accelerationModelMap, bodiesToPropagate, systemInitialState, finalEphemerisTime, encke );
+
+        // Propagate orbit with Encke method
+        SingleArcDynamicsSimulator< double > dynamicsSimulator(
+                    bodyMap, integratorSettings, propagatorSettings, true );
+
+        // Get resutls of Encke integration at given times.
+        currentTestTime = initialTestTime;
+        std::map< double, Eigen::Matrix< double, 18, 1 > > enckeIntegrationResults;
+        while( currentTestTime < finalTestTime )
+        {
+            enckeIntegrationResults[ currentTestTime ].segment( 0, 6 ) =
+                    bodyMap[ "Earth" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
+            enckeIntegrationResults[ currentTestTime ].segment( 6, 6 ) =
+                    bodyMap[ "Mars" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
+            enckeIntegrationResults[ currentTestTime ].segment( 12, 6 ) =
+                    bodyMap[ "Moon" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
+            currentTestTime += testTimeStep;
+        }
+
+        // Compare results of Cowell and Encke propagations
+        std::map< double, Eigen::Matrix< double, 18, 1 > >::iterator enckeIterator = enckeIntegrationResults.begin( );
+        std::map< double, Eigen::Matrix< double, 18, 1 > >::iterator cowellIterator = cowellIntegrationResults.begin( );
+        for( unsigned int i = 0; i < enckeIntegrationResults.size( ); i++ )
+        {
+            for( int j= 0; j< 3; j++ )
+            {
+                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 0.01 );
+            }
+
+            for( int j = 6; j < 9; j++ )
+            {
+                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 0.01 );
+            }
+
+            for( int j = 12; j < 15; j++ )
+            {
+                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 0.075 );
+            }
+
+            for( int j = 3; j < 6; j++ )
+            {
+                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 1.0E-8 );
+            }
+
+            for( int j = 9; j < 12; j++ )
+            {
+                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 1.0E-8 );
+
+            }
+
+            for( int j = 15; j < 18; j++ )
+            {
+                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 1.0E-6 );
+
+            }
+            enckeIterator++;
+            cowellIterator++;
+        }
+    }
+}
+
+// Test Encke propagator for point mass, and spherical harmonics central body.
+BOOST_AUTO_TEST_CASE( testEnckePopagatorForSphericalHarmonicCentralBodies )
+{
+    for( unsigned int simulationCase = 0; simulationCase < 4; simulationCase++ )
+    {
+        using namespace tudat;
+        using namespace simulation_setup;
+        using namespace propagators;
+        using namespace numerical_integrators;
+        using namespace orbital_element_conversions;
+        using namespace basic_mathematics;
+        using namespace gravitation;
+        using namespace numerical_integrators;
+
+        // Load Spice kernels.
+        spice_interface::loadSpiceKernelInTudat( input_output::getSpiceKernelPath( ) + "pck00009.tpc" );
+        spice_interface::loadSpiceKernelInTudat( input_output::getSpiceKernelPath( ) + "de-403-masses.tpc" );
+        spice_interface::loadSpiceKernelInTudat( input_output::getSpiceKernelPath( ) + "de421.bsp" );
+
+        // Set simulation time settings.
+        const double simulationStartEpoch = 0.0;
+        const double simulationEndEpoch = tudat::physical_constants::JULIAN_DAY;
+
+        // Define body settings for simulation.
+        std::vector< std::string > bodiesToCreate;
+        bodiesToCreate.push_back( "Sun" );
+        bodiesToCreate.push_back( "Earth" );
+        bodiesToCreate.push_back( "Moon" );
+        bodiesToCreate.push_back( "Mars" );
+        bodiesToCreate.push_back( "Venus" );
+
+        // Create body objects.
+        std::map< std::string, boost::shared_ptr< BodySettings > > bodySettings =
+                getDefaultBodySettings( bodiesToCreate, simulationStartEpoch - 300.0, simulationEndEpoch + 300.0 );
+        for( unsigned int i = 0; i < bodiesToCreate.size( ); i++ )
+        {
+            bodySettings[ bodiesToCreate.at( i ) ]->ephemerisSettings->resetFrameOrientation( "J2000" );
+            bodySettings[ bodiesToCreate.at( i ) ]->rotationModelSettings->resetOriginalFrame( "J2000" );
+        }
+        NamedBodyMap bodyMap = createBodies( bodySettings );
+
+        // Create spacecraft object.
+        bodyMap[ "Vehicle" ] = boost::make_shared< simulation_setup::Body >( );
+        bodyMap[ "Vehicle" ]->setConstantBodyMass( 400.0 );
+        bodyMap[ "Vehicle" ]->setEphemeris( boost::make_shared< ephemerides::TabulatedCartesianEphemeris< > >(
+                                                boost::shared_ptr< interpolators::OneDimensionalInterpolator
+                                                < double, Vector6d  > >( ), "Earth", "J2000" ) );
+        boost::shared_ptr< RadiationPressureInterfaceSettings > vehicleRadiationPressureSettings =
+                boost::make_shared< CannonBallRadiationPressureInterfaceSettings >(
+                    "Sun", 4.0, 1.2, boost::assign::list_of( "Earth" )( "Moon" ) );
+        bodyMap[ "Vehicle" ]->setRadiationPressureInterface(
+                    "Sun", createRadiationPressureInterface(
+                        vehicleRadiationPressureSettings, "Vehicle", bodyMap ) );
+
+
+        // Finalize body creation.
+        setGlobalFrameBodyEphemerides( bodyMap, "SSB", "J2000" );
+
+        // Define propagator settings variables.
+        SelectedAccelerationMap accelerationMap;
+        std::vector< std::string > bodiesToPropagate;
+        std::vector< std::string > centralBodies;
+
+        // Define propagation settings.
+        std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfVehicle;
+
+        // Use only central gravity for Earth
+        if( simulationCase < 2 )
+        {
+            accelerationsOfVehicle[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >(
+                                                             basic_astrodynamics::central_gravity ) );
+        }
+        // Use spherical harmonics for Earth
+        else
+        {
+            accelerationsOfVehicle[ "Earth" ].push_back(
+                        boost::make_shared< SphericalHarmonicAccelerationSettings >( 5, 5 ) );
+
+        }
+
+        // Use perturbations other than Earth gravity
+        if( simulationCase % 2 == 0 )
+        {
+            accelerationsOfVehicle[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >(
+                                                           basic_astrodynamics::central_gravity ) );
+            accelerationsOfVehicle[ "Moon" ].push_back( boost::make_shared< AccelerationSettings >(
+                                                            basic_astrodynamics::central_gravity ) );
+            accelerationsOfVehicle[ "Mars" ].push_back( boost::make_shared< AccelerationSettings >(
+                                                            basic_astrodynamics::central_gravity ) );
+            accelerationsOfVehicle[ "Venus" ].push_back( boost::make_shared< AccelerationSettings >(
+                                                             basic_astrodynamics::central_gravity ) );
+            accelerationsOfVehicle[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >(
+                                                           basic_astrodynamics::cannon_ball_radiation_pressure ) );
+        }
+        accelerationMap[  "Vehicle" ] = accelerationsOfVehicle;
+        bodiesToPropagate.push_back( "Vehicle" );
+        centralBodies.push_back( "Earth" );
+        basic_astrodynamics::AccelerationMap accelerationModelMap = createAccelerationModelsMap(
+                    bodyMap, accelerationMap, bodiesToPropagate, centralBodies );
+
+        // Set Keplerian elements for Vehicle.
+        Vector6d vehicleInitialStateInKeplerianElements;
+        vehicleInitialStateInKeplerianElements( semiMajorAxisIndex ) = 8000.0E3;
+        vehicleInitialStateInKeplerianElements( eccentricityIndex ) = 0.1;
+        vehicleInitialStateInKeplerianElements( inclinationIndex ) = unit_conversions::convertDegreesToRadians( 85.3 );
+        vehicleInitialStateInKeplerianElements( argumentOfPeriapsisIndex )
+                = unit_conversions::convertDegreesToRadians( 235.7 );
+        vehicleInitialStateInKeplerianElements( longitudeOfAscendingNodeIndex )
+                = unit_conversions::convertDegreesToRadians( 23.4 );
+        vehicleInitialStateInKeplerianElements( trueAnomalyIndex ) = unit_conversions::convertDegreesToRadians( 139.87 );
+
+        double earthGravitationalParameter = bodyMap.at( "Earth" )->getGravityFieldModel( )->getGravitationalParameter( );
+        const Vector6d vehicleInitialState = convertKeplerianToCartesianElements(
+                    vehicleInitialStateInKeplerianElements, earthGravitationalParameter );
+
+        // Define propagator settings (Cowell)
+        boost::shared_ptr< TranslationalStatePropagatorSettings< double > > propagatorSettings =
+                boost::make_shared< TranslationalStatePropagatorSettings< double > >
+                ( centralBodies, accelerationModelMap, bodiesToPropagate, vehicleInitialState, simulationEndEpoch );
+
+        // Define integrator settings.
+        const double fixedStepSize = 5.0;
+        boost::shared_ptr< IntegratorSettings< > > integratorSettings =
+                boost::make_shared< IntegratorSettings< > >
+                ( rungeKutta4, 0.0, fixedStepSize );
+
+        // Propagate orbit with Cowell method
+        SingleArcDynamicsSimulator< double > dynamicsSimulator2(
+                    bodyMap, integratorSettings, propagatorSettings, true );
+
+        // Define ephemeris interrogation settings.
+        double initialTestTime = simulationStartEpoch + 10.0 * fixedStepSize;
+        double finalTestTime = simulationEndEpoch - 10.0 * fixedStepSize;
+        double testTimeStep = 1.0E4;
+
+        // Get resutls of Cowell integration at given times.
+        double currentTestTime = initialTestTime;
+        std::map< double, Eigen::Matrix< double, 6, 1 > > cowellIntegrationResults;
+        while( currentTestTime < finalTestTime )
+        {
+            cowellIntegrationResults[ currentTestTime ].segment( 0, 6 ) =
+                    bodyMap[ "Vehicle" ]->getEphemeris( )->getCartesianStateFromEphemeris( currentTestTime );
+
+            currentTestTime += testTimeStep;
+        }
+
+        // Create propagation settings (Encke)
+        propagatorSettings = boost::make_shared< TranslationalStatePropagatorSettings< double > >
+                ( centralBodies, accelerationModelMap, bodiesToPropagate, vehicleInitialState, simulationEndEpoch, encke );
+
+        // Propagate orbit with Encke method
+        SingleArcDynamicsSimulator< double > dynamicsSimulator(
+                    bodyMap, integratorSettings, propagatorSettings, true );
+
+        // Get resutls of Encke integration at given times.
+        currentTestTime = initialTestTime;
+        std::map< double, Eigen::Matrix< double, 6, 1 > > enckeIntegrationResults;
+        while( currentTestTime < finalTestTime )
+        {
+            enckeIntegrationResults[ currentTestTime ].segment( 0, 6 ) =
+                    bodyMap[ "Vehicle" ]->getEphemeris( )->getCartesianStateFromEphemeris( currentTestTime );
+            currentTestTime += testTimeStep;
+        }
+
+        // Compare results of Cowell and Encke propagations
+        std::map< double, Eigen::Matrix< double, 6, 1 > >::iterator enckeIterator = enckeIntegrationResults.begin( );
+        std::map< double, Eigen::Matrix< double, 6, 1 > >::iterator cowellIterator = cowellIntegrationResults.begin( );
+        for( unsigned int i = 0; i < enckeIntegrationResults.size( ); i++ )
+        {
+            for( int j= 0; j< 3; j++ )
+            {
+                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second )( j ), 0.02 );
+            }
+
+            for( int j = 3; j < 6; j++ )
+            {
+                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second )( j ), 1.0E-5 );
+
+            }
+            enckeIterator++;
+            cowellIterator++;
+        }
+    }
+}
+BOOST_AUTO_TEST_SUITE_END( )
+
+
+}
+
+}
+
+
diff --git a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestEnvironmentUpdater.cpp b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestEnvironmentUpdater.cpp
index 527726b..3630f51 100644
--- a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestEnvironmentUpdater.cpp
+++ b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestEnvironmentUpdater.cpp
@@ -52,6 +52,7 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
 {
 
     double initialTime = 86400.0;
+    double finalTime = 2.0 * 86400.0;
 
     // Load Spice kernels
     const std::string kernelsPath = input_output::getSpiceKernelPath( );
@@ -90,9 +91,9 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
               3.088038821491940e-7, 0.0, 0.0, -9.436980733957690e-8, -3.233531925405220e-7,
               -2.149554083060460e-7, 4.980705501023510e-8, -6.693799351801650e-7
               ).finished( );
-    bodySettings[ "Earth" ]->gravityFieldSettings
-        = boost::make_shared< SphericalHarmonicsGravityFieldSettings >(
-            gravitationalParameter, 6378.0E3, cosineCoefficients, sineCoefficients, "IAU_Earth" );
+    bodySettings[ "Earth" ]->gravityFieldSettings = boost::make_shared< SphericalHarmonicsGravityFieldSettings >(
+                gravitationalParameter, 6378.0E3, cosineCoefficients, sineCoefficients,
+                "IAU_Earth" );
 
     // Create bodies
     NamedBodyMap bodyMap = createBodies( bodySettings );
@@ -100,17 +101,17 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
 
     // Define variables used in tests.
     SelectedAccelerationMap accelerationSettingsMap;
+    std::map< std::string, std::string > centralBodies;
     std::vector< std::string > propagatedBodyList;
     std::vector< std::string > centralBodyList;
 
-    std::map< IntegratedStateType, Eigen::VectorXd > integratedStateToSet;
+    std::unordered_map< IntegratedStateType, Eigen::VectorXd > integratedStateToSet;
     double testTime = 0.0;
 
     {
 
         // Define (arbitrary) test state.
-        Eigen::VectorXd testState = ( Eigen::VectorXd( 6 ) << 1.44E6, 2.234E8, -3343.246E7,
-                                                               1.2E4, 1.344E3, -22.343E3 ).finished( );
+        Eigen::VectorXd testState = ( Eigen::VectorXd( 6 ) << 1.44E6, 2.234E8, -3343.246E7, 1.2E4, 1.344E3, -22.343E3 ).finished( );
         integratedStateToSet[ transational_state ] = testState;
         testTime = 2.0 * 86400.0;
 
@@ -123,18 +124,19 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
                         boost::make_shared< AccelerationSettings >( central_gravity ) );
 
             // Define origin of integration to be barycenter.
+            centralBodies[ "Moon" ] = "SSB";
             propagatedBodyList.push_back( "Moon" );
-            centralBodyList.push_back( "SSB" );
+            centralBodyList.push_back( centralBodies[ "Moon" ] );
 
             // Create accelerations
             AccelerationMap accelerationsMap = createAccelerationModelsMap(
-                        bodyMap, accelerationSettingsMap, propagatedBodyList, centralBodyList );
+                        bodyMap, accelerationSettingsMap, centralBodies );
 
             // Create environment update settings.
             boost::shared_ptr< PropagatorSettings< double > > propagatorSettings =
                     boost::make_shared< TranslationalStatePropagatorSettings< double > >(
                         centralBodyList, accelerationsMap, propagatedBodyList, getInitialStateOfBody(
-                            "Moon", centralBodyList.at( 0 ), bodyMap, initialTime ) );
+                            "Moon", centralBodies[ "Moon" ], bodyMap, initialTime ), finalTime );
             std::map< propagators::EnvironmentModelsToUpdate, std::vector< std::string > > environmentModelsToUpdate =
                     createEnvironmentUpdaterSettings< double >( propagatorSettings, bodyMap );
 
@@ -143,7 +145,6 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
             BOOST_CHECK_EQUAL( environmentModelsToUpdate.count( body_transational_state_update ), 1 );
             BOOST_CHECK_EQUAL( environmentModelsToUpdate.at( body_transational_state_update ).size( ), 2 );
 
-
             // Create and call updater.
             boost::shared_ptr< propagators::EnvironmentUpdater< double, double > > updater =
                     createEnvironmentUpdaterForDynamicalEquations< double, double >(
@@ -153,13 +154,11 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
             // Test if Earth, Sun and Moon are updated
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Earth" )->getState( ),
-                        bodyMap.at( "Earth" )->getEphemeris( )->
-                        getCartesianStateFromEphemeris( testTime ),
+                        bodyMap.at( "Earth" )->getEphemeris( )->getCartesianStateFromEphemeris( testTime ),
                         std::numeric_limits< double >::epsilon( ) );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Sun" )->getState( ),
-                        bodyMap.at( "Sun" )->getEphemeris( )->
-                        getCartesianStateFromEphemeris( testTime ),
+                        bodyMap.at( "Sun" )->getEphemeris( )->getCartesianStateFromEphemeris( testTime ),
                         std::numeric_limits< double >::epsilon( ) );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Moon" )->getState( ), testState,
@@ -172,22 +171,19 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
 
             // Update environment to new time, and state from environment.
             updater->updateEnvironment(
-                        0.5 * testTime, std::map< IntegratedStateType, Eigen::VectorXd >( ),
+                        0.5 * testTime, std::unordered_map< IntegratedStateType, Eigen::VectorXd >( ),
                         boost::assign::list_of( transational_state ) );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Earth" )->getState( ),
-                        bodyMap.at( "Earth" )->getEphemeris( )->
-                        getCartesianStateFromEphemeris( 0.5 * testTime ),
+                        bodyMap.at( "Earth" )->getEphemeris( )->getCartesianStateFromEphemeris( 0.5 * testTime ),
                         std::numeric_limits< double >::epsilon( ) );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Sun" )->getState( ),
-                        bodyMap.at( "Sun" )->getEphemeris( )->
-                        getCartesianStateFromEphemeris( 0.5 * testTime ),
+                        bodyMap.at( "Sun" )->getEphemeris( )->getCartesianStateFromEphemeris( 0.5 * testTime ),
                         std::numeric_limits< double >::epsilon( ) );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Moon" )->getState( ),
-                        bodyMap.at( "Moon" )->getEphemeris( )->
-                        getCartesianStateFromEphemeris( 0.5 * testTime ),
+                        bodyMap.at( "Moon" )->getEphemeris( )->getCartesianStateFromEphemeris( 0.5 * testTime ),
                         std::numeric_limits< double >::epsilon( ) );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Mars" )->getState( ), basic_mathematics::Vector6d::Zero( ),
@@ -197,6 +193,7 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
         // Test third body acceleration updates.
         {
             accelerationSettingsMap.clear( );
+            centralBodies.clear( );
             propagatedBodyList.clear( );
             centralBodyList.clear( );
 
@@ -207,25 +204,26 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
                         boost::make_shared< AccelerationSettings >( central_gravity ) );
 
             // Define origin of integration
+            centralBodies[ "Moon" ] = "Earth";
             propagatedBodyList.push_back( "Moon" );
-            centralBodyList.push_back( "Earth");
+            centralBodyList.push_back( centralBodies[ "Moon" ] );
 
             // Create accelerations
             AccelerationMap accelerationsMap = createAccelerationModelsMap(
-                        bodyMap, accelerationSettingsMap, propagatedBodyList, centralBodyList );
+                        bodyMap, accelerationSettingsMap, centralBodies );
 
             // Create environment update settings.
             boost::shared_ptr< PropagatorSettings< double > > propagatorSettings =
                     boost::make_shared< TranslationalStatePropagatorSettings< double > >(
                         centralBodyList, accelerationsMap, propagatedBodyList, getInitialStateOfBody(
-                            "Moon", centralBodyList.at( 0 ), bodyMap, initialTime ) );
+                            "Moon", centralBodies[ "Moon" ], bodyMap, initialTime ), finalTime );
             std::map< propagators::EnvironmentModelsToUpdate, std::vector< std::string > > environmentModelsToUpdate =
                     createEnvironmentUpdaterSettings< double >( propagatorSettings, bodyMap );
 
             // Test update settings
             BOOST_CHECK_EQUAL( environmentModelsToUpdate.size( ), 1 );
             BOOST_CHECK_EQUAL( environmentModelsToUpdate.count( body_transational_state_update ), 1 );
-            BOOST_CHECK_EQUAL( environmentModelsToUpdate.at( body_transational_state_update ).size( ), 3     );
+            BOOST_CHECK_EQUAL( environmentModelsToUpdate.at( body_transational_state_update ).size( ), 3 );
 
             // Create and call updater.
             boost::shared_ptr< propagators::EnvironmentUpdater< double, double > > updater =
@@ -236,21 +234,18 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
             // Test if Earth, Sun, Mars and Moon are updated
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Earth" )->getState( ),
-                        bodyMap.at( "Earth" )->getEphemeris( )->
-                        getCartesianStateFromEphemeris( testTime ),
+                        bodyMap.at( "Earth" )->getEphemeris( )->getCartesianStateFromEphemeris( testTime ),
                         std::numeric_limits< double >::epsilon( ) );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Sun" )->getState( ),
-                        bodyMap.at( "Sun" )->getEphemeris( )->
-                        getCartesianStateFromEphemeris( testTime ),
+                        bodyMap.at( "Sun" )->getEphemeris( )->getCartesianStateFromEphemeris( testTime ),
                         std::numeric_limits< double >::epsilon( ) );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Moon" )->getState( ), testState,
                         std::numeric_limits< double >::epsilon( ) );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Mars" )->getState( ),
-                        bodyMap.at( "Mars" )->getEphemeris( )->
-                        getCartesianStateFromEphemeris( testTime ),
+                        bodyMap.at( "Mars" )->getEphemeris( )->getCartesianStateFromEphemeris( testTime ),
                         std::numeric_limits< double >::epsilon( ) );
 
             // Test if Venus is not updated
@@ -260,7 +255,7 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
 
             // Update environment to new time, and state from environment.
             updater->updateEnvironment(
-                        0.5 * testTime, std::map< IntegratedStateType, Eigen::VectorXd >( ),
+                        0.5 * testTime, std::unordered_map< IntegratedStateType, Eigen::VectorXd >( ),
                         boost::assign::list_of( transational_state ) );
 
         }
@@ -268,6 +263,7 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
         // Test spherical harmonic acceleration update
         {
             accelerationSettingsMap.clear( );
+            centralBodies.clear( );
             propagatedBodyList.clear( );
             centralBodyList.clear( );
 
@@ -280,17 +276,19 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
                         boost::make_shared< AccelerationSettings >( central_gravity ) );
 
             // Define origin of integration
+            centralBodies[ "Moon" ] = "Earth";
             propagatedBodyList.push_back( "Moon" );
-            centralBodyList.push_back( "Earth" );
+            centralBodyList.push_back( centralBodies[ "Moon" ] );
+
             // Create accelerations
             AccelerationMap accelerationsMap = createAccelerationModelsMap(
-                        bodyMap, accelerationSettingsMap, propagatedBodyList, centralBodyList );
+                        bodyMap, accelerationSettingsMap, centralBodies );
 
             // Create environment update settings.
             boost::shared_ptr< PropagatorSettings< double > > propagatorSettings =
                     boost::make_shared< TranslationalStatePropagatorSettings< double > >(
                         centralBodyList, accelerationsMap, propagatedBodyList, getInitialStateOfBody(
-                            "Moon", centralBodyList.at( 0 ), bodyMap, initialTime ) );
+                            "Moon", centralBodies[ "Moon" ], bodyMap, initialTime ), finalTime );
             std::map< propagators::EnvironmentModelsToUpdate, std::vector< std::string > > environmentModelsToUpdate =
                     createEnvironmentUpdaterSettings< double >( propagatorSettings, bodyMap );
 
@@ -311,21 +309,18 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
             // Test if Earth, Sun, Mars and Moon are updated
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Earth" )->getState( ),
-                        bodyMap.at( "Earth" )->getEphemeris( )->
-                        getCartesianStateFromEphemeris( testTime ),
+                        bodyMap.at( "Earth" )->getEphemeris( )->getCartesianStateFromEphemeris( testTime ),
                         std::numeric_limits< double >::epsilon( ) );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Sun" )->getState( ),
-                        bodyMap.at( "Sun" )->getEphemeris( )->
-                        getCartesianStateFromEphemeris( testTime ),
+                        bodyMap.at( "Sun" )->getEphemeris( )->getCartesianStateFromEphemeris( testTime ),
                         std::numeric_limits< double >::epsilon( ) );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Moon" )->getState( ), testState,
                         std::numeric_limits< double >::epsilon( ) );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Mars" )->getState( ),
-                        bodyMap.at( "Mars" )->getEphemeris( )->
-                        getCartesianStateFromEphemeris( testTime ),
+                        bodyMap.at( "Mars" )->getEphemeris( )->getCartesianStateFromEphemeris( testTime ),
                         std::numeric_limits< double >::epsilon( ) );
 
             // Test if Venus is not updated
@@ -336,23 +331,19 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
             // Test if Earth rotation is updated
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Earth" )->getCurrentRotationToGlobalFrame( ).toRotationMatrix( ),
-                        bodyMap.at( "Earth" )->getRotationalEphemeris( )->
-                        getRotationToBaseFrame( testTime ).toRotationMatrix( ),
+                        bodyMap.at( "Earth" )->getRotationalEphemeris( )->getRotationToBaseFrame( testTime ).toRotationMatrix( ),
                         std::numeric_limits< double >::epsilon( ) );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Earth" )->getCurrentRotationToLocalFrame( ).toRotationMatrix( ),
-                        bodyMap.at( "Earth" )->getRotationalEphemeris( )->
-                        getRotationToTargetFrame( testTime ).toRotationMatrix( ),
+                        bodyMap.at( "Earth" )->getRotationalEphemeris( )->getRotationToTargetFrame( testTime ).toRotationMatrix( ),
                         std::numeric_limits< double >::epsilon( ) );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Earth" )->getCurrentRotationMatrixDerivativeToGlobalFrame( ),
-                        bodyMap.at( "Earth" )->getRotationalEphemeris( )->
-                        getDerivativeOfRotationToBaseFrame( testTime ),
+                        bodyMap.at( "Earth" )->getRotationalEphemeris( )->getDerivativeOfRotationToBaseFrame( testTime ),
                         std::numeric_limits< double >::epsilon( ) );
             TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                         bodyMap.at( "Earth" )->getCurrentRotationMatrixDerivativeToLocalFrame( ),
-                        bodyMap.at( "Earth" )->getRotationalEphemeris( )->
-                        getDerivativeOfRotationToTargetFrame( testTime ),
+                        bodyMap.at( "Earth" )->getRotationalEphemeris( )->getDerivativeOfRotationToTargetFrame( testTime ),
                         std::numeric_limits< double >::epsilon( ) );
 
             // Test if Mars rotation is not updated
@@ -371,7 +362,7 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
 
             // Update environment to new time, and state from environment.
             updater->updateEnvironment(
-                        0.5 * testTime, std::map< IntegratedStateType, Eigen::VectorXd >( ),
+                        0.5 * testTime, std::unordered_map< IntegratedStateType, Eigen::VectorXd >( ),
                         boost::assign::list_of( transational_state ) );
 
         }
@@ -388,6 +379,7 @@ double getBodyMass( const double time )
 BOOST_AUTO_TEST_CASE( test_NonConservativeForceEnvironmentUpdate )
 {
     double initialTime = 86400.0;
+    double finalTime = 2.0 * 86400.0;
 
     using namespace tudat::simulation_setup;
     using namespace tudat;
@@ -424,10 +416,9 @@ BOOST_AUTO_TEST_CASE( test_NonConservativeForceEnvironmentUpdate )
 
     // Define test time and state.
     double testTime = 2.0 * 86400.0;
-    std::map< IntegratedStateType, Eigen::VectorXd > integratedStateToSet;
-    Eigen::VectorXd testState = 1.1 * bodyMap[ "Vehicle" ]->getEphemeris( )->
-                                getCartesianStateFromEphemeris( testTime )
-           + bodyMap.at( "Earth" )->getEphemeris( )->getCartesianStateFromEphemeris( testTime );
+    std::unordered_map< IntegratedStateType, Eigen::VectorXd > integratedStateToSet;
+    Eigen::VectorXd testState = 1.1 * bodyMap[ "Vehicle" ]->getEphemeris( )->getCartesianStateFromEphemeris( testTime ) +
+            bodyMap.at( "Earth" )->getEphemeris( )->getCartesianStateFromEphemeris( testTime );
     integratedStateToSet[ transational_state ] = testState;
 
     {
@@ -437,21 +428,22 @@ BOOST_AUTO_TEST_CASE( test_NonConservativeForceEnvironmentUpdate )
                     boost::make_shared< AccelerationSettings >( cannon_ball_radiation_pressure ) );
 
         // Define origin of integration
-
+        std::map< std::string, std::string > centralBodies;
+        centralBodies[ "Vehicle" ] = "Earth";
         std::vector< std::string > propagatedBodyList;
         propagatedBodyList.push_back( "Vehicle" );
         std::vector< std::string > centralBodyList;
-        centralBodyList.push_back( "Earth" );
+        centralBodyList.push_back( centralBodies[ "Vehicle" ] );
 
         // Create accelerations
         AccelerationMap accelerationsMap = createAccelerationModelsMap(
-                    bodyMap, accelerationSettingsMap, propagatedBodyList, centralBodyList );
+                    bodyMap, accelerationSettingsMap, centralBodies );
 
         // Create environment update settings.
         boost::shared_ptr< PropagatorSettings< double > > propagatorSettings =
                 boost::make_shared< TranslationalStatePropagatorSettings< double > >(
                     centralBodyList, accelerationsMap, propagatedBodyList, getInitialStateOfBody(
-                        "Vehicle", centralBodyList.at( 0 ), bodyMap, initialTime ) );
+                        "Vehicle", centralBodies[ "Vehicle" ], bodyMap, initialTime ), finalTime );
         std::map< propagators::EnvironmentModelsToUpdate, std::vector< std::string > > environmentModelsToUpdate =
                 createEnvironmentUpdaterSettings< double >( propagatorSettings, bodyMap );
 
@@ -484,10 +476,8 @@ BOOST_AUTO_TEST_CASE( test_NonConservativeForceEnvironmentUpdate )
 
 
         updater->updateEnvironment(
-                    0.5 * testTime, std::map< IntegratedStateType, Eigen::VectorXd >( ),
+                    0.5 * testTime, std::unordered_map< IntegratedStateType, Eigen::VectorXd >( ),
                     boost::assign::list_of( transational_state ) );
-
-
     }
 
     {
@@ -499,14 +489,16 @@ BOOST_AUTO_TEST_CASE( test_NonConservativeForceEnvironmentUpdate )
                     boost::make_shared< AccelerationSettings >( aerodynamic ) );
 
         // Define origin of integration
+        std::map< std::string, std::string > centralBodies;
+        centralBodies[ "Vehicle" ] = "Earth";
         std::vector< std::string > propagatedBodyList;
         propagatedBodyList.push_back( "Vehicle" );
         std::vector< std::string > centralBodyList;
-        centralBodyList.push_back( "Earth" );
+        centralBodyList.push_back( centralBodies[ "Vehicle" ] );
 
         // Create accelerations
         AccelerationMap accelerationsMap = createAccelerationModelsMap(
-                    bodyMap, accelerationSettingsMap, propagatedBodyList, centralBodyList );
+                    bodyMap, accelerationSettingsMap, centralBodies );
 
 
         // Define orientation angles.
@@ -523,7 +515,7 @@ BOOST_AUTO_TEST_CASE( test_NonConservativeForceEnvironmentUpdate )
         boost::shared_ptr< PropagatorSettings< double > > propagatorSettings =
                 boost::make_shared< TranslationalStatePropagatorSettings< double > >(
                     centralBodyList, accelerationsMap, propagatedBodyList, getInitialStateOfBody(
-                        "Vehicle", centralBodyList.at( 0 ), bodyMap, initialTime ) );
+                        "Vehicle", centralBodies[ "Vehicle" ], bodyMap, initialTime ), finalTime );
         std::map< propagators::EnvironmentModelsToUpdate, std::vector< std::string > > environmentModelsToUpdate =
                 createEnvironmentUpdaterSettings< double >( propagatorSettings, bodyMap );
 
@@ -536,11 +528,9 @@ BOOST_AUTO_TEST_CASE( test_NonConservativeForceEnvironmentUpdate )
         BOOST_CHECK_EQUAL( environmentModelsToUpdate.count( body_mass_update ), 1 );
         BOOST_CHECK_EQUAL( environmentModelsToUpdate.at( body_mass_update ).size( ), 1 );
         BOOST_CHECK_EQUAL( environmentModelsToUpdate.count( body_rotational_state_update ), 1 );
-        BOOST_CHECK_EQUAL( environmentModelsToUpdate.at(
-            body_rotational_state_update ).size( ), 1 );
+        BOOST_CHECK_EQUAL( environmentModelsToUpdate.at( body_rotational_state_update ).size( ), 1 );
         BOOST_CHECK_EQUAL( environmentModelsToUpdate.count( vehicle_flight_conditions_update ), 1 );
-        BOOST_CHECK_EQUAL( environmentModelsToUpdate.at(
-            vehicle_flight_conditions_update ).size( ), 1 );
+        BOOST_CHECK_EQUAL( environmentModelsToUpdate.at( vehicle_flight_conditions_update ).size( ), 1 );
 
         // Create and call updater.
         boost::shared_ptr< propagators::EnvironmentUpdater< double, double > > updater =
@@ -551,13 +541,11 @@ BOOST_AUTO_TEST_CASE( test_NonConservativeForceEnvironmentUpdate )
         // Test if Earth, Sun and Vehicle states are updated.
         TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                     bodyMap.at( "Earth" )->getState( ),
-                    bodyMap.at( "Earth" )->getEphemeris( )->
-                    getCartesianStateFromEphemeris( testTime ),
+                    bodyMap.at( "Earth" )->getEphemeris( )->getCartesianStateFromEphemeris( testTime ),
                     std::numeric_limits< double >::epsilon( ) );
         TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                     bodyMap.at( "Sun" )->getState( ),
-                    bodyMap.at( "Sun" )->getEphemeris( )->
-                    getCartesianStateFromEphemeris( testTime ),
+                    bodyMap.at( "Sun" )->getEphemeris( )->getCartesianStateFromEphemeris( testTime ),
                     std::numeric_limits< double >::epsilon( ) );
         TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                     bodyMap.at( "Vehicle" )->getState( ), testState,
@@ -566,13 +554,11 @@ BOOST_AUTO_TEST_CASE( test_NonConservativeForceEnvironmentUpdate )
         // Test if Earth rotation is updated.
         TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                     bodyMap.at( "Earth" )->getCurrentRotationToGlobalFrame( ).toRotationMatrix( ),
-                    bodyMap.at( "Earth" )->getRotationalEphemeris( )->
-                    getRotationToBaseFrame( testTime ).toRotationMatrix( ),
+                    bodyMap.at( "Earth" )->getRotationalEphemeris( )->getRotationToBaseFrame( testTime ).toRotationMatrix( ),
                     std::numeric_limits< double >::epsilon( ) );
         TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                     bodyMap.at( "Earth" )->getCurrentRotationToLocalFrame( ).toRotationMatrix( ),
-                    bodyMap.at( "Earth" )->getRotationalEphemeris( )->
-                    getRotationToTargetFrame( testTime ).toRotationMatrix( ),
+                    bodyMap.at( "Earth" )->getRotationalEphemeris( )->getRotationToTargetFrame( testTime ).toRotationMatrix( ),
                     std::numeric_limits< double >::epsilon( ) );
 
         // Test if body mass is updated
@@ -582,33 +568,28 @@ BOOST_AUTO_TEST_CASE( test_NonConservativeForceEnvironmentUpdate )
 
         // Check if flight conditions update has been called
         BOOST_CHECK_EQUAL(
-                    ( vehicleFlightConditions->getCurrentAirspeed( )
-                      == vehicleFlightConditions->getCurrentAirspeed( ) ), 1 );
+                    ( vehicleFlightConditions->getCurrentAirspeed( ) == vehicleFlightConditions->getCurrentAirspeed( ) ), 1 );
         BOOST_CHECK_EQUAL(
-                    ( vehicleFlightConditions->getCurrentAltitude( )
-                      == vehicleFlightConditions->getCurrentAltitude( ) ), 1 );
+                    ( vehicleFlightConditions->getCurrentAltitude( ) == vehicleFlightConditions->getCurrentAltitude( ) ), 1 );
         BOOST_CHECK_EQUAL(
-                    ( vehicleFlightConditions->getCurrentDensity( )
-                      == vehicleFlightConditions->getCurrentDensity( ) ), 1 );
+                    ( vehicleFlightConditions->getCurrentDensity( ) == vehicleFlightConditions->getCurrentDensity( ) ), 1 );
         BOOST_CHECK_EQUAL( vehicleFlightConditions->getCurrentTime( ), testTime );
 
         // Check if radiation pressure update is updated.
-        boost::shared_ptr< electro_magnetism::RadiationPressureInterface > radiationPressureInterface
-               = bodyMap.at( "Vehicle" )->getRadiationPressureInterfaces( ).at( "Sun" );
+        boost::shared_ptr< electro_magnetism::RadiationPressureInterface > radiationPressureInterface =
+                bodyMap.at( "Vehicle" )->getRadiationPressureInterfaces( ).at( "Sun" );
         BOOST_CHECK_EQUAL(
-                    ( radiationPressureInterface->getCurrentTime( )
-                      == radiationPressureInterface->getCurrentTime( ) ), 1 );
+                    ( radiationPressureInterface->getCurrentTime( ) == radiationPressureInterface->getCurrentTime( ) ), 1 );
         BOOST_CHECK_EQUAL(
-                    ( radiationPressureInterface->getCurrentRadiationPressure( )
-                      == radiationPressureInterface->getCurrentRadiationPressure( ) ), 1 );
+                    ( radiationPressureInterface->getCurrentRadiationPressure( ) ==
+                radiationPressureInterface->getCurrentRadiationPressure( ) ), 1 );
         TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
                     radiationPressureInterface->getCurrentSolarVector( ),
-                    ( bodyMap.at( "Sun" )->getPosition( )
-                      - bodyMap.at( "Vehicle" )->getPosition( ) ),
+                    ( bodyMap.at( "Sun" )->getPosition( ) - bodyMap.at( "Vehicle" )->getPosition( ) ),
                     std::numeric_limits< double >::epsilon( ) );
 
         updater->updateEnvironment(
-                    0.5 * testTime, std::map< IntegratedStateType, Eigen::VectorXd >( ),
+                    0.5 * testTime, std::unordered_map< IntegratedStateType, Eigen::VectorXd >( ),
                     boost::assign::list_of( transational_state ) );
 
 
diff --git a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestMultiTypeStatePropagation.cpp b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestMultiTypeStatePropagation.cpp
new file mode 100644
index 0000000..5ad3d49
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestMultiTypeStatePropagation.cpp
@@ -0,0 +1,242 @@
+#define BOOST_TEST_MAIN
+
+
+#include <boost/bind.hpp>
+#include <boost/make_shared.hpp>
+#include <boost/shared_ptr.hpp>
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+
+#include <Eigen/Core>
+
+#include <Tudat/Basics/testMacros.h>
+#include <Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h>
+#include <Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h>
+#include <Tudat/Astrodynamics/BasicAstrodynamics/unitConversions.h>
+#include <Tudat/Mathematics/NumericalIntegrators/rungeKutta4Integrator.h>
+#include <Tudat/Astrodynamics/BasicAstrodynamics/stateVectorIndices.h>
+#include <Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h>
+#include <Tudat/InputOutput/basicInputOutput.h>
+
+#include <Tudat/Astrodynamics/Propagators/dynamicsSimulator.h>
+#include <Tudat/External/SpiceInterface/spiceInterface.h>
+#include <Tudat/SimulationSetup/body.h>
+#include <Tudat/SimulationSetup/createBodies.h>
+#include <Tudat/SimulationSetup/createAccelerationModels.h>
+
+
+
+namespace tudat
+{
+namespace unit_tests
+{
+
+using namespace mathematical_constants;
+
+BOOST_AUTO_TEST_SUITE( test_hybrid_state_derivative_model )
+
+std::map< double, Eigen::VectorXd > propagateKeplerOrbitAndMassState(
+        const int simulationCase )
+{
+    using namespace simulation_setup;
+    using namespace propagators;
+    using namespace numerical_integrators;
+    using namespace orbital_element_conversions;
+    using namespace basic_mathematics;
+    using namespace gravitation;
+    using namespace numerical_integrators;
+    using namespace unit_conversions;
+
+    // Load Spice kernels.
+    spice_interface::loadSpiceKernelInTudat( input_output::getSpiceKernelPath( ) + "pck00009.tpc" );
+    spice_interface::loadSpiceKernelInTudat( input_output::getSpiceKernelPath( ) + "de-403-masses.tpc" );
+    spice_interface::loadSpiceKernelInTudat( input_output::getSpiceKernelPath( ) + "de421.bsp" );
+
+    // Set simulation end epoch.
+    const double simulationEndEpoch = tudat::physical_constants::JULIAN_DAY;
+
+    // Set numerical integration fixed step size.
+    const double fixedStepSize = 60.0;
+
+    // Define body settings for simulation.
+    std::map< std::string, boost::shared_ptr< BodySettings > > bodySettings;
+    bodySettings[ "Earth" ] = boost::make_shared< BodySettings >( );
+    bodySettings[ "Earth" ]->ephemerisSettings = boost::make_shared< ConstantEphemerisSettings >(
+                basic_mathematics::Vector6d::Zero( ), "SSB", "J2000" );
+    bodySettings[ "Earth" ]->gravityFieldSettings = boost::make_shared< GravityFieldSettings >( central_spice );
+
+    // Create Earth object
+    NamedBodyMap bodyMap = createBodies( bodySettings );
+
+    // Create spacecraft object.
+    bodyMap[ "Asterix" ] = boost::make_shared< simulation_setup::Body >( );
+    bodyMap[ "Asterix" ]->setEphemeris( boost::make_shared< ephemerides::TabulatedCartesianEphemeris< > >(
+                                            boost::shared_ptr< interpolators::OneDimensionalInterpolator
+                                                < double, Vector6d  > >( ), "Earth", "J2000" ) );
+
+    // Finalize body creation.
+    setGlobalFrameBodyEphemerides( bodyMap, "SSB", "J2000" );
+
+    // Define propagator settings variables.
+    SelectedAccelerationMap accelerationMap;
+    std::vector< std::string > bodiesToPropagate;
+    std::vector< std::string > centralBodies;
+
+    // Define propagation settings.
+    std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfAsterix;
+    accelerationsOfAsterix[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >(
+                                                     basic_astrodynamics::central_gravity ) );
+    accelerationMap[  "Asterix" ] = accelerationsOfAsterix;
+    bodiesToPropagate.push_back( "Asterix" );
+    centralBodies.push_back( "Earth" );
+
+    // Create acceleration models and propagation settings.
+    basic_astrodynamics::AccelerationMap accelerationModelMap = createAccelerationModelsMap(
+                bodyMap, accelerationMap, bodiesToPropagate, centralBodies );
+
+
+    // Set Keplerian elements for Asterix.
+    Vector6d asterixInitialStateInKeplerianElements;
+    asterixInitialStateInKeplerianElements( semiMajorAxisIndex ) = 7500.0E3;
+    asterixInitialStateInKeplerianElements( eccentricityIndex ) = 0.1;
+    asterixInitialStateInKeplerianElements( inclinationIndex ) = convertDegreesToRadians( 85.3 );
+    asterixInitialStateInKeplerianElements( argumentOfPeriapsisIndex )
+            = convertDegreesToRadians( 235.7 );
+    asterixInitialStateInKeplerianElements( longitudeOfAscendingNodeIndex )
+            = convertDegreesToRadians( 23.4 );
+    asterixInitialStateInKeplerianElements( trueAnomalyIndex ) = convertDegreesToRadians( 139.87 );
+
+    // Convert Asterix state from Keplerian elements to Cartesian elements.
+    double earthGravitationalParameter = bodyMap.at( "Earth" )->getGravityFieldModel( )->getGravitationalParameter( );
+    Eigen::VectorXd systemInitialState = convertKeplerianToCartesianElements(
+                asterixInitialStateInKeplerianElements,
+                earthGravitationalParameter );
+
+
+    boost::shared_ptr< PropagatorSettings< double > > translationalPropagatorSettings =
+            boost::make_shared< TranslationalStatePropagatorSettings< double > >
+            ( centralBodies, accelerationModelMap, bodiesToPropagate, systemInitialState,
+              boost::make_shared< PropagationTimeTerminationSettings >( simulationEndEpoch ) );
+
+    // Create mass rate model and mass propagation settings
+    std::map< std::string, boost::shared_ptr< basic_astrodynamics::MassRateModel > > massRateModels;
+    massRateModels[ "Vehicle" ] = boost::make_shared< basic_astrodynamics::CustomMassRateModel >(
+                boost::lambda::constant( -0.01 ) );
+    Eigen::VectorXd initialMass = Eigen::VectorXd( 1 );
+    initialMass( 0 ) = 500.0;
+    boost::shared_ptr< PropagatorSettings< double > > massPropagatorSettings =
+            boost::make_shared< MassPropagatorSettings< double > >(
+                boost::assign::list_of( "Asterix" ), massRateModels, initialMass,
+                boost::make_shared< PropagationTimeTerminationSettings >( simulationEndEpoch ) );
+
+    // Create total propagator settings, depending on current case.
+    boost::shared_ptr< PropagatorSettings< double > > propagatorSettings;
+    if( ( simulationCase  % 3 ) == 0 )
+    {
+        propagatorSettings = translationalPropagatorSettings;
+    }
+    else if( ( simulationCase  % 3 ) == 1 )
+    {
+        propagatorSettings = massPropagatorSettings;
+    }
+    else if( ( simulationCase  % 3 ) == 2 )
+    {
+        std::vector< boost::shared_ptr< PropagatorSettings< double > > >  propagatorSettingsList;
+        propagatorSettingsList.push_back( translationalPropagatorSettings );
+        propagatorSettingsList.push_back( massPropagatorSettings );
+
+        propagatorSettings = boost::make_shared< MultiTypePropagatorSettings< double > >(
+                    propagatorSettingsList,
+                    boost::make_shared< PropagationTimeTerminationSettings >( simulationEndEpoch ) );
+    }
+
+
+
+    boost::shared_ptr< IntegratorSettings< > > integratorSettings =
+            boost::make_shared< IntegratorSettings< > >
+            ( rungeKutta4, 0.0, fixedStepSize );
+
+    // Create simulation object and propagate dynamics.
+    SingleArcDynamicsSimulator< > dynamicsSimulator(
+                bodyMap, integratorSettings, propagatorSettings, true, false, true );
+
+    // Return propagated dynamics (if simulationCase < 3) or interpolated dynamics (else)
+    if( simulationCase < 3 )
+    {
+        return dynamicsSimulator.getEquationsOfMotionNumericalSolution( );
+    }
+    else
+    {
+        std::map< double, Eigen::VectorXd > returnMap;
+        double currentTime = 4.0 * fixedStepSize;
+
+        double interpolationTimeStep = 32.1;
+
+        // Interpolate dynamics for range of times.
+        while( currentTime < simulationEndEpoch - 4.0 * fixedStepSize )
+        {
+
+            // Interpolate propagated dynamics type
+            if( simulationCase == 3 )
+            {
+                returnMap[ currentTime ] = bodyMap[ "Asterix" ]->getEphemeris( )->getCartesianStateFromEphemeris( currentTime );
+            }
+            else if( simulationCase == 4 )
+            {
+                returnMap[ currentTime ] = Eigen::VectorXd::Zero( 1 );
+                returnMap[ currentTime ]( 0 ) = bodyMap[ "Asterix" ]->getBodyMassFunction( )( currentTime );
+            }
+            else if( simulationCase == 5 )
+            {
+                returnMap[ currentTime ] = Eigen::VectorXd::Zero( 7 );
+                returnMap[ currentTime ].segment( 0, 6 ) = bodyMap[ "Asterix" ]->getEphemeris( )->getCartesianStateFromEphemeris( currentTime );
+                returnMap[ currentTime ]( 6 ) = bodyMap[ "Asterix" ]->getBodyMassFunction( )( currentTime );
+
+            }
+
+            // Increment time (non-resonant with integration time step).
+            currentTime += interpolationTimeStep;
+        }
+
+        return returnMap;
+    }
+
+}
+//! Test if conversion from Keplerian elements to Cartesian elements is working correctly.
+BOOST_AUTO_TEST_CASE( testHybridStateDerivativeModel )
+{
+    // Compare separate and multitype (independent) propagation directly from propagation (useCase = 0) and
+    // interpolated from reset dynamics (useCase = 1)
+    for( int useCase = 0; useCase < 2; useCase++ )
+    {
+        int simulationCaseToAdd = ( useCase == 0 ) ? ( 0 ) : ( 3 );
+
+        // Propagate dynamics for translational, mass and combined state.
+        std::map< double, Eigen::VectorXd >  translationalState = propagateKeplerOrbitAndMassState( 0 + simulationCaseToAdd );
+        std::map< double, Eigen::VectorXd >  massState = propagateKeplerOrbitAndMassState( 1 + simulationCaseToAdd );
+        std::map< double, Eigen::VectorXd >  combinedState = propagateKeplerOrbitAndMassState( 2  + simulationCaseToAdd );
+
+        std::map< double, Eigen::VectorXd >::const_iterator stateIterator = translationalState.begin( );
+        std::map< double, Eigen::VectorXd >::const_iterator massIterator = massState.begin( );
+        std::map< double, Eigen::VectorXd >::const_iterator combinedIterator = combinedState.begin( );
+
+        // Compare separate and multitype dynamics of each type.
+        for( unsigned int i = 0; i < translationalState.size( ); i++ )
+        {
+            TUDAT_CHECK_MATRIX_CLOSE_FRACTION( stateIterator->second, combinedIterator->second.segment( 0, 6 ),
+                                               std::numeric_limits< double >::epsilon( ) );
+            TUDAT_CHECK_MATRIX_CLOSE_FRACTION( massIterator->second, combinedIterator->second.segment( 6, 1 ),
+                                               std::numeric_limits< double >::epsilon( ) );
+            stateIterator++;
+            massIterator++;
+            combinedIterator++;
+        }
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+}
+
+}
diff --git a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestSequentialVariationalEquationIntegration.cpp b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestSequentialVariationalEquationIntegration.cpp
new file mode 100644
index 0000000..2227284
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestSequentialVariationalEquationIntegration.cpp
@@ -0,0 +1,196 @@
+#define BOOST_TEST_MAIN
+
+#include <string>
+#include <thread>
+#include <omp.h>
+#include <limits>
+
+#include <boost/test/unit_test.hpp>
+#include <boost/make_shared.hpp>
+
+#include "Tudat/Basics/testMacros.h"
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebra.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h"
+#include "Tudat/Astrodynamics/Ephemerides/tabulatedEphemeris.h"
+
+#include "Tudat/InputOutput/basicInputOutput.h"
+#include "Tudat/External/SpiceInterface/spiceInterface.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
+
+#include "Tudat/SimulationSetup/defaultBodies.h"
+#include "Tudat/SimulationSetup/createBodies.h"
+#include "Tudat/SimulationSetup/createAccelerationModels.h"
+#include "Tudat/SimulationSetup/createEstimatableParameters.h"
+#include "Tudat/Astrodynamics/Propagators/variationalEquationsSolver.h"
+
+namespace tudat
+{
+
+namespace unit_tests
+{
+
+//Using declarations.
+using namespace tudat::interpolators;
+using namespace tudat::numerical_integrators;
+using namespace tudat::spice_interface;
+using namespace tudat::simulation_setup;
+using namespace tudat::basic_astrodynamics;
+using namespace tudat::estimatable_parameters;
+using namespace tudat::orbital_element_conversions;
+using namespace tudat::ephemerides;
+using namespace tudat::propagators;
+
+
+BOOST_AUTO_TEST_SUITE( test_sequential_variational_equation_integration )
+
+
+std::pair< boost::shared_ptr< CombinedStateTransitionAndSensitivityMatrixInterface >, boost::shared_ptr< Ephemeris > >
+integrateEquations( const bool performIntegrationsSequentially )
+{
+    std::string kernelsPath = input_output::getSpiceKernelPath( );
+
+    //Load spice kernels.
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "naif0009.tls");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "pck00009.tpc");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de-403-masses.tpc");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de421.bsp");
+
+    std::vector< std::string > bodyNames;
+    bodyNames.push_back( "Earth" );
+    bodyNames.push_back( "Sun" );
+    bodyNames.push_back( "Moon" );
+
+    // Specify initial time
+    double initialEphemerisTime = 1.0E7;
+    double finalEphemerisTime = initialEphemerisTime + 14.0 * 86400.0;
+    double maximumTimeStep = 600.0;
+
+    double numberOfTimeStepBuffer = 6.0;
+    double buffer = numberOfTimeStepBuffer * maximumTimeStep;
+
+    // Create bodies needed in simulation
+    std::map< std::string, boost::shared_ptr< BodySettings > > bodySettings =
+            getDefaultBodySettings( bodyNames, initialEphemerisTime - buffer, finalEphemerisTime + buffer );
+    NamedBodyMap bodyMap =
+            createBodies( bodySettings );
+    boost::shared_ptr< Body > lageos = boost::make_shared< Body >( );
+    bodyMap[ "LAGEOS" ] = lageos;
+
+    // Create  body initial state
+    basic_mathematics::Vector6d lageosKeplerianElements;
+    lageosKeplerianElements[ semiMajorAxisIndex ] = 8000.0E3;
+    lageosKeplerianElements[ eccentricityIndex ] = 0.0044;
+    lageosKeplerianElements[ inclinationIndex ] = 109.89 * mathematical_constants::PI / 180.0;
+    lageosKeplerianElements[ argumentOfPeriapsisIndex ] = 259.35 * mathematical_constants::PI / 180.0;
+    lageosKeplerianElements[ longitudeOfAscendingNodeIndex ] = 31.56 * mathematical_constants::PI / 180.0;
+    lageosKeplerianElements[ trueAnomalyIndex ] = 1.0;
+    basic_mathematics::Vector6d lageosState = convertKeplerianToCartesianElements(
+                lageosKeplerianElements, getBodyGravitationalParameter("Earth" ) );
+
+    lageos->setEphemeris( boost::make_shared< TabulatedCartesianEphemeris< double, double > >(
+                              boost::shared_ptr< interpolators::OneDimensionalInterpolator<
+                              double, basic_mathematics::Vector6d > >( ), "Earth" ) );
+    setGlobalFrameBodyEphemerides( bodyMap, "SSB", "ECLIPJ2000" );
+
+    // Set accelerations between bodies that are to be taken into account.
+    SelectedAccelerationMap accelerationMap;
+
+    std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfLageos;
+    //accelerationsOfLageos[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    //accelerationsOfLageos[ "Earth" ].push_back( boost::make_shared< RelativisticCorrectionSettings >( ) );
+    //accelerationsOfLageos[ "Earth" ].push_back( boost::make_shared< SphericalHarmonicAccelerationSettings >( 8, 8 ) );
+    accelerationsOfLageos[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationMap[ "LAGEOS" ] = accelerationsOfLageos;
+
+    // Set bodies for which initial state is to be estimated and integrated.
+    std::vector< std::string > bodiesToIntegrate;
+    bodiesToIntegrate.push_back( "LAGEOS" );
+    unsigned int numberOfNumericalBodies = bodiesToIntegrate.size( );
+
+    std::vector< std::string > centralBodies;
+    std::map< std::string, std::string > centralBodyMap;
+
+    centralBodies.resize( numberOfNumericalBodies );
+    for( unsigned int i = 0; i < numberOfNumericalBodies; i++ )
+    {
+        centralBodies[ i ] = "Earth";
+        centralBodyMap[ bodiesToIntegrate[ i ] ] = centralBodies[ i ];
+    }
+    AccelerationMap accelerationModelMap = createAccelerationModelsMap(
+                bodyMap, accelerationMap, centralBodyMap );
+
+    // Set parameters that are to be included.
+    std::vector< boost::shared_ptr< EstimatableParameterSettings > > parameterNames;
+    parameterNames.push_back( boost::make_shared< InitialTranslationalStateEstimatableParameterSettings< double > >(
+                                  "LAGEOS", lageosState, "Earth" ) );
+    parameterNames.push_back( boost::make_shared< EstimatableParameterSettings >
+                              ( "Earth", gravitational_parameter ) );
+    parameterNames.push_back( boost::make_shared< EstimatableParameterSettings >
+                              ( "Moon", gravitational_parameter ) );
+    boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< double > > parametersToEstimate =
+            createParametersToEstimate( parameterNames, bodyMap, accelerationModelMap );
+
+    // Define integrator settings.
+    boost::shared_ptr< IntegratorSettings< > > integratorSettings =
+            boost::make_shared< RungeKuttaVariableStepSizeSettings< > >
+            ( rungeKuttaVariableStepSize, initialEphemerisTime, 10.0,
+              RungeKuttaCoefficients::rungeKuttaFehlberg45, 0.01, 10.0, 1.0E-6, 1.0E-6 );
+
+    // Define propagator settings.
+    boost::shared_ptr< TranslationalStatePropagatorSettings< double > > propagatorSettings =
+            boost::make_shared< TranslationalStatePropagatorSettings< double > >
+            ( centralBodies, accelerationModelMap, bodiesToIntegrate, lageosState, finalEphemerisTime );
+
+    // Perform requested propagation
+    boost::shared_ptr< SingleArcVariationalEquationsSolver< double, double, double > > variationalEquationSolver;
+    if( !performIntegrationsSequentially )
+    {
+        variationalEquationSolver = boost::make_shared< SingleArcVariationalEquationsSolver< double, double, double > >(
+                    bodyMap, integratorSettings,
+                    propagatorSettings, parametersToEstimate );
+    }
+    else
+    {
+        variationalEquationSolver = boost::make_shared< SingleArcVariationalEquationsSolver< double, double, double > >(
+                    bodyMap, integratorSettings,
+                    propagatorSettings, parametersToEstimate, 0,
+                    integratorSettings );
+    }
+
+    return std::make_pair( variationalEquationSolver->getStateTransitionMatrixInterface( ),
+                           bodyMap[ "LAGEOS" ]->getEphemeris( ) );
+}
+
+//! Test whether concurrent and sequential propagation of variational equations gives same results.
+BOOST_AUTO_TEST_CASE( testSequentialVariationalEquationIntegration )
+{
+    // Propagate concurrently.
+    std::pair< boost::shared_ptr< CombinedStateTransitionAndSensitivityMatrixInterface >, boost::shared_ptr< Ephemeris > >
+            concurrentResult = integrateEquations( 0 );
+
+    // Propagate sequentially.
+    std::pair< boost::shared_ptr< CombinedStateTransitionAndSensitivityMatrixInterface >, boost::shared_ptr< Ephemeris > >
+            sequentialResult = integrateEquations( 1 );
+
+    // Test variational equations solution.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                concurrentResult.first->getCombinedStateTransitionAndSensitivityMatrix( 1.0E7 + 14.0 * 80000.0 ),
+                sequentialResult.first->getCombinedStateTransitionAndSensitivityMatrix( 1.0E7 + 14.0 * 80000.0 ), 2.0E-6 );
+
+    // Test dynamics solution.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                concurrentResult.second->getCartesianStateFromEphemeris( 1.0E7 + 14.0 * 80000.0 ),
+                sequentialResult.second->getCartesianStateFromEphemeris( 1.0E7 + 14.0 * 80000.0 ),
+                std::numeric_limits< double >::epsilon( ) );
+
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+}
+
+}
+
+
+
diff --git a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestStoppingConditions.cpp b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestStoppingConditions.cpp
new file mode 100644
index 0000000..609b4c9
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestStoppingConditions.cpp
@@ -0,0 +1,351 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#define BOOST_TEST_MAIN
+
+#include <boost/test/unit_test.hpp>
+#include <boost/bind.hpp>
+#include <boost/make_shared.hpp>
+#include <boost/shared_ptr.hpp>
+
+#include <Tudat/Astrodynamics/Aerodynamics/UnitTests/testApolloCapsuleCoefficients.h>
+#include <Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h>
+
+#include <Tudat/Astrodynamics/Propagators/dynamicsSimulator.h>
+#include <Tudat/Astrodynamics/BasicAstrodynamics/unitConversions.h>
+#include <Tudat/External/SpiceInterface/spiceInterface.h>
+#include <Tudat/SimulationSetup/body.h>
+#include <Tudat/SimulationSetup/createAccelerationModels.h>
+#include <Tudat/SimulationSetup/defaultBodies.h>
+#include <Tudat/InputOutput/basicInputOutput.h>
+
+#include <iostream>
+#include <limits>
+#include <string>
+
+#include <Eigen/Core>
+
+namespace tudat
+{
+
+namespace unit_tests
+{
+
+BOOST_AUTO_TEST_SUITE( test_propagation_stopping_conditions )
+
+boost::shared_ptr< propagators::PropagationTerminationSettings > getTerminationSettings( const int testType )
+{
+
+    // Define stopping conditions, depending on test case.
+    boost::shared_ptr< propagators::PropagationTerminationSettings > terminationSettings;
+    switch( testType )
+    {
+    // Stop at given time.
+    case 0:
+        terminationSettings = boost::make_shared< propagators::PropagationTimeTerminationSettings >( 3200.0 );
+        break;
+    // Stop at given Mach number
+    case 1:
+        terminationSettings = boost::make_shared< propagators::PropagationDependentVariableTerminationSettings >(
+                    boost::make_shared< propagators::SingleDependentVariableSaveSettings >(
+                        propagators::mach_number_dependent_variable, "Apollo" ), 3.0, 1 );
+        break;
+    // Stop at given altitude
+    case 2:
+        terminationSettings = boost::make_shared< propagators::PropagationDependentVariableTerminationSettings >(
+                    boost::make_shared< propagators::SingleDependentVariableSaveSettings >(
+                        propagators::altitude_dependent_variable, "Apollo" ), 10.0E3, 1 );
+        break;
+    // Stop at given density
+    case 3:
+        terminationSettings = boost::make_shared< propagators::PropagationDependentVariableTerminationSettings >(
+                    boost::make_shared< propagators::SingleDependentVariableSaveSettings >(
+                        propagators::local_density_dependent_variable, "Apollo" ), 1.1, 0);
+        break;
+    // Stop when a single of the conditions 0-3 is fulfilled.
+    case 4:
+    {
+        std::vector< boost::shared_ptr< propagators::PropagationTerminationSettings > > constituentSettings;
+        constituentSettings.push_back( getTerminationSettings( 0 ) );
+        constituentSettings.push_back( getTerminationSettings( 1 ) );
+        constituentSettings.push_back( getTerminationSettings( 2 ) );
+        constituentSettings.push_back( getTerminationSettings( 3 ) );
+
+        terminationSettings = boost::make_shared< propagators::PropagationHybridTerminationSettings >(
+                    constituentSettings, 1 );
+        break;
+    }
+    // Stop when all of the conditions 0-3 is fulfilled.
+    case 5:
+    {
+        std::vector< boost::shared_ptr< propagators::PropagationTerminationSettings > > constituentSettings;
+        constituentSettings.push_back( getTerminationSettings( 0 ) );
+        constituentSettings.push_back( getTerminationSettings( 1 ) );
+        constituentSettings.push_back( getTerminationSettings( 2 ) );
+        constituentSettings.push_back( getTerminationSettings( 3 ) );
+
+        terminationSettings = boost::make_shared< propagators::PropagationHybridTerminationSettings >(
+                    constituentSettings, 0 );
+        break;
+    }
+    }
+    return terminationSettings;
+}
+
+void performSimulation( const int testType )
+{
+    using namespace ephemerides;
+    using namespace interpolators;
+    using namespace numerical_integrators;
+    using namespace spice_interface;
+    using namespace simulation_setup;
+    using namespace basic_astrodynamics;
+    using namespace orbital_element_conversions;
+    using namespace propagators;
+    using namespace aerodynamics;
+    using namespace basic_mathematics;
+    using namespace input_output;
+
+    // Load Spice kernels.
+    spice_interface::loadSpiceKernelInTudat( input_output::getSpiceKernelPath( ) + "pck00009.tpc" );
+    spice_interface::loadSpiceKernelInTudat( input_output::getSpiceKernelPath( ) + "de-403-masses.tpc" );
+    spice_interface::loadSpiceKernelInTudat( input_output::getSpiceKernelPath( ) + "de421.bsp" );
+
+
+    // Set simulation start epoch.
+    const double simulationStartEpoch = 0.0;
+
+    // Set simulation end epoch.
+    const double simulationEndEpoch = 3300.0;
+
+    // Set numerical integration fixed step size.
+    const double fixedStepSize = 1.0;
+
+
+    // Set Keplerian elements for Capsule.
+    Vector6d apolloInitialStateInKeplerianElements;
+    apolloInitialStateInKeplerianElements( semiMajorAxisIndex ) = spice_interface::getAverageRadius( "Earth" ) + 120.0E3;
+    apolloInitialStateInKeplerianElements( eccentricityIndex ) = 0.005;
+    apolloInitialStateInKeplerianElements( inclinationIndex ) = unit_conversions::convertDegreesToRadians( 85.3 );
+    apolloInitialStateInKeplerianElements( argumentOfPeriapsisIndex )
+            = unit_conversions::convertDegreesToRadians( 235.7 );
+    apolloInitialStateInKeplerianElements( longitudeOfAscendingNodeIndex )
+            = unit_conversions::convertDegreesToRadians( 23.4 );
+    apolloInitialStateInKeplerianElements( trueAnomalyIndex ) = unit_conversions::convertDegreesToRadians( 139.87 );
+
+    // Convert apollo state from Keplerian elements to Cartesian elements.
+    const Vector6d apolloInitialState = convertKeplerianToCartesianElements(
+                apolloInitialStateInKeplerianElements,
+                getBodyGravitationalParameter( "Earth" ) );
+
+
+    // Define simulation body settings.
+    std::map< std::string, boost::shared_ptr< BodySettings > > bodySettings =
+            getDefaultBodySettings( { "Earth" }, simulationStartEpoch - 10.0 * fixedStepSize,
+                                    simulationEndEpoch + 10.0 * fixedStepSize );
+    bodySettings[ "Earth" ]->ephemerisSettings = boost::make_shared< simulation_setup::ConstantEphemerisSettings >(
+                basic_mathematics::Vector6d::Zero( ), "SSB", "J2000" );
+    bodySettings[ "Earth" ]->gravityFieldSettings =
+            boost::make_shared< simulation_setup::GravityFieldSettings >(
+                central_spice );
+    bodySettings[ "Earth" ]->rotationModelSettings->resetOriginalFrame( "J2000" );
+
+    // Create Earth object
+    simulation_setup::NamedBodyMap bodyMap = simulation_setup::createBodies( bodySettings );
+
+    // Define propagator settings variables.
+    SelectedAccelerationMap accelerationMap;
+    std::vector< std::string > bodiesToPropagate;
+    std::vector< std::string > centralBodies;
+
+    // Create vehicle objects.
+    bodyMap[ "Apollo" ] = boost::make_shared< simulation_setup::Body >( );
+
+    // Create vehicle aerodynamic coefficients
+    bodyMap[ "Apollo" ]->setAerodynamicCoefficientInterface(
+                unit_tests::getApolloCoefficientInterface( ) );
+    bodyMap[ "Apollo" ]->setConstantBodyMass( 5.0E3 );
+
+    // Finalize body creation.
+    setGlobalFrameBodyEphemerides( bodyMap, "SSB", "J2000" );
+
+    // Define acceleration model settings.
+    std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfApollo;
+    accelerationsOfApollo[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationsOfApollo[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( aerodynamic ) );
+    accelerationMap[  "Apollo" ] = accelerationsOfApollo;
+
+    bodiesToPropagate.push_back( "Apollo" );
+    centralBodies.push_back( "Earth" );
+
+    // Set initial state
+    basic_mathematics::Vector6d systemInitialState = apolloInitialState;
+
+    // Create acceleration models and propagation settings, using current test case to retrieve stop settings..
+    basic_astrodynamics::AccelerationMap accelerationModelMap = createAccelerationModelsMap(
+                bodyMap, accelerationMap, bodiesToPropagate, centralBodies );
+    boost::shared_ptr< TranslationalStatePropagatorSettings< double > > propagatorSettings =
+            boost::make_shared< TranslationalStatePropagatorSettings< double > >
+            ( centralBodies, accelerationModelMap, bodiesToPropagate, systemInitialState,
+              getTerminationSettings( testType ) );
+    boost::shared_ptr< IntegratorSettings< > > integratorSettings =
+            boost::make_shared< IntegratorSettings< > >
+            ( rungeKutta4, simulationStartEpoch, fixedStepSize );
+
+    // Create simulation object and propagate dynamics.
+    SingleArcDynamicsSimulator< > dynamicsSimulator(
+                bodyMap, integratorSettings, propagatorSettings, true, false, false );
+
+    std::map< double, Eigen::Matrix< double, Eigen::Dynamic, 1 > > numericalSolution =
+            dynamicsSimulator.getEquationsOfMotionNumericalSolution( );
+
+    // Check whether propagation has stopped at given conditions
+    switch( testType )
+    {
+    // Check whether propagation stopped when passing t=3200.0
+    case 0:
+    {
+
+        BOOST_CHECK_EQUAL( ( (--( numericalSolution.end( ) ) )->first >= 3200.0 ) &&
+                           ( (--(--( numericalSolution.end( ) ) ) )->first < 3200.0 ), true );
+        break;
+    }
+    case 1:
+    {
+        // Compute Mach number for last two time steps, and check whether last step was first to pass below Mach=3
+        boost::shared_ptr< DynamicsStateDerivativeModel< double, double > > stateDerivativeModel =
+                dynamicsSimulator.getDynamicsStateDerivative( );
+        stateDerivativeModel->computeStateDerivative(
+                    (--(--( numericalSolution.end( ) ) ) )->first, (--(--( numericalSolution.end( ) ) ) )->second );
+        boost::shared_ptr< FlightConditions > flightConditions = bodyMap.at( "Apollo" )->getFlightConditions( );
+        double secondToLastMachNumber = flightConditions->getCurrentAirspeed( ) / flightConditions->getCurrentSpeedOfSound( );
+        stateDerivativeModel->computeStateDerivative(
+                    (--( numericalSolution.end( ) ) )->first, (--( numericalSolution.end( ) ) )->second );
+        double lastMachNumber = flightConditions->getCurrentAirspeed( ) / flightConditions->getCurrentSpeedOfSound( );
+
+        BOOST_CHECK_EQUAL( ( lastMachNumber <= 3.0 ) && ( secondToLastMachNumber > 3.0 ), true );
+
+        break;
+    }
+    case 2:
+    {
+        // Compute altitude for last two time steps, and check whether last step was first to pass below altitude = 10 km
+        boost::shared_ptr< DynamicsStateDerivativeModel< double, double > > stateDerivativeModel =
+                dynamicsSimulator.getDynamicsStateDerivative( );
+        stateDerivativeModel->computeStateDerivative(
+                    (--(--( numericalSolution.end( ) ) ) )->first, (--(--( numericalSolution.end( ) ) ) )->second );
+        boost::shared_ptr< FlightConditions > flightConditions = bodyMap.at( "Apollo" )->getFlightConditions( );
+        double secondToLastAltitude = flightConditions->getCurrentAltitude( );
+        stateDerivativeModel->computeStateDerivative(
+                    (--( numericalSolution.end( ) ) )->first, (--( numericalSolution.end( ) ) )->second );
+        double lastAltitude = flightConditions->getCurrentAltitude( );
+
+        BOOST_CHECK_EQUAL( ( lastAltitude <= 10.0E3 ) && ( secondToLastAltitude > 10.0E3 ), true );
+
+        break;
+    }
+    case 3:
+    {
+        // Compute density for last two time steps, and check whether last step was first to pass below density = 1.1 kg/m3
+        boost::shared_ptr< DynamicsStateDerivativeModel< double, double > > stateDerivativeModel =
+                dynamicsSimulator.getDynamicsStateDerivative( );
+        stateDerivativeModel->computeStateDerivative(
+                    (--(--( numericalSolution.end( ) ) ) )->first, (--(--( numericalSolution.end( ) ) ) )->second );
+        boost::shared_ptr< FlightConditions > flightConditions = bodyMap.at( "Apollo" )->getFlightConditions( );
+        double secondToLastDensity = flightConditions->getCurrentDensity( );
+        stateDerivativeModel->computeStateDerivative(
+                    (--( numericalSolution.end( ) ) )->first, (--( numericalSolution.end( ) ) )->second );
+        double lastDensity = flightConditions->getCurrentDensity( );
+
+        BOOST_CHECK_EQUAL( ( lastDensity >= 1.1 ) && ( secondToLastDensity < 1.1 ), true );
+
+        break;
+    }
+    // Check whether at least a single of the conditions for case 0-3 was first reached at last time step.
+    case 4:
+    {
+        boost::shared_ptr< DynamicsStateDerivativeModel< double, double > > stateDerivativeModel =
+                dynamicsSimulator.getDynamicsStateDerivative( );
+        stateDerivativeModel->computeStateDerivative(
+                    (--(--( numericalSolution.end( ) ) ) )->first, (--(--( numericalSolution.end( ) ) ) )->second );
+        boost::shared_ptr< FlightConditions > flightConditions = bodyMap.at( "Apollo" )->getFlightConditions( );
+
+        double secondToLastMachNumber = flightConditions->getCurrentAirspeed( ) / flightConditions->getCurrentSpeedOfSound( );
+        double secondToLastAltitude = flightConditions->getCurrentAltitude( );
+        double secondToLastDensity = flightConditions->getCurrentDensity( );
+
+        stateDerivativeModel->computeStateDerivative(
+                    (--( numericalSolution.end( ) ) )->first, (--( numericalSolution.end( ) ) )->second );
+
+        double lastMachNumber = flightConditions->getCurrentAirspeed( ) / flightConditions->getCurrentSpeedOfSound( );
+        double lastAltitude = flightConditions->getCurrentAltitude( );
+        double lastDensity = flightConditions->getCurrentDensity( );
+
+        BOOST_CHECK_EQUAL( ( ( (--( numericalSolution.end( ) ) )->first >= 3200.0 ) && ( (--(--( numericalSolution.end( ) ) ) )->first < 3200.0 ) ) ||
+                           ( ( lastMachNumber <= 3.0 ) && ( secondToLastMachNumber > 3.0 ) ) ||
+                           ( ( lastAltitude <= 10.0E3 ) && ( secondToLastAltitude > 10.0E3 ) ) ||
+                           ( ( lastDensity >= 1.1 ) && ( secondToLastDensity < 1.1 ) ), 1 );
+
+        break;
+    }
+        // Check whether all conditions for case 0-3 was first reached at last time step.
+    case 5:
+    {
+        boost::shared_ptr< DynamicsStateDerivativeModel< double, double > > stateDerivativeModel =
+                dynamicsSimulator.getDynamicsStateDerivative( );
+        stateDerivativeModel->computeStateDerivative(
+                    (--(--( numericalSolution.end( ) ) ) )->first, (--(--( numericalSolution.end( ) ) ) )->second );
+        boost::shared_ptr< FlightConditions > flightConditions = bodyMap.at( "Apollo" )->getFlightConditions( );
+
+        double secondToLastMachNumber = flightConditions->getCurrentAirspeed( ) / flightConditions->getCurrentSpeedOfSound( );
+        double secondToLastAltitude = flightConditions->getCurrentAltitude( );
+        double secondToLastDensity = flightConditions->getCurrentDensity( );
+
+        stateDerivativeModel->computeStateDerivative(
+                    (--( numericalSolution.end( ) ) )->first, (--( numericalSolution.end( ) ) )->second );
+
+        double lastMachNumber = flightConditions->getCurrentAirspeed( ) / flightConditions->getCurrentSpeedOfSound( );
+        double lastAltitude = flightConditions->getCurrentAltitude( );
+        double lastDensity = flightConditions->getCurrentDensity( );
+
+        BOOST_CHECK_EQUAL( ( ( (--( numericalSolution.end( ) ) )->first >= 3200.0 ) ) &&
+                           ( ( lastMachNumber <= 3.0 ) ) &&
+                           ( ( lastAltitude <= 10.0E3 ) ) &&
+                           ( ( lastDensity >= 1.1 ) ), 1 );
+
+        BOOST_CHECK_EQUAL( ( (--(--( numericalSolution.end( ) ) ) )->first < 3200.0 )||
+                           ( ( secondToLastMachNumber > 3.0 ) ) ||
+                           ( ( secondToLastAltitude > 10.0E3 ) ) ||
+                           ( ( secondToLastDensity < 1.1 ) ), 1 );
+
+        break;
+    }
+
+    }
+}
+
+//! Test to perform propagation of Apollo capsule for various stopping conditions, and checking whether the final state
+//! corresponds to condition that was given.
+BOOST_AUTO_TEST_CASE( testPropagationStoppingConditions )
+{
+    for( unsigned int i = 0; i < 6; i++ )
+    {
+        performSimulation( i );
+    }
+}
+
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+
+}
+
+}
+
diff --git a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestVariationalEquationPropagation.cpp b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestVariationalEquationPropagation.cpp
new file mode 100644
index 0000000..926e135
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestVariationalEquationPropagation.cpp
@@ -0,0 +1,340 @@
+#define BOOST_TEST_MAIN
+
+#include <string>
+#include <thread>
+#include <omp.h>
+
+#include <boost/test/unit_test.hpp>
+#include <boost/make_shared.hpp>
+
+#include "Tudat/Basics/testMacros.h"
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebra.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+
+#include "Tudat/External/SpiceInterface/spiceInterface.h"
+#include "Tudat/Mathematics/NumericalIntegrators/rungeKuttaCoefficients.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
+#include "Tudat/InputOutput/basicInputOutput.h"
+
+#include "Tudat/SimulationSetup/body.h"
+#include "Tudat/Astrodynamics/Propagators/variationalEquationsSolver.h"
+#include "Tudat/SimulationSetup/defaultBodies.h"
+#include "Tudat/SimulationSetup/createBodies.h"
+#include "Tudat/SimulationSetup/createAccelerationModels.h"
+#include "Tudat/SimulationSetup/createEstimatableParameters.h"
+
+namespace tudat
+{
+
+namespace unit_tests
+{
+
+//Using declarations.
+using namespace tudat::estimatable_parameters;
+using namespace tudat::orbit_determination;
+using namespace tudat::interpolators;
+using namespace tudat::numerical_integrators;
+using namespace tudat::spice_interface;
+using namespace tudat::simulation_setup;
+using namespace tudat::basic_astrodynamics;
+using namespace tudat::orbital_element_conversions;
+using namespace tudat::ephemerides;
+using namespace tudat::propagators;
+
+BOOST_AUTO_TEST_SUITE( test_variational_equation_calculation )
+
+template< typename TimeType = double , typename StateScalarType  = double >
+        std::pair< std::vector< Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > >,
+std::vector< Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > >
+executeEarthMoonSimulation(
+        const std::vector< std::string > centralBodies,
+        const Eigen::Matrix< StateScalarType, 12, 1 > initialStateDifference =
+        Eigen::Matrix< StateScalarType, 12, 1 >::Zero( ),
+        const int propagationType = 0,
+        const Eigen::Vector3d parameterPerturbation = Eigen::Vector3d::Zero( ),
+        const bool propagateVariationalEquations = 1 )
+{
+
+    //Load spice kernels.
+    std::string kernelsPath = input_output::getSpiceKernelPath( );
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de-403-masses.tpc");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "naif0009.tls");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "pck00009.tpc");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de421.bsp");
+
+    // Define
+    std::vector< std::string > bodyNames;
+    bodyNames.push_back( "Earth" );
+    bodyNames.push_back( "Sun" );
+    bodyNames.push_back( "Moon" );
+    bodyNames.push_back( "Mars" );
+
+    // Specify initial time
+    TimeType initialEphemerisTime = TimeType( 1.0E7 );
+    TimeType finalEphemerisTime = initialEphemerisTime + 0.5E7;
+    double maximumTimeStep = 3600.0;
+
+    double buffer = 10.0 * maximumTimeStep;
+
+    // Create bodies needed in simulation
+    std::map< std::string, boost::shared_ptr< BodySettings > > bodySettings =
+            getDefaultBodySettings( bodyNames, initialEphemerisTime - buffer, finalEphemerisTime + buffer );
+
+    NamedBodyMap bodyMap = createBodies( bodySettings );
+    setGlobalFrameBodyEphemerides( bodyMap, "SSB", "ECLIPJ2000" );
+
+
+    // Set accelerations between bodies that are to be taken into account.
+    SelectedAccelerationMap accelerationMap;
+    std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfEarth;
+    accelerationsOfEarth[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationsOfEarth[ "Moon" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationMap[ "Earth" ] = accelerationsOfEarth;
+
+    std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfMoon;
+    accelerationsOfMoon[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationsOfMoon[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationMap[ "Moon" ] = accelerationsOfMoon;
+
+    // Set bodies for which initial state is to be estimated and integrated.
+    std::vector< std::string > bodiesToIntegrate;
+    bodiesToIntegrate.push_back( "Moon" );
+    bodiesToIntegrate.push_back( "Earth" );
+
+    unsigned int numberOfNumericalBodies = bodiesToIntegrate.size( );
+
+    // Define propagator settings.
+    std::map< std::string, std::string > centralBodyMap;
+
+    for( unsigned int i = 0; i < numberOfNumericalBodies; i++ )
+    {
+        centralBodyMap[ bodiesToIntegrate[ i ] ] = centralBodies[ i ];
+    }
+
+    // Create acceleration models
+    AccelerationMap accelerationModelMap = createAccelerationModelsMap(
+                bodyMap, accelerationMap, centralBodyMap );
+
+    // Create integrator settings
+    boost::shared_ptr< IntegratorSettings< TimeType > > integratorSettings =
+            boost::make_shared< IntegratorSettings< TimeType > >
+            ( rungeKutta4, TimeType( initialEphemerisTime ), 1800.0 );
+
+
+    // Set initial states of bodies to integrate.
+    TimeType initialIntegrationTime = initialEphemerisTime;
+
+    // Set (perturbed) initial state.
+    Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > systemInitialState;
+    systemInitialState = getInitialStatesOfBodies< TimeType, StateScalarType >(
+                bodiesToIntegrate, centralBodies, bodyMap, initialIntegrationTime );
+    systemInitialState += initialStateDifference;
+
+    // Create propagator settings
+    boost::shared_ptr< TranslationalStatePropagatorSettings< StateScalarType > > propagatorSettings;
+    TranslationalPropagatorType propagatorType;
+    if( propagationType == 0 )
+    {
+        propagatorType = cowell;
+    }
+    else if( propagationType == 1 )
+    {
+        propagatorType = encke;
+    }
+    propagatorSettings =  boost::make_shared< TranslationalStatePropagatorSettings< StateScalarType > >
+            ( centralBodies, accelerationModelMap, bodiesToIntegrate, systemInitialState,
+              TimeType( finalEphemerisTime ), propagatorType );
+
+    // Define parameters.
+    std::vector< boost::shared_ptr< EstimatableParameterSettings > > parameterNames;
+    {
+        parameterNames.push_back(
+                    boost::make_shared< InitialTranslationalStateEstimatableParameterSettings< StateScalarType > >(
+                        "Moon", propagators::getInitialStateOfBody< TimeType, StateScalarType >(
+                            "Moon", centralBodies[ 0 ], bodyMap, TimeType( initialEphemerisTime ) ) +
+                    initialStateDifference.segment( 0, 6 ),
+                    centralBodies[ 0 ] ) );
+        parameterNames.push_back(
+                    boost::make_shared< InitialTranslationalStateEstimatableParameterSettings< StateScalarType > >(
+                        "Earth", propagators::getInitialStateOfBody< TimeType, StateScalarType >(
+                            "Earth", centralBodies[ 1 ], bodyMap, TimeType( initialEphemerisTime ) ) +
+                    initialStateDifference.segment( 6, 6 ),
+                    centralBodies[ 1 ] ) );
+        parameterNames.push_back( boost::make_shared< EstimatableParameterSettings >( "Moon", gravitational_parameter ) );
+        parameterNames.push_back( boost::make_shared< EstimatableParameterSettings >( "Earth", gravitational_parameter ) );
+        parameterNames.push_back( boost::make_shared< EstimatableParameterSettings >( "Sun", gravitational_parameter ) );
+
+    }
+
+    // Create parameters
+    boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< StateScalarType > > parametersToEstimate =
+            createParametersToEstimate( parameterNames, bodyMap );
+
+    // Perturb parameters.
+    Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > parameterVector =
+            parametersToEstimate->template getFullParameterValues< StateScalarType >( );
+    parameterVector.block( 12, 0, 3, 1 ) += parameterPerturbation;
+    parametersToEstimate->resetParameterValues( parameterVector );
+
+    std::pair< std::vector< Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > >,
+            std::vector< Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > > results;
+
+    {
+        // Create dynamics simulator
+        SingleArcVariationalEquationsSolver< StateScalarType, TimeType, double > dynamicsSimulator =
+                SingleArcVariationalEquationsSolver< StateScalarType, TimeType, double >(
+                    bodyMap, integratorSettings, propagatorSettings, parametersToEstimate,
+                    1, boost::shared_ptr< numerical_integrators::IntegratorSettings< double > >( ), 1, 0 );
+
+        // Propagate requested equations.
+        if( propagateVariationalEquations )
+        {
+            dynamicsSimulator.integrateVariationalAndDynamicalEquations( propagatorSettings->getInitialStates( ), 1 );
+        }
+        else
+        {
+            dynamicsSimulator.integrateDynamicalEquationsOfMotionOnly( propagatorSettings->getInitialStates( ) );
+        }
+
+        // Retrieve test data
+        double testEpoch = 1.4E7;
+        Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > testStates =
+                Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >::Zero( 12 );
+        testStates.block( 0, 0, 6, 1 ) = bodyMap[ "Moon" ]->getStateInBaseFrameFromEphemeris( testEpoch );
+        if( centralBodyMap[ "Moon" ] == "Earth" )
+        {
+            testStates.block( 0, 0, 6, 1 ) -= bodyMap[ "Earth" ]->getStateInBaseFrameFromEphemeris( testEpoch );
+        }
+
+        testStates.block( 6, 0, 6, 1 ) = bodyMap[ "Earth" ]->getStateInBaseFrameFromEphemeris( testEpoch );
+
+        if( propagateVariationalEquations )
+        {
+            results.first.push_back( dynamicsSimulator.getStateTransitionMatrixInterface( )->
+                                     getCombinedStateTransitionAndSensitivityMatrix( testEpoch ) );
+        }
+        results.second.push_back( testStates );
+    }
+    return results;
+}
+
+//! Test the state transition and sensitivity matrix computation against their numerical propagation.
+/*!
+ *  Test the state transition and sensitivity matrix computation against their numerical propagation. This unit test
+ *  propagates the variational equations for the Earth and Moon, using both a barycentric origin and hierarchical origin.
+ *  For the hierarchical origin, both an Encke and Cowell propagator are used. The results are compared against
+ *  results obtained from numerical differentiation (first-order central difference). *
+ */
+BOOST_AUTO_TEST_CASE( testEarthMoonVariationalEquationCalculation )
+{
+    std::pair< std::vector< Eigen::MatrixXd >, std::vector< Eigen::VectorXd > > currentOutput;
+
+    std::vector< std::vector< std::string > > centralBodiesSet;
+    std::vector< std::string > centralBodies;
+
+    // Define central bodt settings
+    centralBodies.resize( 2 );
+
+    centralBodies[ 0 ] = "SSB";
+    centralBodies[ 1 ] = "SSB";
+    centralBodiesSet.push_back( centralBodies );
+
+    centralBodies[ 0 ] = "Earth";
+    centralBodies[ 1 ] = "Sun";
+    centralBodiesSet.push_back( centralBodies );
+
+
+    // Define variables for numerical differentiation
+    Eigen::Matrix< double, 12, 1>  perturbedState;
+    Eigen::Vector3d perturbedParameter;
+
+    Eigen::Matrix< double, 12, 1> statePerturbation;
+    Eigen::Vector3d parameterPerturbation;
+
+
+    for( unsigned int i = 0; i < centralBodiesSet.size( ); i++ )
+    {
+        // Define parameter perturbation
+        parameterPerturbation  = ( Eigen::Vector3d( ) << 1.0E10, 1.0E10, 1.0E14 ).finished( );
+
+        // Define state perturbation
+        if( i == 0 )
+        {
+            statePerturbation = ( Eigen::Matrix< double, 12, 1>( )<<
+                                  100000.0, 100000.0, 100000.0, 0.1, 0.1, 0.1,
+                                  100000.0, 100000.0, 100000.0, 0.1, 0.1, 0.1 ).finished( );
+        }
+        else if( i == 1 )
+        {
+            statePerturbation = ( Eigen::Matrix< double, 12, 1>( )<<
+                                  100000.0, 100000.0, 100000.0, 0.1, 0.1, 0.1,
+                                  100000.0, 100000.0, 10000000.0, 0.1, 0.1, 10.0 ).finished( );
+        }
+
+        // Only perform Encke propagation is origin is not SSB
+        unsigned int maximumPropagatorType = 1;
+        if( i == 1 )
+        {
+            maximumPropagatorType = 2;
+        }
+
+        // Test for all requested propagator types.
+        for( unsigned int k = 0; k < maximumPropagatorType; k++ )
+        {
+            // Compute state transition and sensitivity matrices
+            currentOutput = executeEarthMoonSimulation< double, double >(
+                        centralBodiesSet[ i ], Eigen::Matrix< double, 12, 1 >::Zero( ), k );
+            Eigen::MatrixXd stateTransitionAndSensitivityMatrixAtEpoch = currentOutput.first.at( 0 );
+            Eigen::MatrixXd manualPartial = Eigen::MatrixXd::Zero( 12, 15 );
+
+            // Numerically compute state transition matrix
+            for( unsigned int j = 0; j < 12; j++ )
+            {
+                Eigen::VectorXd upPerturbedState, downPerturbedState;
+                perturbedState.setZero( );
+                perturbedState( j ) += statePerturbation( j );
+                upPerturbedState = executeEarthMoonSimulation< double, double >(
+                            centralBodiesSet[ i ], perturbedState, k, Eigen::Vector3d::Zero( ), 0 ).second.at( 0 );
+
+                perturbedState.setZero( );
+                perturbedState( j ) -= statePerturbation( j );
+                downPerturbedState = executeEarthMoonSimulation< double, double >(
+                            centralBodiesSet[ i ], perturbedState, k, Eigen::Vector3d::Zero( ), 0 ).second.at( 0 );
+                manualPartial.block( 0, j, 12, 1 ) =
+                        ( upPerturbedState - downPerturbedState ) / ( 2.0 * statePerturbation( j ) );
+            }
+
+            // Numerically compute sensitivity matrix
+            for( unsigned int j = 0; j < 3; j ++ )
+            {
+                Eigen::VectorXd upPerturbedState, downPerturbedState;
+                perturbedState.setZero( );
+                Eigen::Vector3d upPerturbedParameter, downPerturbedParameter;
+                perturbedParameter.setZero( );
+                perturbedParameter( j ) += parameterPerturbation( j );
+                upPerturbedState = executeEarthMoonSimulation< double, double >(
+                            centralBodiesSet[ i ], perturbedState, k, perturbedParameter, 0 ).second.at( 0 );
+
+                perturbedParameter.setZero( );
+                perturbedParameter( j ) -= parameterPerturbation( j );
+                downPerturbedState = executeEarthMoonSimulation< double, double >(
+                            centralBodiesSet[ i ], perturbedState, k, perturbedParameter, 0 ).second.at( 0 );
+                manualPartial.block( 0, j + 12, 12, 1 ) =
+                        ( upPerturbedState - downPerturbedState ) / ( 2.0 * parameterPerturbation( j ) );
+            }
+
+            // Check results
+            TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                        stateTransitionAndSensitivityMatrixAtEpoch.block( 0, 0, 12, 15 ), manualPartial, 2.0E-4 );
+
+        }
+
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+}
+
+}
+
diff --git a/Tudat/Astrodynamics/Propagators/bodyMassStateDerivative.h b/Tudat/Astrodynamics/Propagators/bodyMassStateDerivative.h
new file mode 100644
index 0000000..06e29b8
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/bodyMassStateDerivative.h
@@ -0,0 +1,187 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_BODYMASSSTATEDERIVATIVE_H
+#define TUDAT_BODYMASSSTATEDERIVATIVE_H
+
+#include <vector>
+#include <map>
+#include <string>
+
+#include <boost/shared_ptr.hpp>
+#include <boost/function.hpp>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/massRateModel.h"
+#include "Tudat/Astrodynamics/Propagators/propagationSettings.h"
+#include "Tudat/Astrodynamics/Propagators/singleStateTypeDerivative.h"
+
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+//! Class for computing the derivative of the mass of a set of bodies.
+/*!
+ *  Class for computing the derivative of the mass of a set of bodies. Note that the local and global states are equal
+ *  for mass propagation, both represent the physical body mass (in kg).
+ */
+template< typename StateScalarType = double, typename TimeType = double >
+class BodyMassStateDerivative: public propagators::SingleStateTypeDerivative< StateScalarType, TimeType >
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor, sets the mass rate models and the bodies that are to be propagated
+     * \param massRateModels Map of models per body that are to be used for the mass rate computation.
+     * \param bodiesToIntegrate List of bodies for which the mass is to be propagated. Note that this vector have
+     * more entries than the massRateModels map, as a body's mass can be 'propagated' with no rate model (i.e. constant
+     * mass).
+     */
+    BodyMassStateDerivative(
+            const std::map< std::string, boost::shared_ptr< basic_astrodynamics::MassRateModel > >& massRateModels,
+            const std::vector< std::string >& bodiesToIntegrate ):
+        propagators::SingleStateTypeDerivative< StateScalarType, TimeType >(
+            propagators::body_mass_state ),
+        massRateModels_( massRateModels ), bodiesToIntegrate_( bodiesToIntegrate ){ }
+
+    //! Destructor
+    virtual ~BodyMassStateDerivative( ){ }
+
+    //! Calculates the state derivative of the system of equations for the mass dynamics
+    /*!
+     * Calculates the state derivative of the system of equations for the mass dynamics
+     * The environment and acceleration models (updateStateDerivativeModel) must be
+     * updated before calling this function.
+     * \param time Time at which the state derivative is to be calculated.
+     * \param stateOfSystemToBeIntegrated Current masses of the bodies that are propagated
+     * \param stateDerivative Mass rates of the bodies for which the mass is propagated, in the same order as
+     * bodiesToIntegrate_
+     */
+    void calculateSystemStateDerivative(
+                const TimeType time,
+                const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& stateOfSystemToBeIntegrated,
+                Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > > stateDerivative )
+    {
+        stateDerivative.setZero( );
+
+        // Iterate over all mass rate models, retrieve value and put into corresponding entry.
+        int currentIndex = 0;
+        for( massRateModelIterator_ = massRateModels_.begin( );
+             massRateModelIterator_ != massRateModels_.end( );
+             massRateModelIterator_++ )
+        {
+            stateDerivative( currentIndex, 0 ) = static_cast< StateScalarType >(
+                        massRateModelIterator_->second->getMassRate( ) );
+
+            currentIndex++;
+
+        }
+    }
+
+    //! Function to clear reference/cached values of body mass state derivative model
+    /*!
+     * Function to clear reference/cached values of body mass state derivative model. All mass rate models' current times
+     * are reset to ensure that they are all recalculated.
+     */
+    void clearStateDerivativeModel( )
+    {
+        // Reset all mass rate times (to allow multiple evaluations at same time, e.g. stage 2  and 3 in RK4 integrator)
+        for( massRateModelIterator_ = massRateModels_.begin( );
+             massRateModelIterator_ != massRateModels_.end( );
+             massRateModelIterator_++ )
+        {
+            massRateModelIterator_->second->resetTime( TUDAT_NAN );
+        }
+    }
+
+    //! Function to update the mass state derivative model to the current time.
+    /*!
+     * Function to update the mass state derivative model to the urrent time.
+     * cNote that this function only updates the state derivative model itself, the
+     * environment models must be updated before calling this function
+     * \param currentTime Time to which the mass state derivative is to be updated.
+     */
+    void updateStateDerivativeModel( const TimeType currentTime )
+    {
+
+
+        // Update local variables of mass rate model objects.
+        for( massRateModelIterator_ = massRateModels_.begin( );
+             massRateModelIterator_ != massRateModels_.end( );
+             massRateModelIterator_++ )
+        {
+            massRateModelIterator_->second->updateMembers( static_cast< double >( currentTime ) );
+        }
+    }
+
+    //! Function included for compatibility purposes with base class, local and global representation is equal for mass rate
+    //! model. Function returns (by reference)  input internalSolution.
+    void convertCurrentStateToGlobalRepresentation(
+                const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& internalSolution, const TimeType& time,
+                Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > currentCartesianLocalSoluton )
+    {
+        currentCartesianLocalSoluton = internalSolution;
+    }
+
+    //! Function included for compatibility purposes with base class, input and output representation is equal for mass rate
+    //! model. Function returns input outputSolution.
+    virtual Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > convertFromOutputSolution(
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& outputSolution, const TimeType& time )
+    {
+        return outputSolution;
+    }
+
+    //! Function included for compatibility purposes with base class, input and output representation is equal for mass rate
+    //! model. Function returns  (by reference) input internalSolution.
+    void convertToOutputSolution(
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& internalSolution,
+            const TimeType& time,
+            Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > currentCartesianLocalSoluton )
+    {
+        currentCartesianLocalSoluton = internalSolution;
+    }
+
+    //! Function to get the total size of the state of propagated masses.
+    /*!
+     * Function to get the total size of the state of propagated masses. Equal to number of bodies for which the mass
+     * is propagated.
+     * \return Size of propagated mass state.
+     */
+    virtual int getStateSize( )
+    {
+        return bodiesToIntegrate_.size( );
+    }
+
+private:
+
+    //! Map of models per body that are to be used for the mass rate computation.
+    std::map< std::string, boost::shared_ptr< basic_astrodynamics::MassRateModel > > massRateModels_;
+
+    //! Predefined iterator to save (de-)allocation time.
+    std::map< std::string, boost::shared_ptr< basic_astrodynamics::MassRateModel > >::const_iterator massRateModelIterator_;
+
+    //! List of bodies for which the mass is to be propagated.
+    /*!
+     * List of bodies for which the mass is to be propagated. Note that this vector have
+     * more entries than the massRateModels map, as a body's mass can be 'propagated' with no rate model (i.e. constant
+     * mass).
+     */
+    std::vector< std::string > bodiesToIntegrate_;
+
+};
+
+} // namespace propagators
+
+} // namespace tudat
+
+#endif // TUDAT_BODYMASSSTATEDERIVATIVE_H
diff --git a/Tudat/Astrodynamics/Propagators/centralBodyData.h b/Tudat/Astrodynamics/Propagators/centralBodyData.h
index f396b3f..c245444 100644
--- a/Tudat/Astrodynamics/Propagators/centralBodyData.h
+++ b/Tudat/Astrodynamics/Propagators/centralBodyData.h
@@ -162,6 +162,8 @@ public:
             updateOrder_[ currentUpdateIndex ] = numericalBodies_.at( i );
             currentUpdateIndex++;
         }
+
+        localInternalState_.resize( 6 * bodiesToIntegrate.size( ), 1 );
     }
 
 
@@ -174,33 +176,36 @@ public:
      *  size of bodiesToIntegrate, with entries in the order of the bodies in the bodiesToIntegrate
      *  vector.
      *  \param time Current time (used for retrieving states from ephemerides)
-     *  \param areInputStateLocal True if the internalState vector is given in the local frames of
-     *  the integrated bodies, or the global frame.
-     *  \return Vector of states of the reference frame origins for each body.
+     *  \param referenceFrameOriginStates Vector of states of the reference frame origins for each body
+     *  (returned by reference).
+     *  \param areInputStateLocal True if the internalState vector is given in the local frames of the integrated
+     *   bodies, or the global frame.
      */
-    std::vector<  Eigen::Matrix< StateScalarType, 6, 1 > > getReferenceFrameOriginInertialStates(
-            Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > internalState, const TimeType time,
+    void getReferenceFrameOriginInertialStates(
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& internalState, const TimeType time,
+            std::vector< Eigen::Matrix< StateScalarType, 6, 1 > >& referenceFrameOriginStates,
             const bool areInputStateLocal = true )
     {
-        std::vector< Eigen::Matrix< StateScalarType, 6, 1 > > referenceFrameOriginStates_;
-        referenceFrameOriginStates_.resize( updateOrder_.size( ) );
+        localInternalState_ =  internalState;
+        if( referenceFrameOriginStates.size( ) != updateOrder_.size( ) )\
+        {
+            referenceFrameOriginStates.resize( updateOrder_.size( ) );
+        }
 
         // Update state in correct order.
         for( unsigned int i = 0; i < updateOrder_.size( ); i++ )
         {
-            referenceFrameOriginStates_[ updateOrder_[ i ] ] =
-                    getSingleReferenceFrameOriginInertialState( internalState,
-                                                                time, updateOrder_[ i ] );
+            getSingleReferenceFrameOriginInertialState(
+                        localInternalState_, time, updateOrder_.at( i ),
+                        referenceFrameOriginStates.at( updateOrder_.at( i ) ));
 
             // Modify current input state to global frame if input is local (in propagation frame).
             if( areInputStateLocal )
             {
-                internalState.segment( 6 * updateOrder_[ i ], 6 )
-                    += referenceFrameOriginStates_[ updateOrder_[ i ] ];
+                localInternalState_.segment( 6 * updateOrder_.at( i ), 6 ) +=
+                        referenceFrameOriginStates.at( updateOrder_.at( i ) );
             }
         }
-
-        return referenceFrameOriginStates_;
     }
 
 
@@ -250,6 +255,9 @@ private:
     //! as propagation origin
     std::map< int, int > centralBodiesFromIntegration_;
 
+    //! State of propagated bodies, with the origins translated to the global origin
+    Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > localInternalState_;
+
     //! Function to get the global origin of the propagation center of a single body.
     /*!
      *  Function to get the global origin of the propagation center of a single body, where the
@@ -261,20 +269,19 @@ private:
      *  \sa updateOrder
      *  \param time Current time.
      *  \param bodyIndex Index of the body for which the global origin state is to be retrieved
-     *  \return Global origin state of the requested body.
+     *  \param originState Global origin state of the requested body (returned by reference).
      */
-    Eigen::Matrix< StateScalarType, 6, 1 > getSingleReferenceFrameOriginInertialState(
-            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > internalSolution,
+    void getSingleReferenceFrameOriginInertialState(
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& internalSolution,
             const TimeType time,
-            const int bodyIndex )
+            const int bodyIndex,
+            Eigen::Matrix< StateScalarType, 6, 1 >& originState )
     {
-        Eigen::Matrix< StateScalarType, 6, 1 > originState
-            = Eigen::Matrix< StateScalarType, 6, 1 >::Zero( );
-
         // Check origin type.
         switch( bodyOriginType_[ bodyIndex ] )
         {
         case inertial:
+            originState.setZero( );
             break;
         case from_ephemeris:
             originState
@@ -289,7 +296,6 @@ private:
                               boost::lexical_cast< std::string >( bodyOriginType_[ bodyIndex ] ) );
             break;
         }
-        return originState;
     }
 };
 
diff --git a/Tudat/Astrodynamics/Propagators/createEnvironmentUpdater.cpp b/Tudat/Astrodynamics/Propagators/createEnvironmentUpdater.cpp
index 92a723b..e412891 100644
--- a/Tudat/Astrodynamics/Propagators/createEnvironmentUpdater.cpp
+++ b/Tudat/Astrodynamics/Propagators/createEnvironmentUpdater.cpp
@@ -219,8 +219,11 @@ createTranslationalEquationsOfMotionEnvironmentUpdaterSettings(
                     if( thirdBodyAcceleration != NULL && translationalAccelerationModels.count(
                                 thirdBodyAcceleration->getCentralBodyName( ) ) == 0 )
                     {
-                        singleAccelerationUpdateNeeds[ body_transational_state_update ].push_back(
-                                    thirdBodyAcceleration->getCentralBodyName( ) );
+                        if( translationalAccelerationModels.count( thirdBodyAcceleration->getCentralBodyName( ) ) == 0 )
+                        {
+                            singleAccelerationUpdateNeeds[ body_transational_state_update ].push_back(
+                                        thirdBodyAcceleration->getCentralBodyName( ) );
+                        }
                     }
                     else if( thirdBodyAcceleration == NULL )
                     {
@@ -250,6 +253,16 @@ createTranslationalEquationsOfMotionEnvironmentUpdaterSettings(
                     singleAccelerationUpdateNeeds[ spherical_harmonic_gravity_field_update ].
                         push_back( accelerationModelIterator->first );
                     break;
+                case mutual_spherical_harmonic_gravity:
+                    singleAccelerationUpdateNeeds[ body_rotational_state_update ].push_back(
+                                accelerationModelIterator->first );
+                    singleAccelerationUpdateNeeds[ spherical_harmonic_gravity_field_update ].push_back(
+                                accelerationModelIterator->first );
+                    singleAccelerationUpdateNeeds[ body_rotational_state_update ].push_back(
+                                acceleratedBodyIterator->first );
+                    singleAccelerationUpdateNeeds[ spherical_harmonic_gravity_field_update ].push_back(
+                                acceleratedBodyIterator->first );
+                    break;
                 case third_body_spherical_harmonic_gravity:
                 {
                     singleAccelerationUpdateNeeds[ body_rotational_state_update ].push_back(
@@ -277,7 +290,43 @@ createTranslationalEquationsOfMotionEnvironmentUpdaterSettings(
                     }
                     break;
                 }
+                case third_body_mutual_spherical_harmonic_gravity:
+                {
+                    singleAccelerationUpdateNeeds[ body_rotational_state_update ].push_back(
+                                accelerationModelIterator->first );
+                    singleAccelerationUpdateNeeds[ spherical_harmonic_gravity_field_update ].push_back(
+                                accelerationModelIterator->first );
+                    singleAccelerationUpdateNeeds[ body_rotational_state_update ].push_back(
+                                acceleratedBodyIterator->first );
+                    singleAccelerationUpdateNeeds[ spherical_harmonic_gravity_field_update ].push_back(
+                                acceleratedBodyIterator->first );
+
+                    boost::shared_ptr< gravitation::ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel >
+                            thirdBodyAcceleration = boost::dynamic_pointer_cast<
+                            gravitation::ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel >(
+                                accelerationModelIterator->second.at( i ) );;
+                    if( thirdBodyAcceleration != NULL && translationalAccelerationModels.count(
+                                thirdBodyAcceleration->getCentralBodyName( ) ) == 0  )
+                    {
+                        singleAccelerationUpdateNeeds[ body_transational_state_update ].push_back(
+                                    thirdBodyAcceleration->getCentralBodyName( ) );
+                        singleAccelerationUpdateNeeds[ body_rotational_state_update ].push_back(
+                                    thirdBodyAcceleration->getCentralBodyName( ) );
+                        singleAccelerationUpdateNeeds[ spherical_harmonic_gravity_field_update ].push_back(
+                                    thirdBodyAcceleration->getCentralBodyName( ) );
+                    }
+                    else if( thirdBodyAcceleration == NULL )
+                    {
+                        throw std::runtime_error(
+                                    std::string( "Error, incompatible input (ThirdBodyMutualSphericalHarmonicsGravitational" ) +
+                                    std::string( "AccelerationModel) to createTranslationalEquationsOfMotion ") +
+                                    std::string( "EnvironmentUpdaterSettings" ) );
+                    }
+                    break;
+                }
                 default:
+                    throw std::runtime_error( std::string( "Error when setting acceleration model update needs, model type not recognized: " ) +
+                                              boost::lexical_cast< std::string >( currentAccelerationModelType ) );
                     break;
                 }
 
@@ -295,10 +344,54 @@ createTranslationalEquationsOfMotionEnvironmentUpdaterSettings(
     return environmentModelsToUpdate;
 }
 
+//! Get list of required environment model update settings from mass rate models.
+std::map< propagators::EnvironmentModelsToUpdate, std::vector< std::string > >
+createMassPropagationEnvironmentUpdaterSettings(
+        const std::map< std::string, boost::shared_ptr< basic_astrodynamics::MassRateModel > > massRateModels,
+        const simulation_setup::NamedBodyMap& bodyMap )
+{
+    using namespace basic_astrodynamics;
+    using namespace propagators;
+
+    std::map< propagators::EnvironmentModelsToUpdate,
+              std::vector< std::string > > environmentModelsToUpdate;
+    std::map< propagators::EnvironmentModelsToUpdate,
+              std::vector< std::string > > singleRateModelUpdateNeeds;
+
+    // Iterate over all bodies with mass rate model.
+    for( std::map< std::string, boost::shared_ptr< MassRateModel > >::const_iterator massRateModelIterator =
+         massRateModels.begin( ); massRateModelIterator != massRateModels.end( ); massRateModelIterator++ )
+    {
+        singleRateModelUpdateNeeds.clear( );
+
+        // Identify mass rate type and set required environment update settings.
+        AvailableMassRateModels currentAccelerationModelType =
+                getMassRateModelType( massRateModelIterator->second );
+        switch( currentAccelerationModelType )
+        {
+        case custom:
+            break;
+        default:
+            throw std::runtime_error( std::string( "Error when setting mass rate model update needs, model type not recognized: " ) +
+                                      boost::lexical_cast< std::string >( currentAccelerationModelType ) );
+
+        }
+
+        // Check whether requested updates are possible.
+        checkValidityOfRequiredEnvironmentUpdates( singleRateModelUpdateNeeds, bodyMap );
+
+        // Add requested updates of current acceleration model to
+        // full list of environment updates.
+        addEnvironmentUpdates( environmentModelsToUpdate, singleRateModelUpdateNeeds );
+    }
+
+    return environmentModelsToUpdate;
+
+}
 
 //! Function to create 'brute-force' update settings, in which each environment model is updated.
 std::map< propagators::EnvironmentModelsToUpdate,
-          std::vector< std::string > > createFullEnvironmentUpdaterSettings(
+std::vector< std::string > > createFullEnvironmentUpdaterSettings(
         const simulation_setup::NamedBodyMap& bodyMap )
 {
     using namespace basic_astrodynamics;
diff --git a/Tudat/Astrodynamics/Propagators/createEnvironmentUpdater.h b/Tudat/Astrodynamics/Propagators/createEnvironmentUpdater.h
index cc1863c..f57d347 100644
--- a/Tudat/Astrodynamics/Propagators/createEnvironmentUpdater.h
+++ b/Tudat/Astrodynamics/Propagators/createEnvironmentUpdater.h
@@ -62,6 +62,18 @@ createTranslationalEquationsOfMotionEnvironmentUpdaterSettings(
         const basic_astrodynamics::AccelerationMap& translationalAccelerationModels,
         const simulation_setup::NamedBodyMap& bodyMap );
 
+//! Get list of required environment model update settings from mass rate models.
+/*!
+ * Get list of required environment model update settings from mass rate models.
+ * \param massRateModels List of mass rate models used in simulation.
+ * \param bodyMap List of body objects used in the simulations.
+ * \return List of required environment model update settings.
+ */
+std::map< propagators::EnvironmentModelsToUpdate, std::vector< std::string > >
+createMassPropagationEnvironmentUpdaterSettings(
+        const std::map< std::string, boost::shared_ptr< basic_astrodynamics::MassRateModel > > massRateModels,
+        const simulation_setup::NamedBodyMap& bodyMap );
+
 //! Get list of required environment model update settings from a list of propagation settings.
 /*!
 * Get list of required environment model update settings from a list of propagation settings.
@@ -82,6 +94,42 @@ std::map< propagators::EnvironmentModelsToUpdate,
     // Check dynamics type
     switch( propagatorSettings->stateType_ )
     {
+    case hybrid:
+    {
+        // Cast to derived type
+        boost::shared_ptr< MultiTypePropagatorSettings< StateScalarType > > multiTypePropagatorSettings =
+                boost::dynamic_pointer_cast< MultiTypePropagatorSettings< StateScalarType > >( propagatorSettings );
+
+        // Iterate over all propagation settings in hybrid model
+        std::map< propagators::EnvironmentModelsToUpdate, std::vector< std::string > > singleAccelerationUpdateNeeds;
+
+        for( typename std::map< IntegratedStateType,
+             std::vector< boost::shared_ptr< PropagatorSettings< StateScalarType > > > >::const_iterator
+             typeIterator = multiTypePropagatorSettings->propagatorSettingsMap_.begin( );
+             typeIterator != multiTypePropagatorSettings->propagatorSettingsMap_.end( ); typeIterator++ )
+        {
+            for( unsigned int i = 0; i < typeIterator->second.size( ); i++ )
+            {
+                // Create current propagation model from settings list (must not be hybrid).
+                if( typeIterator->first != hybrid )
+                {
+                    singleAccelerationUpdateNeeds = createEnvironmentUpdaterSettings< StateScalarType >(
+                                typeIterator->second.at( i ), bodyMap );
+
+                    // Add single model environment model update settings to full list
+                    checkValidityOfRequiredEnvironmentUpdates( singleAccelerationUpdateNeeds, bodyMap );
+                    addEnvironmentUpdates( environmentModelsToUpdate, singleAccelerationUpdateNeeds );
+                }
+                else
+                {
+                    throw std::runtime_error(
+                                "Error when making environment updater type list, cannot handle hybrid propagator inside hybrid propagator" );
+                }
+            }
+        }
+        break;
+    }
+    // Retrieve environment model settings for translational dynamics
     case transational_state:
     {
         environmentModelsToUpdate = createTranslationalEquationsOfMotionEnvironmentUpdaterSettings(
@@ -91,6 +139,15 @@ std::map< propagators::EnvironmentModelsToUpdate,
                     bodyMap );
         break;
     }
+    // Retrieve environment model settings for mass rate model
+    case body_mass_state:
+    {
+        environmentModelsToUpdate = createMassPropagationEnvironmentUpdaterSettings(
+                    boost::dynamic_pointer_cast<
+                    MassPropagatorSettings< StateScalarType > >(
+                        propagatorSettings )->massRateModels_, bodyMap );
+        break;
+    }
     default:
     {
         throw std::runtime_error( "Error, cannot create environment updates for type " +
diff --git a/Tudat/Astrodynamics/Propagators/createStateDerivativeModel.cpp b/Tudat/Astrodynamics/Propagators/createStateDerivativeModel.cpp
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/createStateDerivativeModel.cpp
@@ -0,0 +1 @@
+
diff --git a/Tudat/Astrodynamics/Propagators/createStateDerivativeModel.h b/Tudat/Astrodynamics/Propagators/createStateDerivativeModel.h
index cf962a2..016fa1e 100644
--- a/Tudat/Astrodynamics/Propagators/createStateDerivativeModel.h
+++ b/Tudat/Astrodynamics/Propagators/createStateDerivativeModel.h
@@ -11,9 +11,14 @@
 #ifndef TUDAT_CREATESTATEDERIVATIVEMODEL_H
 #define TUDAT_CREATESTATEDERIVATIVEMODEL_H
 
+#include <boost/bind.hpp>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h"
 #include "Tudat/Astrodynamics/Propagators/singleStateTypeDerivative.h"
 #include "Tudat/Astrodynamics/Propagators/propagationSettings.h"
 #include "Tudat/Astrodynamics/Propagators/nBodyCowellStateDerivative.h"
+#include "Tudat/Astrodynamics/Propagators/nBodyEnckeStateDerivative.h"
+#include "Tudat/Astrodynamics/Propagators/bodyMassStateDerivative.h"
 #include "Tudat/SimulationSetup/body.h"
 
 namespace tudat
@@ -94,14 +99,16 @@ boost::shared_ptr< CentralBodyData< StateScalarType, TimeType > > createCentralB
  *  propagation settings and environment.
  *  \param translationPropagatorSettings Settings for the translational dynamics model.
  *  \param bodyMap List of body objects in the environment
+ *  \param propagationStartTime Time from which numerical propagation starts.
  *  \return Translational state derivative model (instance of derived class of NBodyStateDerivative)
  */
 template< typename StateScalarType = double, typename TimeType = double >
 boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > >
-                                     createTranslationalStateDerivativeModel(
+createTranslationalStateDerivativeModel(
         const boost::shared_ptr< TranslationalStatePropagatorSettings< StateScalarType > >
-            translationPropagatorSettings,
-        const  simulation_setup::NamedBodyMap& bodyMap )
+        translationPropagatorSettings,
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const TimeType propagationStartTime )
 {
 
     // Create object for frame origin transformations.
@@ -124,6 +131,31 @@ boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > >
                   translationPropagatorSettings->bodiesToIntegrate_ );
         break;
     }
+    case encke:
+    {
+        // Calculate initial Kepler elements for Encke propagator
+        std::vector< Eigen::Matrix< StateScalarType, 6, 1 > > initialKeplerElements;
+        initialKeplerElements.resize( translationPropagatorSettings->bodiesToIntegrate_.size( ) );
+        std::vector< std::string > centralBodies = translationPropagatorSettings->centralBodies_;
+
+        for( unsigned int i = 0; i < translationPropagatorSettings->bodiesToIntegrate_.size( ); i++ )
+        {
+            if( bodyMap.count( centralBodies[ i ] ) == 0 )
+            {
+                std::cerr<<"Error when creating Encke propagator, did not find central body "<<centralBodies[ i ]<<std::endl;
+            }
+            initialKeplerElements[ i ] = orbital_element_conversions::convertCartesianToKeplerianElements< StateScalarType >(
+                        translationPropagatorSettings->getInitialStates( ).segment( i * 6, 6 ), static_cast< StateScalarType >(
+                            bodyMap.at( centralBodies[ i ] )->getGravityFieldModel( )->getGravitationalParameter( ) ) );
+        }
+
+        // Create Encke state derivative object.
+        stateDerivativeModel = boost::make_shared< NBodyEnckeStateDerivative< StateScalarType, TimeType > >
+                ( translationPropagatorSettings->accelerationsMap_, centralBodyData, translationPropagatorSettings->bodiesToIntegrate_,
+                  initialKeplerElements, propagationStartTime );
+
+        break;
+    }
     default:
         throw std::runtime_error(
             "Error, did not recognize translational state propagation type: " +
@@ -132,18 +164,37 @@ boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > >
     return stateDerivativeModel;
 }
 
+//! Function to create a mass state derivative model.
+/*!
+ *  Function to create a mass state derivative model from propagation settings and environment.
+ *  \param massPropagatorSettings Settings for the mass dynamics model.
+ *  \param bodyMap List of body objects in the environment
+ *  \return Mass state derivative model.
+ */
+template< typename StateScalarType = double, typename TimeType = double >
+boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > createBodyMassStateDerivativeModel(
+        const boost::shared_ptr< MassPropagatorSettings< StateScalarType > > massPropagatorSettings,
+        const  simulation_setup::NamedBodyMap& bodyMap )
+{
+    return boost::make_shared< propagators::BodyMassStateDerivative< StateScalarType, TimeType > >(
+                massPropagatorSettings->massRateModels_,
+                massPropagatorSettings->bodiesWithMassToPropagate_ );
+}
+
 //! Function to create a state derivative model.
 /*!
  *  Function to create a state derivative model from propagation settings and the environment.
  *  \param propagatorSettings Settings for the dynamical model.
  *  \param bodyMap List of body objects in the environment
+ *  \param propagationStartTime Time from which numerical propagation starts.
  *  \return State derivative model (instance of required derived class of SingleStateTypeDerivative)
  */
 template< typename StateScalarType = double, typename TimeType = double >
 boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > >
-                                     createStateDerivativeModel(
+createStateDerivativeModel(
         const boost::shared_ptr< PropagatorSettings< StateScalarType > > propagatorSettings,
-        const simulation_setup::NamedBodyMap& bodyMap )
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const TimeType propagationStartTime )
 {
     boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > stateDerivativeModel;
 
@@ -155,9 +206,9 @@ boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > >
     {
         // Check input consistency.
         boost::shared_ptr< TranslationalStatePropagatorSettings< StateScalarType > >
-            translationPropagatorSettings =
+                translationPropagatorSettings =
                 boost::dynamic_pointer_cast<
-            TranslationalStatePropagatorSettings< StateScalarType > >( propagatorSettings );
+                TranslationalStatePropagatorSettings< StateScalarType > >( propagatorSettings );
         if( translationPropagatorSettings == NULL )
         {
             throw std::runtime_error(
@@ -166,7 +217,24 @@ boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > >
         else
         {
             stateDerivativeModel = createTranslationalStateDerivativeModel< StateScalarType, TimeType >(
-                        translationPropagatorSettings, bodyMap );
+                        translationPropagatorSettings, bodyMap, propagationStartTime );
+        }
+        break;
+    }
+    case body_mass_state:
+    {
+        // Check input consistency.
+        boost::shared_ptr< MassPropagatorSettings< StateScalarType > > massPropagatorSettings =
+                boost::dynamic_pointer_cast< MassPropagatorSettings< StateScalarType > >( propagatorSettings );
+        if( massPropagatorSettings == NULL )
+        {
+            throw std::runtime_error(
+                "Error, expected mass propagation settings when making state derivative model" );
+        }
+        else
+        {
+            stateDerivativeModel = createBodyMassStateDerivativeModel< StateScalarType, TimeType >(
+                        massPropagatorSettings, bodyMap );
         }
         break;
     }
@@ -184,15 +252,17 @@ boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > >
  *  Function to create a list of state derivative models from
  *  propagation settings and the environment.
  *  \param propagatorSettings Settings for the dynamical model.
- *  \param bodyMap List of body objects in the environment
+ *  \param bodyMap List of body objects in the environment.
+ *  \param propagationStartTime Time from which numerical propagation starts.
  *  \return List of state derivative models (instances of required
  *  derived class of SingleStateTypeDerivative)
  */
 template< typename StateScalarType = double, typename TimeType = double >
 std::vector< boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > >
-                                     createStateDerivativeModels(
+createStateDerivativeModels(
         const boost::shared_ptr< PropagatorSettings< StateScalarType > > propagatorSettings,
-        const simulation_setup::NamedBodyMap& bodyMap )
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const TimeType propagationStartTime )
 {
     std::vector< boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > >
     stateDerivativeModels;
@@ -200,9 +270,39 @@ std::vector< boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, Time
     // Check type of state derivative model and call associated create function.
     switch( propagatorSettings->stateType_ )
     {
+    // If hybrid, call create function separately for each entry.
+    case hybrid:
+    {
+        boost::shared_ptr< MultiTypePropagatorSettings< StateScalarType > > multiTypePropagatorSettings =
+                boost::dynamic_pointer_cast< MultiTypePropagatorSettings< StateScalarType > >( propagatorSettings );
+
+        // Iterate over all propagation settings
+        for( typename std::map< IntegratedStateType,
+             std::vector< boost::shared_ptr< PropagatorSettings< StateScalarType > > > >::iterator
+             propagatorIterator = multiTypePropagatorSettings->propagatorSettingsMap_.begin( );
+             propagatorIterator != multiTypePropagatorSettings->propagatorSettingsMap_.end( ); propagatorIterator++ )
+        {
+            for( unsigned int i = 0; i < propagatorIterator->second.size( ); i++ )
+            {
+                // Call create function for current propagation settings.
+                if( propagatorIterator->first != hybrid )
+                {
+                    stateDerivativeModels.push_back( createStateDerivativeModel< StateScalarType, TimeType >(
+                                                         propagatorIterator->second.at( i ), bodyMap, propagationStartTime ) );
+                }
+                else
+                {
+                    throw std::runtime_error(
+                                "Error when making state derivative model, cannot process nested hybrid propagators" );
+                }
+            }
+        }
+        break;
+    }
+    // If not hybrid, call create function for single object directly.
     default:
         stateDerivativeModels.push_back( createStateDerivativeModel< StateScalarType, TimeType >(
-                                             propagatorSettings, bodyMap ) );
+                                             propagatorSettings, bodyMap, propagationStartTime ) );
     }
 
     return stateDerivativeModels;
diff --git a/Tudat/Astrodynamics/Propagators/dynamicsSimulator.h b/Tudat/Astrodynamics/Propagators/dynamicsSimulator.h
index 806906d..53ca7af 100644
--- a/Tudat/Astrodynamics/Propagators/dynamicsSimulator.h
+++ b/Tudat/Astrodynamics/Propagators/dynamicsSimulator.h
@@ -40,17 +40,15 @@ namespace tudat
 namespace propagators
 {
 
-//! Function to get the states of a set of bodies
+//! Function to get the states of a set of bodies, w.r.t. some set of central bodies, at the requested time.
 /*!
-* Function to get the states of a set of bodies, w.r.t. some set of
-* central bodies, at the requested time.
+* Function to get the states of a set of bodies, w.r.t. some set of central bodies, at the requested time.
 * \param bodiesToIntegrate List of bodies for which to retrieve state.
 * \param centralBodies Origins w.r.t. which to retrieve states of bodiesToIntegrate.
 * \param bodyMap List of bodies to use in simulations.
 * \param initialTime Time at which to retrieve states.
 * \param frameManager OBject with which to calculate frame origin translations.
-* \return Initial state vector (with 6 Cartesian elements per body, in
-* order of bodiesToIntegrate vector).
+* \return Initial state vector (with 6 Cartesian elements per body, in order of bodiesToIntegrate vector).
 */
 template< typename TimeType = double, typename StateScalarType = double >
 Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > getInitialStatesOfBodies(
@@ -62,8 +60,7 @@ Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > getInitialStatesOfBodies(
 {
     // Set initial states of bodies to integrate.
     Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > systemInitialState =
-            Eigen::Matrix< StateScalarType,
-            Eigen::Dynamic, 1 >::Zero( bodiesToIntegrate.size( ) * 6, 1 );
+            Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >::Zero( bodiesToIntegrate.size( ) * 6, 1 );
     boost::shared_ptr< ephemerides::Ephemeris > ephemerisOfCurrentBody;
 
     // Iterate over all bodies.
@@ -72,35 +69,30 @@ Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > getInitialStatesOfBodies(
         ephemerisOfCurrentBody = bodyMap.at( bodiesToIntegrate.at( i ) )->getEphemeris( );
 
         // Get body initial state from ephemeris
-        systemInitialState.segment( i * 6 , 6 )
-            = ephemerisOfCurrentBody->getTemplatedStateFromEphemeris<
+        systemInitialState.segment( i * 6 , 6 ) = ephemerisOfCurrentBody->getTemplatedStateFromEphemeris<
                 StateScalarType, TimeType >( initialTime );
 
         // Correct initial state if integration origin and ephemeris origin are not equal.
         if( centralBodies.at( i ) != ephemerisOfCurrentBody->getReferenceFrameOrigin( ) )
         {
-            boost::shared_ptr< ephemerides::Ephemeris > correctionEphemeris
-                = frameManager->getEphemeris( ephemerisOfCurrentBody->getReferenceFrameOrigin( ),
-                                              centralBodies.at( i ) );
-            systemInitialState.segment( i * 6 , 6 )
-                -= correctionEphemeris->getTemplatedStateFromEphemeris<
+            boost::shared_ptr< ephemerides::Ephemeris > correctionEphemeris =
+                    frameManager->getEphemeris( ephemerisOfCurrentBody->getReferenceFrameOrigin( ), centralBodies.at( i ) );
+            systemInitialState.segment( i * 6 , 6 ) -= correctionEphemeris->getTemplatedStateFromEphemeris<
                     StateScalarType, TimeType >( initialTime );
         }
     }
     return systemInitialState;
 }
 
-//! Function to get the states of a set of bodies
+//! Function to get the states of a set of bodies, w.r.t. some set of central bodies, at the requested time.
 /*!
-* Function to get the states of a set of bodies, w.r.t. some set of
-* central bodies, at the requested time, creates
+* Function to get the states of a set of bodies, w.r.t. some set of central bodies, at the requested time, creates
 * frameManager from input data.
 * \param bodiesToIntegrate List of bodies for which to retrieve state.
 * \param centralBodies Origins w.r.t. which to retrieve states of bodiesToIntegrate.
 * \param bodyMap List of bodies to use in simulations.
 * \param initialTime Time at which to retrieve states.
-* \return Initial state vector (with 6 Cartesian elements per body, in
-* order of bodiesToIntegrate vector).
+* \return Initial state vector (with 6 Cartesian elements per body, in order of bodiesToIntegrate vector).
 */
 template< typename TimeType = double, typename StateScalarType = double >
 Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > getInitialStatesOfBodies(
@@ -111,15 +103,13 @@ Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > getInitialStatesOfBodies(
 {
     // Create ReferenceFrameManager and call overloaded function.
     return getInitialStatesOfBodies( bodiesToIntegrate, centralBodies, bodyMap, initialTime,
-                                     boost::make_shared< ephemerides::ReferenceFrameManager >
-                                     ( bodyMap ) );
+                                     boost::make_shared< ephemerides::ReferenceFrameManager >( bodyMap ) );
 }
 
-//! Function to get the states of bodyToIntegrate
+//! Function to get the states of single body, w.r.t. some central body, at the requested time.
 /*!
-* Function to get the states of single, w.r.t. some set of central
-* body, at the requested time., creates
-* frameManager from input data.
+* Function to get the states of  single body, w.r.t. some central body, at the requested time. This function creates
+* frameManager from input data to perform all required conversions.
 * \param bodyToIntegrate Bodies for which to retrieve state
 * \param centralBody Origins w.r.t. which to retrieve state of bodyToIntegrate.
 * \param bodyMap List of bodies to use in simulations.
@@ -134,17 +124,15 @@ Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > getInitialStateOfBody(
         const TimeType initialTime )
 {
     return getInitialStatesOfBodies< TimeType, StateScalarType >(
-                boost::assign::list_of( bodyToIntegrate ), boost::assign::list_of( centralBody ),
-                bodyMap, initialTime );
+                boost::assign::list_of( bodyToIntegrate ), boost::assign::list_of( centralBody ), bodyMap, initialTime );
 }
 
 //! Base class for performing full numerical integration of a dynamical system.
 /*!
- *  Base class for performing full numerical integration of a
- *  dynamical system. Governing equations are set once,
+ *  Base class for performing full numerical integration of a dynamical system. Governing equations are set once,
  *  but can be re-integrated for different initial conditions using the same instance of the class.
  *  Derived classes define the specific kind of integration that is performed
- *  (single-arc/multi-arc; dynamics/variational equations, etc.)
+ *  (single-arc/multi-arc/etc.)
  */
 template< typename StateScalarType = double, typename TimeType = double >
 class DynamicsSimulator
@@ -153,33 +141,29 @@ public:
 
     //! Constructor of simulator.
     /*!
-     *  Constructor of simulator, constructs integrator and object for
-     *  calculating each time step of integration.
+     *  Constructor of simulator, constructs integrator and object for calculating each time step of integration.
      *  \param bodyMap Map of bodies (with names) of all bodies in integration.
      *  \param integratorSettings Settings for numerical integrator.
      *  \param propagatorSettings Settings for propagator.
-     *  \param clearNumericalSolutions Boolean to determine whether to
-     *  clear the raw numerical solution member variables (default true)
-     *  after propagation and resetting ephemerides.
-     *  \param setIntegratedResult Boolean to determine whether to (default true).
-     *  automatically use the integrated results to set ephemerides.
+     *  \param clearNumericalSolutions Boolean to determine whether to clear the raw numerical solution member variables
+     *  after propagation and resetting ephemerides (default true).
+     *  \param setIntegratedResult Boolean to determine whether to automatically use the integrated results to set
+     *  ephemerides (default true).
      */
     DynamicsSimulator(
             const  simulation_setup::NamedBodyMap& bodyMap,
-            const boost::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > >
-                integratorSettings,
+            const boost::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > > integratorSettings,
             const boost::shared_ptr< PropagatorSettings< StateScalarType > > propagatorSettings,
             const bool clearNumericalSolutions = true,
             const bool setIntegratedResult = true ):
         bodyMap_( bodyMap ), integratorSettings_( integratorSettings ),
-        propagatorSettings_( propagatorSettings ),
-        clearNumericalSolutions_( clearNumericalSolutions ),
+        propagatorSettings_( propagatorSettings ), clearNumericalSolutions_( clearNumericalSolutions ),
         setIntegratedResult_( setIntegratedResult )
     {
-        frameManager_ = boost::make_shared< ephemerides::ReferenceFrameManager >( bodyMap );
 
-        if( setIntegratedResult )
+        if( setIntegratedResult_ )
         {
+            frameManager_ = boost::make_shared< ephemerides::ReferenceFrameManager >( bodyMap );
             integratedStateProcessors_ = createIntegratedStateProcessors< TimeType, StateScalarType >(
                         propagatorSettings_, bodyMap_, frameManager_ );
         }
@@ -188,10 +172,23 @@ public:
                     propagatorSettings_, bodyMap_ );
         dynamicsStateDerivative_ = boost::make_shared< DynamicsStateDerivativeModel< TimeType, StateScalarType > >(
                     createStateDerivativeModels< StateScalarType, TimeType >(
-                        propagatorSettings_, bodyMap_ ), environmentUpdater_ );
+                        propagatorSettings_, bodyMap_, integratorSettings_->initialTime_  ), environmentUpdater_ );
+        propagationTerminationCondition_ = createPropagationTerminationConditions(
+                    propagatorSettings->getTerminationSettings( ), bodyMap_, integratorSettings->initialTimeStep_ );
+
+        if( propagatorSettings_->getDependentVariablesToSave( ) != NULL )
+        {
+            dependentVariablesFunctions_ =
+                    createDependentVariableListFunction(
+                        propagatorSettings_->getDependentVariablesToSave( ), bodyMap_,
+                        dynamicsStateDerivative_->getStateDerivativeModels( ) );
+        }
+
         stateDerivativeFunction_ =
-                boost::bind( &DynamicsStateDerivativeModel
-                             < TimeType, StateScalarType >::computeStateDerivative,
+                boost::bind( &DynamicsStateDerivativeModel< TimeType, StateScalarType >::computeStateDerivative,
+                             dynamicsStateDerivative_, _1, _2 );
+        doubleStateDerivativeFunction_ =
+                boost::bind( &DynamicsStateDerivativeModel< TimeType, StateScalarType >::computeStateDoubleDerivative,
                              dynamicsStateDerivative_, _1, _2 );
     }
 
@@ -200,26 +197,22 @@ public:
 
     //! This function numerically (re-)integrates the equations of motion.
     /*!
-     *  This function numerically (re-)integrates the equations of motion, using the settings set
-     *  through the constructor and a new initial state vector provided here. The raw results are
-     *  set in the equationsOfMotionNumericalSolution_
-     *  \param initialGlobalStates Initial state vector that is to be used for numerical
-     *  integration.  Note that this state should be in the correct frame (i.e. corresponding to
-     *  centralBodies in propagatorSettings_), but not in the propagator-specific form (i.e Encke,
-     *  Gauss, etc. for translational dynamics)
-     *  \sa SingleStateTypeDerivative::convertToOutputSolution
+     *  This function numerically (re-)integrates the equations of motion, using the settings set through the constructor
+     *  and a new initial state vector provided here. The raw results are set in the equationsOfMotionNumericalSolution_
+     *  \param initialGlobalStates Initial state vector that is to be used for numerical integration.
+     *  Note that this state should be in the correct frame (i.e. corresponding to centralBodies in propagatorSettings_),
+     *  but not in the propagator-specific form (i.e Encke, Gauss, etc. for translational dynamics)
+     * \sa SingleStateTypeDerivative::convertToOutputSolution
      */
     virtual void integrateEquationsOfMotion(
-            const Eigen::Matrix< StateScalarType,
-            Eigen::Dynamic, Eigen::Dynamic >& initialGlobalStates ) = 0;
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& initialGlobalStates ) = 0;
 
     //! Function to get the settings for the numerical integrator.
     /*!
      * Function to get the settings for the numerical integrator.
      * \return The settings for the numerical integrator.
      */
-    boost::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > >
-            getIntegratorSettings( )
+    boost::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > > getIntegratorSettings( )
     {
         return integratorSettings_;
     }
@@ -236,6 +229,18 @@ public:
         return stateDerivativeFunction_;
     }
 
+    //! Function to get the function that performs a single state derivative function evaluation with double precision.
+    /*!
+     * Function to get the function that performs a single state derivative function evaluation with double precision,
+     * regardless of template arguments.
+     * \return Function that performs a single state derivative function evaluation with double precision.
+     */
+    boost::function< Eigen::Matrix< double, Eigen::Dynamic, Eigen::Dynamic >
+    ( const double, const Eigen::Matrix< double, Eigen::Dynamic, Eigen::Dynamic >& ) > getDoubleStateDerivativeFunction( )
+    {
+        return doubleStateDerivativeFunction_;
+    }
+
     //! Function to get the settings for the propagator.
     /*!
      * Function to get the settings for the propagator.
@@ -246,11 +251,10 @@ public:
         return propagatorSettings_;
     }
 
-    //! Function to get the object that updates the environment
+    //! Function to get the object that updates the environment.
     /*!
-     * Function to get the object responsible for updating the environment based on the current
-     * state and time.
-     * \return Object resposible for updating the environment based on the current state and time.
+     * Function to get the object responsible for updating the environment based on the current state and time.
+     * \return Object responsible for updating the environment based on the current state and time.
      */
     boost::shared_ptr< EnvironmentUpdater< StateScalarType, TimeType > > getEnvironmentUpdater( )
     {
@@ -259,13 +263,10 @@ public:
 
     //! Function to get the object that updates and returns state derivative
     /*!
-     * Function to get the object that updates current environment and returns state derivative from
-     * single function call.
-     * \return Object that updates current environment and returns state derivative from single
-     * function call
+     * Function to get the object that updates current environment and returns state derivative from single function call
+     * \return Object that updates current environment and returns state derivative from single function call
      */
-    boost::shared_ptr< DynamicsStateDerivativeModel< TimeType, StateScalarType > >
-        getDynamicsStateDerivative( )
+    boost::shared_ptr< DynamicsStateDerivativeModel< TimeType, StateScalarType > > getDynamicsStateDerivative( )
     {
         return dynamicsStateDerivative_;
     }
@@ -280,47 +281,52 @@ public:
         return bodyMap_;
     }
 
+    boost::shared_ptr< PropagationTerminationCondition > getPropagationTerminationCondition( )
+    {
+        return propagationTerminationCondition_;
+    }
+
 protected:
 
     //! This function updates the environment with the numerical solution of the propagation.
     /*!
-     *  This function updates the environment with the numerical solution of the propagation. For
-     *  instance, it sets the propagated translational dynamics solution as the new input for the
-     *  Ephemeris object of the body that was propagated. This function is pure virtual and must be
-     *  implemented in the derived class.
+     *  This function updates the environment with the numerical solution of the propagation. For instance, it sets
+     *  the propagated translational dynamics solution as the new input for the Ephemeris object of the body that was
+     *  propagated. This function is pure virtual and must be implemented in the derived class.
      */
     virtual void processNumericalEquationsOfMotionSolution( ) = 0;
 
-    //! List of object (per dynamics type) that process the integrated numerical solution by
-    //! updating the environment
+    //! List of object (per dynamics type) that process the integrated numerical solution by updating the environment
     std::map< IntegratedStateType, std::vector< boost::shared_ptr<
     IntegratedStateProcessor< TimeType, StateScalarType > > > > integratedStateProcessors_;
 
     //! Object responsible for updating the environment based on the current state and time.
     /*!
-
-     *  Object responsible for updating the environment based on the current state and time. Calling
-     * the updateEnvironment function automatically updates all dependent variables that are needed
-     * to calulate the state derivative.
+     *  Object responsible for updating the environment based on the current state and time. Calling the updateEnvironment
+     * function automatically updates all dependent variables that are needed to calulate the state derivative.
      */
     boost::shared_ptr< EnvironmentUpdater< StateScalarType, TimeType > > environmentUpdater_;
 
-    //! Interface object that updates current environment and returns state derivative from single
-    //! function call.
-    boost::shared_ptr< DynamicsStateDerivativeModel< TimeType, StateScalarType > >
-        dynamicsStateDerivative_;
+    //! Interface object that updates current environment and returns state derivative from single function call.
+    boost::shared_ptr< DynamicsStateDerivativeModel< TimeType, StateScalarType > > dynamicsStateDerivative_;
 
     //! Function that performs a single state derivative function evaluation.
     /*!
-     *  Function that performs a single state derivative function evaluation, will typically be set
-     *  to DynamicsStateDerivativeModel< TimeType, StateScalarType >::computeStateDerivative
-     *  function.  Calling this function will first update the environment (using
-     *  environmentUpdater_) and then calculate the full system state derivative.
+     *  Function that performs a single state derivative function evaluation, will typically be set to
+     *  DynamicsStateDerivativeModel< TimeType, StateScalarType >::computeStateDerivative function.
+     *  Calling this function will first update the environment (using environmentUpdater_) and then calculate the
+     *  full system state derivative.
      */
     boost::function< Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >
-    ( const TimeType, const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& ) >
-    stateDerivativeFunction_;
+    ( const TimeType, const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& ) > stateDerivativeFunction_;
 
+    //! Function that performs a single state derivative function evaluation with double precision.
+    /*!
+     *  Function that performs a single state derivative function evaluation with double precision
+     *  \sa stateDerivativeFunction_
+     */
+    boost::function< Eigen::Matrix< double, Eigen::Dynamic, Eigen::Dynamic >
+    ( const double, const Eigen::Matrix< double, Eigen::Dynamic, Eigen::Dynamic >& ) > doubleStateDerivativeFunction_;
 
     //!  Map of bodies (with names) of all bodies in integration.
     simulation_setup::NamedBodyMap bodyMap_;
@@ -331,11 +337,15 @@ protected:
     //! Settings for propagator.
     boost::shared_ptr< PropagatorSettings< StateScalarType > > propagatorSettings_;
 
+    boost::shared_ptr< PropagationTerminationCondition > propagationTerminationCondition_;
+
+    boost::function< Eigen::VectorXd( ) > dependentVariablesFunctions_;
+
     //! Object for retrieving ephemerides for transformation of reference frame (origins)
     boost::shared_ptr< ephemerides::ReferenceFrameManager > frameManager_;
 
-    //! Boolean to determine whether to clear the raw numerical solution member variables after
-    //! propagation and resetting ephemerides.
+    //! Boolean to determine whether to clear the raw numerical solution member variables after propagation and
+    //! resetting ephemerides.
     bool clearNumericalSolutions_;
 
     //! Boolean to determine whether to automatically use the integrated results to set ephemerides.
@@ -344,13 +354,12 @@ protected:
 
 };
 
-//! Class for performing full numerical integration of a dynamical system in a single arc..
+//! Class for performing full numerical integration of a dynamical system in a single arc.
 /*!
- *  Class for performing full numerical integration of a dynamical system in a single arc, i.e. the
- *  equations of motion have a single initial time, and are propagated once for the full prescribed
- *  time interval. This is in contrast to multi-arc dynamics, where the time interval si cut into
- *  pieces. In this class, the governing equations are set once, but can be re-integrated for
- *  different initial conditions using the same instance of the class.
+ *  Class for performing full numerical integration of a dynamical system in a single arc, i.e. the equations of motion
+ *  have a single initial time, and are propagated once for the full prescribed time interval. This is in contrast to
+ *  multi-arc dynamics, where the time interval si cut into pieces. In this class, the governing equations are set once,
+ *  but can be re-integrated for different initial conditions using the same instance of the class.
  */
 template< typename StateScalarType = double, typename TimeType = double >
 class SingleArcDynamicsSimulator: public DynamicsSimulator< StateScalarType, TimeType >
@@ -366,33 +375,32 @@ public:
     using DynamicsSimulator< StateScalarType, TimeType >::integratorSettings_;
     using DynamicsSimulator< StateScalarType, TimeType >::propagatorSettings_;
     using DynamicsSimulator< StateScalarType, TimeType >::integratedStateProcessors_;
+    using DynamicsSimulator< StateScalarType, TimeType >::propagationTerminationCondition_;
+    using DynamicsSimulator< StateScalarType, TimeType >::dependentVariablesFunctions_;
 
 
     //! Constructor of simulator.
     /*!
-     *  Constructor of simulator, constructs integrator and object for calculating each time step of
-     *  integration.
+     *  Constructor of simulator, constructs integrator and object for calculating each time step of integration.
      *  \param bodyMap Map of bodies (with names) of all bodies in integration.
      *  \param integratorSettings Settings for numerical integrator.
      *  \param propagatorSettings Settings for propagator.
-     *  \param areEquationsOfMotionToBeIntegrated Boolean to denote whether equations of motion
-     *  should be integrated immediately at the end of the contructor or not.
-     *  \param clearNumericalSolutions Boolean to determine whether to clear the raw numerical
-     *  solution member variables after propagation and resetting ephemerides.
-     *  \param setIntegratedResult Boolean to determine whether to automatically use the integrated
-     *  results to set ephemerides.
+     *  \param areEquationsOfMotionToBeIntegrated Boolean to denote whether equations of motion should be integrated
+     *  immediately at the end of the contructor or not (default true).
+     *  \param clearNumericalSolutions Boolean to determine whether to clear the raw numerical solution member variables
+     *  after propagation and resetting ephemerides (default true).
+     *  \param setIntegratedResult Boolean to determine whether to automatically use the integrated results to set
+     *  ephemerides (default true).
      */
     SingleArcDynamicsSimulator(
             const  simulation_setup::NamedBodyMap& bodyMap,
-            const boost::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > >
-                integratorSettings,
+            const boost::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > > integratorSettings,
             const boost::shared_ptr< PropagatorSettings< StateScalarType > > propagatorSettings,
             const bool areEquationsOfMotionToBeIntegrated = true,
             const bool clearNumericalSolutions = true,
             const bool setIntegratedResult = true ):
         DynamicsSimulator< StateScalarType, TimeType >(
-            bodyMap, integratorSettings, propagatorSettings, clearNumericalSolutions,
-            setIntegratedResult )
+            bodyMap, integratorSettings, propagatorSettings, clearNumericalSolutions, setIntegratedResult )
     {
         // Integrate equations of motion if required.
         if( areEquationsOfMotionToBeIntegrated )
@@ -407,13 +415,11 @@ public:
 
     //! This function numerically (re-)integrates the equations of motion.
     /*!
-     *  This function numerically (re-)integrates the equations of motion, using the settings set
-     *  through the constructor and a new initial state vector provided here. The raw results are
-     *  set in the equationsOfMotionNumericalSolution_
-     *  \param initialStates Initial state vector that is to be used for numerical integration. Note
-     *  that this state should be in the correct frame (i.e. corresponding to centralBodies in
-     *  propagatorSettings_), but not in the propagator- specific form (i.e Encke, Gauss, etc. for
-     *  translational dynamics)
+     *  This function numerically (re-)integrates the equations of motion, using the settings set through the constructor
+     *  and a new initial state vector provided here. The raw results are set in the equationsOfMotionNumericalSolution_
+     *  \param initialStates Initial state vector that is to be used for numerical integration. Note that this state should
+     *  be in the correct frame (i.e. corresponding to centralBodies in propagatorSettings_), but not in the propagator-
+     *  specific form (i.e Encke, Gauss, etc. for translational dynamics)
      * \sa SingleStateTypeDerivative::convertToOutputSolution
      */
     void integrateEquationsOfMotion(
@@ -422,13 +428,18 @@ public:
 
         equationsOfMotionNumericalSolution_.clear( );
 
-        dynamicsStateDerivative_->setPropagationSettings( std::vector< IntegratedStateType >( ), 1 );
+        dynamicsStateDerivative_->setPropagationSettings( std::vector< IntegratedStateType >( ), 1, 0 );
 
         // Integrate equations of motion numerically.
-        equationsOfMotionNumericalSolution_ =
-                integrateEquations< Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >, TimeType >(
-                    stateDerivativeFunction_, dynamicsStateDerivative_->convertFromOutputSolution(
-                        initialStates, integratorSettings_->initialTime_ ), integratorSettings_ );
+        integrateEquations< Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >, TimeType >(
+                    stateDerivativeFunction_, equationsOfMotionNumericalSolution_,
+                    dynamicsStateDerivative_->convertFromOutputSolution(
+                        initialStates, integratorSettings_->initialTime_ ), integratorSettings_,
+                    boost::bind( &PropagationTerminationCondition::checkStopCondition,
+                                 propagationTerminationCondition_, _1 ),
+                    dependentVariableHistory_,
+                    dependentVariablesFunctions_,
+                    propagatorSettings_->getPrintInterval( ) );
         equationsOfMotionNumericalSolution_ = dynamicsStateDerivative_->
                 convertNumericalStateSolutionsToOutputSolutions( equationsOfMotionNumericalSolution_ );
 
@@ -443,16 +454,26 @@ public:
      * Function to return the map of state history of numerically integrated bodies.
      * \return Map of state history of numerically integrated bodies.
      */
-    std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >
-        getEquationsOfMotionNumericalSolution( )
+    std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > getEquationsOfMotionNumericalSolution( )
     {
         return equationsOfMotionNumericalSolution_;
     }
 
+    //! Function to return the map of dependent variable history that was saved during numerical propagation.
+    /*!
+     * Function to return the map of dependent variable history that was saved during numerical propagation.
+     * \return Map of dependent variable history that was saved during numerical propagation.
+     */
+    std::map< TimeType, Eigen::VectorXd > getDependentVariableHistory( )
+    {
+        return dependentVariableHistory_;
+    }
+
+
     //! Function to reset the environment from an externally generated state history.
     /*!
-     * Function to reset the environment from an externally generated state history, the order of
-     * the entries in the state vectors are proscribed by propagatorSettings
+     * Function to reset the environment from an externally generated state history, the order of the entries in the
+     * state vectors are proscribed by propagatorSettings
      * \param equationsOfMotionNumericalSolution Externally generated state history.
      */
     void manuallySetAndProcessRawNumericalEquationsOfMotionSolution(
@@ -468,9 +489,9 @@ protected:
 
     //! This function updates the environment with the numerical solution of the propagation.
     /*!
-     *  This function updates the environment with the numerical solution of the propagation. It
-     *  sets the propagated translational dynamics solution as the new input for the Ephemeris
-     *  object of the body that was propagated.
+     *  This function updates the environment with the numerical solution of the propagation. It sets
+     *  the propagated translational dynamics solution as the new input for the Ephemeris object of the body that was
+     *  propagated.
      */
     void processNumericalEquationsOfMotionSolution( )
     {
@@ -484,7 +505,7 @@ protected:
             equationsOfMotionNumericalSolution_.clear( );
         }
 
-        for( std::map< std::string, boost::shared_ptr< simulation_setup::Body > >::const_iterator
+        for( simulation_setup::NamedBodyMap::const_iterator
              bodyIterator = bodyMap_.begin( );
              bodyIterator != bodyMap_.end( ); bodyIterator++ )
         {
@@ -494,15 +515,16 @@ protected:
 
     //! Map of state history of numerically integrated bodies.
     /*!
-     *  Map of state history of numerically integrated bodies, i.e. the result of the numerical
-     *  integration, transformed into the 'conventional form' (\sa
-     *  SingleStateTypeDerivative::convertToOutputSolution). Key of map denotes time, values are
-     *  concatenated vectors of integrated body states (order defined by propagatorSettings_).
-     *
+     *  Map of state history of numerically integrated bodies, i.e. the result of the numerical integration, transformed
+     *  into the 'conventional form' (\sa SingleStateTypeDerivative::convertToOutputSolution). Key of map denotes time,
+     *  values are concatenated vectors of integrated body states (order defined by propagatorSettings_).
      *  NOTE: this map is empty if clearNumericalSolutions_ is set to true.
      */
-    std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >
-        equationsOfMotionNumericalSolution_;
+    std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > equationsOfMotionNumericalSolution_;
+
+    //! Map of dependent variable history that was saved during numerical propagation.
+    std::map< TimeType, Eigen::VectorXd > dependentVariableHistory_;
+
 };
 
 } // namespace propagators
diff --git a/Tudat/Astrodynamics/Propagators/dynamicsStateDerivativeModel.h b/Tudat/Astrodynamics/Propagators/dynamicsStateDerivativeModel.h
index 21048f4..1c20cd4 100644
--- a/Tudat/Astrodynamics/Propagators/dynamicsStateDerivativeModel.h
+++ b/Tudat/Astrodynamics/Propagators/dynamicsStateDerivativeModel.h
@@ -25,6 +25,8 @@
 
 #include "Tudat/Astrodynamics/Propagators/singleStateTypeDerivative.h"
 #include "Tudat/Astrodynamics/Propagators/environmentUpdater.h"
+#include "Tudat/Astrodynamics/Propagators/nBodyStateDerivative.h"
+#include "Tudat/Astrodynamics/Propagators/variationalEquations.h"
 
 namespace tudat
 {
@@ -51,17 +53,18 @@ public:
     /*!
      *  Derivative model constructor. Takes state derivative model and environment
      *  updater. Constructor checks whether all models use the same environment updater.     
-     *  \param stateDerivativeModels Vector of state derivative models, with one entry for each type
-     *         of dynamical equation.
-     *  \param environmentUpdater Object which is used to update time-dependent environment models
-     *         to current time and state,
+     *  \param stateDerivativeModels Vector of state derivative models, with one entry for each type of dynamical equation.
+     *  \param environmentUpdater Object which is used to update time-dependent environment models to current time and state,
      *  must be consistent with member environment updaters of stateDerivativeModels entries.
+     *  \param variationalEquations Object used for computing the state derivative in the variational equations
      */
     DynamicsStateDerivativeModel(
             const std::vector< boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > >
             stateDerivativeModels,
-            const boost::shared_ptr< EnvironmentUpdater< StateScalarType, TimeType > > environmentUpdater ):
-        environmentUpdater_( environmentUpdater )
+            const boost::shared_ptr< EnvironmentUpdater< StateScalarType, TimeType > > environmentUpdater,
+            const boost::shared_ptr< VariationalEquations > variationalEquations =
+                        boost::shared_ptr< VariationalEquations >( ) ):
+        environmentUpdater_( environmentUpdater ), variationalEquations_( variationalEquations )
     {
         std::vector< IntegratedStateType > stateTypeList;
         totalStateSize_ = 0;
@@ -105,6 +108,11 @@ public:
             // Set current model in member map.
             stateDerivativeModels_[ stateDerivativeModels.at( i )->getIntegratedStateType( ) ].push_back(
                         stateDerivativeModels.at( i ) );
+
+
+            currentStatesPerTypeInConventionalRepresentation_[ stateDerivativeModels.at( i )->getIntegratedStateType( )  ] =
+                    Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >::Zero(
+                        stateTypeSize_.at( stateDerivativeModels.at( i )->getIntegratedStateType( )  ), 1 );
         }
     }
 
@@ -123,23 +131,41 @@ public:
     StateType computeStateDerivative( const TimeType time, const StateType& state )
     {
         // Initialize state derivative
-        StateType stateDerivative = StateType::Zero( state.rows( ), state.cols( ) );
+        if( stateDerivative_.rows( ) != state.rows( ) || stateDerivative_.cols( ) != state.cols( )  )
+        {
+            stateDerivative_.resize( state.rows( ), state.cols( ) );
+        }
 
         // If dynamical equations are integrated, update the environment with the current state.
         if( evaluateDynamicsEquations_ )
         {
-            std::map< IntegratedStateType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >
-                    statesPerTypeInConventionalRepresentation =
-                    convertCurrentStateToGlobalRepresentationPerType( state, time );
-            environmentUpdater_->updateEnvironment( time, statesPerTypeInConventionalRepresentation,
+            // Iterate over all types of equations.
+            for( stateDerivativeModelsIterator_ = stateDerivativeModels_.begin( );
+                 stateDerivativeModelsIterator_ != stateDerivativeModels_.end( );
+                 stateDerivativeModelsIterator_++ )
+
+            {
+                for( unsigned int i = 0; i < stateDerivativeModelsIterator_->second.size( ); i++ )
+                {
+                    stateDerivativeModelsIterator_->second.at( i )->clearStateDerivativeModel( );
+                }
+            }
+
+            convertCurrentStateToGlobalRepresentationPerType( state, time, evaluateVariationalEquations_ );
+            environmentUpdater_->updateEnvironment( time, currentStatesPerTypeInConventionalRepresentation_,
                                                     integratedStatesFromEnvironment_ );
         }
         else
         {
             environmentUpdater_->updateEnvironment(
-                        time, std::map< IntegratedStateType,
-                                        Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >( ),
-                        integratedStatesFromEnvironment_ );
+                        time, std::unordered_map<
+                        IntegratedStateType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >( ),
+                                                    integratedStatesFromEnvironment_ );
+        }
+
+        if( evaluateVariationalEquations_ )
+        {
+            variationalEquations_->clearPartials( );
         }
 
         // If dynamical equations are integrated, evaluate dynamics state derivatives.
@@ -156,26 +182,54 @@ public:
                 {
                     // Update state derivative models
                     stateDerivativeModelsIterator_->second.at( i )->updateStateDerivativeModel( time );
+                }
+            }
 
+            for( stateDerivativeModelsIterator_ = stateDerivativeModels_.begin( );
+                 stateDerivativeModelsIterator_ != stateDerivativeModels_.end( );
+                 stateDerivativeModelsIterator_++ )
+
+            {
+                for( unsigned int i = 0; i < stateDerivativeModelsIterator_->second.size( ); i++ )
+                {
                     // Evaluate and set current dynamical state derivative
                     currentIndices = stateIndices_.at( stateDerivativeModelsIterator_->first ).at( i );
 
                     stateDerivativeModelsIterator_->second.at( i )->calculateSystemStateDerivative(
-                        time, state.block( currentIndices.first, dynamicsStartColumn_,
-                                           currentIndices.second, 1 ) );
-
-                    stateDerivative.block( currentIndices.first, dynamicsStartColumn_,
-                                           currentIndices.second, 1 ) =
-                            stateDerivativeModelsIterator_->second.at( i )->calculateSystemStateDerivative(
-                                time, state.block( currentIndices.first, dynamicsStartColumn_,
-                                                   currentIndices.second, 1 ) );
+                                time, state.block( currentIndices.first, dynamicsStartColumn_, currentIndices.second, 1 ),
+                                stateDerivative_.block( currentIndices.first, dynamicsStartColumn_, currentIndices.second, 1 ) );
+
                 }
             }
         }
 
-        return stateDerivative;
+
+        // If variational equations are to be integrated: evaluate and set.
+        if( evaluateVariationalEquations_ )
+        {
+            variationalEquations_->updatePartials( time );
+
+            variationalEquations_->evaluateVariationalEquations< StateScalarType >(
+                        time, state.block( 0, 0, totalStateSize_, variationalEquations_->getNumberOfParameterValues( ) ),
+                        stateDerivative_.block( 0, 0, totalStateSize_, variationalEquations_->getNumberOfParameterValues( ) )  );
+        }
+
+        return stateDerivative_;
     }
 
+    //! Function to calculate the system state derivative with double precision, regardless of template arguments
+    /*!
+     *   Function to calculate the system state derivative with double precision, regardless of template arguments
+     *  \sa computeStateDerivative
+     *  \param time Current time.
+     *  \param state Current complete state.
+     *  \return Calculated state derivative.
+     */
+    Eigen::MatrixXd computeStateDoubleDerivative(
+            const double time, const Eigen::MatrixXd& state )
+    {
+        return computeStateDerivative( static_cast< TimeType >( time ), state.template cast< StateScalarType >( ) ).template cast< double >( );
+    }
 
     //! Function to convert the state in the conventional form to the propagator-specific form.
     /*!
@@ -242,12 +296,11 @@ public:
                         stateDerivativeModelsIterator_->first );
             for( unsigned int i = 0; i < stateDerivativeModelsIterator_->second.size( ); i++ )
             {
-                outputState.segment( currentStateIndices.at( i ).first,
-                                     currentStateIndices.at( i ).second ) =
-                        stateDerivativeModelsIterator_->second.at( i )->convertToOutputSolution(
+                stateDerivativeModelsIterator_->second.at( i )->convertToOutputSolution(
                             internalSolution.segment(
-                                currentStateIndices.at( i ).first,
-                                currentStateIndices.at( i ).second ), time );
+                                currentStateIndices.at( i ).first, currentStateIndices.at( i ).second ), time,
+                            outputState.block( currentStateIndices.at( i ).first, 0,
+                                               currentStateIndices.at( i ).second, 1 ) );
             }
         }
         return outputState;
@@ -282,21 +335,84 @@ public:
         return convertedSolution;
     }
 
+    //! Function to add variational equations to the state derivative model
+    /*!
+     * Function to add variational equations to the state derivative model.
+     * \param variationalEquations Object used for computing the state derivative in the variational equations
+     */
+    void addVariationalEquations( boost::shared_ptr< VariationalEquations > variationalEquations )
+    {
+        variationalEquations_ = variationalEquations;
+    }
+
+
     //! Function to set which segments of the full state to propagate
     /*!
      * Function to set which segments of the full state to propagate, i.e. whether to propagate the
      * variational/dynamical equations, and which types of the dynamics to propagate.     
      * \param stateTypesToNotIntegrate Types of dynamics to propagate
-     * \param evaluateDynamicsEquations Boolean to denote whether the dynamical equations are to be
-     *        propagated or not
+     * \param evaluateDynamicsEquations Boolean to denote whether the dynamical equations are to be propagated or not
+     * \param evaluateVariationalEquations Boolean to denote whether the variational equations are to be propagated or not
      */
     void setPropagationSettings(
             const std::vector< IntegratedStateType >& stateTypesToNotIntegrate,
-            const bool evaluateDynamicsEquations )
+            const bool evaluateDynamicsEquations,
+            const bool evaluateVariationalEquations )
     {
         integratedStatesFromEnvironment_ = stateTypesToNotIntegrate;
         evaluateDynamicsEquations_ = evaluateDynamicsEquations;
-        dynamicsStartColumn_ = 0;
+        evaluateVariationalEquations_ = evaluateVariationalEquations;
+
+        if( evaluateVariationalEquations_ )
+        {
+            dynamicsStartColumn_ = variationalEquations_->getNumberOfParameterValues( );
+        }
+        else
+        {
+            dynamicsStartColumn_ = 0;
+        }
+    }
+
+    //! Function to update the settings of the state derivative models with new initial states
+    /*!
+     * Function to update the settings of the state derivative models with new initial states. This function is
+     * called when using, for instance and Encke propagator for the translational dynamics, and the reference orbits
+     * are modified.
+     * \param initialBodyStates New initial state for the full propagated dynamics.
+     */
+    void updateStateDerivativeModelSettings(
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > initialBodyStates )
+    {
+        // Iterate over all dynamics types
+        for( stateDerivativeModelsIterator_ = stateDerivativeModels_.begin( ); stateDerivativeModelsIterator_ != stateDerivativeModels_.end( );
+             stateDerivativeModelsIterator_++ )
+        {
+            switch( stateDerivativeModelsIterator_->first )
+            {
+            case transational_state:
+            {
+                for( unsigned int i = 0; i < stateDerivativeModelsIterator_->second.size( ); i++ )
+                {
+                    boost::shared_ptr< NBodyStateDerivative< StateScalarType, TimeType > > currentTranslationalStateDerivative =
+                            boost::dynamic_pointer_cast< NBodyStateDerivative< StateScalarType, TimeType > >(
+                                stateDerivativeModelsIterator_->second.at( i ) );
+                    switch( currentTranslationalStateDerivative->getPropagatorType( ) )
+                    {
+                    case cowell:
+                        break;
+                    default:
+                        throw std::runtime_error( "Error when updating state derivative model settings, did not recognize translational propagator type" );
+                        break;
+                    }
+                }
+            }
+            case body_mass_state:
+                break;
+            default:
+                throw std::runtime_error( "Error when updating state derivative model settings, did not recognize dynamics type" );
+                break;
+            }
+        }
     }
 
     //! Function to get complete list of state derivative models, sorted per state type.
@@ -304,7 +420,7 @@ public:
      * Function to get complete list of state derivative models, sorted per state type.
      * \return Complete list of state derivative models, sorted per state type.
      */
-    std::map< IntegratedStateType, std::vector< boost::shared_ptr
+    std::unordered_map< IntegratedStateType, std::vector< boost::shared_ptr
     < SingleStateTypeDerivative< StateScalarType, TimeType > > > > getStateDerivativeModels( )
     {
         return stateDerivativeModels_;
@@ -324,23 +440,30 @@ private:
 
     //! Function to convert the to the conventional form in the global frame per dynamics type.
     /*!
-     * Function to convert the propagator-specific form of the state to the conventional form in the
-     * global frame, split by dynamics type.  The conventional form is one that is typically used to
-     * represent the current state in the environment (e.g. Body class). For translational dynamics
-     * this is the Cartesian position and velocity).  The inertial frame is typically the barycenter
-     * with J2000/ECLIPJ2000 orientation, but may differ depending on simulation settings.     
+     * Function to convert the propagator-specific form of the state to the conventional form in the global frame, split
+     * by dynamics type. This function updates the currentStatesPerTypeInConventionalRepresentation_ to the current state
+     * and time.
+     * The conventional form is one that is typically used to represent the current state in the environment
+     * (e.g. Body class). For translational dynamics this is the Cartesian position and velocity).
+     * The inertial frame is typically the barycenter with J2000/ECLIPJ2000 orientation, but may differ depending on
+     * simulation settings
      * \param state State in propagator-specific form (i.e. form that is used in numerical integration).
      * \param time Current time at which the state is valid.
-     * \return State (state), converted to the 'conventional form' in inertial coordinates,
-     * that can for instance be set directly  in the body object.
+     * \param stateIncludesVariationalState Boolean defining whether the stae includes the state transition/sensitivity
+     * matrices
      */
-    std::map< IntegratedStateType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >
-    convertCurrentStateToGlobalRepresentationPerType( const StateType& state, const TimeType& time )
+    void convertCurrentStateToGlobalRepresentationPerType(
+            const StateType& state, const TimeType& time, const bool stateIncludesVariationalState )
     {
         int startColumn = 0;
-
-        std::map< IntegratedStateType,
-                  Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > splitConventionalStates;
+        if( stateIncludesVariationalState )
+        {
+            startColumn = variationalEquations_->getNumberOfParameterValues( );
+        }
+        else
+        {
+            startColumn = 0;
+        }
 
         std::pair< int, int > currentIndices;
 
@@ -348,10 +471,7 @@ private:
         for( stateDerivativeModelsIterator_ = stateDerivativeModels_.begin( );
              stateDerivativeModelsIterator_ != stateDerivativeModels_.end( );
              stateDerivativeModelsIterator_++ )
-        {            
-            splitConventionalStates[ stateDerivativeModelsIterator_->first ] =
-                    Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >::Zero(
-                        stateTypeSize_.at( stateDerivativeModelsIterator_->first ), 1 );
+        {
             int currentStateTypeSize = 0;
 
             // Iterate over all state derivative models of current type
@@ -361,21 +481,23 @@ private:
                 currentIndices = stateIndices_.at( stateDerivativeModelsIterator_->first ).at( i );
 
                 // Set current block in split state (in global form)
-                splitConventionalStates[ stateDerivativeModelsIterator_->first ].block(
-                            currentStateTypeSize, 0, currentIndices.second, 1 ) =
-                        stateDerivativeModelsIterator_->second.at( i )
-                            ->convertCurrentStateToGlobalRepresentation(
-                                state.block( currentIndices.first, startColumn,
-                                             currentIndices.second, 1 ), time );
+                stateDerivativeModelsIterator_->second.at( i )->convertCurrentStateToGlobalRepresentation(
+                            state.block( currentIndices.first, startColumn, currentIndices.second, 1 ), time,
+                            currentStatesPerTypeInConventionalRepresentation_.at(
+                                stateDerivativeModelsIterator_->first ).block(
+                                        currentStateTypeSize, 0, currentIndices.second, 1 ) );
+
                 currentStateTypeSize += currentIndices.second;
             }
         }
-        return splitConventionalStates;
     }
 
     //! Object used to update the environment to the current state and time.
     boost::shared_ptr< EnvironmentUpdater< StateScalarType, TimeType > > environmentUpdater_;
 
+    //! Object used for computing the state derivative in the variational equations
+    boost::shared_ptr< VariationalEquations > variationalEquations_;
+
     //! Map that denotes for each state derivative model the start index and size of the associated
     //! state in the full state vector.
     std::map< IntegratedStateType, std::vector< std::pair< int, int > > > stateIndices_;
@@ -387,14 +509,12 @@ private:
     std::map< IntegratedStateType, int > stateTypeStartIndex_;
 
     //! Complete list of state derivative models, sorted per state type.
-    std::map< IntegratedStateType,
-    std::vector< boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > > >
-        stateDerivativeModels_;
+    std::unordered_map< IntegratedStateType,
+    std::vector< boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > > > stateDerivativeModels_;
 
     //! Predefined iterator for computational efficiency.
-    typename std::map< IntegratedStateType, std::vector< boost::shared_ptr
-    < SingleStateTypeDerivative< StateScalarType, TimeType > > > >::iterator
-        stateDerivativeModelsIterator_;
+    typename std::unordered_map< IntegratedStateType, std::vector< boost::shared_ptr
+    < SingleStateTypeDerivative< StateScalarType, TimeType > > > >::iterator stateDerivativeModelsIterator_;
 
     //! Total length of state vector.
     int totalStateSize_;
@@ -406,13 +526,154 @@ private:
     //! Boolean denoting whether the equations of motion are to be propagated or not.
     bool evaluateDynamicsEquations_;
 
+    //! Boolean denoting whether the variational equations are to be propagated or not.
+    bool evaluateVariationalEquations_;
+
     //! Start index in propagated matrix of the equations of motion (=0 if variational equations are
     //! not propagated).
     int dynamicsStartColumn_;
 
+    //! Current state derivative, as computed by computeStateDerivative.
+    StateType stateDerivative_;
 
+    //! Current state in 'conventional' representation, computed from current propagated state by
+    //! convertCurrentStateToGlobalRepresentationPerType
+    std::unordered_map< IntegratedStateType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >
+            currentStatesPerTypeInConventionalRepresentation_;
 };
 
+//! Function to retrieve a single given acceleration model from a list of models
+/*!
+ *  Function to retrieve a single given acceleration model, determined by
+ *  the body exerting and undergoing the acceleration, as well as the acceleration type, from a list of
+ *  state derivative models.
+ *  \param bodyUndergoingAcceleration Name of body undergoing the acceleration.
+ *  \param bodyExertingAcceleration Name of body exerting the acceleration.
+ *  \param stateDerivativeModels Complete list of state derivativ models
+ *  \param accelerationModeType Type of acceleration model that is to be retrieved.
+ */
+template< typename TimeType = double, typename StateScalarType = double >
+std::vector< boost::shared_ptr< basic_astrodynamics::AccelerationModel3d > > getAccelerationBetweenBodies(
+        const std::string bodyUndergoingAcceleration,
+        const std::string bodyExertingAcceleration,
+        const std::unordered_map< IntegratedStateType,
+        std::vector< boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > > > stateDerivativeModels,
+        const basic_astrodynamics::AvailableAcceleration accelerationModeType )
+
+{
+    std::vector< boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > >
+            listOfSuitableAccelerationModels;
+
+    // Retrieve acceleration models
+    if( stateDerivativeModels.count( propagators::transational_state ) == 1 )
+    {
+        basic_astrodynamics::AccelerationMap accelerationModelList =
+                boost::dynamic_pointer_cast< NBodyStateDerivative< StateScalarType, TimeType > >(
+                    stateDerivativeModels.at( propagators::transational_state ).at( 0 ) )->getAccelerationsMap( );
+        if( accelerationModelList.count( bodyUndergoingAcceleration ) == 0 )
+        {
+
+            std::string errorMessage = "Error when getting acceleration between bodies, no translational dynamics models acting on " +
+                    bodyUndergoingAcceleration + " are found";
+            throw std::runtime_error( errorMessage );
+        }
+        else
+        {
+            // Retrieve accelerations acting on bodyUndergoingAcceleration
+            if( accelerationModelList.at( bodyUndergoingAcceleration ).count( bodyExertingAcceleration ) == 0 )
+            {
+                std::string errorMessage = "Error when getting acceleration between bodies, no translational dynamics models by " +
+                        bodyExertingAcceleration + " acting on " + bodyUndergoingAcceleration + " are found";
+                throw std::runtime_error( errorMessage );
+            }
+            else
+            {
+                // Retrieve required acceleration.
+                listOfSuitableAccelerationModels = basic_astrodynamics::getAccelerationModelsOfType(
+                            accelerationModelList.at( bodyUndergoingAcceleration ).at( bodyExertingAcceleration ), accelerationModeType );
+            }
+        }
+    }
+    else
+    {
+        std::string errorMessage = "Error when getting acceleration between bodies, no translational dynamics models found";
+        throw std::runtime_error( errorMessage );
+    }
+    return listOfSuitableAccelerationModels;
+}
+
+//! Function to retrieve the state derivative models for translational dynamics of given body.
+/*!
+ * Function to retrieve the state derivative models for translational dynamics (object of derived class from
+ * NBodyStateDerivative) of given body from full list of state derivative models
+ *  \param bodyUndergoingAcceleration Name of body for which state derivative model is to be retrieved
+ *  \param stateDerivativeModels Complete list of state derivativ models
+ */
+template< typename TimeType = double, typename StateScalarType = double >
+boost::shared_ptr< NBodyStateDerivative< StateScalarType, TimeType > > getTranslationalStateDerivativeModelForBody(
+        const std::string bodyUndergoingAcceleration,
+        const std::unordered_map< IntegratedStateType,
+        std::vector< boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > > >& stateDerivativeModels )
+
+{
+    bool modelFound = 0;
+    boost::shared_ptr< NBodyStateDerivative< StateScalarType, TimeType > > modelForBody;
+
+    // Check if translational state derivative models exists
+    if( stateDerivativeModels.count( propagators::transational_state ) > 0 )
+    {
+        for( unsigned int i = 0; i < stateDerivativeModels.at( propagators::transational_state ).size( ); i++ )
+        {
+            boost::shared_ptr< NBodyStateDerivative< StateScalarType, TimeType > > nBodyModel =
+                    boost::dynamic_pointer_cast< NBodyStateDerivative< StateScalarType, TimeType > >(
+                        stateDerivativeModels.at( propagators::transational_state ).at( i ) );
+            std::vector< std::string > propagatedBodies = nBodyModel->getBodiesToBeIntegratedNumerically( );
+
+            // Check if bodyUndergoingAcceleration is propagated by bodyUndergoingAcceleration
+            if( std::find( propagatedBodies.begin( ), propagatedBodies.end( ), bodyUndergoingAcceleration )
+                    != propagatedBodies.end( ) )
+            {
+                if( modelFound == true )
+                {
+                    std::string errorMessage = "Error when getting translational dynamics model for " +
+                            bodyUndergoingAcceleration + ", multiple models found";
+                    throw std::runtime_error( errorMessage );
+                }
+                else
+                {
+                    modelForBody = nBodyModel;
+                    modelFound = true;
+                }
+            }
+        }
+    }
+    else
+    {
+        std::string errorMessage = "Error when getting translational dynamics model for " +
+                bodyUndergoingAcceleration + " no translational dynamics models found";
+        throw std::runtime_error( errorMessage );
+    }
+    return modelForBody;
+}
+
+template< typename TimeType = double, typename StateScalarType = double,
+          typename ConversionClassType = DynamicsStateDerivativeModel< TimeType, StateScalarType > >
+std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > convertNumericalStateSolutionsToOutputSolutions(
+        const std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >& rawSolution,
+        boost::shared_ptr< ConversionClassType > converterClass )
+{
+    // Initialize converted solution.
+    std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > convertedSolution;
+
+    // Iterate over all times.
+    for( typename std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >::const_iterator stateIterator =
+         rawSolution.begin( ); stateIterator != rawSolution.end( ); stateIterator++ )
+    {
+        // Convert solution at this time to output (typically ephemeris frame of given body) solution
+        convertedSolution[ stateIterator->first ] = converterClass->convertToOutputSolution( stateIterator->second, stateIterator->first );
+    }
+    return convertedSolution;
+}
 
 } // namespace propagators
 } // namespace tudat
diff --git a/Tudat/Astrodynamics/Propagators/environmentUpdater.h b/Tudat/Astrodynamics/Propagators/environmentUpdater.h
index 52a7f02..ebd5db7 100644
--- a/Tudat/Astrodynamics/Propagators/environmentUpdater.h
+++ b/Tudat/Astrodynamics/Propagators/environmentUpdater.h
@@ -96,7 +96,7 @@ public:
      */
     void updateEnvironment(
             const TimeType currentTime,
-            const std::map< IntegratedStateType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >&
+            const std::unordered_map< IntegratedStateType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >&
             integratedStatesToSet,
             const std::vector< IntegratedStateType >& setIntegratedStatesFromEnvironment =
             std::vector< IntegratedStateType >( ) )
@@ -136,7 +136,7 @@ public:
         {
             for( unsigned int i = 0; i < updateFunctionIterator->second.size( ); i++ )
             {
-                updateFunctionIterator->second.at( i ).second( );
+                updateFunctionIterator->second[ i ].second( );
             }
         }
 
@@ -148,7 +148,7 @@ public:
         {
             for( unsigned int i = 0; i < updateTimeIterator->second.size( ); i++ )
             {
-                updateTimeIterator->second.at( i ).second( static_cast< double >( currentTime ) );
+                updateTimeIterator->second[ i ].second( static_cast< double >( currentTime ) );
             }
         }
     }
@@ -164,35 +164,43 @@ private:
      * \param integratedStatesToSet Integrated states which are to be set in environment.
      */
     void setIntegratedStatesInEnvironment(
-            const std::map< IntegratedStateType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >&
+            const std::unordered_map< IntegratedStateType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >&
             integratedStatesToSet )
     {
         // Iterate over state types and set states in environment
-        for( typename std::map< IntegratedStateType,
-                                Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >::const_iterator
-             integratedStateIterator = integratedStatesToSet.begin( );
-             integratedStateIterator != integratedStatesToSet.end( );
-             integratedStateIterator++ )
+        for( integratedStateIterator_ = integratedStatesToSet.begin( );
+             integratedStateIterator_ != integratedStatesToSet.end( );
+             integratedStateIterator_++ )
         {
-
-            switch( integratedStateIterator->first )
+            switch( integratedStateIterator_->first )
             {
             case transational_state:
             {
                 // Set translational states for bodies provided as input.
-                std::vector< std::pair< std::string, std::string > > bodiesWithIntegratedStates =
-                        integratedStates_.at( transational_state );
-                for( unsigned int i = 0; i < bodiesWithIntegratedStates.size( ); i++ )
+                for( unsigned int i = 0; i < integratedStates_[ transational_state ].size( ); i++ )
                 {
-                    bodyList_[ bodiesWithIntegratedStates[ i ].first ]
-                            ->template setTemplatedState< StateScalarType >(
-                                integratedStateIterator->second.segment( i * 6, 6 ) );
+                    bodyList_[ integratedStates_[ transational_state ][ i ].first ]->template
+                            setTemplatedState< StateScalarType >(
+                                integratedStateIterator_->second.segment( i * 6, 6 ) );
                 }
                 break;
             };
+            case body_mass_state:
+            {
+                // Set mass for bodies provided as input.
+                std::vector< std::pair< std::string, std::string > > bodiesWithIntegratedMass =
+                        integratedStates_.at( body_mass_state );
+
+                for( unsigned int i = 0; i < bodiesWithIntegratedMass.size( ); i++ )
+                {
+                    bodyList_[ bodiesWithIntegratedMass[ i ].first ]
+                            ->setConstantBodyMass( integratedStateIterator_->second( i ) );
+                }                
+                break;
+            };
             default:
                 throw std::runtime_error( "Error, could not find integrated state settings for " +
-                                          boost::lexical_cast< std::string >( integratedStateIterator->first ) );
+                                          boost::lexical_cast< std::string >( integratedStateIterator_->first ) );
             }
         }
     }
@@ -217,7 +225,7 @@ private:
             {
                 // Iterate over all integrated translational states.
                 std::vector< std::pair< std::string, std::string > > bodiesWithIntegratedStates =
-                        integratedStates_.at( transational_state );
+                        integratedStates_[ transational_state ];
                 for( unsigned int i = 0; i < bodiesWithIntegratedStates.size( ); i++ )
                 {
                     bodyList_[ bodiesWithIntegratedStates[ i ].first ]->
@@ -226,6 +234,19 @@ private:
                 }
                 break;
             }
+            case body_mass_state:
+            {
+                // Iterate over all integrated masses.
+                std::vector< std::pair< std::string, std::string > > bodiesWithIntegratedStates =
+                        integratedStates_.at( body_mass_state );
+                for( unsigned int i = 0; i < bodiesWithIntegratedStates.size( ); i++ )
+                {
+                    bodyList_[ bodiesWithIntegratedStates[ i ].first ]->
+                            updateMass( currentTime );
+
+                }
+                break;
+            }
             default:
                 throw std::runtime_error( "Error, could not find  state settings for " +
                                           boost::lexical_cast< std::string >( statesToSet.at( i ) ) );
@@ -269,7 +290,7 @@ private:
                     {
                         bool addUpdate = 1;
 
-                        // Check if translational state is propagated
+                        // Check if mass is propagated
                         if( integratedStates_.count( transational_state ) > 0 )
                         {
                             // Check if current body is propagated
@@ -325,11 +346,32 @@ private:
 
                     }
                     case body_mass_update:
+                    {
+                        bool addUpdate = 1;
+
+                        // Check if translational state is propagated
+                        if( integratedStates_.count( body_mass_state ) > 0 )
+                        {
+                            // Check if current body is propagated
+                            std::pair< std::string, std::string > bodyToCheck
+                                    = std::make_pair( currentBodies.at( i ), "" );
+                            std::vector< std::pair< std::string, std::string > > integratedBodyMasses
+                                    = integratedStates_.at( body_mass_state );
+                            if( std::find( integratedBodyMasses.begin( ),
+                                           integratedBodyMasses.end( ),
+                                           bodyToCheck ) != integratedBodyMasses.end( ) )
+                            {
+                                addUpdate = 0;
+                            }
+                        }
+
+                        if( addUpdate )
                         {
                             updateTimeFunctionList_[ body_mass_update ].push_back(
-                                std::make_pair( currentBodies.at( i ),
-                                                boost::bind( &simulation_setup::Body::updateMass,
-                                                             bodyList_.at( currentBodies.at( i ) ), _1  ) ) );
+                                        std::make_pair( currentBodies.at( i ),
+                                                        boost::bind( &simulation_setup::Body::updateMass,
+                                                                     bodyList_.at( currentBodies.at( i ) ), _1  ) ) );
+                        }
                         break;
                     }
                     case spherical_harmonic_gravity_field_update:
@@ -338,16 +380,16 @@ private:
                         // Check if body has time-dependent sh field
                         boost::shared_ptr< gravitation::TimeDependentSphericalHarmonicsGravityField >
                                 gravityField = boost::dynamic_pointer_cast
-                                         < gravitation::TimeDependentSphericalHarmonicsGravityField >
-                                      (  bodyList_.at( currentBodies.at( i ) )->getGravityFieldModel( ) );
+                                < gravitation::TimeDependentSphericalHarmonicsGravityField >
+                                (  bodyList_.at( currentBodies.at( i ) )->getGravityFieldModel( ) );
                         if( gravityField != NULL )
                         {
                             updateTimeFunctionList_[ spherical_harmonic_gravity_field_update ].push_back(
                                         std::make_pair(
                                             currentBodies.at( i ),
                                             boost::bind( &gravitation
-                                                              ::TimeDependentSphericalHarmonicsGravityField
-                                                                   ::update,
+                                                         ::TimeDependentSphericalHarmonicsGravityField
+                                                         ::update,
                                                          gravityField, _1 ) ) );
                         }
                         // If no sh field at all, throw eeror.
@@ -399,7 +441,7 @@ private:
                         }
                         else if( radiationPressureInterfaces.size( ) > 1 )
                         {
-                            std::cerr<<"Request radiation pressure update of "<<currentBodies.at( i )<<
+                            std::cerr<<"Warning, requested radiation pressure update of "<<currentBodies.at( i )<<
                                        ", but body has multiple radiation pressure interfaces: updating all."<<std::endl;
                         }
 
@@ -470,10 +512,14 @@ private:
               std::vector< std::pair< std::string, boost::function< void( const double ) > > > >
             updateTimeFunctionList_;
 
-    //! Predefined iterator for computational efficiency.
-    std::map< EnvironmentModelsToUpdate,
-              std::vector< std::pair< std::string, boost::function< void( const double ) > > > >::iterator
-            updateTimeIterator;
+    //! Predefined environment model iterator for computational efficiency.
+    std::map< EnvironmentModelsToUpdate, std::vector< std::pair< std::string, boost::function< void( const double ) > > > >
+    ::iterator updateTimeIterator;
+
+
+    //! Predefined state history iterator for computational efficiency.
+    typename std::unordered_map< IntegratedStateType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >::const_iterator
+    integratedStateIterator_;
 
 
 };
diff --git a/Tudat/Astrodynamics/Propagators/integrateEquations.cpp b/Tudat/Astrodynamics/Propagators/integrateEquations.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/Tudat/Astrodynamics/Propagators/integrateEquations.h b/Tudat/Astrodynamics/Propagators/integrateEquations.h
index a71366c..962480f 100644
--- a/Tudat/Astrodynamics/Propagators/integrateEquations.h
+++ b/Tudat/Astrodynamics/Propagators/integrateEquations.h
@@ -11,11 +11,10 @@
 #ifndef TUDAT_INTEGRATEEQUATIONS_H
 #define TUDAT_INTEGRATEEQUATIONS_H
 
-#include <iostream>
-#include <map>
-
 #include <Eigen/Core>
 
+#include <map>
+
 #include "Tudat/Mathematics/NumericalIntegrators/numericalIntegrator.h"
 
 #include "Tudat/Astrodynamics/BasicAstrodynamics/timeConversions.h"
@@ -23,6 +22,7 @@
 #include "Tudat/Astrodynamics/Propagators/environmentUpdater.h"
 #include "Tudat/Mathematics/NumericalIntegrators/createNumericalIntegrator.h"
 #include "Tudat/Mathematics/Interpolators/lagrangeInterpolator.h"
+#include "Tudat/Astrodynamics/Propagators/propagationTermination.h"
 
 namespace tudat
 {
@@ -32,98 +32,139 @@ namespace propagators
 
 //! Function to numerically integrate a given first order differential equation
 /*!
- *  Function to numerically integrate a given first order differential equation, with the state
- *  derivative a function of a single independent variable and the current state
- *  \param stateDerivativeFunction Function returning the state derivative from current time and state.
- *  \param initialState Initial state
- *  \param integratorSettings Settings for numerical integrator.
+ *  Function to numerically integrate a given first order differential equation, with the state derivative a function of
+ *  a single independent variable and the current state
+ *  \param integrator Numerical integrator used for propagation
+ *  \param initialTimeStep Time step to use for first step of numerical integration
+ *  \param stopPropagationFunction Function determining whether the propagation is to be stopped at the current time.
+ *  \param solutionHistory History of dependent variables that are to be saved given as map
+ *  (time as key; returned by reference)
+ *  \param dependentVariableHistory History of dependent variables that are to be saved given as map
+ *  (time as key; returned by reference)
+ *  \param dependentVariableFunction Function returning dependent variables (obtained from environment and state
+ *  derivative model).
+ *  \param saveFrequency Frequency at which to save the numerical integrated states (in units of i.e. per n integration time
+ *  steps, with n = saveFrequency).
  *  \param printInterval Frequency with which to print progress to console (nan = never).
- *  \return History of numerical states (first of pair) and derivatives of states (second of pair)
- *  given as maps with time as key.
  */
 template< typename StateType = Eigen::MatrixXd, typename TimeType = double >
-std::map< TimeType, StateType > integrateEquations(
-        boost::function< StateType( const TimeType, const StateType&) > stateDerivativeFunction,
-        const StateType initialState,
-        boost::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > > integratorSettings,
+void integrateEquations(
+        const boost::shared_ptr< numerical_integrators::NumericalIntegrator< TimeType, StateType, StateType > > integrator,
+        const double initialTimeStep,
+        const boost::function< bool( const double ) > stopPropagationFunction,
+        std::map< TimeType, StateType >& solutionHistory,
+        std::map< TimeType, Eigen::VectorXd >& dependentVariableHistory,
+        const boost::function< Eigen::VectorXd( ) > dependentVariableFunction =
+        boost::function< Eigen::VectorXd( ) >( ),
+        const int saveFrequency = TUDAT_NAN,
         const TimeType printInterval = TUDAT_NAN )
 {
-    using namespace tudat::numerical_integrators;
-
-
-    // Create numerical integrator.
-    boost::shared_ptr< NumericalIntegrator< TimeType, StateType, StateType > > integrator
-          = createIntegrator< TimeType, StateType >( stateDerivativeFunction,
-                                                     initialState, integratorSettings );
 
     // Get Initial state and time.
-    TimeType currentTime = integratorSettings->initialTime_;
-    StateType newState = initialState;
+    TimeType currentTime = integrator->getCurrentIndependentVariable( );
+    TimeType initialTime = currentTime;
+    StateType newState = integrator->getCurrentState( );
 
-    // Initialization of numerical solutions for variational equations.
-    std::map< TimeType, StateType > solutionHistory;
+    // Initialization of numerical solutions for variational equations
+    solutionHistory.clear( );
     solutionHistory[ currentTime ] = newState;
+    dependentVariableHistory.clear( );
+
 
-    // Check if numerical integration is forward or backwrd.
-    TimeType timeStepSign = 1.0L;
-    if( integratorSettings->initialTimeStep_ < 0.0 )
+    if( !dependentVariableFunction.empty( ) )
     {
-        timeStepSign = -1.0L;
+        integrator->getStateDerivativeFunction( )( currentTime, newState );
+        dependentVariableHistory[ currentTime ] = dependentVariableFunction( );
     }
 
     // Set initial time step and total integration time.
-    TimeType timeStep = integratorSettings->initialTimeStep_;
-    TimeType endTime = integratorSettings->endTime_;
+    TimeType timeStep = initialTimeStep;
     TimeType previousTime = currentTime;
 
-    // Perform first integration step.
-    newState = integrator->performIntegrationStep( timeStep );
-
-    currentTime = integrator->getCurrentIndependentVariable( );
-
-    timeStep = timeStepSign * integrator->getNextStepSize( );
-    solutionHistory[ currentTime ] = newState;
-
-    int printIndex = 0;
-    int printFrequency = integratorSettings->printFrequency_;
+    int saveIndex = 0;
 
     // Perform numerical integration steps until end time reached.
-    while( timeStepSign * static_cast< TimeType >( currentTime )
-           < timeStepSign * static_cast< TimeType >( endTime ) )
+    do
     {
         previousTime = currentTime;
 
         // Perform integration step.
         newState = integrator->performIntegrationStep( timeStep );
         currentTime = integrator->getCurrentIndependentVariable( );
-        timeStep = timeStepSign * integrator->getNextStepSize( );
+        timeStep = integrator->getNextStepSize( );
 
         // Save integration result in map
-        printIndex++;
-        printIndex = printIndex % printFrequency;
-        if( printIndex == 0 )
+        saveIndex++;
+        saveIndex = saveIndex % saveFrequency;
+        if( saveIndex == 0 )
         {
             solutionHistory[ currentTime ] = newState;
+
+            if( !dependentVariableFunction.empty( ) )
+            {
+                integrator->getStateDerivativeFunction( )( currentTime, newState );
+                dependentVariableHistory[ currentTime ] = dependentVariableFunction( );
+            }
         }
 
         // Print solutions
         if( printInterval == printInterval )
         {
-            if( ( static_cast<int>( std::fabs( currentTime - integratorSettings->initialTime_ ) ) %
+            if( ( static_cast<int>( std::fabs( currentTime - initialTime ) ) %
                   static_cast< int >( printInterval ) ) <
-                    ( static_cast< int >( std::fabs( previousTime - integratorSettings->initialTime_ ) ) %
+                    ( static_cast< int >( std::fabs( previousTime - initialTime ) ) %
                       static_cast<int>( printInterval ) )  )
             {
-                std::cout << "Current time and state in integration: " << std::setprecision( 10 ) <<
-                           timeStep << " " << currentTime << " " << newState.transpose( ) << std::endl;
+                std::cout<<"Current time and state in integration: "<<std::setprecision( 10 )<<
+                           timeStep<<" "<<currentTime<<" "<<newState.transpose( )<<std::endl;
             }
         }
     }
+    while( !stopPropagationFunction( static_cast< double >( currentTime ) ) );
+}
+
+//! Function to numerically integrate a given first order differential equation
+/*!
+ *  Function to numerically integrate a given first order differential equation, with the state derivative a function of
+ *  a single independent variable and the current state
+ *  \param stateDerivativeFunction Function returning the state derivative from current time and state.
+ *  \param solutionHistory History of numerical states given as map (time as key; returned by reference)
+ *  \param initialState Initial state
+ *  \param integratorSettings Settings for numerical integrator.
+ *  \param stopPropagationFunction Function determining whether the propagation is to be stopped at the current time.
+ *  \param dependentVariableHistory History of dependent variables that are to be saved given as map
+ *  (time as key; returned by reference)
+ *  \param dependentVariableFunction Function returning dependent variables (obtained from environment and state
+ *  derivative model).
+ *  \param printInterval Frequency with which to print progress to console (nan = never).
+ */
+template< typename StateType = Eigen::MatrixXd, typename TimeType = double >
+void integrateEquations(
+        boost::function< StateType( const TimeType, const StateType& ) > stateDerivativeFunction,
+        std::map< TimeType, StateType >& solutionHistory,
+        const StateType initialState,
+        const boost::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > > integratorSettings,
+        const boost::function< bool( const double ) > stopPropagationFunction,
+        std::map< TimeType, Eigen::VectorXd >& dependentVariableHistory,
+        const boost::function< Eigen::VectorXd( ) > dependentVariableFunction =
+        boost::function< Eigen::VectorXd( ) >( ),
+        const TimeType printInterval = TUDAT_NAN )
+{
+    // Create numerical integrator.
+    boost::shared_ptr< numerical_integrators::NumericalIntegrator< TimeType, StateType, StateType > > integrator =
+            numerical_integrators::createIntegrator< TimeType, StateType >(
+                stateDerivativeFunction, initialState, integratorSettings );
+
+    integrateEquations< StateType, TimeType >(
+                integrator, integratorSettings->initialTimeStep_, stopPropagationFunction, solutionHistory,
+                dependentVariableHistory,
+                dependentVariableFunction,
+                integratorSettings->saveFrequency_, printInterval );
 
-    return solutionHistory;
 }
 
 } // namespace propagators
 
 } // namespace tudat
+
 #endif // TUDAT_INTEGRATEEQUATIONS_H
diff --git a/Tudat/Astrodynamics/Propagators/nBodyCowellStateDerivative.h b/Tudat/Astrodynamics/Propagators/nBodyCowellStateDerivative.h
index 0b843ce..b9d10fc 100644
--- a/Tudat/Astrodynamics/Propagators/nBodyCowellStateDerivative.h
+++ b/Tudat/Astrodynamics/Propagators/nBodyCowellStateDerivative.h
@@ -19,51 +19,86 @@ namespace tudat
 namespace propagators
 {
 
+//! Class for computing the state derivative of translational motion of N bodies, using a Cowell propagator.
 template< typename StateScalarType = double, typename TimeType = double >
 class NBodyCowellStateDerivative: public NBodyStateDerivative< StateScalarType, TimeType >
 {
 public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     *  \param accelerationModelsPerBody A map containing the list of accelerations acting on each
+     *  body, identifying the body being acted on and the body acted on by an acceleration. The map
+     *  has as key a string denoting the name of the body the list of accelerations, provided as the
+     *  value corresponding to a key, is acting on.  This map-value is again a map with string as
+     *  key, denoting the body exerting the acceleration, and as value a pointer to an acceleration
+     *  model.
+     *  \param centralBodyData Object responsible for providing the current integration origins from
+     *  the global origins.
+     *  \param bodiesToIntegrate List of names of bodies that are to be integrated numerically.
+     */
     NBodyCowellStateDerivative( const basic_astrodynamics::AccelerationMap& accelerationModelsPerBody,
                                 const boost::shared_ptr< CentralBodyData< StateScalarType, TimeType > > centralBodyData,
                                 const std::vector< std::string >& bodiesToIntegrate ):
         NBodyStateDerivative< StateScalarType, TimeType >(
             accelerationModelsPerBody, centralBodyData, cowell, bodiesToIntegrate ){ }
 
+    //! Destructor
     ~NBodyCowellStateDerivative( ){ }
 
     //! Calculates the state derivative of the translational motion of the system.
     /*!
-     * Calculates the state derivative (velocity+acceleration of each body) of the translational
-     * motion of the system at the given time and position/velocity of bodies.
-     * \param time Time (TDB seconds since J2000) at which the system is to be updated.
-     * \param stateOfSystemToBeIntegrated List of 6 * bodiesToBeIntegratedNumerically_.size( ),
-     * containing Caartesian position/velocity of the bodies being integrated. The order of the
-     * values is defined by the order of bodies in bodiesToBeIntegratedNumerically_
-     * \return Current state derivative (velocity+acceleration) of system of bodies integrated numerically.
+     * Calculates the state derivative (velocity+acceleration of each body) of the translational motion of the system
+     * at the given time and position/velocity of bodies.
+     *  \param time Time (TDB seconds since J2000) at which the system is to be updated.
+     *  \param stateOfSystemToBeIntegrated List of 6 * bodiesToBeIntegratedNumerically_.size( ), containing Caartesian
+     *  position/velocity of the bodies being integrated. The order of the values is defined by the order of bodies in
+     *  bodiesToBeIntegratedNumerically_
+     *  \param stateDerivative Current state derivative (velocity+acceleration) of system of bodies integrated numerically
+     *  (returned by reference).
      */
-    Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > calculateSystemStateDerivative(
-            const TimeType time,
-            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& stateOfSystemToBeIntegrated )
+    void calculateSystemStateDerivative(
+            const TimeType time, const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& stateOfSystemToBeIntegrated,
+            Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > > stateDerivative )
     {
-        return ( this->sumStateDerivativeContributions(
-            stateOfSystemToBeIntegrated.template cast< double >( ),
-            time ) ).template cast< StateScalarType >( );
+        stateDerivative.setZero( );
+        this->sumStateDerivativeContributions( stateOfSystemToBeIntegrated, stateDerivative );
     }
 
+    //! Function to convert the state in the conventional form to the propagator-specific form.
+    /*!
+     * Function to convert the state in the conventional form to the propagator-specific form. For the Cowell propagator,
+     * the two are equivalent, and this function returns the input state.
+     * \param cartesianSolution State in 'conventional form'
+     * \param time Current time at which the state is valid (not used in this class).
+     * \return State (outputSolution), converted to the 'propagator-specific form' (which is equal to outputSolution).
+     */
     Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >
         convertFromOutputSolution(
-            const Eigen::Matrix< StateScalarType, Eigen::Dynamic,
-            Eigen::Dynamic >& cartesianSolution, const TimeType& time )
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& cartesianSolution, const TimeType& time )
     {
         return cartesianSolution;
     }
 
-    Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >
-        convertToOutputSolution(
-            const Eigen::Matrix< StateScalarType, Eigen::Dynamic,
-            Eigen::Dynamic >& internalSolution, const TimeType& time )
+    //! Function to convert the propagator-specific form of the state to the conventional form.
+    /*!
+     * Function to convert the propagator-specific form of the state to the conventional form. For the Cowell propagator,
+     * the two are equivalent, and this function returns the input state.
+     * In contrast to the convertCurrentStateToGlobalRepresentation function, this
+     * function does not provide the state in the inertial frame, but instead provides it in the
+     * frame in which it is propagated.
+     * \param internalSolution State in propagator-specific form (i.e. form that is used in
+     * numerical integration, equal to conventional form for this class).
+     * \param time Current time at which the state is valid (not used in this class).
+     * \param currentCartesianLocalSoluton State (internalSolution), converted to the 'conventional form',
+     *  which is equal to outputSolution for this class (returned by reference).
+     */
+    void convertToOutputSolution(
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& internalSolution, const TimeType& time,
+            Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > currentCartesianLocalSoluton )
     {
-        return internalSolution;
+        currentCartesianLocalSoluton = internalSolution;
     }
 };
 
diff --git a/Tudat/Astrodynamics/Propagators/nBodyEnckeStateDerivative.cpp b/Tudat/Astrodynamics/Propagators/nBodyEnckeStateDerivative.cpp
new file mode 100644
index 0000000..5ef934d
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/nBodyEnckeStateDerivative.cpp
@@ -0,0 +1,136 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#include "Tudat/Astrodynamics/Propagators/nBodyEnckeStateDerivative.h"
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+//! Function to remove the central gravity acceleration from an AccelerationMap
+std::vector< boost::function< double( ) > > removeCentralGravityAccelerations(
+        const std::vector< std::string >& centralBodies, const std::vector< std::string >& bodiesToIntegrate,
+        basic_astrodynamics::AccelerationMap& accelerationModelsPerBody )
+{
+    using namespace basic_astrodynamics;
+    using namespace gravitation;
+
+    std::vector< boost::function< double( ) > > centralBodyGravitationalParameters;
+    centralBodyGravitationalParameters.resize( bodiesToIntegrate.size( ) );
+
+    std::vector< boost::shared_ptr< AccelerationModel< Eigen::Vector3d > > > listOfAccelerations;
+
+    // Iterate over all central bodies.
+    for( unsigned int i = 0; i < centralBodies.size( ); i++ )
+    {
+        // Check if current central body is exerting any accelerations on current body.
+        if( accelerationModelsPerBody[ bodiesToIntegrate.at( i ) ].count( centralBodies.at( i ) ) == 0 )
+        {
+            std::string errorMessage =
+                    "Error, cannot remove central point gravity of body " + bodiesToIntegrate.at( i ) +
+                    " with central body " + centralBodies.at( i ) + " no accelerations due to requested central body found.";
+            throw std::runtime_error( errorMessage );
+        }
+        else
+        {
+            // Find central acceleration to central body, i.e. iterate over list of accelerations and find
+            // central acceleration candiates (should be 1)
+            int lastCandidate = -1;
+            int numberOfCandidates = 0;
+            bool isLastCandidateSphericalHarmonic = 0;
+            listOfAccelerations =
+                    accelerationModelsPerBody[ bodiesToIntegrate.at( i ) ][ centralBodies.at( i ) ];
+
+            for( unsigned int j = 0; j < listOfAccelerations.size( ); j++ )
+            {
+                // Get type of current acceleration.
+                AvailableAcceleration currentAccelerationType = getAccelerationModelType( listOfAccelerations[ j ] );
+
+                // If central gravity, set as central acceleration candidate.
+                if( currentAccelerationType == central_gravity )
+                {
+                    numberOfCandidates++;
+                    lastCandidate = j;
+                }
+                else if( currentAccelerationType == spherical_harmonic_gravity )
+                {
+                    isLastCandidateSphericalHarmonic = 1;
+                    numberOfCandidates++;
+                    lastCandidate = j;
+                }
+                else if( ( currentAccelerationType == third_body_central_gravity ) ||
+                         ( currentAccelerationType == third_body_spherical_harmonic_gravity ) )
+                {
+                    std::string errorMessage =
+                            "Error when removing central body point gravity term, removal of 3rd body accelerations (of " +
+                            centralBodies.at( i ) +
+                            " on " + bodiesToIntegrate.at( i ) + ",) not yet supported";
+                    throw std::runtime_error( errorMessage );
+                }
+            }
+
+            // If no or multiple central acceleration candidates were found, give error.
+            if( numberOfCandidates == 0 )
+            {
+                std::string errorMessage =
+                        "Error when removing central body point gravity term on body " +
+                        bodiesToIntegrate.at( i ) +
+                        " with central body " + centralBodies.at( i ) + ", no central gravity found.";
+                throw std::runtime_error( errorMessage );
+
+            }
+            else if( numberOfCandidates != 1 )
+            {
+                std::string errorMessage =
+                        "Error when removing central body point gravity term on body " +
+                        bodiesToIntegrate.at( i ) +
+                        " with central body " + centralBodies.at( i ) + ", multiple central gravities found.";
+                throw std::runtime_error( errorMessage );
+            }
+            else
+            {
+                if( !isLastCandidateSphericalHarmonic )
+                {
+                    // Set central body gravitational parameter (used for Kepler orbit propagation)
+                    centralBodyGravitationalParameters.at( i ) =
+                            boost::dynamic_pointer_cast< CentralGravitationalAccelerationModel3d >(
+                                listOfAccelerations.at( lastCandidate ) )->getGravitationalParameterFunction( );
+
+                    // Remove central acceleration from list of accelerations that are evaluated at each time step.
+                    listOfAccelerations.erase( listOfAccelerations.begin( ) + lastCandidate,
+                                               listOfAccelerations.begin( ) + lastCandidate + 1 );
+                    accelerationModelsPerBody[ bodiesToIntegrate.at( i ) ][ centralBodies.at( i ) ] =
+                            listOfAccelerations;
+                }
+                else
+                {
+                    boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModel > originalAcceleration =
+                            boost::dynamic_pointer_cast< SphericalHarmonicsGravitationalAccelerationModel >(
+                                listOfAccelerations.at( lastCandidate ) );
+                    centralBodyGravitationalParameters.at( i ) = originalAcceleration->getGravitationalParameterFunction( );
+
+                    // Create 'additional' acceleration model which subtracts central gravity term.
+                    accelerationModelsPerBody[ bodiesToIntegrate.at( i ) ][ centralBodies.at( i ) ].push_back(
+                                boost::make_shared< CentralGravitationalAccelerationModel3d >
+                                ( originalAcceleration->getStateFunctionOfBodyExertingAcceleration( ),
+                                  originalAcceleration->getGravitationalParameterFunction( ),
+                                  originalAcceleration->getStateFunctionOfBodyUndergoingAcceleration( ) ) );
+                }
+            }
+        }
+    }
+    return centralBodyGravitationalParameters;
+}
+
+}
+
+}
diff --git a/Tudat/Astrodynamics/Propagators/nBodyEnckeStateDerivative.h b/Tudat/Astrodynamics/Propagators/nBodyEnckeStateDerivative.h
new file mode 100644
index 0000000..34db4e1
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/nBodyEnckeStateDerivative.h
@@ -0,0 +1,329 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_NBODYENCKESTATEDERIVATIVE_H
+#define TUDAT_NBODYENCKESTATEDERIVATIVE_H
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h"
+
+#include "Tudat/Mathematics/RootFinders/rootFinder.h"
+#include "Tudat/Astrodynamics/Gravitation/centralGravityModel.h"
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.h"
+#include "Tudat/Astrodynamics/Propagators/nBodyStateDerivative.h"
+#include "Tudat/SimulationSetup/body.h"
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+//! Function to calculate Encke's function, to be used during propagation using Encke's method
+/*!
+ *  Function to calculate Encke's function, to be used during propagation using Encke's method
+ *  \param qValue Value of free parameter in Encke's function (typically denoted as q)
+ *  \return value of Encke's function for given free parameter.
+ */
+template< typename StateScalarType = double >
+StateScalarType calculateEnckeQFunction( const StateScalarType qValue )
+{
+    StateScalarType powerTerm =  mathematical_constants::getFloatingInteger< StateScalarType >( 1 )  +
+            mathematical_constants::getFloatingInteger< StateScalarType >( 2 ) * qValue;
+    return mathematical_constants::getFloatingInteger< StateScalarType >( 1 ) - 1.0 / ( powerTerm * std::sqrt( powerTerm ) );
+}
+
+//! Function to remove the central gravity acceleration from an AccelerationMap
+/*!
+ * Function to remove the central gravity acceleration from an AccelerationMap. This is crucial for propagation methods in
+ * which the deviation from a reference Kepler orbit is propagated. If the central gravity is a spherical harmonic
+ * acceleration, the point mass term is removed by setting the C(0,0) coefficnet to 0
+ *  \param bodiesToIntegrate List of names of bodies that are to be integrated numerically.
+ *  \param centralBodies List of names of bodies of which the central terms are to be removed
+ *  (per entry of bodiesToIntegrate)
+ *  \param accelerationModelsPerBody A map containing the list of accelerations acting on each
+ *  body, identifying the body being acted on and the body acted on by an acceleration. The map
+ *  has as key a string denoting the name of the body the list of accelerations, provided as the
+ *  value corresponding to a key, is acting on.  This map-value is again a map with string as
+ *  key, denoting the body exerting the acceleration, and as value a pointer to an acceleration
+ *  model.
+ * \return Functions returning the gravitational parameters of the central terms that were removed.
+ */
+std::vector< boost::function< double( ) > > removeCentralGravityAccelerations(
+        const std::vector< std::string >& centralBodies, const std::vector< std::string >& bodiesToIntegrate,
+        basic_astrodynamics::AccelerationMap& accelerationModelsPerBody );
+
+//! Class for computing the state derivative of translational motion of N bodies, using an Encke propagator.
+/*!
+ * Class for computing the state derivative of translational motion of N bodies, using an Encke propagator.
+ * The Encke propagator propagates the Cartesian deviation from an ideal (pre-defined) Keplerian orbit.
+ * See e.g. Wakker, Astrodynamics II for mathematical details.
+ */
+template< typename StateScalarType = double, typename TimeType = double >
+class NBodyEnckeStateDerivative: public NBodyStateDerivative< StateScalarType, TimeType >
+{
+public:
+
+    //! Constructor, computes required reference quantities, and removes central gravity from acceleration list.
+    /*!
+     * Constructor, computes required reference quantities, and removes central gravity from acceleration list. For
+     * a spherical harmonic central gravity, the C(0,0) coefficient is set to zero.
+     *  \param accelerationModelsPerBody A map containing the list of accelerations acting on each
+     *  body, identifying the body being acted on and the body acted on by an acceleration. The map
+     *  has as key a string denoting the name of the body the list of accelerations, provided as the
+     *  value corresponding to a key, is acting on.  This map-value is again a map with string as
+     *  key, denoting the body exerting the acceleration, and as value a pointer to an acceleration
+     *  model.
+     *  \param centralBodyData Object responsible for providing the current integration origins from
+     *  the global origins.
+     *  \param bodiesToIntegrate List of names of bodies that are to be integrated numerically.
+     *  \param initialKeplerElements Kepler elements of bodiesToIntegrate, valid at initialTime.
+     *  \param initialTime Time at which the initialKeplerElements provide the orbital state.
+     */
+    NBodyEnckeStateDerivative( const basic_astrodynamics::AccelerationMap& accelerationModelsPerBody,
+                               const boost::shared_ptr< CentralBodyData< StateScalarType, TimeType > > centralBodyData,
+                               const std::vector< std::string >& bodiesToIntegrate,
+                               const std::vector< Eigen::Matrix< StateScalarType, 6, 1 > >& initialKeplerElements,
+                               const TimeType& initialTime ):
+        NBodyStateDerivative< StateScalarType, TimeType >(
+            accelerationModelsPerBody, centralBodyData, encke, bodiesToIntegrate ),
+        initialKeplerElements_( initialKeplerElements ),
+        initialTime_( initialTime ),
+        currentKeplerOrbitTime_( TUDAT_NAN )
+    {
+        currentKeplerianOrbitCartesianState_.resize( bodiesToIntegrate.size( ) );
+
+
+        originalAccelerationModelsPerBody_ = this->accelerationModelsPerBody_ ;
+
+        // Remove central gravitational acceleration from list of accelerations that is to be evaluated
+        centralBodyGravitationalParameters_ =
+                removeCentralGravityAccelerations(
+                    centralBodyData->getCentralBodies( ), this->bodiesToBeIntegratedNumerically_,
+                    this->accelerationModelsPerBody_ );
+
+        // Create root-finder for Kepler orbit propagation
+        rootFinder_ = boost::make_shared< root_finders::NewtonRaphsonCore< StateScalarType > >(
+                    boost::bind( &root_finders::termination_conditions::
+                                 RootAbsoluteToleranceTerminationCondition< StateScalarType >::
+                                 checkTerminationCondition,
+                                 boost::make_shared< root_finders::termination_conditions::
+                                 RootAbsoluteToleranceTerminationCondition< StateScalarType > >(
+                                     20.0 * std::numeric_limits< StateScalarType >::epsilon( ), 1000 ),
+                                 _1, _2, _3, _4, _5 ) );
+    }
+
+    //! Function to clear reference values of Encke state derivative model
+    /*!
+     * Function to clear reference values of Encke state derivative model, in addition to those performed in the
+     * clearTranslationalStateDerivativeModel function. It resets the currentKeplerOrbitTime_ to ensure that
+     * the reference orbit is recomputed.
+     */
+    void clearDerivedStateDerivativeModel( )
+    {
+        currentKeplerOrbitTime_ = TUDAT_NAN;
+    }
+
+    //! Calculates the state derivative of the translational motion of the system, using the Encke algorithm
+    /*!
+     *  Calculates the state derivative the translational motion of the system
+     *  at the given time and state of bodies. The velocity and acceleration of each body w.r.t. their reference Kepler
+     *  orbits are computed by this function, i.e. the derivative of the Encke state.
+     *  \param time Time (TDB seconds since J2000) at which the system is to be updated.
+     *  \param stateOfSystemToBeIntegrated List of 6 * bodiesToBeIntegratedNumerically_.size( ), containing Cartesian
+     *  position/velocity deviations from the reference Kepler orbits  of the bodies being integrated.
+     *  The order of the values is defined by the order of bodies in bodiesToBeIntegratedNumerically_
+     *  \param stateDerivative Current derivative of Encke state (velocity + acceleration w.r.t. reference Kepler orbit) of
+     *  system of bodies integrated numerically (returned by reference).
+     */
+    void calculateSystemStateDerivative(
+            const TimeType time,
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& stateOfSystemToBeIntegrated,
+            Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > > stateDerivative )
+    {
+        stateDerivative.setZero( );
+
+        // Retrieve Keplerian orbit state for each body.
+        calculateKeplerTrajectoryCartesianStates( time );
+
+        // Get Cartesian state derivative for all bodies of Encke state (excluding central gravitational accelerations).
+        this->sumStateDerivativeContributions(
+                    stateOfSystemToBeIntegrated, stateDerivative );
+
+        // Initialize Encke algorithm variables.
+        StateScalarType qValue = 0.0;
+        StateScalarType qFunction = 0.0;
+        StateScalarType keplerianRadius = 0.0;
+        Eigen::Matrix< StateScalarType, 3, 1 > positionPerturbation = Eigen::Matrix< StateScalarType, 3, 1 >::Zero( );
+
+        // Update state derivative for each body.
+        for( unsigned int i = 0; i < this->bodiesToBeIntegratedNumerically_.size( ); i++ )
+        {
+            // Get position perturbation.
+            positionPerturbation = stateOfSystemToBeIntegrated.segment( i * 6, 3 );
+
+            // Get distance from central body, assuming purely Keplerian orbit.
+            keplerianRadius = currentKeplerianOrbitCartesianState_[ i ].segment( 0, 3 ).norm( );
+
+            // Calculate Encke algorithm variables.
+            qValue = positionPerturbation.dot( currentKeplerianOrbitCartesianState_[ i ].segment( 0, 3 ) +
+                                               0.5 * positionPerturbation ) / ( keplerianRadius * keplerianRadius );
+            qFunction = calculateEnckeQFunction( qValue );
+
+            // Update state derivative with Encke term.
+            stateDerivative.block( i * 6 + 3, 0, 3, 1 ) += static_cast< StateScalarType >(
+                        centralBodyGravitationalParameters_[ i ]( ) ) /
+                    ( keplerianRadius * keplerianRadius * keplerianRadius ) * (
+                        ( positionPerturbation + currentKeplerianOrbitCartesianState_[ i ].segment( 0, 3 ) ) * qFunction -
+                        positionPerturbation );
+        }
+
+    }
+
+    //! Function to convert the state in the conventional form to the Encke-propagator-specific form.
+    /*!
+     * Function to convert the state in the conventional form to the propagator-specific form. For the Encke propagator,
+     * this transforms the Cartesian state w.r.t. the central body (conventional form) to the Cartesian deviation
+     * from the Kepler orbit w.r.t. this central body (Encke form).
+     * \param cartesianSolution State in 'conventional form'
+     * \param time Current time at which the state is valid, used to computed Kepler orbits
+     * \return State (outputSolution), converted to the Encke-propagator-specific form
+     */
+    Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > convertFromOutputSolution(
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& cartesianSolution,
+            const TimeType& time )
+    {
+        Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > currentState = cartesianSolution;
+
+        // Calculate Keplerian orbit states in local frames.
+        calculateKeplerTrajectoryCartesianStates( time );
+
+        // Subtract frame origin and Keplerian states from inertial state.
+        for( unsigned int i = 0; i < this->bodiesToBeIntegratedNumerically_.size( ); i++ )
+        {
+            currentState.segment( i * 6, 6 ) -= ( currentKeplerianOrbitCartesianState_[ i ] );
+        }
+
+        return currentState;
+
+    }
+
+    //! Function to convert the Encke-propagator-specific form of the state to the conventional form.
+    /*!
+     * Function to convert the Encle-propagator-specific form of the state to the conventional form. For the Encke
+     * propagator, this transforms the Cartesian state w.r.t. the central body (conventional form) to the Cartesian deviation
+     * from the Kepler orbit w.r.t. this central body (Encke form).
+     * In contrast to the convertCurrentStateToGlobalRepresentation function, this
+     * function does not provide the state in the inertial frame, but instead provides it in the
+     * frame in which it is propagated.
+     * \param internalSolution State in Encke-propagator-specific form (i.e. form that is used in
+     * numerical integration)/
+     * \param time Current time at which the state is valid
+     * \param currentCartesianLocalSoluton State (internalSolution, which is Encke-formulation),
+     *  converted to the 'conventional form'.
+     */
+    void convertToOutputSolution(
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& internalSolution, const TimeType& time,
+            Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > currentCartesianLocalSoluton )
+    {
+        // Calculate Keplerian orbit state around centeal bodies.
+        calculateKeplerTrajectoryCartesianStates( time );
+
+        // Add Keplerian state to perturbation from Encke algorithm to get Cartesian state in local frames.
+        for( unsigned int i = 0; i < this->bodiesToBeIntegratedNumerically_.size( ); i++ )
+        {
+            currentCartesianLocalSoluton.segment( i * 6, 6 ) = currentKeplerianOrbitCartesianState_[ i ] +
+                    internalSolution.block( i * 6, 0, 6, 1 );
+        }
+    }
+
+    basic_astrodynamics::AccelerationMap getFullAccelerationsMap( )
+    {
+        return originalAccelerationModelsPerBody_;
+    }
+
+private:
+
+    //! Function to calculate and set the reference Kepler orbit in Cartesian coordinates for given body.
+    /*!
+     * Function to calculate and set the reference Kepler orbit in Cartesian coordinates for given body.
+     * \param time Time at which Kepler orbit is to be computed.
+     * \param bodyIndex Index in list of bodies for which Kepler orbit is to be computed.
+     */
+    void calculateKeplerTrajectoryCartesianState(
+            const TimeType time,
+            const int bodyIndex )
+    {
+        // Propagate Kepler orbit to current time and set.
+        currentKeplerianOrbitCartesianState_[ bodyIndex ] =
+                orbital_element_conversions::convertKeplerianToCartesianElements< StateScalarType >(
+                    orbital_element_conversions::propagateKeplerOrbit< StateScalarType >(
+                        initialKeplerElements_.at( bodyIndex ), static_cast< StateScalarType >( time - initialTime_ ),
+                        static_cast< StateScalarType >( centralBodyGravitationalParameters_.at( bodyIndex )( ) ),
+                        rootFinder_ ),
+                    static_cast< StateScalarType >( centralBodyGravitationalParameters_.at( bodyIndex )( ) ) );
+    }
+
+    //! Function to calculate and set the reference Kepler orbit in Cartesian coordinates for all bodies.
+    /*!
+     * Function to calculate and set the reference Kepler orbit in Cartesian coordinates for all bodies.
+     * \param time Time at which Kepler orbits are to be computed.
+     */
+    void calculateKeplerTrajectoryCartesianStates(
+            const TimeType time )
+    {
+        // Check if update is neede.
+        if( !( currentKeplerOrbitTime_ == time ) )
+        {
+            // Iterate over bodies and calculate Cartesian state of associated Kepler orbit at current time.
+            for( unsigned int i = 0; i < this->bodiesToBeIntegratedNumerically_.size( ); i++ )
+            {
+                calculateKeplerTrajectoryCartesianState( time, i );
+            }
+            currentKeplerOrbitTime_ = time;
+        }
+    }
+
+    //!  Gravitational parameters of central bodies used to convert Cartesian to Keplerian orbits, and vice versa
+    std::vector< boost::function< double( ) > > centralBodyGravitationalParameters_;
+
+    //!  Kepler elements of bodiesToIntegrate, valid at initialTime_.
+    std::vector< Eigen::Matrix< StateScalarType, 6, 1 > > initialKeplerElements_;
+
+    //! Time at which the initialKeplerElements provide the reference Keper orbit.
+    TimeType initialTime_ ;
+
+    //! Central body accelerations for each propagated body, which has been removed from accelerationModelsPerBody_/
+    std::vector< boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > >
+    centralAccelerations_;
+
+    //! Root finder used to propagate Kepler orbit.
+    boost::shared_ptr< root_finders::RootFinderCore< StateScalarType > > rootFinder_;
+
+    //! Current Cartesian states of reference Kepler orbits, valid at currentKeplerOrbitTime_, computed by
+    //! calculateKeplerTrajectoryCartesianStates
+    std::vector< Eigen::Matrix< StateScalarType, 6, 1 > > currentKeplerianOrbitCartesianState_;
+
+    //! Time at which the currentKeplerianOrbitCartesianState_ provide the Cartesian representation of the
+    //! referfence Kepler state.
+    TimeType currentKeplerOrbitTime_;
+
+    basic_astrodynamics::AccelerationMap originalAccelerationModelsPerBody_;
+
+
+};
+
+
+}
+
+}
+
+#endif // TUDAT_NBODYENCKESTATEDERIVATIVE_H
diff --git a/Tudat/Astrodynamics/Propagators/nBodyStateDerivative.h b/Tudat/Astrodynamics/Propagators/nBodyStateDerivative.h
index 11db5dc..6f74496 100644
--- a/Tudat/Astrodynamics/Propagators/nBodyStateDerivative.h
+++ b/Tudat/Astrodynamics/Propagators/nBodyStateDerivative.h
@@ -75,53 +75,97 @@ public:
         centralBodyData_( centralBodyData ),
         propagatorType_( propagatorType ),
         bodiesToBeIntegratedNumerically_( bodiesToIntegrate )
-    { }
+    {
+        // Add empty acceleration map if body is to be propagated with no accelerations.
+        for( unsigned int i = 0; i < bodiesToBeIntegratedNumerically_.size( ); i++ )
+        {
+            if( accelerationModelsPerBody_.count( bodiesToBeIntegratedNumerically_.at( i ) ) == 0 )
+            {
+                accelerationModelsPerBody_[ bodiesToBeIntegratedNumerically_.at( i ) ] =
+                        basic_astrodynamics::SingleBodyAccelerationMap( );
+            }
+        }
+
+        // Correct order of propagated bodies.
+        for( outerAccelerationIterator = accelerationModelsPerBody_.begin( );
+             outerAccelerationIterator != accelerationModelsPerBody_.end( );
+             outerAccelerationIterator++ )
+        {
+            std::vector< std::string >::iterator findIterator =
+                    std::find( bodiesToBeIntegratedNumerically_.begin( ), bodiesToBeIntegratedNumerically_.end( ), outerAccelerationIterator->first );
+            bodyOrder_.push_back( std::distance( bodiesToBeIntegratedNumerically_.begin( ), findIterator ) );
+        }
+
+    }
 
     //! Destructor
     virtual ~NBodyStateDerivative( ){ }
 
-    //! Function to update the state derivative model to the current time.
+    //! Function to clear any reference/cached values of state derivative model
     /*!
-     * Function to update the state derivative model (i.e. acceleration, torque, etc. models) to the
-     * current time. Note that this function only updates the state derivative model itself, the
-     * environment models must be updated before calling this function.
-     * \param currentTime Time at which state derivative is to be calculated
+     * Function to clear any reference/cached values of state derivative model, in addition to those performed in the
+     * clearTranslationalStateDerivativeModel function. Default implementation is empty.
      */
-    void updateStateDerivativeModel( const TimeType currentTime )
+    virtual void clearDerivedTranslationalStateDerivativeModel( ){ }
+
+    //! Function to clear reference/cached values of acceleration models
+    /*!
+     * Function to clear reference/cached values of acceleration models, to ensure that they are all recalculated.
+     */
+    void clearTranslationalStateDerivativeModel( )
     {
-        // Reser all acceleration times (to allow multiple evaluations at same time, e.g. stage 2
-        // and 3 in RK4 integrator)
-        for( accelerationMapIterator = accelerationModelsPerBody_.begin( );
-             accelerationMapIterator != accelerationModelsPerBody_.end( );
-             accelerationMapIterator++ )
+        // Reset all acceleration times (to allow multiple evaluations at same time, e.g. stage 2 and 3 in RK4 integrator)
+        for( outerAccelerationIterator = accelerationModelsPerBody_.begin( );
+             outerAccelerationIterator != accelerationModelsPerBody_.end( ); outerAccelerationIterator++ )
         {
             // Iterate over all accelerations acting on body
-            for( innerAccelerationIterator  = accelerationMapIterator->second.begin( );
-                 innerAccelerationIterator != accelerationMapIterator->second.end( );
-                 innerAccelerationIterator++ )
+            for( innerAccelerationIterator  = outerAccelerationIterator->second.begin( );
+                 innerAccelerationIterator != outerAccelerationIterator->second.end( ); innerAccelerationIterator++ )
             {
-                // Update accelerations
+                // Update accelerationsj
                 for( unsigned int j = 0; j < innerAccelerationIterator->second.size( ); j++ )
                 {
-
                     innerAccelerationIterator->second[ j ]->resetTime( TUDAT_NAN );
                 }
             }
         }
 
+    }
+
+    //! Function to clear reference/cached values of translational state derivative model
+    /*!
+     * Function to clear reference/cached values of translational state derivative model. For each derived class, this
+     * entails resetting the current time in the acceleration models to NaN (see clearTranslationalStateDerivativeModel).
+     * Every derived class requiring additional values to be cleared should implement the
+     * clearDerivedTranslationalStateDerivativeModel function.
+     */
+    void clearStateDerivativeModel(  )
+    {
+        clearTranslationalStateDerivativeModel( );
+        clearDerivedTranslationalStateDerivativeModel( );
+    }
+
+    //! Function to update the state derivative model to the current time.
+    /*!
+     * Function to update the state derivative model (i.e. acceleration, torque, etc. models) to the
+     * current time. Note that this function only updates the state derivative model itself, the
+     * environment models must be updated before calling this function.
+     * \param currentTime Time at which state derivative is to be calculated
+     */
+    void updateStateDerivativeModel( const TimeType currentTime )
+    {
         // Iterate over all accelerations and update their internal state.
-        for( accelerationMapIterator = accelerationModelsPerBody_.begin( );
-             accelerationMapIterator != accelerationModelsPerBody_.end( ); accelerationMapIterator++ )
+        for( outerAccelerationIterator = accelerationModelsPerBody_.begin( );
+             outerAccelerationIterator != accelerationModelsPerBody_.end( ); outerAccelerationIterator++ )
         {
             // Iterate over all accelerations acting on body
-            for( innerAccelerationIterator  = accelerationMapIterator->second.begin( );
-                 innerAccelerationIterator != accelerationMapIterator->second.end( );
+            for( innerAccelerationIterator  = outerAccelerationIterator->second.begin( );
+                 innerAccelerationIterator != outerAccelerationIterator->second.end( );
                  innerAccelerationIterator++ )
             {
                 // Update accelerations
                 for( unsigned int j = 0; j < innerAccelerationIterator->second.size( ); j++ )
                 {
-
                     innerAccelerationIterator->second[ j ]->updateMembers( currentTime );
                 }
             }
@@ -137,23 +181,22 @@ public:
      * \param internalSolution State in propagator-specific form (i.e. form that is used in
      * numerical integration).
      * \param time Current time at which the state is valid.
-     * \return State (internalSolution), converted to the Cartesian state in inertial coordinates.
+     * \param currentCartesianLocalSoluton State (internalSolution), converted to the Cartesian state in inertial coordinates
+     * (returned by reference).
      */
-    Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > convertCurrentStateToGlobalRepresentation(
-            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& internalSolution,
-            const TimeType& time )
+    void convertCurrentStateToGlobalRepresentation(
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& internalSolution, const TimeType& time,
+            Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > currentCartesianLocalSoluton )
     {
-        Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > cartesianLocalSolution
-               = this->convertToOutputSolution( internalSolution, time );
+        this->convertToOutputSolution( internalSolution, time, currentCartesianLocalSoluton );
 
-        std::vector< Eigen::Matrix< StateScalarType, 6, 1 >  > centralBodyInertialStates
-               = centralBodyData_->getReferenceFrameOriginInertialStates( cartesianLocalSolution,
-                                                                          time, true );
-        for( unsigned int i = 0; i < centralBodyInertialStates.size( ); i++ )
+        centralBodyData_->getReferenceFrameOriginInertialStates(
+                    currentCartesianLocalSoluton, time, centralBodyInertialStates_, true );
+
+        for( unsigned int i = 0; i < centralBodyInertialStates_.size( ); i++ )
         {
-            cartesianLocalSolution.segment( i * 6, 6 ) += centralBodyInertialStates[ i ];
+            currentCartesianLocalSoluton.segment( i * 6, 6 ) += centralBodyInertialStates_[ i ];
         }
-        return cartesianLocalSolution;
     }
 
     //! Function to get list of names of bodies that are to be integrated numerically.
@@ -171,12 +214,12 @@ public:
      * Function to get map containing the list of accelerations acting on each body,
      * \return A map containing the list of accelerations acting on each body,
      */
-    basic_astrodynamics::AccelerationMap getAccelerationsMap( )
+    virtual basic_astrodynamics::AccelerationMap getFullAccelerationsMap( )
     {
         return accelerationModelsPerBody_;
     }
 
-    //! Function to get object providing the current integration origins 
+    //! Function to get object providing the current integration origins
     /*!
      * Function to get object responsible for providing the current integration origins from the
      * global origins.
@@ -207,6 +250,57 @@ public:
         return 6 * bodiesToBeIntegratedNumerically_.size( );
     }
 
+    //! Function to retrieve the total acceleration acting on a given body.
+    /*!
+     * Function to retrieve the total acceleration acting on a given body. The environment
+     * and acceleration models must have been updated to the current state before calling this
+     * function. NOTE: This function is typically used to retrieve the acceleration for output purposes, not to compute the
+     * translational state derivative.
+     * \param bodyName Name of body for which accelerations are to be retrieved.
+     * \return
+     */
+    Eigen::Vector3d getTotalAccelerationForBody(
+            const std::string& bodyName )
+    {
+        // Check if body is propagated.
+        Eigen::Vector3d totalAcceleration = Eigen::Vector3d::Zero( );
+        if( std::find( bodiesToBeIntegratedNumerically_.begin( ),
+                       bodiesToBeIntegratedNumerically_.end( ),
+                       bodyName ) == bodiesToBeIntegratedNumerically_.end( ) )
+        {
+            std::string errorMessage = "Error when getting total acceleration for body " + bodyName +
+                    ", no such acceleration is found";
+            throw std::runtime_error( errorMessage );
+        }
+        else
+        {
+            if( accelerationModelsPerBody_.count( bodyName ) != 0 )
+            {
+                basic_astrodynamics::SingleBodyAccelerationMap accelerationsOnBody =
+                        accelerationModelsPerBody_.at( bodyName );
+
+                // Iterate over all accelerations acting on body
+                for( innerAccelerationIterator  = accelerationsOnBody.begin( );
+                     innerAccelerationIterator != accelerationsOnBody.end( );
+                     innerAccelerationIterator++ )
+                {
+                    for( unsigned int j = 0; j < innerAccelerationIterator->second.size( ); j++ )
+                    {
+                        // Calculate acceleration and add to state derivative.
+                        totalAcceleration += innerAccelerationIterator->second[ j ]->getAcceleration( );
+                    }
+                }
+            }
+        }
+        return totalAcceleration;
+    }
+
+    basic_astrodynamics::AccelerationMap getAccelerationsMap( )
+    {
+        return accelerationModelsPerBody_;
+
+    }
+
 protected:
 
     //! Function to get the state derivative of the system in Cartesian coordinates.
@@ -215,46 +309,45 @@ protected:
      * and acceleration models must have been updated to the current state before calling this
      * function.
      * \param stateOfSystemToBeIntegrated Current Cartesian state of the system.
-     * \param time Time at which the state derivative is to be computed
-     * \return State derivative of the system in Cartesian coordinates.
+     * \param stateDerivative State derivative of the system in Cartesian coordinates (returned by reference).
      */
-    Eigen::VectorXd sumStateDerivativeContributions(
-            const Eigen::VectorXd& stateOfSystemToBeIntegrated, const TimeType time )
+    void sumStateDerivativeContributions(
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& stateOfSystemToBeIntegrated,
+            Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > > stateDerivative )
     {
         using namespace basic_astrodynamics;
 
-        // Declare and initialize to zero vector to be returned.
-        Eigen::VectorXd stateDerivative = Eigen::VectorXd::Zero( stateOfSystemToBeIntegrated.size( ) );
+        stateDerivative.setZero( );
+
+        int currentBodyIndex = TUDAT_NAN;
+        int currentAccelerationIndex = 0;
 
         // Iterate over all bodies with accelerations.
-        for( unsigned int i = 0; i < bodiesToBeIntegratedNumerically_.size( ); i++ )
+        for( outerAccelerationIterator = accelerationModelsPerBody_.begin( );
+             outerAccelerationIterator != accelerationModelsPerBody_.end( );
+             outerAccelerationIterator++ )
         {
-            // If body undergoes acceleration, calculate and add accelerations.
-            if( accelerationModelsPerBody_.count( bodiesToBeIntegratedNumerically_[ i ] ) != 0 )
-            {
+            currentBodyIndex = bodyOrder_[ currentAccelerationIndex ];
 
+            // Iterate over all accelerations acting on body
+            for( innerAccelerationIterator  = outerAccelerationIterator->second.begin( );
+                 innerAccelerationIterator != outerAccelerationIterator->second.end( );
+                 innerAccelerationIterator++ )
+            {
+                for( unsigned int j = 0; j < innerAccelerationIterator->second.size( ); j++ )
                 {
-                    // Iterate over all accelerations acting on body
-                    for( innerAccelerationIterator  =
-                         accelerationModelsPerBody_[ bodiesToBeIntegratedNumerically_[ i ] ].begin( );
-                         innerAccelerationIterator !=
-                         accelerationModelsPerBody_[ bodiesToBeIntegratedNumerically_[ i ] ].end( );
-                         innerAccelerationIterator++ )
-                    {
-                        for( unsigned int j = 0; j < innerAccelerationIterator->second.size( ); j++ )
-                        {
-                            // Calculate acceleration and add to state derivative.
-                            stateDerivative.segment( i * 6 + 3, 3 ) += (
-                                        innerAccelerationIterator->second[ j ]->getAcceleration( ) );
-                        }
-                    }
+                    // Calculate acceleration and add to state derivative.
+                    stateDerivative.block( currentBodyIndex * 6 + 3, 0, 3, 1 ) += (
+                                innerAccelerationIterator->second[ j ]->getAcceleration( ) ).
+                            template cast< StateScalarType >( );
                 }
             }
+
             // Add body velocity as derivative of its position.
-            stateDerivative.segment( i * 6, 3 ) = stateOfSystemToBeIntegrated.segment( i * 6 + 3, 3 );
+            stateDerivative.block( currentBodyIndex * 6, 0, 3, 1 ) =
+                    ( stateOfSystemToBeIntegrated.segment( currentBodyIndex * 6 + 3, 3 ) );
+            currentAccelerationIndex++;
         }
-
-        return stateDerivative;
     }
 
 
@@ -277,17 +370,23 @@ protected:
     //! List of names of bodies that are to be integrated numerically.
     std::vector< std::string > bodiesToBeIntegratedNumerically_;
 
+    std::vector< int > bodyOrder_;
+
     //! Predefined iterator to save (de-)allocation time.
-    basic_astrodynamics::AccelerationMap::iterator accelerationMapIterator;
+    std::unordered_map< std::string, std::vector<
+    boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > > >::iterator innerAccelerationIterator;
 
     //! Predefined iterator to save (de-)allocation time.
-    std::map< std::string, std::vector< boost::shared_ptr<
-               basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > > >::iterator
-        innerAccelerationIterator;
+    std::unordered_map< std::string, std::unordered_map< std::string, std::vector<
+    boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > > > >::iterator outerAccelerationIterator;
 
+    //! List of states of teh central bodies of the propagated bodies.
+    std::vector< Eigen::Matrix< StateScalarType, 6, 1 >  > centralBodyInertialStates_;
 };
 
 } // namespace propagators
 
+
 } // namespace tudat
+
 #endif // TUDAT_NBODYSTATEDERIVATIVE_H
diff --git a/Tudat/Astrodynamics/Propagators/propagationOutput.cpp b/Tudat/Astrodynamics/Propagators/propagationOutput.cpp
new file mode 100644
index 0000000..c2e78e0
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/propagationOutput.cpp
@@ -0,0 +1,117 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#include "Tudat/Astrodynamics/Aerodynamics/aerodynamics.h"
+#include "Tudat/Astrodynamics/Propagators/propagationOutput.h"
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+//! Function to evaluate a set of double and vector-returning functions and concatenate the results.
+Eigen::VectorXd evaluateListOfFunctions(
+        const std::vector< boost::function< double( ) > >& doubleFunctionList,
+        const std::vector< std::pair< boost::function< Eigen::VectorXd( ) >, int > > vectorFunctionList,
+        const int totalSize)
+{
+    Eigen::VectorXd variableList = Eigen::VectorXd::Zero( totalSize );
+    int currentIndex = 0;
+
+    for( unsigned int i = 0; i < doubleFunctionList.size( ); i++ )
+    {
+        variableList( i ) = doubleFunctionList.at( i )( );
+        currentIndex++;
+    }
+
+    for( unsigned int i = 0; i < vectorFunctionList.size( ); i++ )
+    {
+        variableList.segment( currentIndex, vectorFunctionList.at( i ).second ) =
+                vectorFunctionList.at( i ).first( );
+        currentIndex += vectorFunctionList.at( i ).second;
+    }
+
+    // Check consistency with input
+    if( currentIndex != totalSize )
+    {
+        std::string errorMessage = "Error when evaluating lists of functions, sizes are inconsistent: " +
+                boost::lexical_cast< std::string >( currentIndex ) + " and " +
+                boost::lexical_cast< std::string >( totalSize );
+        throw std::runtime_error( errorMessage );
+    }
+
+    return variableList;
+}
+
+//! Funtion to get the size of a dependent variable
+int getDependentVariableSize(
+        const PropagationDependentVariables dependentVariableSettings )
+{
+    int variableSize = -1;
+    switch( dependentVariableSettings )
+    {
+    case mach_number_dependent_variable:
+        variableSize = 1;
+        break;
+    case altitude_dependent_variable:
+        variableSize = 1;
+        break;
+    case airspeed_dependent_variable:
+        variableSize = 1;
+        break;
+    case local_density_dependent_variable:
+        variableSize = 1;
+        break;
+    case relative_speed_dependent_variable:
+        variableSize = 1;
+        break;
+    case relative_position_dependent_variable:
+        variableSize = 3;
+        break;
+    case relative_distance_dependent_variable:
+        variableSize = 1;
+        break;
+    case relative_velocity_dependent_variable:
+        variableSize = 3;
+        break;
+    case radiation_pressure_dependent_variable:
+        variableSize = 1;
+        break;
+    case total_acceleration_norm_dependent_variable:
+        variableSize = 1;
+        break;
+    case single_acceleration_norm_dependent_variable:
+        variableSize = 1;
+        break;
+    case total_acceleration_dependent_variable:
+        variableSize = 3;
+        break;
+    case single_acceleration_dependent_variable:
+        variableSize = 3;
+        break;
+    case aerodynamic_force_coefficients_dependent_variable:
+        variableSize = 3;
+        break;
+    case aerodynamic_moment_coefficients_dependent_variable:
+        variableSize = 3;
+        break;
+    default:
+        std::string errorMessage = "Error, did not recognize dependent variable size of type: " +
+                boost::lexical_cast< std::string >( dependentVariableSettings );
+        throw std::runtime_error( errorMessage );
+    }
+    return variableSize;
+}
+
+
+} // namespace propagators
+
+} // namespace tudat
diff --git a/Tudat/Astrodynamics/Propagators/propagationOutput.h b/Tudat/Astrodynamics/Propagators/propagationOutput.h
new file mode 100644
index 0000000..8402d1a
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/propagationOutput.h
@@ -0,0 +1,467 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_PROPAGATIONOUTPUT_H
+#define TUDAT_PROPAGATIONOUTPUT_H
+
+#include <boost/function.hpp>
+
+#include "Tudat/Astrodynamics/Aerodynamics/aerodynamics.h"
+#include "Tudat/Astrodynamics/Propagators/dynamicsStateDerivativeModel.h"
+#include "Tudat/SimulationSetup/body.h"
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+//! Function to evaluate a function with two input variables (by reference) from function pointers
+/*!
+ *  Function to evaluate a function with two input variables (by reference) from function pointers that return these
+ *  two input variables.
+ *  \param functionToEvaluate Function that is to be evaluated with input from function pointers.
+ *  \param firstInput Function returning first input to functionToEvaluate.
+ *  \param secondInput Function returning second input to functionToEvaluate.
+ *  \return Output from functionToEvaluate, using functions firstInput and secondInput as input.
+ */
+template< typename OutputType, typename InputType >
+OutputType evaluateReferenceFunction(
+        const boost::function< OutputType( const InputType&, const InputType& ) > functionToEvaluate,
+        const boost::function< InputType( ) > firstInput,
+        const boost::function< InputType( ) > secondInput )
+{
+    return functionToEvaluate( firstInput( ), secondInput( ) );
+}
+
+//! Function to evaluate a function with two input variables from function pointers
+/*!
+ *  Function to evaluate a function with two input variables from function pointers that return these
+ *  two input variables.
+ *  \param functionToEvaluate Function that is to be evaluated with input from function pointers.
+ *  \param firstInput Function returning first input to functionToEvaluate.
+ *  \param secondInput Function returning second input to functionToEvaluate.
+ *  \return Output from functionToEvaluate, using functions firstInput and secondInput as input.
+ */
+template< typename OutputType, typename InputType >
+OutputType evaluateFunction(
+        const boost::function< OutputType( const InputType, const InputType ) > functionToEvaluate,
+        const boost::function< InputType( ) > firstInput,
+        const boost::function< InputType( ) > secondInput )
+{
+    return functionToEvaluate( firstInput( ), secondInput( ) );
+}
+
+//! Funtion to get the size of a dependent variable
+/*!
+ * Funtion to get the size (i.e. number of values in variable: one for altitude, three for position, etc.)
+ * of a dependent variable
+ * \param dependentVariableSettings Dependent variable type for which size is to be determined.
+ * \return Size of requested dependent variable.
+ */
+int getDependentVariableSize(
+        const PropagationDependentVariables dependentVariableSettings );
+
+//! Function to create a function returning a requested dependent variable value (of type double).
+/*!
+ *  Function to create a function returning a requested dependent variable value (of type double), retrieved from
+ *  environment and/or state derivative models.
+ *  \param dependentVariableSettings Settings for dependent variable that is to be returned by function created here.
+ *  \param bodyMap List of bodies to use in simulations (containing full environment).
+ *  \param stateDerivativeModels List of state derivative models used in simulations (sorted by dynamics type as key)
+ *  \return Function returning requested dependent variable. NOTE: The environment and state derivative models need to
+ *  be updated to current state and independent variable before computation is performed.
+ */
+template< typename TimeType = double, typename StateScalarType = double >
+boost::function< double( ) > getDoubleDependentVariableFunction(
+        const boost::shared_ptr< SingleDependentVariableSaveSettings > dependentVariableSettings,
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const std::unordered_map< IntegratedStateType,
+        std::vector< boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > > > stateDerivativeModels =
+        std::unordered_map< IntegratedStateType,
+        std::vector< boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > > >( ) )
+{
+    boost::function< double( ) > variableFunction;
+
+    // Retrieve base information on dependent variable
+    PropagationDependentVariables dependentVariable = dependentVariableSettings->variableType_;
+    const std::string& bodyWithProperty = dependentVariableSettings->associatedBody_;
+    const std::string& secondaryBody = dependentVariableSettings->secondaryBody_;
+
+    // Check dependent variable type and create function accordingly.
+    switch( dependentVariable )
+    {
+    case mach_number_dependent_variable:
+    {
+        if( bodyMap.at( bodyWithProperty )->getFlightConditions( ) == NULL )
+        {
+
+        }
+
+        boost::function< double( const double, const double ) > functionToEvaluate =
+                boost::bind( &aerodynamics::computeMachNumber, _1, _2 );
+
+        // Retrieve functions for airspeed and speed of sound.
+        boost::function< double( ) > firstInput =
+                boost::bind( &aerodynamics::FlightConditions::getCurrentAirspeed,
+                             bodyMap.at( bodyWithProperty )->getFlightConditions( ) );
+        boost::function< double( ) > secondInput =
+                boost::bind( &aerodynamics::FlightConditions::getCurrentSpeedOfSound,
+                             bodyMap.at( bodyWithProperty )->getFlightConditions( ) );
+
+
+        variableFunction = boost::bind( &evaluateFunction< double, double >,
+                                        functionToEvaluate, firstInput, secondInput );
+        break;
+    }
+    case altitude_dependent_variable:
+        if( bodyMap.at( bodyWithProperty )->getFlightConditions( ) == NULL )
+        {
+
+        }
+        variableFunction = boost::bind( &aerodynamics::FlightConditions::getCurrentAltitude,
+                                        bodyMap.at( bodyWithProperty )->getFlightConditions( ) );
+        break;
+    case airspeed_dependent_variable:
+        if( bodyMap.at( bodyWithProperty )->getFlightConditions( ) == NULL )
+        {
+
+        }
+        variableFunction = boost::bind( &aerodynamics::FlightConditions::getCurrentAirspeed,
+                                        bodyMap.at( bodyWithProperty )->getFlightConditions( ) );
+        break;
+    case local_density_dependent_variable:
+        if( bodyMap.at( bodyWithProperty )->getFlightConditions( ) == NULL )
+        {
+
+        }
+        variableFunction = boost::bind( &aerodynamics::FlightConditions::getCurrentDensity,
+                                        bodyMap.at( bodyWithProperty )->getFlightConditions( ) );
+        break;
+    case radiation_pressure_dependent_variable:
+        if( bodyMap.at( bodyWithProperty )->getRadiationPressureInterfaces( ).count( secondaryBody ) == 0 )
+        {
+
+        }
+        variableFunction = boost::bind( &electro_magnetism::RadiationPressureInterface::getCurrentRadiationPressure,
+                                        bodyMap.at( bodyWithProperty )->getRadiationPressureInterfaces( ).at( secondaryBody ) );
+        break;
+    case relative_distance_dependent_variable:
+    {
+        // Retrieve functions for positions of two bodies.
+        boost::function< double( const Eigen::Vector3d&, const Eigen::Vector3d& ) > functionToEvaluate =
+                boost::bind( &linear_algebra::computeNormOfVectorDifference, _1, _2 );
+        boost::function< Eigen::Vector3d( ) > firstInput =
+                boost::bind( &simulation_setup::Body::getPosition, bodyMap.at( bodyWithProperty ) );
+        boost::function< Eigen::Vector3d( ) > secondInput =
+                boost::bind( &simulation_setup::Body::getPosition, bodyMap.at( secondaryBody ) );
+
+        variableFunction = boost::bind(
+                    &evaluateReferenceFunction< double, Eigen::Vector3d >, functionToEvaluate, firstInput, secondInput );
+        break;
+    }
+    case relative_speed_dependent_variable:
+    {
+        // Retrieve functions for velicoty of two bodies.
+        boost::function< double( const Eigen::Vector3d&, const Eigen::Vector3d& ) > functionToEvaluate =
+                boost::bind( &linear_algebra::computeNormOfVectorDifference, _1, _2 );
+        boost::function< Eigen::Vector3d( ) > firstInput =
+                boost::bind( &simulation_setup::Body::getVelocity, bodyMap.at( bodyWithProperty ) );
+        boost::function< Eigen::Vector3d( ) > secondInput =
+                boost::bind( &simulation_setup::Body::getVelocity, bodyMap.at( secondaryBody ) );
+
+        variableFunction = boost::bind(
+                    &evaluateReferenceFunction< double, Eigen::Vector3d >, functionToEvaluate, firstInput, secondInput );
+
+        break;
+    }
+    case single_acceleration_norm_dependent_variable:
+    {
+        // Check input consistency
+        boost::shared_ptr< SingleAccelerationDependentVariableSaveSettings > accelerationDependentVariableSettings =
+                boost::dynamic_pointer_cast< SingleAccelerationDependentVariableSaveSettings >(
+                    dependentVariableSettings );
+        if( accelerationDependentVariableSettings == NULL )
+        {
+            std::string errorMessage = "Error, inconsistent inout when creating dependent variable function of type single_acceleration_norm_dependent_variable";
+            throw std::runtime_error( errorMessage );
+        }
+        else
+        {
+            // Retrieve list of suitable acceleration models (size should be one to avoid ambiguities)
+            std::vector< boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > >
+                    listOfSuitableAccelerationModels = getAccelerationBetweenBodies(
+                        accelerationDependentVariableSettings->associatedBody_,
+                        accelerationDependentVariableSettings->secondaryBody_,
+                        stateDerivativeModels, accelerationDependentVariableSettings->accelerationModeType_ );
+            if( listOfSuitableAccelerationModels.size( ) != 1 )
+            {
+                std::string errorMessage = "Error when getting acceleration between bodies " +
+                        accelerationDependentVariableSettings->associatedBody_ + " and " +
+                        accelerationDependentVariableSettings->secondaryBody_ + " of type " +
+                        boost::lexical_cast< std::string >(
+                                            accelerationDependentVariableSettings->accelerationModeType_ ) +
+                        ", no such acceleration found";
+                throw std::runtime_error( errorMessage );
+            }
+            else
+            {
+                boost::function< Eigen::Vector3d( ) > vectorFunction =
+                        boost::bind( &basic_astrodynamics::AccelerationModel3d::getAcceleration,
+                                     listOfSuitableAccelerationModels.at( 0 ) );
+                variableFunction = boost::bind( &linear_algebra::getVectorNormFromFunction, vectorFunction );
+            }
+        }
+        break;
+    }
+    case total_acceleration_norm_dependent_variable:
+    {
+        // Retrieve model responsible for computing accelerations of requested bodies.
+        boost::shared_ptr< NBodyStateDerivative< StateScalarType, TimeType > > nBodyModel =
+                getTranslationalStateDerivativeModelForBody( bodyWithProperty, stateDerivativeModels );
+        boost::function< Eigen::Vector3d( ) > vectorFunction =
+                boost::bind( &NBodyStateDerivative< StateScalarType, TimeType >::getTotalAccelerationForBody,
+                             nBodyModel, bodyWithProperty );
+        variableFunction = boost::bind( &linear_algebra::getVectorNormFromFunction, vectorFunction );
+
+        break;
+    }
+    default:
+        std::string errorMessage =
+                "Error, did not recognize double dependent variable type when making variable function: " +
+                boost::lexical_cast< std::string >( dependentVariableSettings->variableType_ );
+        throw std::runtime_error( errorMessage );
+    }
+    return variableFunction;
+}
+
+//! Function to create a function returning a requested dependent variable value (of type VectorXd).
+/*!
+ *  Function to create a function returning a requested dependent variable value (of type VectorXd), retrieved from
+ *  environment and/or state derivative models.
+ *  \param dependentVariableSettings Settings for dependent variable that is to be returned by function created here.
+ *  \param bodyMap List of bodies to use in simulations (containing full environment).
+ *  \param stateDerivativeModels List of state derivative models used in simulations (sorted by dynamics type as key)
+ *  \return Function returning requested dependent variable. NOTE: The environment and state derivative models need to
+ *  be updated to current state and independent variable before computation is performed.
+ */
+template< typename TimeType = double, typename StateScalarType = double >
+std::pair< boost::function< Eigen::VectorXd( ) >, int > getVectorDependentVariableFunction(
+        const boost::shared_ptr< SingleDependentVariableSaveSettings > dependentVariableSettings,
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const std::unordered_map< IntegratedStateType,
+        std::vector< boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > > > stateDerivativeModels =
+        std::unordered_map< IntegratedStateType,
+        std::vector< boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > > >( ) )
+{
+    boost::function< Eigen::VectorXd( ) > variableFunction;
+    int parameterSize;
+
+    // Retrieve base information on dependent variable
+    PropagationDependentVariables dependentVariable = dependentVariableSettings->variableType_;
+    const std::string& bodyWithProperty = dependentVariableSettings->associatedBody_;
+    const std::string& secondaryBody = dependentVariableSettings->secondaryBody_;
+
+    // Check dependent variable type and create function accordingly.
+    switch( dependentVariable )
+    {
+    case relative_position_dependent_variable:
+    {
+        // Retrieve functions for positions of two bodies.
+        boost::function< Eigen::Vector3d( const Eigen::Vector3d&, const Eigen::Vector3d& ) > functionToEvaluate =
+                boost::bind( &linear_algebra::computeVectorDifference, _1, _2 );
+        boost::function< Eigen::Vector3d( ) > firstInput =
+                boost::bind( &simulation_setup::Body::getPosition, bodyMap.at( bodyWithProperty ) );
+        boost::function< Eigen::Vector3d( ) > secondInput =
+                boost::bind( &simulation_setup::Body::getPosition, bodyMap.at( secondaryBody ) );
+
+        variableFunction = boost::bind(
+                    &evaluateReferenceFunction< Eigen::Vector3d, Eigen::Vector3d >,
+                    functionToEvaluate, firstInput, secondInput );
+        parameterSize = 3;
+        break;
+    }
+    case relative_velocity_dependent_variable:
+    {
+        // Retrieve functions for velocities of two bodies.
+        boost::function< Eigen::Vector3d( const Eigen::Vector3d&, const Eigen::Vector3d& ) > functionToEvaluate =
+                boost::bind( &linear_algebra::computeVectorDifference, _1, _2 );
+        boost::function< Eigen::Vector3d( ) > firstInput =
+                boost::bind( &simulation_setup::Body::getVelocity, bodyMap.at( bodyWithProperty ) );
+        boost::function< Eigen::Vector3d( ) > secondInput =
+                boost::bind( &simulation_setup::Body::getVelocity, bodyMap.at( secondaryBody ) );
+
+        variableFunction = boost::bind(
+                    &evaluateReferenceFunction< Eigen::Vector3d, Eigen::Vector3d >,
+                    functionToEvaluate, firstInput, secondInput );
+        parameterSize = 3;
+
+
+        break;
+    }
+    case total_acceleration_dependent_variable:
+    {
+        // Retrieve model responsible for computing accelerations of requested bodies.
+        boost::shared_ptr< NBodyStateDerivative< StateScalarType, TimeType > > nBodyModel =
+                getTranslationalStateDerivativeModelForBody( bodyWithProperty, stateDerivativeModels );
+        variableFunction =
+                boost::bind( &NBodyStateDerivative< StateScalarType, TimeType >::getTotalAccelerationForBody, nBodyModel,
+                             bodyWithProperty );
+        parameterSize = 3;
+
+
+        break;
+    }
+    case single_acceleration_dependent_variable:
+    {
+        // Check input consistency.
+        boost::shared_ptr< SingleAccelerationDependentVariableSaveSettings > accelerationDependentVariableSettings =
+                boost::dynamic_pointer_cast< SingleAccelerationDependentVariableSaveSettings >( dependentVariableSettings );
+        if( accelerationDependentVariableSettings == NULL )
+        {
+            std::string errorMessage= "Error, inconsistent inout when creating dependent variable function of type single_acceleration_dependent_variable";
+            throw std::runtime_error( errorMessage );
+        }
+        else
+        {
+            // Retrieve list of suitable acceleration models (size should be one to avoid ambiguities)
+            std::vector< boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > >
+                    listOfSuitableAccelerationModels = getAccelerationBetweenBodies(
+                        accelerationDependentVariableSettings->associatedBody_,
+                        accelerationDependentVariableSettings->secondaryBody_,
+                        stateDerivativeModels, accelerationDependentVariableSettings->accelerationModeType_ );
+            if( listOfSuitableAccelerationModels.size( ) != 1 )
+            {
+                std::string errorMessage = "Error when getting acceleration between bodies " +
+                        accelerationDependentVariableSettings->associatedBody_ + " and " +
+                        accelerationDependentVariableSettings->secondaryBody_ + " of type " +
+                        boost::lexical_cast< std::string >(
+                                            accelerationDependentVariableSettings->accelerationModeType_ ) +
+                        ", no such acceleration found";
+                throw std::runtime_error( errorMessage );
+            }
+            else
+            {
+                //boost::function< Eigen::Vector3d( ) > vectorFunction =
+                variableFunction = boost::bind( &basic_astrodynamics::AccelerationModel3d::getAcceleration,
+                                                listOfSuitableAccelerationModels.at( 0 ) );
+                parameterSize = 3;
+            }
+        }
+        break;
+    }
+    case aerodynamic_force_coefficients_dependent_variable:
+    {
+        if( bodyMap.at( bodyWithProperty )->getFlightConditions( ) == NULL )
+        {
+
+        }
+        variableFunction = boost::bind(
+                    &aerodynamics::AerodynamicCoefficientInterface::getCurrentForceCoefficients,
+                    bodyMap.at( bodyWithProperty )->getFlightConditions( )->getAerodynamicCoefficientInterface( ) );
+        parameterSize = 3;
+
+        break;
+    }
+    case aerodynamic_moment_coefficients_dependent_variable:
+    {
+        if( bodyMap.at( bodyWithProperty )->getFlightConditions( ) == NULL )
+        {
+
+        }
+        variableFunction = boost::bind(
+                    &aerodynamics::AerodynamicCoefficientInterface::getCurrentMomentCoefficients,
+                    bodyMap.at( bodyWithProperty )->getFlightConditions( )->getAerodynamicCoefficientInterface( ) );
+        parameterSize = 3;
+
+        break;
+    }
+    default:
+        std::string errorMessage =
+                "Error, did not recognize vector dependent variable type when making variable function: " +
+                boost::lexical_cast< std::string >( dependentVariableSettings->variableType_ );
+        throw std::runtime_error( errorMessage );
+    }
+    return std::make_pair( variableFunction, parameterSize );
+}
+
+//! Function to evaluate a set of double and vector-returning functions and concatenate the results.
+/*!
+ * Function to evaluate a set of double and vector-returning functions and concatenate the results. Results of double
+ * function list are put in return vector first, followed by those in vector function list.
+ * \param doubleFunctionList List of functions returning double variables
+ * \param vectorFunctionList List of functions returning vector variables (pairs denote function and return vector size)
+ * \param totalSize Total size of concatenated vector (used as input for efficiency.
+ * \return Concatenated results from input functions.
+ */
+Eigen::VectorXd evaluateListOfFunctions(
+        const std::vector< boost::function< double( ) > >& doubleFunctionList,
+        const std::vector< std::pair< boost::function< Eigen::VectorXd( ) >, int > > vectorFunctionList,
+        const int totalSize );
+
+//! Function to create a function that evaluates a list of dependent variables and concatenates the results.
+/*!
+ *  Function to create a function that evaluates a list of dependent variables and concatenates the results.
+ *  Dependent variables functions are created inside this function from a list of settings on their required
+ *  types/properties.
+ *  \param saveSettings Object containing types and other properties of dependent variables.
+ *  \param bodyMap List of bodies to use in simulations (containing full environment).
+ *  \param stateDerivativeModels List of state derivative models used in simulations (sorted by dynamics type as key)
+ *  \return Function returning requested dependent variable values.
+ *  NOTE: The environment and state derivative models need to
+ *  be updated to current state and independent variable before computation is performed.
+ */
+template< typename TimeType = double, typename StateScalarType = double >
+boost::function< Eigen::VectorXd( ) > createDependentVariableListFunction(
+        const boost::shared_ptr< DependentVariableSaveSettings > saveSettings,
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const std::unordered_map< IntegratedStateType,
+        std::vector< boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > > >& stateDerivativeModels =
+        std::unordered_map< IntegratedStateType,
+        std::vector< boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > > >( ) )
+{
+    // Retrieve list of save settings
+    std::vector< boost::shared_ptr< SingleDependentVariableSaveSettings > > dependentVariables =
+            saveSettings->dependentVariables_;
+
+    // create list of double and vector parameters
+    std::vector< boost::function< double( ) > > doubleFunctionList;
+    std::vector< std::pair< boost::function< Eigen::VectorXd( ) >, int > > vectorFunctionList;
+    int totalVariableSize = 0;
+    for( unsigned int i = 0; i < dependentVariables.size( ); i++ )
+    {
+        // Create double parameter
+        if( getDependentVariableSize( dependentVariables.at( i )->variableType_ ) == 1 )
+        {
+            doubleFunctionList.push_back( getDoubleDependentVariableFunction(
+                                              dependentVariables.at( i ),
+                                              bodyMap, stateDerivativeModels ) );
+            totalVariableSize++;
+        }
+        // Create vector parameter
+        else
+        {
+            vectorFunctionList.push_back( getVectorDependentVariableFunction(
+                                              dependentVariables.at( i ),
+                                              bodyMap, stateDerivativeModels ) );
+            totalVariableSize += vectorFunctionList.at( vectorFunctionList.size( ) - 1 ).second;
+        }
+    }
+
+    // Create function conatenating function results.
+    return boost::bind( &evaluateListOfFunctions, doubleFunctionList, vectorFunctionList, totalVariableSize );
+}
+
+
+} // namespace propagators
+
+} // namespace tudat
+
+#endif // TUDAT_PROPAGATIONOUTPUT_H
diff --git a/Tudat/Astrodynamics/Propagators/propagationOutputSettings.h b/Tudat/Astrodynamics/Propagators/propagationOutputSettings.h
new file mode 100644
index 0000000..785feb7
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/propagationOutputSettings.h
@@ -0,0 +1,139 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_PROPAGATIONOUTPUTSETTINGS_H
+#define TUDAT_PROPAGATIONOUTPUTSETTINGS_H
+
+#include <string>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.h"
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+
+//! Enum listing the dependent variables that can be saved during the propagation
+enum PropagationDependentVariables
+{
+    mach_number_dependent_variable = 0,
+    altitude_dependent_variable = 1,
+    airspeed_dependent_variable = 2,
+    local_density_dependent_variable = 3,
+    relative_speed_dependent_variable = 4,
+    relative_position_dependent_variable = 5,
+    relative_distance_dependent_variable = 6,
+    relative_velocity_dependent_variable = 7,
+    radiation_pressure_dependent_variable = 8,
+    total_acceleration_norm_dependent_variable = 9,
+    single_acceleration_norm_dependent_variable = 10,
+    total_acceleration_dependent_variable = 11,
+    single_acceleration_dependent_variable = 12,
+    aerodynamic_force_coefficients_dependent_variable = 13,
+    aerodynamic_moment_coefficients_dependent_variable = 14
+
+};
+
+//! Functional base class for defining settings for dependent variables that are to be saved during propagation
+/*!
+ *  Functional base class for defining settings for dependent variables that are to be saved during propagation.
+ *  Any dependent variable that requires additional information in addition to what can be provided here, should be
+ *  defined by a dedicated derived class.
+ */
+class SingleDependentVariableSaveSettings
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param variableType Type of dependent variable that is to be saved.
+     * \param associatedBody Body associated with dependent variable
+     * \param secondaryBody Secondary body (not necessarilly required) w.r.t. which parameter is defined (e.g. relative
+     * position, velocity etc. is defined of associatedBody w.r.t. secondaryBody).
+     */
+    SingleDependentVariableSaveSettings(
+            const PropagationDependentVariables variableType,
+            const std::string& associatedBody,
+            const std::string& secondaryBody = "" ):
+        variableType_( variableType ), associatedBody_( associatedBody ), secondaryBody_( secondaryBody ){ }
+
+    //! Destructor.
+    virtual ~SingleDependentVariableSaveSettings( ){ }
+
+    //! Type of dependent variable that is to be saved.
+    PropagationDependentVariables variableType_;
+
+    //! Body associated with dependent variable
+    std::string associatedBody_;
+
+    //! Secondary body (not necessarilly required) w.r.t. which parameter is defined (e.g. relative  position,
+    //! velocity etc. is defined of associatedBody w.r.t. secondaryBody).
+    std::string secondaryBody_;
+
+};
+
+//! Class to define settings for saving a single acceleration (norm or vector) during propagation
+class SingleAccelerationDependentVariableSaveSettings: public SingleDependentVariableSaveSettings
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param accelerationModeType Type of acceleration that is to be saved.
+     * \param bodyUndergoingAcceleration Name of body undergoing the acceleration.
+     * \param bodyExertingAcceleration Name of body exerting the acceleration.
+     * \param useNorm Boolean denoting whether to use the norm (if true) or the vector (if false) of the acceleration.
+     */
+    SingleAccelerationDependentVariableSaveSettings(
+            const basic_astrodynamics::AvailableAcceleration accelerationModeType,
+            const std::string& bodyUndergoingAcceleration,
+            const std::string& bodyExertingAcceleration,
+            const bool useNorm = 0 ):
+        SingleDependentVariableSaveSettings(
+            ( useNorm == 1 ) ? ( single_acceleration_norm_dependent_variable ) : ( single_acceleration_dependent_variable ),
+            bodyUndergoingAcceleration, bodyExertingAcceleration ),
+        accelerationModeType_( accelerationModeType )
+    { }
+
+    //! Boolean denoting whether to use the norm (if true) or the vector (if false) of the acceleration.
+    basic_astrodynamics::AvailableAcceleration accelerationModeType_;
+
+};
+
+//addAllFlightConditionsDependentVariables
+
+//! Container class for settings of all dependent variables that are to be saved.
+class DependentVariableSaveSettings
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param dependentVariables List of settings for parameters that are to be saved.
+     */
+    DependentVariableSaveSettings(
+            const std::vector< boost::shared_ptr< SingleDependentVariableSaveSettings > > dependentVariables ):
+    dependentVariables_( dependentVariables ){ }
+
+    //! List of settings for parameters that are to be saved.
+    std::vector< boost::shared_ptr< SingleDependentVariableSaveSettings > > dependentVariables_;
+};
+
+} // namespace propagators
+
+} // namespace tudat
+
+
+#endif // TUDAT_PROPAGATIONOUTPUTSETTINGS_H
diff --git a/Tudat/Astrodynamics/Propagators/propagationSettings.cpp b/Tudat/Astrodynamics/Propagators/propagationSettings.cpp
new file mode 100644
index 0000000..fab99a4
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/propagationSettings.cpp
@@ -0,0 +1,61 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#include "Tudat/Astrodynamics/Propagators/propagationSettings.h"
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+//! Get size of state for single propagated state of given type.
+int getSingleIntegrationSize( const IntegratedStateType stateType )
+{
+    int singleStateSize = 0;
+    switch( stateType )
+    {
+    case transational_state:
+        singleStateSize = 6;
+        break;
+    case body_mass_state:
+        singleStateSize = 1;
+        break;
+    default:
+        std::string errorMessage =
+                "Did not recognize state type " + boost::lexical_cast< std::string >( stateType ) + "when getting size";
+       throw std::runtime_error( errorMessage );
+    }
+    return singleStateSize;
+}
+
+//! Get order of differential equation for governing equations of dynamics of given type.
+int getSingleIntegrationDifferentialEquationOrder( const IntegratedStateType stateType )
+{
+    int singleStateSize = 0;
+    switch( stateType )
+    {
+    case transational_state:
+        singleStateSize = 2;
+        break;
+    case body_mass_state:
+        singleStateSize = 1;
+        break;
+    default:
+        std::string errorMessage =
+                "Did not recognize state type " + boost::lexical_cast< std::string >( stateType ) + "when getting order";
+       throw std::runtime_error( errorMessage );
+    }
+    return singleStateSize;
+}
+
+} // namespace propagators
+
+} // namespace tudat
diff --git a/Tudat/Astrodynamics/Propagators/propagationSettings.h b/Tudat/Astrodynamics/Propagators/propagationSettings.h
index 5d5ef9a..f9eaedf 100644
--- a/Tudat/Astrodynamics/Propagators/propagationSettings.h
+++ b/Tudat/Astrodynamics/Propagators/propagationSettings.h
@@ -15,13 +15,19 @@
 #include <string>
 #include <map>
 #include <iostream>
+#include <unordered_map>
 
+#include <boost/make_shared.hpp>
 #include <boost/lexical_cast.hpp>
 
 #include <Eigen/Core>
 
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.h"
 #include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
 #include "Tudat/Astrodynamics/BasicAstrodynamics/timeConversions.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/massRateModel.h"
+#include "Tudat/Astrodynamics/Propagators/propagationOutputSettings.h"
+#include "Tudat/Astrodynamics/Propagators/propagationTerminationSettings.h"
 
 namespace tudat
 {
@@ -33,19 +39,39 @@ namespace propagators
 //! Enum listing types of dynamics that can be numerically integrated
 enum IntegratedStateType
 {
-    transational_state
+    hybrid = 0,
+    transational_state = 1,
+    body_mass_state = 2
 };
 
+
 //! Enum listing propagator types for translational dynamics that can be used.
 enum TranslationalPropagatorType
 {
-    cowell = 0
+    cowell = 0,
+    encke = 1
 };
 
+//! Get size of state for single propagated state of given type.
+/*!
+ * Get size of state for single propagated state of given type (i.e. 6 for translational state).
+ * \param stateType Type of state
+ * \return Size of single state.
+ */
+int getSingleIntegrationSize( const IntegratedStateType stateType );
+
+//! Get order of differential equation for governing equations of dynamics of given type.
+/*!
+ * Get order of differential equation for governing equations of dynamics of given type (i.e. 2 for translational state).
+ * \param stateType Type of state
+ * \return Order of differential equations.
+ */
+int getSingleIntegrationDifferentialEquationOrder( const IntegratedStateType stateType );
+
 //! Base class for defining setting of a propagator
 /*!
- *  Base class for defining setting of a propagator. This class is non-functional, and each state
- *  type requires its own derived class (which may have multiple derived classes of its own).
+ *  Base class for defining setting of a propagator. This class is non-functional, and each state type requires its
+ *  own derived class (which may have multiple derived classes of its own).
  */
 template< typename StateScalarType >
 class PropagatorSettings
@@ -57,10 +83,21 @@ public:
      * Constructor
      * \param stateType Type of state being propagated
      * \param initialBodyStates Initial state used as input for numerical integration
+     * \param terminationSettings Settings for creating the object that checks whether the propagation is finished.
+     * \param dependentVariablesToSave Settings for the dependent variables that are to be saved during propagation
+     * (default none).
+     * \param printInterval Variable indicating how often (once per printInterval_ seconds or propagation independenty
+     * variable) the current state and time are to be printed to console (default never).
      */
     PropagatorSettings( const IntegratedStateType stateType,
-                        const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > initialBodyStates ):
-        stateType_( stateType ), initialStates_( initialBodyStates ){ }
+                        const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > initialBodyStates,
+                        const boost::shared_ptr< PropagationTerminationSettings > terminationSettings,
+                        const boost::shared_ptr< DependentVariableSaveSettings > dependentVariablesToSave =
+            boost::shared_ptr< DependentVariableSaveSettings >( ),
+                        const double printInterval = TUDAT_NAN ):
+        stateType_( stateType ), initialStates_( initialBodyStates ), stateSize_( initialBodyStates.rows( ) ),
+        terminationSettings_( terminationSettings ), dependentVariablesToSave_( dependentVariablesToSave ),
+        printInterval_( printInterval){ }
 
     //! Virtual destructor.
     virtual ~PropagatorSettings( ){ }
@@ -83,58 +120,152 @@ public:
      * Function to reset the initial state used as input for numerical integration
      * \param initialBodyStates New initial state used as input for numerical integration
      */
-    virtual void resetInitialStates( const Eigen::Matrix< StateScalarType,
-                                     Eigen::Dynamic, 1 >& initialBodyStates )
+    virtual void resetInitialStates( const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& initialBodyStates )
     {
         initialStates_ = initialBodyStates;
+        stateSize_ = initialStates_.rows( );
+    }
+
+    //! Get total size of the propagated state.
+    /*!
+     * Get total size of the propagated state.
+     * \return Total size of the propagated state.
+     */
+    int getStateSize( )
+    {
+        return stateSize_;
+    }
+
+    //! Function to retrieve settings for creating the object that checks whether the propagation is finished.
+    /*!
+     * Function to retrieve settings for creating the object that checks whether the propagation is finished.
+     * \return Settings for creating the object that checks whether the propagation is finished.
+     */
+    boost::shared_ptr< PropagationTerminationSettings > getTerminationSettings( )
+    {
+        return terminationSettings_;
+    }
+
+    //! Function to retrieve settings for the dependent variables that are to be saved during propagation (default none).
+    /*!
+     * Function to retrieve settings for the dependent variables that are to be saved during propagation (default none).
+     * \return Settings for the dependent variables that are to be saved during propagation (default none).
+     */
+    boost::shared_ptr< DependentVariableSaveSettings > getDependentVariablesToSave( )
+    {
+        return dependentVariablesToSave_;
+    }
+
+    //! Function to retrieve how often the current state and time are to be printed to console
+    /*!
+     * Function to retrieve how often the current state and time are to be printed to console
+     * \return Time intercal with which the current state and time are to be printed to console (default NaN, meaning never).
+     */
+    double getPrintInterval( )
+    {
+        return printInterval_;
     }
 
+
 protected:
 
     //!  Initial state used as input for numerical integration
     Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > initialStates_;
 
+    //! Total size of the propagated state.
+    int stateSize_;
+
+    //! Settings for creating the object that checks whether the propagation is finished.
+    boost::shared_ptr< PropagationTerminationSettings > terminationSettings_;
+
+    //! Settings for the dependent variables that are to be saved during propagation (default none).
+    boost::shared_ptr< DependentVariableSaveSettings > dependentVariablesToSave_;
+
+    //! Variable indicating how often (once per printInterval_ seconds or propagation independenty variable) the
+    //! current state and time are to be printed to console (default never).
+    double printInterval_;
+
 };
 
 //! Class for defining settings for propagating translational dynamics.
 /*!
- *  Class for defining settings for propagating translational dynamics. The propagator defines the
- *  form of the equations of motion (i.e. Cowell, Encke, Gauss etc.). This base class can be used
- *  for Cowell propagator.  Other propagators have dedicated derived class.
+ *  Class for defining settings for propagating translational dynamics. The propagator defines the form of the equations of
+ *  motion (i.e. Cowell, Encke, Gauss etc.). This base class can be used for Cowell propagator.
+ *  Other propagators have dedicated derived class.
  */
 template< typename StateScalarType = double >
 class TranslationalStatePropagatorSettings: public PropagatorSettings< StateScalarType >
 {
 public:
 
-    //! Constructor of translational state propagator settings
+    //! Constructor for generic stopping conditions.
     /*!
-     * Constructor creating translational state propagator settings object
-     * \param centralBodies List of bodies w.r.t. which the bodies in bodiesToIntegrate_ are
-     *  propagated.     
-     * \param accelerationsMap A map containing the list of accelerations acting on each body,
-     *  identifying the body being acted on and the body acted on by an acceleration. The map has as
-     *  key a string denoting the name of the body the list of accelerations, provided as the value
-     *  corresponding to a key, is acting on.  This map-value is again a map with string as key,
-     *  denoting the body exerting the acceleration, and as value a pointer to an acceleration model.     
+     * Constructor for generic stopping conditions.
+     * \param centralBodies List of bodies w.r.t. which the bodies in bodiesToIntegrate_ are propagated.
+     * \param accelerationsMap A map containing the list of accelerations acting on each body, identifying
+     *  the body being acted on and the body acted on by an acceleration. The map has as key a string denoting
+     *  the name of the body the list of accelerations, provided as the value corresponding to a key, is acting on.
+     *  This map-value is again a map with string as key, denoting the body exerting the acceleration, and as value
+     *  a pointer to an acceleration model.
      * \param bodiesToIntegrate List of bodies for which the translational state is to be propagated.
      * \param initialBodyStates Initial state used as input for numerical integration
+     * \param terminationSettings Settings for creating the object that checks whether the propagation is finished.
      * \param propagator Type of translational state propagator to be used
+     * \param dependentVariablesToSave Settings for the dependent variables that are to be saved during propagation
+     * (default none).
+     * \param printInterval Variable indicating how often (once per printInterval_ seconds or propagation independenty
+     * variable) the current state and time are to be printed to console (default never).
      */
     TranslationalStatePropagatorSettings( const std::vector< std::string >& centralBodies,
                                           const basic_astrodynamics::AccelerationMap& accelerationsMap,
                                           const std::vector< std::string >& bodiesToIntegrate,
-                                          const Eigen::Matrix< StateScalarType,
-                                                               Eigen::Dynamic, 1 >& initialBodyStates,
-                                          const TranslationalPropagatorType propagator = cowell):
-        PropagatorSettings< StateScalarType >( transational_state, initialBodyStates ),
-        centralBodies_( centralBodies ), accelerationsMap_( accelerationsMap ),
-        bodiesToIntegrate_( bodiesToIntegrate ), propagator_( propagator ){ }
-
-    //! Virtual destructor
+                                          const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& initialBodyStates,
+                                          const boost::shared_ptr< PropagationTerminationSettings > terminationSettings,
+                                          const TranslationalPropagatorType propagator = cowell,
+                                          const boost::shared_ptr< DependentVariableSaveSettings > dependentVariablesToSave =
+            boost::shared_ptr< DependentVariableSaveSettings >( ),
+                                          const double printInterval = TUDAT_NAN ):
+        PropagatorSettings< StateScalarType >( transational_state, initialBodyStates, terminationSettings,
+                                               dependentVariablesToSave, printInterval ),
+        centralBodies_( centralBodies ),
+        accelerationsMap_( accelerationsMap ), bodiesToIntegrate_( bodiesToIntegrate ),
+        propagator_( propagator ){ }
+
+    //! Constructor for fixed propagation time stopping conditions.
     /*!
-     *  Virtual destructor
+     * Constructor for fixed propagation time stopping conditions.
+     * \param centralBodies List of bodies w.r.t. which the bodies in bodiesToIntegrate_ are propagated.
+     * \param accelerationsMap A map containing the list of accelerations acting on each body, identifying
+     *  the body being acted on and the body acted on by an acceleration. The map has as key a string denoting
+     *  the name of the body the list of accelerations, provided as the value corresponding to a key, is acting on.
+     *  This map-value is again a map with string as key, denoting the body exerting the acceleration, and as value
+     *  a pointer to an acceleration model.
+     * \param bodiesToIntegrate List of bodies for which the translational state is to be propagated.
+     * \param initialBodyStates Initial state used as input for numerical integration
+     * \param endTime Time at which to stop the numerical propagation
+     * \param propagator Type of translational state propagator to be used
+     * \param dependentVariablesToSave Settings for the dependent variables that are to be saved during propagation
+     * (default none).
+     * \param printInterval Variable indicating how often (once per printInterval_ seconds or propagation independenty
+     * variable) the current state and time are to be printed to console (default never).
      */
+    TranslationalStatePropagatorSettings( const std::vector< std::string >& centralBodies,
+                                          const basic_astrodynamics::AccelerationMap& accelerationsMap,
+                                          const std::vector< std::string >& bodiesToIntegrate,
+                                          const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& initialBodyStates,
+                                          const double endTime,
+                                          const TranslationalPropagatorType propagator = cowell,
+                                          const boost::shared_ptr< DependentVariableSaveSettings > dependentVariablesToSave =
+            boost::shared_ptr< DependentVariableSaveSettings >( ),
+                                          const double printInterval = TUDAT_NAN ):
+        PropagatorSettings< StateScalarType >(
+            transational_state, initialBodyStates,  boost::make_shared< PropagationTimeTerminationSettings >( endTime ),
+            dependentVariablesToSave, printInterval ),
+        centralBodies_( centralBodies ),
+        accelerationsMap_( accelerationsMap ), bodiesToIntegrate_( bodiesToIntegrate ),
+        propagator_( propagator ){ }
+
+    //! Destructor
     ~TranslationalStatePropagatorSettings( ){ }
 
     //! List of bodies w.r.t. which the bodies in bodiesToIntegrate_ are propagated.
@@ -142,11 +273,11 @@ public:
 
     //! A map containing the list of accelerations acting on each body
     /*!
-     *  A map containing the list of accelerations acting on each body, identifying the body being
-     *  acted on and the body acted on by an acceleration. The map has as key a string denoting the
-     *  name of the body the list of accelerations, provided as the value corresponding to a key, is
-     *  acting on.  This map-value is again a map with string as key, denoting the body exerting the
-     *  acceleration, and as value a pointer to an acceleration model.
+     *  A map containing the list of accelerations acting on each body, identifying
+     *  the body being acted on and the body acted on by an acceleration. The map has as key a string denoting
+     *  the name of the body the list of accelerations, provided as the value corresponding to a key, is acting on.
+     *  This map-value is again a map with string as key, denoting the body exerting the acceleration, and as value
+     *  a pointer to an acceleration model.
      */
     basic_astrodynamics::AccelerationMap accelerationsMap_;
 
@@ -158,16 +289,243 @@ public:
 
 };
 
+
+//! Class for defining settings for propagating the mass of a body
+/*!
+ *  Class for defining settings for propagating the mass of a body. The body masses are propagated in their natural
+ *  form (i.e. no choice of equations of motion as is the case for translational dynamics)l
+ */
 template< typename StateScalarType >
-//! Function to retrieve the list of integrated state types and reference ids
+class MassPropagatorSettings: public PropagatorSettings< StateScalarType >
+{
+public:
+
+    //! Constructor of mass state propagator settings
+    /*!
+     * Constructor  of mass state propagator settings
+     * \param bodiesWithMassToPropagate List of bodies for which the mass is to be propagated.
+     * \param massRateModels List of mass rate models per propagated body.
+     * \param initialBodyMasses Initial masses used as input for numerical integration.
+     * \param terminationSettings Settings for creating the object that checks whether the propagation is finished.
+     * \param dependentVariablesToSave Settings for the dependent variables that are to be saved during propagation
+     * (default none).
+     * \param printInterval Variable indicating how often (once per printInterval_ seconds or propagation independenty
+     * variable) the current state and time are to be printed to console (default never).
+     */
+    MassPropagatorSettings(
+            const std::vector< std::string > bodiesWithMassToPropagate,
+            const std::map< std::string, boost::shared_ptr< basic_astrodynamics::MassRateModel > > massRateModels,
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& initialBodyMasses,
+            const boost::shared_ptr< PropagationTerminationSettings > terminationSettings,
+            const boost::shared_ptr< DependentVariableSaveSettings > dependentVariablesToSave =
+            boost::shared_ptr< DependentVariableSaveSettings >( ),
+            const double printInterval = TUDAT_NAN ):
+        PropagatorSettings< StateScalarType >( body_mass_state, initialBodyMasses, terminationSettings,
+                                               dependentVariablesToSave, printInterval ),
+        bodiesWithMassToPropagate_( bodiesWithMassToPropagate ), massRateModels_( massRateModels )
+    { }
+
+    //! List of bodies for which the mass is to be propagated.
+    std::vector< std::string > bodiesWithMassToPropagate_;
+
+    //! List of mass rate models per propagated body.
+    std::map< std::string, boost::shared_ptr< basic_astrodynamics::MassRateModel > > massRateModels_;
+};
+
+//! Function to retrieve the state size for a list of propagator settings.
+/*!
+ *  Function to retrieve the initial state for a list of propagator settings.
+ *  \param propagatorSettingsList List of propagator settings (sorted by type as key). Map value provides list
+ *  of propagator settings for given type.
+ *  \return Vector of initial states, sorted in order of IntegratedStateType, and then in the order of the
+ *  vector of PropagatorSettings of given type.
+ */
+template< typename StateScalarType >
+int getMultiTypePropagatorStateSize(
+        const std::map< IntegratedStateType, std::vector< boost::shared_ptr< PropagatorSettings< StateScalarType > > > >&
+        propagatorSettingsList )
+{
+    int stateSize = 0;
+
+    // Iterate over all propagation settings and add size to list
+    for( typename std::map< IntegratedStateType,
+         std::vector< boost::shared_ptr< PropagatorSettings< StateScalarType > > > >::const_iterator
+         typeIterator = propagatorSettingsList.begin( ); typeIterator != propagatorSettingsList.end( ); typeIterator++ )
+    {
+        for( unsigned int i = 0; i < typeIterator->second.size( ); i++ )
+        {
+            stateSize += typeIterator->second.at( i )->getStateSize( );
+        }
+    }
+    return stateSize;
+}
+
+//! Function to retrieve the initial state for a list of propagator settings.
 /*!
- * Function to retrieve the list of integrated state types and reference ids. For translational and
- * rotational dynamics, the id refers only to the body being propagated (and the second entry of the
- * pair is empty: ""). For proper time propagation, a body and a reference point may be provided,
- * resulting in non-empty first and second pair entries.
- * \param propagatorSettings Settings that are to be used for the propagation.
- * \return List of integrated state types and reference ids
+ *  Function to retrieve the initial state for a list of propagator settings.
+ *  \param propagatorSettingsList List of propagator settings (sorted by type as key). Map value provides list
+ *  of propagator settings for given type.
+ *  \return Vector of initial states, sorted in order of IntegratedStateType, and then in the order of the
+ *  vector of PropagatorSettings of given type.
  */
+template< typename StateScalarType >
+Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > createCombinedInitialState(
+        const std::map< IntegratedStateType, std::vector< boost::shared_ptr< PropagatorSettings< StateScalarType > > > >&
+        propagatorSettingsList )
+{
+    // Get total size of propagated state
+    int totalSize = getMultiTypePropagatorStateSize( propagatorSettingsList );
+
+    Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > combinedInitialState =
+            Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >::Zero( totalSize, 1 );
+
+    // Iterate over all propagation settings and add to total list
+    int currentIndex = 0;
+    Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > currentInitialState;
+    for( typename std::map< IntegratedStateType,
+         std::vector< boost::shared_ptr< PropagatorSettings< StateScalarType > > > >::const_iterator
+         typeIterator = propagatorSettingsList.begin( ); typeIterator != propagatorSettingsList.end( ); typeIterator++ )
+    {
+        for( unsigned int i = 0; i < typeIterator->second.size( ); i++ )
+        {
+            currentInitialState = typeIterator->second.at( i )->getInitialStates( );
+            combinedInitialState.segment( currentIndex, currentInitialState.rows( ) ) = currentInitialState;
+            currentIndex += currentInitialState.rows( );
+        }
+    }
+
+    return combinedInitialState;
+}
+
+//! Class for defining settings for propagating multiple types of dynamics concurrently.
+template< typename StateScalarType >
+class MultiTypePropagatorSettings: public PropagatorSettings< StateScalarType >
+{
+public:
+
+    //! Constructor.
+    /*!
+     * Constructor
+     * \param propagatorSettingsMap List of propagator settings to use (state type as key). List of propagator settigns
+     * per type given as vector in map value.
+     * \param terminationSettings Settings for creating the object that checks whether the propagation is finished.
+     * \param dependentVariablesToSave Settings for the dependent variables that are to be saved during propagation
+     * (default none).
+     * \param printInterval Variable indicating how often (once per printInterval_ seconds or propagation independenty
+     * variable) the current state and time are to be printed to console (default never).
+     */
+    MultiTypePropagatorSettings(
+            const std::map< IntegratedStateType,
+            std::vector< boost::shared_ptr< PropagatorSettings< StateScalarType > > > > propagatorSettingsMap,
+            const boost::shared_ptr< PropagationTerminationSettings > terminationSettings,
+            const boost::shared_ptr< DependentVariableSaveSettings > dependentVariablesToSave =
+            boost::shared_ptr< DependentVariableSaveSettings >( ),
+            const double printInterval = TUDAT_NAN ):
+        PropagatorSettings< StateScalarType >(
+            hybrid, createCombinedInitialState< StateScalarType >( propagatorSettingsMap ),
+            terminationSettings, dependentVariablesToSave, printInterval ),
+        propagatorSettingsMap_( propagatorSettingsMap )
+    {
+
+    }
+
+    //! Constructor.
+    /*!
+     * Constructor
+     * \param propagatorSettingsVector Vector of propagator settings to use.
+     * \param terminationSettings Settings for creating the object that checks whether the propagation is finished.
+     * \param dependentVariablesToSave Settings for the dependent variables that are to be saved during propagation
+     * (default none).
+     * \param printInterval Variable indicating how often (once per printInterval_ seconds or propagation independenty
+     * variable) the current state and time are to be printed to console (default never).
+     */
+    MultiTypePropagatorSettings(
+            const std::vector< boost::shared_ptr< PropagatorSettings< StateScalarType > > > propagatorSettingsVector,
+            const boost::shared_ptr< PropagationTerminationSettings > terminationSettings,
+            const boost::shared_ptr< DependentVariableSaveSettings > dependentVariablesToSave =
+            boost::shared_ptr< DependentVariableSaveSettings >( ),
+            const double printInterval = TUDAT_NAN ):
+        PropagatorSettings< StateScalarType >(
+            hybrid, Eigen::VectorXd::Zero( 0 ),
+            terminationSettings, dependentVariablesToSave, printInterval )
+    {
+        for( unsigned int i = 0; i < propagatorSettingsVector.size( ); i++ )
+        {
+            propagatorSettingsMap_[ propagatorSettingsVector.at( i )->stateType_ ].push_back(
+                        propagatorSettingsVector.at( i ) );
+        }
+
+        this->initialStates_ = createCombinedInitialState< StateScalarType >( propagatorSettingsMap_ );
+    }
+
+    //! Destructor
+    ~MultiTypePropagatorSettings( ){ }
+
+    //! Function to reset the initial state used as input for numerical integration
+    /*!
+     * Function to reset the initial state used as input for numerical integration
+     * \param initialBodyStates New initial state used as input for numerical integration, sorted in order of
+     * IntegratedStateType, and then in the order of the vector of PropagatorSettings of given type.
+     */
+    void resetInitialStates( const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& initialBodyStates )
+    {
+        // Iterate over all propagator settings.
+        int currentStartIndex = 0;
+        for( typename std::map< IntegratedStateType,
+             std::vector< boost::shared_ptr< PropagatorSettings< StateScalarType > > > >::iterator
+             propagatorIterator = propagatorSettingsMap_.begin( ); propagatorIterator != propagatorSettingsMap_.end( );
+             propagatorIterator++ )
+        {
+            for( unsigned int i = 0; i < propagatorIterator->second.size( ); i++ )
+            {
+                // Get current state size
+                int currentParameterSize = propagatorIterator->second.at( i )->getInitialStates( ).rows( );
+
+                // Check consistency
+                if( currentParameterSize + currentStartIndex > initialBodyStates.rows( ) )
+                {
+                    throw std::runtime_error(
+                                "Error when resetting multi-type state, sizes are incompatible " );
+                }
+
+                // Reset state for current settings
+                propagatorIterator->second.at( i )->resetInitialStates(
+                            initialBodyStates.block( currentStartIndex, 0, currentParameterSize, 1 ) );
+                currentStartIndex += currentParameterSize;
+
+            }
+        }
+
+        // Check consistency
+        if( currentStartIndex != initialBodyStates.rows( ) )
+        {
+            std::string errorMessage = "Error when resetting multi-type state, total size is incompatible "+
+                    boost::lexical_cast< std::string >( currentStartIndex ) +
+                    boost::lexical_cast< std::string >( initialBodyStates.rows( ) );
+            throw std::runtime_error( errorMessage );
+        }
+    }
+
+    //! List of propagator settings to use
+    /*!
+     * List of propagator settings to use (state type as key). List of propagator settigns
+     * per type given as vector in map value.
+     */
+
+    std::map< IntegratedStateType, std::vector< boost::shared_ptr< PropagatorSettings< StateScalarType > > > >
+    propagatorSettingsMap_;
+
+};
+
+template< typename StateScalarType >
+//! Function to retrieve the list of integrated state types and reference ids
+/*!
+* Function to retrieve the list of integrated state types and reference ids. For translational and rotational dynamics,
+* the id refers only to the body being propagated (and the second entry of the pair is empty: ""). For proper time
+* propagation, a body and a reference point may be provided, resulting in non-empty first and second pair entries.
+* \param propagatorSettings Settings that are to be used for the propagation.
+* \return List of integrated state types and reference ids
+*/
 std::map< IntegratedStateType, std::vector< std::pair< std::string, std::string > > > getIntegratedTypeAndBodyList(
         const boost::shared_ptr< PropagatorSettings< StateScalarType > > propagatorSettings )
 {
@@ -176,12 +534,57 @@ std::map< IntegratedStateType, std::vector< std::pair< std::string, std::string
     // Identify propagator type
     switch( propagatorSettings->stateType_ )
     {    
-    case transational_state:
+    case hybrid:
     {
+        boost::shared_ptr< MultiTypePropagatorSettings< StateScalarType > > multiTypePropagatorSettings =
+                boost::dynamic_pointer_cast< MultiTypePropagatorSettings< StateScalarType > >( propagatorSettings );
+
+        std::map< IntegratedStateType, std::vector< std::pair< std::string, std::string > > > singleTypeIntegratedStateList;
 
+        for( typename std::map< IntegratedStateType,
+             std::vector< boost::shared_ptr< PropagatorSettings< StateScalarType > > > >::const_iterator
+             typeIterator = multiTypePropagatorSettings->propagatorSettingsMap_.begin( );
+             typeIterator != multiTypePropagatorSettings->propagatorSettingsMap_.end( ); typeIterator++ )
+        {
+            if( typeIterator->first != hybrid )
+            {
+                for( unsigned int i = 0; i < typeIterator->second.size( ); i++ )
+                {
+                    singleTypeIntegratedStateList = getIntegratedTypeAndBodyList< StateScalarType >(
+                                typeIterator->second.at( i ) );
+
+                    if( singleTypeIntegratedStateList.begin( )->first != typeIterator->first
+                            || singleTypeIntegratedStateList.size( ) != 1 )
+                    {
+                        std::cerr<<"Error when making integrated state list for hybrid propagator, inconsistency encountered "<<
+                                   singleTypeIntegratedStateList.begin( )->first<<" "<<typeIterator->first<<" "<<
+                                   singleTypeIntegratedStateList.size( )<<" "<<
+                                   singleTypeIntegratedStateList.begin( )->second.size( )<<std::endl;
+                    }
+                    else
+                    {
+                        for( unsigned int j = 0; j < singleTypeIntegratedStateList[ typeIterator->first ].size( ); j++ )
+                        {
+                            integratedStateList[ typeIterator->first ].push_back(
+                                        singleTypeIntegratedStateList.begin( )->second.at( j ) );
+                        }
+
+                    }
+                }
+            }
+            else
+            {
+                std::cerr<<"Error when making integrated state list, cannot handle hybrid propagator inside hybrid propagator"<<std::endl;
+            }
+        }
+        break;
+    }
+    case transational_state:
+    {
         boost::shared_ptr< TranslationalStatePropagatorSettings< StateScalarType > >
                 translationalPropagatorSettings = boost::dynamic_pointer_cast<
                      TranslationalStatePropagatorSettings< StateScalarType > >( propagatorSettings );
+
         if( translationalPropagatorSettings == NULL )
         {
             throw std::runtime_error( "Error getting integrated state type list, translational state input inconsistent" );
@@ -191,23 +594,63 @@ std::map< IntegratedStateType, std::vector< std::pair< std::string, std::string
         std::vector< std::pair< std::string, std::string > > integratedBodies;
         for( unsigned int i = 0; i < translationalPropagatorSettings->bodiesToIntegrate_.size( ); i++ )
         {
-            integratedBodies.push_back( std::make_pair(
-                translationalPropagatorSettings->bodiesToIntegrate_.at( i ), "" ) );
+            integratedBodies.push_back( std::make_pair( translationalPropagatorSettings->bodiesToIntegrate_.at( i ), "" ) );
         }
         integratedStateList[ transational_state ] = integratedBodies;
 
         break;
     }
+    case body_mass_state:
+    {
+        boost::shared_ptr< MassPropagatorSettings< StateScalarType > >
+                massPropagatorSettings = boost::dynamic_pointer_cast<
+                     MassPropagatorSettings< StateScalarType > >( propagatorSettings );
+        if( massPropagatorSettings == NULL )
+        {
+            throw std::runtime_error( "Error getting integrated state type list, mass state input inconsistent" );
+        }
+
+        // Retrieve list of integrated bodies in correct formatting.
+        std::vector< std::pair< std::string, std::string > > integratedBodies;
+        for( unsigned int i = 0; i < massPropagatorSettings->bodiesWithMassToPropagate_.size( ); i++ )
+        {
+            integratedBodies.push_back( std::make_pair(
+                massPropagatorSettings->bodiesWithMassToPropagate_.at( i ), "" ) );
+        }
+        integratedStateList[ body_mass_state ] = integratedBodies;
+
+        break;
+    }
     default:
-        throw std::runtime_error( "Error, could not process integrated state type " +
+        throw std::runtime_error( "Error, could not process integrated state type ingetIntegratedTypeAndBodyList " +
                                   boost::lexical_cast< std::string >( propagatorSettings->stateType_ ) );
     }
 
     return integratedStateList;
 }
 
+
 } // namespace propagators
 
 } // namespace tudat
 
+namespace std
+{
+
+//! Hash for IntegratedStateType enum.
+template< >
+struct hash< tudat::propagators::IntegratedStateType >
+{
+    typedef tudat::propagators::IntegratedStateType argument_type;
+    typedef size_t result_type;
+
+    result_type operator () (const argument_type& x) const
+    {
+        using type = typename std::underlying_type<argument_type>::type;
+        return std::hash< type >( )( static_cast< type >( x ) );
+    }
+};
+
+} // namespace std
+
 #endif // TUDAT_PROPAGATIONSETTINGS_H
diff --git a/Tudat/Astrodynamics/Propagators/propagationTermination.cpp b/Tudat/Astrodynamics/Propagators/propagationTermination.cpp
new file mode 100644
index 0000000..0920c17
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/propagationTermination.cpp
@@ -0,0 +1,162 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#include "Tudat/Astrodynamics/Propagators/propagationTermination.h"
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+//! Function to check whether the propagation is to be be stopped
+bool FixedTimePropagationTerminationCondition::checkStopCondition( const double time  )
+{
+    bool stopPropagation = 0;
+
+    // Check whether stop time has been reached
+    if( propagationDirectionIsPositive_ && ( time >= stopTime_ ) )
+    {
+        stopPropagation = 1;
+    }
+    else if( !propagationDirectionIsPositive_ && ( time <= stopTime_ ) )
+    {
+        stopPropagation = 1;
+    }
+    return stopPropagation;
+}
+
+//! Function to check whether the propagation is to be be stopped
+bool SingleVariableLimitPropagationTerminationCondition::checkStopCondition( const double time  )
+{
+    bool stopPropagation = 0;
+    double currentVariable = variableRetrievalFuntion_( );
+    if( useAsLowerBound_ && ( currentVariable < limitingValue_ ) )
+    {
+        stopPropagation = 1;
+    }
+    else if( !useAsLowerBound_ && ( currentVariable > limitingValue_ ) )
+    {
+        stopPropagation = 1;
+    }
+    return stopPropagation;
+}
+
+//! Function to check whether the propagation is to be be stopped
+bool HybridPropagationTerminationCondition::checkStopCondition( const double time )
+{
+    // Check if single condition is fulfilled.
+    if( fulFillSingleCondition_ )
+    {
+        bool stopPropagation = 0;
+        for( unsigned int i = 0; i < propagationTerminationCondition_.size( ); i++ )
+        {
+            if( propagationTerminationCondition_.at( i )->checkStopCondition( time ) )
+            {
+                stopPropagation = 1;
+                break;
+            }
+        }
+        return stopPropagation;
+    }
+    // Check all conditions are fulfilled.
+    else
+    {
+        bool stopPropagation = 1;
+        for( unsigned int i = 0; i < propagationTerminationCondition_.size( ); i++ )
+        {
+            if( !propagationTerminationCondition_.at( i )->checkStopCondition( time ) )
+            {
+                stopPropagation = 0;
+                break;
+            }
+        }
+        return stopPropagation;
+    }
+}
+
+
+//! Function to create propagation termination conditions from associated settings
+boost::shared_ptr< PropagationTerminationCondition > createPropagationTerminationConditions(
+        const boost::shared_ptr< PropagationTerminationSettings > terminationSettings,
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const double initialTimeStep )
+{
+    boost::shared_ptr< PropagationTerminationCondition > propagationTerminationCondition;
+
+    // Check termination type.
+    switch( terminationSettings->terminationType_ )
+    {
+    case time_stopping_condition:
+    {
+        // Create stopping time termination condition.
+        boost::shared_ptr< PropagationTimeTerminationSettings > timeTerminationSettings =
+                boost::dynamic_pointer_cast< PropagationTimeTerminationSettings >( terminationSettings );
+        propagationTerminationCondition = boost::make_shared< FixedTimePropagationTerminationCondition >(
+                    timeTerminationSettings->terminationTime_, ( initialTimeStep > 0 ) ? true : false );
+        break;
+    }
+    case dependent_variable_stopping_condition:
+    {
+        boost::shared_ptr< PropagationDependentVariableTerminationSettings > dependentVariableTerminationSettings =
+                boost::dynamic_pointer_cast< PropagationDependentVariableTerminationSettings >( terminationSettings );
+
+        // Get dependent variable function
+        boost::function< double( ) > dependentVariableFunction;
+        if( getDependentVariableSize(
+                    dependentVariableTerminationSettings->dependentVariableSettings_->variableType_ ) == 1 )
+        {
+            dependentVariableFunction =
+                    getDoubleDependentVariableFunction(
+                        dependentVariableTerminationSettings->dependentVariableSettings_, bodyMap );
+        }
+        else
+        {
+            throw std::runtime_error( "Error, cannot make stopping condition from vector dependent variable" );
+        }
+
+        // Create dependent variable termination condition.
+        propagationTerminationCondition = boost::make_shared< SingleVariableLimitPropagationTerminationCondition >(
+                    dependentVariableTerminationSettings->dependentVariableSettings_,
+                    dependentVariableFunction, dependentVariableTerminationSettings->limitValue_,
+                    dependentVariableTerminationSettings->useAsLowerLimit_ );
+        break;
+    }
+    case hybrid_stopping_condition:
+    {
+        boost::shared_ptr< PropagationHybridTerminationSettings > hybridTerminationSettings =
+                boost::dynamic_pointer_cast< PropagationHybridTerminationSettings >( terminationSettings );
+
+        // Recursively create termination condition list.
+        std::vector< boost::shared_ptr< PropagationTerminationCondition > > propagationTerminationConditionList;
+        for( unsigned int i = 0; i < hybridTerminationSettings->terminationSettings_.size( ); i++ )
+        {
+            propagationTerminationConditionList.push_back(
+                        createPropagationTerminationConditions(
+                            hybridTerminationSettings->terminationSettings_.at( i ),
+                            bodyMap, initialTimeStep ) );
+        }
+        propagationTerminationCondition = boost::make_shared< HybridPropagationTerminationCondition >(
+                    propagationTerminationConditionList, hybridTerminationSettings->fulFillSingleCondition_ );
+        break;
+    }
+    default:
+        std::string errorMessage = "Error, stopping condition type " + boost::lexical_cast< std::string >(
+                    terminationSettings->terminationType_ ) + "not recognized when making stopping conditions object";
+        throw std::runtime_error( errorMessage );
+        break;
+    }
+    return propagationTerminationCondition;
+
+} // namespace propagators
+
+} // namespace tudat
+
+}
diff --git a/Tudat/Astrodynamics/Propagators/propagationTermination.h b/Tudat/Astrodynamics/Propagators/propagationTermination.h
new file mode 100644
index 0000000..31e2c7b
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/propagationTermination.h
@@ -0,0 +1,191 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_PROPAGATIONTERMINATIONCONDITIONS_H
+#define TUDAT_PROPAGATIONTERMINATIONCONDITIONS_H
+
+#include <boost/shared_ptr.hpp>
+
+#include "Tudat/Astrodynamics/Propagators/propagationOutput.h"
+#include "Tudat/Astrodynamics/Propagators/propagationSettings.h"
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+//! Base class for checking whether the numerical propagation is to be stopped at current time step or not
+/*!
+ *  Base class for checking whether the numerical propagation is to be stopped at current time step or not. Derived
+ *  classes implement the various types of conditions (and associated threshold values) under which the propagation is to
+ *  be stopped.
+ */
+class PropagationTerminationCondition
+{
+public:
+
+    //! Constructor
+    PropagationTerminationCondition( ){ }
+
+    //! Destructor
+    virtual ~PropagationTerminationCondition( ){ }
+
+    //! (Pure virtual) function to check whether the propagation should be stopped
+    /*!
+     * (Pure virtual) function to check whether the propagation should be stopped. Note that the accelerations and
+     * environment must be updated (done automatically during numerical propagation) to check the stopping condition.
+     * \param time Current time in propagation
+     * \return True if propagation is to be stopped, false otherwise.
+     */
+    virtual bool checkStopCondition( const double time ) = 0;
+};
+
+//! Class for stopping the propagation after a fixed amount of time (i.e. for certain independent variable value)
+class FixedTimePropagationTerminationCondition: public PropagationTerminationCondition
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param stopTime Time at which the propagation is to stop.
+     * \param propagationDirectionIsPositive Boolean denoting whether propagation is forward (if true) or backwards
+     * (if false) in time.
+     */
+    FixedTimePropagationTerminationCondition(
+            const double stopTime,
+            const bool propagationDirectionIsPositive ):
+        stopTime_( stopTime ),
+        propagationDirectionIsPositive_( propagationDirectionIsPositive ){ }
+
+
+    //! Function to check whether the propagation is to be be stopped
+    /*!
+     * Function to check whether the propagation is to be be stopped, i.e. whether the stopTime_ has been reached or not.
+     * \param time Current time in propagation
+     * \return True if propagation is to be stopped, false otherwise.
+     */
+    bool checkStopCondition( const double time );
+
+private:
+
+    //! Time at which the propagation is to stop.
+    double stopTime_;
+
+    //!  Boolean denoting whether propagation is forward (if true) or backwards (if false) in time.
+    bool propagationDirectionIsPositive_;
+};
+
+//! Class for stopping the propagation when a dependent variable reaches a given value (either upper or lower bound)
+class SingleVariableLimitPropagationTerminationCondition: public PropagationTerminationCondition
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param dependentVariableSettings Settings for dependent variable that is to be checked
+     * \param variableRetrievalFuntion Function returning the dependent variable.
+     * \param limitingValue Value at which the propagation is to be stopped
+     * \param useAsLowerBound Boolean denoting whether the propagation should stop if the dependent variable goes below
+     * (if true) or above (if false) limitingValue
+     */
+    SingleVariableLimitPropagationTerminationCondition(
+            const boost::shared_ptr< SingleDependentVariableSaveSettings > dependentVariableSettings,
+            const boost::function< double( ) > variableRetrievalFuntion,
+            const double limitingValue,
+            const bool useAsLowerBound ):
+        dependentVariableSettings_( dependentVariableSettings ), variableRetrievalFuntion_( variableRetrievalFuntion ),
+        limitingValue_( limitingValue ), useAsLowerBound_( useAsLowerBound ){ }
+
+    //! Destructor.
+    ~SingleVariableLimitPropagationTerminationCondition( ){ }
+
+    //! Function to check whether the propagation is to be be stopped
+    /*!
+     * Function to check whether the propagation is to be be stopped, i.e. whether the given dependent variable has been
+     * reached or not.
+     * \return True if propagation is to be stopped, false otherwise.
+     */
+    bool checkStopCondition( const double time );
+
+private:
+
+    //! Settings for dependent variable that is to be checked
+    boost::shared_ptr< SingleDependentVariableSaveSettings > dependentVariableSettings_;
+
+    //! Function returning the dependent variable.
+    boost::function< double( ) > variableRetrievalFuntion_;
+
+    //! Value at which the propagation is to be stopped
+    double limitingValue_;
+
+    //! Boolean denoting whether the propagation should stop if the dependent variable goes below
+    //! (if true) or above (if false) limitingValue
+    bool useAsLowerBound_;
+};
+
+//! Class for stopping the propagation when one or all of a given set of stopping conditions is reached.
+class HybridPropagationTerminationCondition: public PropagationTerminationCondition
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param propagationTerminationCondition List of termination conditions that are checked when calling
+     * checkStopCondition is called.
+     * \param fulFillSingleCondition Boolean denoting whether a single (if true) or all (if false) of the entries in the
+     * propagationTerminationCondition_ should return true from the checkStopCondition function to stop the propagation.
+     */
+    HybridPropagationTerminationCondition(
+            const std::vector< boost::shared_ptr< PropagationTerminationCondition > > propagationTerminationCondition,
+            const bool fulFillSingleCondition = 0 ):
+        propagationTerminationCondition_( propagationTerminationCondition ),
+        fulFillSingleCondition_( fulFillSingleCondition ){ }
+
+    //! Function to check whether the propagation is to be be stopped
+    /*!
+     * Function to check whether the propagation is to be be stopped, i.e. one or all (depending on value of
+     * fulFillSingleCondition_) of the stopping conditions are fulfilled.
+     * \return True if propagation is to be stopped, false otherwise.
+     */
+    bool checkStopCondition( const double time );
+
+private:
+
+    //! List of termination conditions that are checked when calling checkStopCondition is called.
+    std::vector< boost::shared_ptr< PropagationTerminationCondition > > propagationTerminationCondition_;
+
+    //!  Boolean denoting whether a single (if true) or all (if false) of the entries in the propagationTerminationCondition_
+    //!  should return true from the checkStopCondition function to stop the propagation.
+    bool fulFillSingleCondition_;
+};
+
+//! Function to create propagation termination conditions from associated settings
+/*!
+ * Function to create propagation termination conditions from associated settings
+ * \param terminationSettings Settings for propagation termination conditions
+ * \param bodyMap List of body objects that contains all environment models
+ * \param initialTimeStep Time step at first call of numerical integration.
+ * \return Object used to check whether propagation is to be stopped or not.
+ */
+boost::shared_ptr< PropagationTerminationCondition > createPropagationTerminationConditions(
+        const boost::shared_ptr< PropagationTerminationSettings > terminationSettings,
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const double initialTimeStep );
+
+} // namespace propagators
+
+} // namespace tudat
+
+
+#endif // TUDAT_PROPAGATIONTERMINATIONCONDITIONS_H
diff --git a/Tudat/Astrodynamics/Propagators/propagationTerminationSettings.h b/Tudat/Astrodynamics/Propagators/propagationTerminationSettings.h
new file mode 100644
index 0000000..35caf1f
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/propagationTerminationSettings.h
@@ -0,0 +1,165 @@
+/*    Copyright (c) 2010-2016, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#ifndef TUDAT_PROPAGATIONTERMINATIONSETTINGS_H
+#define TUDAT_PROPAGATIONTERMINATIONSETTINGS_H
+
+#include <vector>
+
+#include <boost/shared_ptr.hpp>
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+class SingleDependentVariableSaveSettings;
+
+//! Enum listing the available types of propagation termination settings.
+enum PropagationTerminationTypes
+{
+    time_stopping_condition,
+    dependent_variable_stopping_condition,
+    hybrid_stopping_condition
+};
+
+
+//! Base class for defining propagation termination settings.
+/*!
+ *  Base class for defining propagation termination settings, i.e. conditions on which the porpagation is deemed to be
+ *  'finished'. Each particular type of stopping condition requires a different derived class.
+ */
+class PropagationTerminationSettings
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param terminationType Type of stopping condition that is to be used.
+     */
+    PropagationTerminationSettings( const PropagationTerminationTypes terminationType ):
+        terminationType_( terminationType ){ }
+
+    //! Destructor
+    virtual ~PropagationTerminationSettings( ){ }
+
+    //! Type of stopping condition that is to be used.
+    PropagationTerminationTypes terminationType_;
+};
+
+//! Class for propagation stopping conditions settings: stopping the propagation after a fixed amount of time
+/*!
+ *  Class for propagation stopping conditions settings: stopping the propagation after a fixed amount of time. Note that the
+ *  propagator will finish a given time step, slightly surpassing the defined final time.
+ */
+class PropagationTimeTerminationSettings: public PropagationTerminationSettings
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param terminationTime Maximum time for the propagation, upon which the propagation is to be stopped
+     */
+    PropagationTimeTerminationSettings( const double terminationTime ):
+        PropagationTerminationSettings( time_stopping_condition ),
+        terminationTime_( terminationTime ){ }
+
+    //! Destructor
+    ~PropagationTimeTerminationSettings( ){ }
+
+    //! Maximum time for the propagation, upon which the propagation is to be stopped
+    double terminationTime_;
+};
+
+//! Class for propagation stopping conditions settings: stopping the propagation after a given dependent variable reaches a
+//! certain value.
+/*!
+ *  Class for propagation stopping conditions settings: stopping the propagation after a given dependent variable reaches a
+ *  certain value. The limit value may be set as both an upper or lower bound (i.e. the propagation continues while the
+ *  value is below or above some given value).
+ *  Note that the propagator will finish a given time step, slightly surpassing the defined limit value of the dependent
+ *  variable
+ */
+class PropagationDependentVariableTerminationSettings: public PropagationTerminationSettings
+{
+public:
+    //! Constructor
+    /*!
+     * Constructor
+     * \param dependentVariableSettings Settings for dependent variable that is to be checked
+     * \param limitValue Value at which the propagation is to be stopped
+     * \param useAsLowerLimit Boolean denoting whether the propagation should stop if the dependent variable goes below
+     * (if true) or above (if false) limitingValue
+     */
+    PropagationDependentVariableTerminationSettings(
+            const boost::shared_ptr< SingleDependentVariableSaveSettings > dependentVariableSettings,
+            const double limitValue,
+            const bool useAsLowerLimit ):
+        PropagationTerminationSettings( dependent_variable_stopping_condition ),
+        dependentVariableSettings_( dependentVariableSettings ),
+        limitValue_( limitValue ), useAsLowerLimit_( useAsLowerLimit ){ }
+
+    //! Destructor
+    ~PropagationDependentVariableTerminationSettings( ){ }
+
+    //! Settings for dependent variable that is to be checked
+    boost::shared_ptr< SingleDependentVariableSaveSettings > dependentVariableSettings_;
+
+    //! Value at which the propagation is to be stopped
+    double limitValue_;
+
+    //! Boolean denoting whether the propagation should stop if the dependent variable goes below (if true) or above
+    //! (if false) limitingValue
+    bool useAsLowerLimit_;
+};
+
+//! Class for propagation stopping conditions settings: combination of other stopping conditions.
+/*!
+ *  Class for propagation stopping conditions settings: combination of other stopping conditions. This class can be used
+ *  to define that all of any number of conditions must be met, or that a single of these settings must be met to
+ *  stop the propagation.
+ */
+class PropagationHybridTerminationSettings: public PropagationTerminationSettings
+{
+public:
+
+    //! Constructor
+    /*!
+     * \brief PropagationHybridTerminationSettings
+     * \param terminationSettings List of termination settings for which stopping conditions are created.
+     * \param fulFillSingleCondition Boolean denoting whether a single (if true) or all (if false) of the conditions
+     * defined by the entries in the terminationSettings list should be met.
+     */
+    PropagationHybridTerminationSettings(
+            const std::vector< boost::shared_ptr< PropagationTerminationSettings > > terminationSettings,
+            const bool fulFillSingleCondition = 0 ):
+        PropagationTerminationSettings( hybrid_stopping_condition ),
+        terminationSettings_( terminationSettings ),
+        fulFillSingleCondition_( fulFillSingleCondition ){ }
+
+    //! Destructor
+    ~PropagationHybridTerminationSettings( ){ }
+
+    //! List of termination settings for which stopping conditions are created.
+    std::vector< boost::shared_ptr< PropagationTerminationSettings > > terminationSettings_;
+
+    //! Boolean denoting whether a single (if true) or all (if false) of the conditions
+    //! defined by the entries in the terminationSettings list should be met.
+    bool fulFillSingleCondition_;
+};
+
+} // namespace propagators
+
+} // namespace tudat
+
+#endif // TUDAT_PROPAGATIONTERMINATIONSETTINGS_H
diff --git a/Tudat/Astrodynamics/Propagators/setNumericallyIntegratedStates.cpp b/Tudat/Astrodynamics/Propagators/setNumericallyIntegratedStates.cpp
index 095f2fc..5f2b664 100644
--- a/Tudat/Astrodynamics/Propagators/setNumericallyIntegratedStates.cpp
+++ b/Tudat/Astrodynamics/Propagators/setNumericallyIntegratedStates.cpp
@@ -17,7 +17,6 @@ namespace tudat
 namespace propagators
 {
 
-
 //! Function to create an interpolator for the new translational state of a body.
 template< >
 boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::Matrix< double, 6, 1 > > >
diff --git a/Tudat/Astrodynamics/Propagators/setNumericallyIntegratedStates.h b/Tudat/Astrodynamics/Propagators/setNumericallyIntegratedStates.h
index 6761178..180cc71 100644
--- a/Tudat/Astrodynamics/Propagators/setNumericallyIntegratedStates.h
+++ b/Tudat/Astrodynamics/Propagators/setNumericallyIntegratedStates.h
@@ -74,6 +74,7 @@ void resetIntegratedEphemerisOfBody(
  * integrated states Additionally, it changes the origin of the reference frame in which the states
  * are given, by using the integrationToEphemerisFrameFunction input variable.
  * \param bodyIndex Index of integrated body for which the state is to be retrieved
+ * \param startIndex Index in entries of equationsOfMotionNumericalSolution where the translational states start.
  * \param equationsOfMotionNumericalSolution Full numerical solution of numerical integrator,
  * already converted to Cartesian states (w.r.t. the integration origin of the body of bodyIndex)
  * \param integrationToEphemerisFrameFunction Function to provide the state of the ephemeris origin
@@ -83,6 +84,7 @@ void resetIntegratedEphemerisOfBody(
 template< typename TimeType, typename StateScalarType >
 std::map< TimeType, Eigen::Matrix< StateScalarType, 6, 1 > > convertNumericalSolutionToEphemerisInput(
         const int bodyIndex,
+        const int startIndex,
         const std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >&
             equationsOfMotionNumericalSolution,
         const boost::function< Eigen::Matrix< StateScalarType, 6, 1 >( const TimeType ) >
@@ -98,7 +100,7 @@ std::map< TimeType, Eigen::Matrix< StateScalarType, 6, 1 > > convertNumericalSol
              bodyIterator = equationsOfMotionNumericalSolution.begin( );
              bodyIterator != equationsOfMotionNumericalSolution.end( ); bodyIterator++ )
         {
-            ephemerisTable[ bodyIterator->first ] = bodyIterator->second.block( 6 * bodyIndex, 0, 6, 1 );
+            ephemerisTable[ bodyIterator->first ] = bodyIterator->second.block( startIndex + 6 * bodyIndex, 0, 6, 1 );
         }
     }
     // Else, extract indices and add required translation from integrationToEphemerisFrameFunction
@@ -109,7 +111,7 @@ std::map< TimeType, Eigen::Matrix< StateScalarType, 6, 1 > > convertNumericalSol
              bodyIterator != equationsOfMotionNumericalSolution.end( ); bodyIterator++ )
         {
 
-            ephemerisTable[ bodyIterator->first ] = bodyIterator->second.block( 6 * bodyIndex, 0, 6, 1 ) -
+            ephemerisTable[ bodyIterator->first ] = bodyIterator->second.block( startIndex + 6 * bodyIndex, 0, 6, 1 ) -
                     integrationToEphemerisFrameFunction( bodyIterator->first );
         }
     }
@@ -134,6 +136,7 @@ createStateInterpolator(
  * \param bodyMap List of bodies used in simulations.
  * \param bodiesToIntegrate List of names of bodies which are numericall integrated (in the order in
  * which they are in the equationsOfMotionNumericalSolution map. 
+ * \param startIndex Index in entries of equationsOfMotionNumericalSolution where the translational states start.
  * \param ephemerisUpdateOrder Order in which to update the ephemeris objects. 
  * \param equationsOfMotionNumericalSolution Numerical solution of translational equations of
  * motion, in Cartesian elements w.r.t. integratation origins. 
@@ -144,14 +147,12 @@ template< typename TimeType, typename StateScalarType >
 void createAndSetInterpolatorsForEphemerides(
         const simulation_setup::NamedBodyMap& bodyMap,
         const std::vector< std::string >& bodiesToIntegrate,
+        const int startIndex,
         const std::vector< std::string >& ephemerisUpdateOrder,
-        const std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >&
-            equationsOfMotionNumericalSolution,
-        const std::map< std::string,
-                        boost::function< Eigen::Matrix< StateScalarType, 6, 1 >( const TimeType ) > >&
+        const std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >& equationsOfMotionNumericalSolution,
+        const std::map< std::string, boost::function< Eigen::Matrix< StateScalarType, 6, 1 >( const TimeType ) > >&
             integrationToEphemerisFrameFunctions =
-            std::map< std::string,
-                      boost::function< Eigen::Matrix< StateScalarType, 6, 1 >( const TimeType ) > >( ) )
+            std::map< std::string, boost::function< Eigen::Matrix< StateScalarType, 6, 1 >( const TimeType ) > >( ) )
 {
     using namespace tudat::interpolators;
 
@@ -180,11 +181,12 @@ void createAndSetInterpolatorsForEphemerides(
         // Create and reset interpolator.
         boost::shared_ptr< OneDimensionalInterpolator< TimeType, Eigen::Matrix< StateScalarType, 6, 1 > > >
                 ephemerisInterpolator =
-                createStateInterpolator( convertNumericalSolutionToEphemerisInput(
-                                             bodyIndex, equationsOfMotionNumericalSolution,
-                                             integrationToEphemerisFrameFunction ) );
-        resetIntegratedEphemerisOfBody( bodyMap, ephemerisInterpolator,
-                                        bodiesToIntegrate.at( bodyIndex ) );
+                createStateInterpolator(
+                    convertNumericalSolutionToEphemerisInput(
+                        bodyIndex, startIndex, equationsOfMotionNumericalSolution, integrationToEphemerisFrameFunction ) );
+
+        resetIntegratedEphemerisOfBody(
+                    bodyMap, ephemerisInterpolator, bodiesToIntegrate.at( bodyIndex ) );
     }
 }
 
@@ -195,6 +197,8 @@ void createAndSetInterpolatorsForEphemerides(
  * \param bodyMap List of bodies used in simulations. 
  * \param bodiesToIntegrate List of names of bodies which are numerically integrated (in the order in
  * which they are in the equationsOfMotionNumericalSolution map. 
+ * \param startIndexAndSize Pair with start index and total (contiguous) size of integrated states in entries of
+ * equationsOfMotionNumericalSolution
  * \param ephemerisUpdateOrder Order in which to update the ephemeris objects (empty if arbitrary). 
  * \param equationsOfMotionNumericalSolution Numerical solution of translational equations of
  * motion, in Cartesian elements w.r.t. integratation origins. 
@@ -204,14 +208,13 @@ void createAndSetInterpolatorsForEphemerides(
 template< typename TimeType, typename StateScalarType >
 void resetIntegratedEphemerides(
         const simulation_setup::NamedBodyMap& bodyMap,
-        const std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >&
-            equationsOfMotionNumericalSolution,
+        const std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >& equationsOfMotionNumericalSolution,
         const std::vector< std::string >& bodiesToIntegrate,
+        const std::pair< int, int > startIndexAndSize,
         std::vector< std::string > ephemerisUpdateOrder = std::vector< std::string >( ),
-        const std::map< std::string,
-            boost::function< Eigen::Matrix< StateScalarType, 6, 1 >( const TimeType ) > >&
-            integrationToEphemerisFrameFunctions = std::map< std::string,
-                boost::function< Eigen::Matrix< StateScalarType, 6, 1 >( const TimeType ) > >( ) )
+        const std::map< std::string, boost::function< Eigen::Matrix< StateScalarType, 6, 1 >( const TimeType ) > >&
+            integrationToEphemerisFrameFunctions =
+        std::map< std::string, boost::function< Eigen::Matrix< StateScalarType, 6, 1 >( const TimeType ) > >( ) )
 {
     // Set update order arbitrarily if no order is provided.
     if( ephemerisUpdateOrder.size( ) == 0 )
@@ -224,10 +227,67 @@ void resetIntegratedEphemerides(
         throw std::runtime_error( "Error when resetting ephemerides, input vectors have inconsistent size" );
     }
 
+    if( equationsOfMotionNumericalSolution.begin( )->second.rows( ) < startIndexAndSize.first + startIndexAndSize.second )
+    {
+        throw std::runtime_error( "Error when resetting ephemerides, input solution inconsistent with start index and size." );
+    }
+
+    if( startIndexAndSize.second != 6 * bodiesToIntegrate.size( ) )
+    {
+        throw std::runtime_error( "Error when resetting ephemerides, number of bodies inconsistent with input size." );
+
+    }
+
     // Create interpolators from numerical integration results (states) at discrete times.
     createAndSetInterpolatorsForEphemerides(
-                bodyMap, bodiesToIntegrate, ephemerisUpdateOrder, equationsOfMotionNumericalSolution,
-                                             integrationToEphemerisFrameFunctions );
+                bodyMap, bodiesToIntegrate, startIndexAndSize.first, ephemerisUpdateOrder,
+                equationsOfMotionNumericalSolution, integrationToEphemerisFrameFunctions );
+}
+
+//! Resets the mass models of the integrated bodies from the numerical integration results.
+/*!
+ * Resets the mass models of the integrated bodies from the numerical integration results.
+ * \param bodyMap List of bodies used in simulations.
+ * \param equationsOfMotionNumericalSolution Numerical solution of the body masses.
+ * \param bodiesToIntegrate List of names of bodies for which mass is numerically integrated (in the order in
+ * which they are in the equationsOfMotionNumericalSolution map.
+ * \param startIndexAndSize Pair with start index and total (contiguous) size of integrated states in entries of
+ * equationsOfMotionNumericalSolution
+ */
+template< typename TimeType, typename StateScalarType >
+void resetIntegratedBodyMass(
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >& equationsOfMotionNumericalSolution,
+        const std::vector< std::string >& bodiesToIntegrate ,
+        const std::pair< int, int > startIndexAndSize )
+{
+    if( startIndexAndSize.second != bodiesToIntegrate.size( ) )
+    {
+        throw std::runtime_error( "Error when resetting body masses, number of bodies inconsistent with input size." );
+    }
+
+    // Iterate over all bodies for which mass is propagated.
+    for( unsigned int i = 0; i < bodiesToIntegrate.size( ); i++ )
+    {
+        std::map< double, double > currentBodyMassMap;
+
+        // Create mass map with double entries.
+        for( typename std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >::const_iterator
+             stateIterator = equationsOfMotionNumericalSolution.begin( );
+             stateIterator != equationsOfMotionNumericalSolution.end( ); stateIterator++ )
+        {
+           currentBodyMassMap[ static_cast< double >( stateIterator->first ) ] =
+                   static_cast< double >( stateIterator->second( startIndexAndSize.first + i ) );
+        }
+
+        typedef interpolators::OneDimensionalInterpolator< double, double > LocalInterpolator;
+
+        // Create and set interpolator.
+         bodyMap.at( bodiesToIntegrate.at( i ) )->setBodyMassFunction( boost::bind(
+                    static_cast< double( LocalInterpolator::* )( const double ) >
+                    ( &LocalInterpolator::interpolate ),
+                    boost::make_shared< interpolators::LagrangeInterpolatorDouble >( currentBodyMassMap, 6 ), _1 ) );
+    }
 }
 
 //! Function to determine in which order the ephemerides are to be updated
@@ -331,6 +391,8 @@ public:
                                                bodiesToIntegrate_, frameManager );
     }
 
+    ~TranslationalStateIntegratedStateProcessor( ){ }
+
     //! Function processing translational state in the full numericalSolution
     /*!
      * Function that processes the entries of the translational state in the full numericalSolution,
@@ -344,7 +406,7 @@ public:
                             Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >& numericalSolution )
     {
         resetIntegratedEphemerides< TimeType, StateScalarType >(
-                    bodyMap_, numericalSolution, bodiesToIntegrate_, ephemerisUpdateOrder_,
+                    bodyMap_, numericalSolution, bodiesToIntegrate_, this->startIndexAndSize_, ephemerisUpdateOrder_,
                     integrationToEphemerisFrameFunctions_ );
     }
 
@@ -369,6 +431,58 @@ private:
     integrationToEphemerisFrameFunctions_;
 };
 
+//! Class used for processing numerically integrated masses of bodies.
+template< typename TimeType, typename StateScalarType >
+class BodyMassIntegratedStateProcessor: public IntegratedStateProcessor< TimeType, StateScalarType >
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param startIndex Index in the state vector where the translational state starts.
+     * \param bodyMap List of bodies used in simulations.
+     * \param bodiesToIntegrate List of bodies for which the mass is numerically
+     * integrated. Order in this vector is the same as the order in state vector.
+     */
+    BodyMassIntegratedStateProcessor(
+            const int startIndex,
+            const simulation_setup::NamedBodyMap& bodyMap,
+            const std::vector< std::string >& bodiesToIntegrate ):
+        IntegratedStateProcessor<  TimeType, StateScalarType >(
+            body_mass_state, std::make_pair( startIndex, bodiesToIntegrate.size( ) ) ),
+        bodyMap_( bodyMap ), bodiesToIntegrate_( bodiesToIntegrate )
+    { }
+
+    //! Destructor
+    ~BodyMassIntegratedStateProcessor( ){ }
+
+    //! Function processing mass state in the full numericalSolution
+    /*!
+     * Function that processes the entries of the propagated mass in the full numericalSolution.
+     * \param numericalSolution Full numerical solution of state, in global representation (representation is constant
+     * for mass).
+     */
+    void processIntegratedStates(
+            const std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > >& numericalSolution )
+    {
+        resetIntegratedBodyMass( bodyMap_, numericalSolution, bodiesToIntegrate_, this->startIndexAndSize_ );
+    }
+
+private:
+
+    //! List of bodies used in simulations.
+    simulation_setup::NamedBodyMap bodyMap_;
+
+    //! List of bodies for which the body mass is numerically integrated.
+    /*!
+     * List of bodies for which the body mass is numerically integrated. Order in this
+     * vector is the same as the order in state vector.
+     */
+    std::vector< std::string > bodiesToIntegrate_;
+};
+
+
 //! Function checking feasibility of resetting the translational dynamics
 /*!
  * Function to check the feasibility of resetting the translational dynamics of a set of
@@ -466,6 +580,50 @@ createIntegratedStateProcessors(
     // Check dynamics type.
     switch( propagatorSettings->stateType_ )
     {   
+    case hybrid:
+    {
+        boost::shared_ptr< MultiTypePropagatorSettings< StateScalarType > > multiTypePropagatorSettings =
+                boost::dynamic_pointer_cast< MultiTypePropagatorSettings< StateScalarType > >( propagatorSettings );
+        std::map< IntegratedStateType, std::vector< boost::shared_ptr< IntegratedStateProcessor< TimeType, StateScalarType > > > >
+                singleTypeIntegratedStateProcessors;
+        int currentStartIndex = 0;
+        for( typename std::map< IntegratedStateType, std::vector< boost::shared_ptr< PropagatorSettings< StateScalarType > > > >::const_iterator
+             typeIterator = multiTypePropagatorSettings->propagatorSettingsMap_.begin( );
+             typeIterator != multiTypePropagatorSettings->propagatorSettingsMap_.end( ); typeIterator++ )
+        {
+            if( typeIterator->first != hybrid )
+            {
+                for( unsigned int i = 0; i < typeIterator->second.size( ); i++ )
+                {
+                    singleTypeIntegratedStateProcessors = createIntegratedStateProcessors< TimeType, StateScalarType >(
+                                typeIterator->second.at( i ), bodyMap, frameManager, currentStartIndex );
+
+                    if( singleTypeIntegratedStateProcessors.size( ) != 1 )
+                    {
+                        throw std::runtime_error( "Error when making hybrid integrated result processors, multiple types found" );
+                    }
+                    else
+                    {
+                        if( singleTypeIntegratedStateProcessors.begin( )->second.size( ) != 1 )
+                        {
+                            throw std::runtime_error( "Error when making hybrid integrated result processors, multiple processors of single type found" );
+                        }
+                    }
+
+                    currentStartIndex += typeIterator->second.at( i )->getStateSize( );
+                    integratedStateProcessors[ singleTypeIntegratedStateProcessors.begin( )->first ].push_back(
+                                singleTypeIntegratedStateProcessors.begin( )->second.at( 0 ) );
+                }
+            }
+            else
+            {
+                throw std::runtime_error( "Error when making integrated state processors, cannot handle hybrid propagator inside hybrid propagator" );
+            }
+
+        }
+
+        break;
+    }
     case transational_state:
     {
 
@@ -480,13 +638,31 @@ createIntegratedStateProcessors(
         checkTranslationalStatesFeasibility< TimeType, StateScalarType >(
                     translationalPropagatorSettings->bodiesToIntegrate_, bodyMap );
 
-        // Create state propagator settings
+        // Create state processors
         integratedStateProcessors[ transational_state ].push_back(
                     boost::make_shared< TranslationalStateIntegratedStateProcessor< TimeType, StateScalarType > >(
                         startIndex, bodyMap, translationalPropagatorSettings->bodiesToIntegrate_,
                         translationalPropagatorSettings->centralBodies_, frameManager ) );
         break;
     }
+    case body_mass_state:
+    {
+
+        // Check input feasibility
+        boost::shared_ptr< MassPropagatorSettings< StateScalarType > >
+                massPropagatorSettings = boost::dynamic_pointer_cast
+                     < MassPropagatorSettings< StateScalarType > >( propagatorSettings );
+        if( massPropagatorSettings == NULL )
+        {
+            throw std::runtime_error( "Error, input type is inconsistent in createIntegratedStateProcessors" );
+        }
+
+        // Create mass processors.
+        integratedStateProcessors[ body_mass_state ].push_back(
+                    boost::make_shared< BodyMassIntegratedStateProcessor< TimeType, StateScalarType > >(
+                        startIndex, bodyMap, massPropagatorSettings->bodiesWithMassToPropagate_ ) );
+        break;
+    }
     default:
         throw std::runtime_error( "Error, could not process integrated state type " +
                                   boost::lexical_cast< std::string >( propagatorSettings->stateType_ ) );
diff --git a/Tudat/Astrodynamics/Propagators/singleStateTypeDerivative.h b/Tudat/Astrodynamics/Propagators/singleStateTypeDerivative.h
index 1258093..4a67d2d 100644
--- a/Tudat/Astrodynamics/Propagators/singleStateTypeDerivative.h
+++ b/Tudat/Astrodynamics/Propagators/singleStateTypeDerivative.h
@@ -53,14 +53,22 @@ public:
      * updated before calling this function. It returns the state derivative in teh form required
      * for the specific type of propagator used (defined by derived class).
      * \param time Time at which the state derivative is to be calculated.
-     * \param stateOfSystemToBeIntegrated Current state of the system, in the form that the
-     * equations are propagated (i.e.  directly from numerical integrator)
-     * \return Derivative of the state of the system, in the form that the equations are propagated
-     * (i.e. to be piped directly to numerical integrator)
+     * \param stateOfSystemToBeIntegrated Current state of the system, in the form that the equations are propagated (i.e.
+     * directly from numerical integrator)
+     * \param stateDerivative Derivative of the state of the system, in the form that the equations are propagated
+     * (i.e. to be piped directly to numerical integrator), returned by reference.
      */
-    virtual Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > calculateSystemStateDerivative(
+    virtual void calculateSystemStateDerivative(
             const TimeType time,
-            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& stateOfSystemToBeIntegrated ) =  0;
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& stateOfSystemToBeIntegrated,
+            Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > > stateDerivative ) = 0;
+
+    //! Function to clear reference/cached values of state derivative model
+    /*!
+     * Function to clear reference/cached values of state derivative model, such as the current time and/or state.
+     * This function is to be implemented in each derived class
+     */
+    virtual void clearStateDerivativeModel( ) = 0;
 
     //! Function to update the state derivative model to the current time.
     /*!
@@ -82,11 +90,12 @@ public:
      * \param internalSolution State in propagator-specific form (i.e. form that is used in
      * numerical integration).
      * \param time Current time at which the state is valid.
-     * \return State (internalSolution), converted to the 'conventional form' in inertial
-     * coordinates, that can for instance be set directly in the body object.
+     * \param currentCartesianLocalSoluton State (internalSolution), converted to the 'conventional form' in inertial
+     * coordinates, that can for instance be set directly  in the body object (returned by reference).
      */
-    virtual Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > convertCurrentStateToGlobalRepresentation(
-            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& internalSolution, const TimeType& time ) = 0;
+    virtual void convertCurrentStateToGlobalRepresentation(
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& internalSolution, const TimeType& time,
+            Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > currentCartesianLocalSoluton ) = 0;
 
 
     //! Function to convert the state in the conventional form to the propagator-specific form.
@@ -113,10 +122,12 @@ public:
      * \param internalSolution State in propagator-specific form (i.e. form that is used in
      * numerical integration).
      * \param time Current time at which the state is valid.
-     * \return State (internalSolution), converted to the 'conventional form'
+     * \param currentCartesianLocalSoluton State (internalSolution), converted to the 'conventional form' (returned by
+     * reference).
      */
-    virtual Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > convertToOutputSolution(
-            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& internalSolution, const TimeType& time ) = 0;
+    virtual void convertToOutputSolution(
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& internalSolution, const TimeType& time,
+            Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > currentCartesianLocalSoluton ) = 0;
 
     //! Function to return the size of the state handled by the object
     /*!
diff --git a/Tudat/Astrodynamics/Propagators/stateTransitionMatrixInterface.cpp b/Tudat/Astrodynamics/Propagators/stateTransitionMatrixInterface.cpp
new file mode 100644
index 0000000..641dad5
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/stateTransitionMatrixInterface.cpp
@@ -0,0 +1,42 @@
+#include <boost/make_shared.hpp>
+
+#include "Tudat/Astrodynamics/Propagators/stateTransitionMatrixInterface.h"
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+//! Function to reset the state transition and sensitivity matrix interpolators
+void SingleArcCombinedStateTransitionAndSensitivityMatrixInterface::updateMatrixInterpolators(
+        const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > > stateTransitionMatrixInterpolator,
+        const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > > sensitivityMatrixInterpolator )
+{
+    stateTransitionMatrixInterpolator_ = stateTransitionMatrixInterpolator;
+    sensitivityMatrixInterpolator_ = sensitivityMatrixInterpolator;
+}
+
+//! Function to get the concatenated state transition and sensitivity matrix at a given time.
+Eigen::MatrixXd SingleArcCombinedStateTransitionAndSensitivityMatrixInterface::getCombinedStateTransitionAndSensitivityMatrix(
+        const double evaluationTime )
+{
+    combinedStateTransitionMatrix_.setZero( );
+
+    // Set Phi and S matrices.
+    combinedStateTransitionMatrix_.block( 0, 0, stateTransitionMatrixSize_, stateTransitionMatrixSize_ ) =
+            stateTransitionMatrixInterpolator_->interpolate( evaluationTime );
+
+    if( sensitivityMatrixSize_ > 0 )
+    {
+        combinedStateTransitionMatrix_.block( 0, stateTransitionMatrixSize_, stateTransitionMatrixSize_, sensitivityMatrixSize_ ) =
+                sensitivityMatrixInterpolator_->interpolate( evaluationTime );
+    }
+
+    return combinedStateTransitionMatrix_;
+}
+
+}
+
+}
+
diff --git a/Tudat/Astrodynamics/Propagators/stateTransitionMatrixInterface.h b/Tudat/Astrodynamics/Propagators/stateTransitionMatrixInterface.h
new file mode 100644
index 0000000..6d3bf88
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/stateTransitionMatrixInterface.h
@@ -0,0 +1,217 @@
+#ifndef STATETRANSITIONMATRIXINTERFACE_H
+#define STATETRANSITIONMATRIXINTERFACE_H
+
+#include <vector>
+
+#include <boost/shared_ptr.hpp>
+
+#include <Eigen/Core>
+
+#include "Tudat/Mathematics/Interpolators/oneDimensionalInterpolator.h"
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+//! Base class for interface object of interpolation of numerically propagated state transition and sensitivity matrices.
+/*!
+ *  Base class for interface object of interpolation of numerically propagated state transition and sensitivity matrices.
+ *  Derived classes implement the case of single-arc/multi-arc/combined dynamics.
+ */
+class CombinedStateTransitionAndSensitivityMatrixInterface
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param numberOfInitialDynamicalParameters Size of the estimated initial state vector (and size of square
+     * state transition matrix.
+     * \param numberOfParameters Total number of estimated parameters (initial states and other parameters).
+     */
+    CombinedStateTransitionAndSensitivityMatrixInterface(
+            const int numberOfInitialDynamicalParameters,
+            const int numberOfParameters )
+    {
+        stateTransitionMatrixSize_ = numberOfInitialDynamicalParameters;
+        sensitivityMatrixSize_ = numberOfParameters - stateTransitionMatrixSize_;
+    }
+
+    //! Destructor.
+    virtual ~CombinedStateTransitionAndSensitivityMatrixInterface( ){ }
+
+    //! Function to get the concatenated state transition and sensitivity matrix at a given time.
+    /*!
+     *  Function to get the concatenated state transition and sensitivity matrix at a given time.
+     *  \param evaluationTime Time at which to evaluate matrix interpolators
+     *  \return Concatenated state transition and sensitivity matrices.
+     */
+    virtual Eigen::MatrixXd getCombinedStateTransitionAndSensitivityMatrix( const double evaluationTime ) = 0;
+
+    //! Function to get the concatenated state transition and sensitivity matrix at a given time, which includes
+    //! zero values for parameters not active in current arc.
+    /*!
+     *  Function to get the concatenated state transition and sensitivity matrix at a given time, which includes
+     *  zero values for parameters not active in current arc.
+     *  \param evaluationTime Time at which to evaluate matrix interpolators
+     *  \return Concatenated state transition and sensitivity matrices, including inactive parameters at
+     *  evaluationTime.
+     */
+    virtual Eigen::MatrixXd getFullCombinedStateTransitionAndSensitivityMatrix( const double evaluationTime ) = 0;
+
+    //! Function to get the size of state transition matrix
+    /*!
+     * Function to get the size of state transition matrix
+     * \return Size of state transition matrix
+     */
+    int getStateTransitionMatrixSize( )
+    {
+        return stateTransitionMatrixSize_;
+    }
+
+    //! Function to get the number of columns of sensitivity matrix.
+    /*!
+     * Function to get the number of columns of sensitivity matrix.
+     * \return Number of columns of sensitivity matrix.
+     */
+    int getSensitivityMatrixSize( )
+    {
+        return sensitivityMatrixSize_;
+    }
+
+    //! Function to get the size of the total parameter vector.
+    /*!
+     * Function to get the size of the total parameter vector (both global and all local parameters).
+     * \return Size of the total parameter vector.
+     */
+    virtual int getFullParameterVectorSize( ) = 0;
+
+protected:
+
+    //! Size of state transition matrix
+    int stateTransitionMatrixSize_;
+
+    //! Number of columns of sensitivity matrix.
+    int sensitivityMatrixSize_;
+
+};
+
+//! Interface object of interpolation of numerically propagated state transition and sensitivity matrices for single-arc
+//! estimation.
+class SingleArcCombinedStateTransitionAndSensitivityMatrixInterface:
+        public CombinedStateTransitionAndSensitivityMatrixInterface
+{
+public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param stateTransitionMatrixInterpolator Interpolator returning the state transition matrix as a function of time.
+     * \param sensitivityMatrixInterpolator Interpolator returning the sensitivity matrix as a function of time.
+     * \param numberOfInitialDynamicalParameters Size of the estimated initial state vector (and size of square
+     * state transition matrix.
+     * \param numberOfParameters Total number of estimated parameters (initial states and other parameters).
+     */
+    SingleArcCombinedStateTransitionAndSensitivityMatrixInterface(
+            const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+            stateTransitionMatrixInterpolator,
+            const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+            sensitivityMatrixInterpolator,
+            const int numberOfInitialDynamicalParameters,
+            const int numberOfParameters ):
+        CombinedStateTransitionAndSensitivityMatrixInterface( numberOfInitialDynamicalParameters, numberOfParameters ),
+        stateTransitionMatrixInterpolator_( stateTransitionMatrixInterpolator ),
+        sensitivityMatrixInterpolator_( sensitivityMatrixInterpolator )
+    {
+        combinedStateTransitionMatrix_ = Eigen::MatrixXd::Zero(
+                        stateTransitionMatrixSize_, stateTransitionMatrixSize_ + sensitivityMatrixSize_ );
+    }
+
+    //! Destructor.
+    ~SingleArcCombinedStateTransitionAndSensitivityMatrixInterface( ){ }
+
+    //! Function to reset the state transition and sensitivity matrix interpolators
+    /*!
+     * Function to reset the state transition and sensitivity matrix interpolators
+     * \param stateTransitionMatrixInterpolator New interpolator returning the state transition matrix as a function of time.
+     * \param sensitivityMatrixInterpolator New interpolator returning the sensitivity matrix as a function of time.
+     */
+    void updateMatrixInterpolators(
+            const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+            stateTransitionMatrixInterpolator,
+            const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+            sensitivityMatrixInterpolator );
+
+    //! Function to get the interpolator returning the state transition matrix as a function of time.
+    /*!
+     * \brief Function to get the interpolator returning the state transition matrix as a function of time.
+     * \return Interpolator returning the state transition matrix as a function of time.
+     */
+    boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+    getStateTransitionMatrixInterpolator( )
+    {
+        return stateTransitionMatrixInterpolator_;
+    }
+
+    //! Function to get the interpolator returning the sensitivity matrix as a function of time.
+    /*!
+     * \brief Function to get the interpolator returning the sensitivity matrix as a function of time.
+     * \return Interpolator returning the sensitivity matrix as a function of time.
+     */
+    boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+    getSensitivityMatrixInterpolator( )
+    {
+        return sensitivityMatrixInterpolator_;
+    }
+    //! Function to get the concatenated state transition and sensitivity matrix at a given time.
+    /*!
+     *  Function to get the concatenated state transition and sensitivity matrix at a given time.
+     *  \param evaluationTime Time at which to evaluate matrix interpolators
+     *  \return Concatenated state transition and sensitivity matrices.
+     */
+    Eigen::MatrixXd getCombinedStateTransitionAndSensitivityMatrix( const double evaluationTime );
+
+    //! Function to get the concatenated state transition and sensitivity matrix at a given time.
+    /*!
+     *  Function to get the concatenated state transition and sensitivity matrix at a given time
+     *  (functionality equal to getCombinedStateTransitionAndSensitivityMatrix for single-arc case).
+     *  \param evaluationTime Time at which to evaluate matrix interpolators
+     *  \return Concatenated state transition and sensitivity matrices.
+     */
+    Eigen::MatrixXd getFullCombinedStateTransitionAndSensitivityMatrix( const double evaluationTime )
+    {
+        return getCombinedStateTransitionAndSensitivityMatrix( evaluationTime );
+    }
+
+    //! Function to get the size of the total parameter vector.
+    /*!
+     * Function to get the size of the total parameter vector. For single-arc, this is simply the combination of
+     * the size of the state transition and sensitivity matrices.
+     * \return Size of the total parameter vector.
+     */
+    int getFullParameterVectorSize( )
+    {
+        return sensitivityMatrixSize_ + stateTransitionMatrixSize_;
+    }
+
+
+private:
+
+    //! Predefined matrix to use as return value when calling getCombinedStateTransitionAndSensitivityMatrix.
+    Eigen::MatrixXd combinedStateTransitionMatrix_;
+
+    //! Interpolator returning the state transition matrix as a function of time.
+    boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+    stateTransitionMatrixInterpolator_;
+
+    //! Interpolator returning the sensitivity matrix as a function of time.
+    boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+    sensitivityMatrixInterpolator_;
+};
+
+}
+
+}
+#endif // STATETRANSITIONMATRIXINTERFACE_H
diff --git a/Tudat/Astrodynamics/Propagators/variationalEquations.cpp b/Tudat/Astrodynamics/Propagators/variationalEquations.cpp
new file mode 100644
index 0000000..b4743e0
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/variationalEquations.cpp
@@ -0,0 +1,175 @@
+#include <map>
+
+#include <boost/function.hpp>
+
+#include <Eigen/Core>
+
+#include "Tudat/Astrodynamics/Propagators/variationalEquations.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/accelerationPartial.h"
+
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+//! Calculates matrix containing partial derivatives of state derivatives w.r.t. body state.
+void VariationalEquations::setBodyStatePartialMatrix( )
+{
+    using namespace orbit_determination::partial_derivatives;
+
+    // Initialize partial matrix
+    variationalMatrix_.setZero( );
+
+    if( dynamicalStatesToEstimate_.count( propagators::transational_state ) > 0 )
+    {
+        int startIndex = stateTypeStartIndices_.at( propagators::transational_state );
+        for( unsigned int i = 0; i < dynamicalStatesToEstimate_.at( propagators::transational_state ).size( ); i++ )
+        {
+            variationalMatrix_.block( startIndex + i * 6, startIndex + i * 6 + 3, 3, 3 ).setIdentity( );
+        }
+    }
+
+    // Iterate over all bodies undergoing accelerations for which initial condition is to be estimated.
+    for( std::map< IntegratedStateType, std::vector< std::multimap< std::pair< int, int >,
+         boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > > > >::iterator
+         typeIterator = statePartialList_.begin( ); typeIterator != statePartialList_.end( ); typeIterator++ )
+    {
+        int startIndex = stateTypeStartIndices_.at( typeIterator->first );
+        int currentStateSize = getSingleIntegrationSize( typeIterator->first );
+        int entriesToSkipPerEntry = currentStateSize - currentStateSize /
+                getSingleIntegrationDifferentialEquationOrder( typeIterator->first );
+        for( unsigned int i = 0; i < typeIterator->second.size( ); i++ )
+        {
+            // Iterate over all bodies exerting an acceleration on this body.
+            for( statePartialIterator_ = typeIterator->second.at( i ).begin( );
+                 statePartialIterator_ != typeIterator->second.at( i ).end( );
+                 statePartialIterator_++ )
+            {
+                statePartialIterator_->second(
+                            variationalMatrix_.block(
+                                startIndex + entriesToSkipPerEntry + i* currentStateSize, statePartialIterator_->first.first,
+                                currentStateSize - entriesToSkipPerEntry, statePartialIterator_->first.second ) );
+
+            }
+        }
+    }
+
+    // Correct partials for hierarchical dynamics
+   for( unsigned int i = 0; i < statePartialAdditionIndices_.size( ); i++ )
+   {
+       variationalMatrix_.block( 0, statePartialAdditionIndices_.at( i ).second, totalDynamicalStateSize_, 3 ) +=
+               variationalMatrix_.block( 0, statePartialAdditionIndices_.at( i ).first, totalDynamicalStateSize_, 3 );
+   }
+}
+
+//! Function to clear reference/cached values of state derivative partials.
+void VariationalEquations::clearPartials( )
+{
+    for( stateDerivativeTypeIterator_ = stateDerivativePartialList_.begin( );
+         stateDerivativeTypeIterator_ != stateDerivativePartialList_.end( );
+         stateDerivativeTypeIterator_++ )
+    {
+        for( unsigned int i = 0; i < stateDerivativeTypeIterator_->second.size( ); i++ )
+        {
+            for( unsigned int j = 0; j < stateDerivativeTypeIterator_->second.at( i ).size( ); j++ )
+            {
+                stateDerivativeTypeIterator_->second.at( i ).at( j )->resetTime( TUDAT_NAN );
+            }
+
+        }
+    }
+}
+
+//! This function updates all state derivative models to the current time and state.
+void VariationalEquations::updatePartials( const double currentTime )
+{
+    // Update all acceleration partials to current state and time. Information is passed indirectly from here, through
+    // (function) pointers set in acceleration partial classes
+    for( stateDerivativeTypeIterator_ = stateDerivativePartialList_.begin( );
+         stateDerivativeTypeIterator_ != stateDerivativePartialList_.end( );
+         stateDerivativeTypeIterator_++ )
+    {
+        for( unsigned int i = 0; i < stateDerivativeTypeIterator_->second.size( ); i++ )
+        {
+            for( unsigned int j = 0; j < stateDerivativeTypeIterator_->second.at( i ).size( ); j++ )
+            {
+                stateDerivativeTypeIterator_->second.at( i ).at( j )->update( currentTime );
+            }
+
+        }
+    }
+
+    for( stateDerivativeTypeIterator_ = stateDerivativePartialList_.begin( );
+         stateDerivativeTypeIterator_ != stateDerivativePartialList_.end( );
+         stateDerivativeTypeIterator_++ )
+    {
+        for( unsigned int i = 0; i < stateDerivativeTypeIterator_->second.size( ); i++ )
+        {
+            for( unsigned int j = 0; j < stateDerivativeTypeIterator_->second.at( i ).size( ); j++ )
+            {
+                stateDerivativeTypeIterator_->second.at( i ).at( j )->updateParameterPartials( );
+            }
+
+        }
+    }
+}
+\
+//! Function (called by constructor) to set up the statePartialList_ member from the state derivative partials
+void VariationalEquations::setStatePartialFunctionList( )
+{
+    using namespace orbit_determination::partial_derivatives;
+
+    std::pair< boost::function< void( Eigen::Block< Eigen::MatrixXd > ) >, int > currentDerivativeFunction;
+
+    // Iterate over all state types
+    for( std::map< propagators::IntegratedStateType,
+         orbit_determination::partial_derivatives::StateDerivativePartialsMap >::iterator
+         stateDerivativeTypeIterator_ = stateDerivativePartialList_.begin( );
+         stateDerivativeTypeIterator_ != stateDerivativePartialList_.end( );
+         stateDerivativeTypeIterator_++ )
+    {
+        // Iterate over all bodies undergoing 'accelerations' for which initial state is to be estimated.
+        for( unsigned int i = 0; i < stateDerivativeTypeIterator_->second.size( ); i++ )
+        {
+            std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > >
+                    currentBodyPartialList;
+
+            // Iterate over all 'accelerations' from single body on other single body
+            for( unsigned int j = 0; j < stateDerivativeTypeIterator_->second.at( i ).size( ); j++ )
+            {
+                for( std::map< propagators::IntegratedStateType,
+                     std::vector< std::pair< std::string, std::string > > >::iterator
+                     estimatedStateIterator = dynamicalStatesToEstimate_.begin( );
+                     estimatedStateIterator != dynamicalStatesToEstimate_.end( );
+                     estimatedStateIterator++ )
+                {
+                    // Iterate over all bodies to see if body exerting acceleration is also to be estimated (cross-terms)
+                    for( unsigned int k = 0; k < estimatedStateIterator->second.size( ); k++ )
+                    {
+                        currentDerivativeFunction = stateDerivativeTypeIterator_->second.at( i ).at( j )->
+                                getDerivativeFunctionWrtStateOfIntegratedBody(
+                                    estimatedStateIterator->second.at( k ), estimatedStateIterator->first );
+
+                        // If function is not-empty: add to list.
+                        if( currentDerivativeFunction.second != 0 )
+                        {
+                            currentBodyPartialList.insert(
+                                        std::make_pair(
+                                            std::make_pair( k * getSingleIntegrationSize( estimatedStateIterator->first ) +
+                                                            stateTypeStartIndices_.at( estimatedStateIterator->first ),
+                                                            getSingleIntegrationSize( estimatedStateIterator->first ) ),
+                                            currentDerivativeFunction.first ) );
+                        }
+                    }
+                }
+            }
+            statePartialList_[ stateDerivativeTypeIterator_->first ].push_back( currentBodyPartialList );
+        }
+    }
+}
+
+}
+
+}
diff --git a/Tudat/Astrodynamics/Propagators/variationalEquations.h b/Tudat/Astrodynamics/Propagators/variationalEquations.h
new file mode 100644
index 0000000..a49aea8
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/variationalEquations.h
@@ -0,0 +1,485 @@
+#ifndef TUDAT_VARIATIONALEQUATIONS_H
+#define TUDAT_VARIATIONALEQUATIONS_H
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include <boost/shared_ptr.hpp>
+
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebra.h"
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
+
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/estimatableParameter.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/initialTranslationalState.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/accelerationPartial.h"
+#include "Tudat/Astrodynamics/Propagators/setNumericallyIntegratedStates.h"
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+//! Class from which the variational equations can be evaluated.
+/*!
+ *  Class from which the variational equations can be evaluated. The time derivative of the state transition  and
+ *  sensitivity matrices are computed from a set of state derivative partials objects, at the current time and state.
+ *  This class performs all required bookkeeping to update, evaluate and combine these state derivative partials into
+ *  the variational equations. The VariationalEquationsSolver object is used to manage and execute the full numerical
+ *  integration of these variational equations and equations of motion.
+ */
+class VariationalEquations
+{
+    
+public:
+    
+    //! Constructor of variation equations class.
+    /*!
+     * Constructor of variation equations class. Since the vehicle state must be integrated along with
+     * the variational equations, an object calculating the state derivative is required.
+     * \param stateDerivativePartialList List partials of state derivative models from which the variational equations
+     * are set up. The key is the type of dynamics for which partials are taken, the values are StateDerivativePartialsMap
+     * (see StateDerivativePartialsMap definition for details)
+     * \param parametersToEstimate Object containing all parameters that are to be estimated and their current settings and
+     * values.
+     * \param stateTypeStartIndices Start index (value) in vector of propagated state for each type of state (key)
+     */
+    template< typename ParameterType >
+    VariationalEquations(
+            const std::map< IntegratedStateType, orbit_determination::partial_derivatives::StateDerivativePartialsMap >
+            stateDerivativePartialList,
+            const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > parametersToEstimate,
+            const std::map< IntegratedStateType, int >& stateTypeStartIndices ):
+        stateDerivativePartialList_( stateDerivativePartialList ), stateTypeStartIndices_( stateTypeStartIndices )
+    {
+        dynamicalStatesToEstimate_ =
+                estimatable_parameters::getListOfInitialDynamicalStateParametersEstimate< ParameterType >(
+                    parametersToEstimate );
+        
+        // Get size of dynamical state to estimate
+        numberOfParameterValues_ = estimatable_parameters::getSingleArcParameterSetSize( parametersToEstimate );
+        totalDynamicalStateSize_ = 0;        
+        for( std::map< IntegratedStateType, orbit_determination::partial_derivatives::StateDerivativePartialsMap >::iterator
+             partialTypeIterator = stateDerivativePartialList_.begin( );
+             partialTypeIterator != stateDerivativePartialList_.end( ); partialTypeIterator++ )
+        {
+            
+            if( dynamicalStatesToEstimate_.count( partialTypeIterator->first ) == 0 )
+            {
+                std::cerr<<"Error when making variational equations object, found no state to estimate of type "<<
+                           partialTypeIterator->first <<std::endl;
+            }
+            else if( dynamicalStatesToEstimate_.at( partialTypeIterator->first ).size( ) !=
+                     partialTypeIterator->second.size( ) )
+            {
+                std::cerr<<"Error when making variational equations object, input partial list size is inconsistent"
+                        <<std::endl;
+            }
+            
+            totalDynamicalStateSize_ +=
+                    getSingleIntegrationSize( partialTypeIterator->first ) * partialTypeIterator->second.size( );
+        }
+        
+        // Initialize matrices.
+        variationalMatrix_ = Eigen::MatrixXd::Zero( totalDynamicalStateSize_, totalDynamicalStateSize_ );
+        variationalParameterMatrix_ =
+                Eigen::MatrixXd::Zero( totalDynamicalStateSize_, numberOfParameterValues_ - totalDynamicalStateSize_ );
+
+        // Set parameter partial functions.
+        setStatePartialFunctionList( );
+        setTranslationalStatePartialFrameScalingFunctions( parametersToEstimate );
+        setParameterPartialFunctionList( parametersToEstimate );
+    }
+    
+    //! Calculates matrix containing partial derivatives of state derivatives w.r.t. body state.
+    /*!
+     *  Calculates matrix containing partial derivatives of state derivatives w.r.t. body state, i.e.
+     *  first matrix in right hand side of Eq. (7.45) in (Montenbruck & Gill, 2000).
+     *  \return Matrix containing partial derivatives of state derivative w.r.t. body state
+     */
+    void setBodyStatePartialMatrix( );
+
+    //! Function to compute the contribution of the derivatives w.r.t. current states in the variational equations
+    /*!
+     *  Function to compute the contribution of the derivatives w.r.t. current states in the variational equations,
+     *  e.g. first term in Eq. (7.45) in (Montenbruck & Gill, 2000).
+     *  \param stateTransitionAndSensitivityMatrices Current combined state transition and sensitivity matric
+     *  \param currentMatrixDerivative Matrix block which is to return (by reference) the given contribution to the
+     *  variational equations.
+     */
+    template< typename StateScalarType >
+    void getBodyInitialStatePartialMatrix(
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& stateTransitionAndSensitivityMatrices,
+            Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > > currentMatrixDerivative )
+    {
+        setBodyStatePartialMatrix( );
+
+        // Add partials of body positions and velocities.
+        currentMatrixDerivative.block( 0, 0, totalDynamicalStateSize_, numberOfParameterValues_ ) =
+                ( variationalMatrix_.template cast< StateScalarType >( ) * stateTransitionAndSensitivityMatrices );
+    }
+
+    //! Calculates matrix containing partial derivatives of state derivatives w.r.t. parameters.
+    /*!
+     *  Calculates matrix containing partial derivatives of state derivatives  w.r.t. parameters, i.e.
+     *  second matrix in rhs of Eq. (7.45) in (Montenbruck & Gill, 2000).
+     *  \param currentMatrixDerivative Matrix block containing partial derivatives of accelerarion w.r.t. parameters
+     *  (returned by reference).
+     */
+    template< typename StateScalarType >
+    void getParameterPartialMatrix(
+            Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > > currentMatrixDerivative )
+    {
+        // Initialize matrix to zeros
+        variationalParameterMatrix_.setZero( );
+
+
+        // Iterate over all bodies undergoing accelerations for which initial condition is to be estimated.
+        for( std::map< IntegratedStateType, std::vector< std::multimap< std::pair< int, int >,
+             boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > > > >::iterator typeIterator =
+             parameterPartialList_.begin( ); typeIterator != parameterPartialList_.end( ); typeIterator++ )
+        {
+            int startIndex = stateTypeStartIndices_.at( typeIterator->first );
+            int currentStateSize = getSingleIntegrationSize( typeIterator->first );
+            int entriesToSkipPerEntry = currentStateSize -
+                    currentStateSize / getSingleIntegrationDifferentialEquationOrder( typeIterator->first );
+
+            // Iterate over all bodies being estimated.
+            for( unsigned int i = 0; i < typeIterator->second.size( ); i++ )
+            {
+                // Iterate over all parameter partial functions determined by setParameterPartialFunctionList( )
+                for( functionIterator = typeIterator->second[ i ].begin( );
+                     functionIterator != typeIterator->second[ i ].end( );
+                     functionIterator++ )
+                {
+                    functionIterator->second(
+                                variationalParameterMatrix_.block(
+                                    startIndex + entriesToSkipPerEntry + currentStateSize * i,
+                                    functionIterator->first.first - totalDynamicalStateSize_,
+                                    currentStateSize - entriesToSkipPerEntry,
+                                    functionIterator->first.second ) );
+                }
+            }
+
+        }
+
+        currentMatrixDerivative.block( 0, totalDynamicalStateSize_, totalDynamicalStateSize_,
+                                       numberOfParameterValues_ - totalDynamicalStateSize_ ) +=
+                variationalParameterMatrix_.template cast< StateScalarType >( );
+
+    }
+    
+    //! Evaluates the complete variational equations.
+    /*!
+     *  Evaluates the complete variational equations at a given time and state transition matrix, sensitivity matrix and
+     *  state (accessed indirectly). This function evaluates the complete Eq. (7.45) from (Montenbruck & Gill, 2000).
+     *  \param time Current time
+     *  \param stateTransitionAndSensitivityMatrices Combined state transition and sensitivity matrix.
+     *  \param currentMatrixDerivative Variation equations result (returned by reference).
+     */
+    template< typename StateScalarType >
+    void evaluateVariationalEquations(
+            const double time, const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >&
+            stateTransitionAndSensitivityMatrices,
+            Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > > currentMatrixDerivative )
+    {
+        // Compute and add state partials.
+        getBodyInitialStatePartialMatrix< StateScalarType >( stateTransitionAndSensitivityMatrices,currentMatrixDerivative );
+
+        if( numberOfParameterValues_ > totalDynamicalStateSize_ )
+        {
+            // Add partials of parameters.
+            getParameterPartialMatrix< StateScalarType >( currentMatrixDerivative );
+        }
+    }
+
+    //! Function to clear reference/cached values of state derivative partials.
+    /*!
+     * Function to clear reference/cached values of state derivative partials, to ensure that they are all recalculated.
+     */
+    void clearPartials( );
+    
+    //! This function updates all state derivative models to the current time and state.
+    /*!
+     *  This function updates all state derivative models to the current time and state.
+     *  \param currentTime Time to  which the system is to be updated.
+     */
+    void updatePartials( const double currentTime );
+    
+    //! Returns the number of parameter values.
+    /*!
+     *  Returns the number of parameter values (i.e. number of columns in state transition matrix).
+     *  \return Number of parameter values.
+     */
+    double getNumberOfParameterValues( )
+    {
+        return numberOfParameterValues_;
+    }
+    
+protected:
+    
+private:
+    
+    //! Function (called by constructor) to set up the statePartialList_ member from the state derivative partials
+    /*!
+     * Function (called by constructor) to set up the functions to evaluate the partial derivatives of the state derivatives
+     * w.r.t. a current state (stored in the statePartialList_ member) from the state derivative partials.
+     */
+    void setStatePartialFunctionList( );
+        
+    //! Function to add parameter partial functions for single state derivative model, and set of parameter objects.
+    /*!
+     *  Function to add parameter partial functions for single state derivative model, and set of parameter objects.
+     *  Partial derivative functions that are not-empty are added to the functionListOfBody input (returned by reference).
+     *  A list of parameters of a single type (double or vector) are handled a single function call.
+     *  \param parameterList Map of parameters for which partial functions are to checked and created. Map keys are
+     *  start entry of parameter in total parameter vector.
+     *  \param partialObject State derivative partial object from which partial functions are to be retrieved.
+     *  \param functionListOfBody Multimap of partial derivative functions to which entries are to be added by this function.
+     *  Map key is start index and size of given parameter in sensitivity matrix. Map value is partial function.
+     *  \param totalParameterVectorIndicesToSubtract Number of entries by which to shift start index in sensitivity
+     *  matrix from entry in parameter vector (used for multi-arc estimation).
+     */
+    template< typename CurrentParameterType >
+    void addParameterPartialToList(
+            const std::map< int, boost::shared_ptr< estimatable_parameters::EstimatableParameter< CurrentParameterType > > >&
+            parameterList,
+            const boost::shared_ptr< orbit_determination::partial_derivatives::StateDerivativePartial > partialObject,
+            std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > >&
+            functionListOfBody,
+            const int totalParameterVectorIndicesToSubtract = 0 )
+    {
+        using namespace orbit_determination::partial_derivatives;
+
+        // Iterate over all parameters.
+        for( typename std::map< int,
+             boost::shared_ptr< estimatable_parameters::EstimatableParameter< CurrentParameterType > > >::const_iterator
+             parameterIterator = parameterList.begin( ); parameterIterator != parameterList.end( ); parameterIterator++ )
+        {
+            // Add current parameter to list of partials to be computed for current acceleration (if dependency exists)
+            int functionToEvaluate =
+                    partialObject->setParameterPartialUpdateFunction( parameterIterator->second );
+            
+            // If function is non-NULL, add to list
+            if( functionToEvaluate != 0 )
+            {
+                // Make pair of indices for generating parameter partial matrix:
+                //first is start column in matrix, second is number of entries (1 for double parameter)
+                std::pair< int, int > indexPair = std::make_pair(
+                            parameterIterator->first - totalParameterVectorIndicesToSubtract, functionToEvaluate );
+                
+                // Add to list.
+                functionListOfBody.insert(
+                            std::pair< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > >
+                            ( indexPair, boost::bind(
+                                  static_cast< void ( StateDerivativePartial::* )
+                                  ( const boost::shared_ptr<
+                                    estimatable_parameters::EstimatableParameter< CurrentParameterType > >,
+                                    Eigen::Block< Eigen::MatrixXd > )>
+                                  ( &StateDerivativePartial::getCurrentParameterPartial ),
+                                  partialObject, parameterIterator->second, _1  ) ) );
+            }
+        }
+    }
+    
+    //! This function creates the list of partial derivatives of the state w.r.t. parameter values.
+    /*!
+     *  This function creates the list of partial derivatives of the state w.r.t. parameter values.
+     *  The function is called once by the constructor and the resulting functions are set as member variables.
+     *  This prevents having to check whether an acceleration model depends on every parameter during every time step.
+     *  \param parametersToEstimate Object containing all parameters that are to be estimated and their current settings and
+     *  values.
+     */
+    template< typename ParameterType >
+    void setParameterPartialFunctionList(
+            const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > >
+            parametersToEstimate )
+    {
+        // Get double parameters.
+        std::map< int, boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > >
+                doubleParametersToEstimate =
+                parametersToEstimate->getDoubleParameters( );
+
+        // Get vector parameters.
+        std::map< int, boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > >
+                vectorParametersToEstimate =
+                parametersToEstimate->getVectorParameters( );
+        
+        int totalParameterVectorIndicesToSubtract = parametersToEstimate->getInitialDynamicalStateParameterSize( ) -
+                estimatable_parameters::getSingleArcInitialDynamicalStateParameterSetSize( parametersToEstimate );
+
+        for( std::map< propagators::IntegratedStateType,
+             orbit_determination::partial_derivatives::StateDerivativePartialsMap >::iterator
+             stateDerivativeTypeIterator = stateDerivativePartialList_.begin( );
+             stateDerivativeTypeIterator != stateDerivativePartialList_.end( );
+             stateDerivativeTypeIterator++ )
+        {
+            
+            // Initialize vector of lists to correct size.
+            parameterPartialList_[ stateDerivativeTypeIterator->first ].resize(
+                        stateDerivativeTypeIterator->second.size( ) );
+            
+            // Iterate over all bodies of which initial position is being estimated.
+            for( unsigned int i = 0; i < stateDerivativeTypeIterator->second.size( ); i++ )
+            {
+                // Initialize list of parameter partial functions for single body.
+                std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > >
+                        functionListOfBody;
+                
+                // Iterate over all accelerations due to this body on current body.
+                for( unsigned int j = 0; j < stateDerivativeTypeIterator->second.at( i ).size( ); j++ )
+                {
+                    addParameterPartialToList< double >(
+                                doubleParametersToEstimate, stateDerivativeTypeIterator->second.at( i ).at( j ),
+                                functionListOfBody, totalParameterVectorIndicesToSubtract );
+                    addParameterPartialToList< Eigen::VectorXd >(
+                                vectorParametersToEstimate, stateDerivativeTypeIterator->second.at( i ).at( j ),
+                                functionListOfBody, totalParameterVectorIndicesToSubtract );
+                }
+                                
+                // Add generated parameter partial list of current body.
+                parameterPartialList_[ stateDerivativeTypeIterator->first ][ i ] = functionListOfBody;
+            }
+        }
+    }
+
+    //! Function called by constructor to handle estimation of hierarchical translational dynamics
+    /*!
+     *  Function called by constructor to handle estimation of hierarchical translational dynamics, i.e. where
+     *  the state of body A is estimated w.r.t. body B, and body B is itself estimated w.r.t. to some third body (or inertial
+     *  point) C.
+     *  \param parametersToEstimate Total list of parameters to estimate.
+     */
+    template< typename ParameterType >
+    void setTranslationalStatePartialFrameScalingFunctions(
+            const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > >
+            parametersToEstimate )
+    {
+        std::vector< boost::shared_ptr< estimatable_parameters::EstimatableParameter<
+                Eigen::Matrix< ParameterType, Eigen::Dynamic, 1 > > > > initialDynamicalParameters =
+                parametersToEstimate->getEstimatedInitialStateParameters( );
+
+        std::vector< std::string > propagatedBodies;
+        std::vector< std::string > centralBodies;
+
+        // Retrieve propagated bodies and central bodies of estimation.
+        for( unsigned int i = 0; i < initialDynamicalParameters.size( ); i++ )
+        {
+            if( initialDynamicalParameters.at( i )->getParameterName( ).first == estimatable_parameters::initial_body_state )
+            {
+                propagatedBodies.push_back(
+                            initialDynamicalParameters.at( i )->getParameterName( ).second.first );
+                centralBodies.push_back( boost::dynamic_pointer_cast
+                                         < estimatable_parameters::InitialTranslationalStateParameter< ParameterType > >(
+                                             initialDynamicalParameters.at( i ) )->getCentralBody( ) );
+            }
+        }
+
+        // Get order in which ephemerides were to be updated.
+        std::vector< std::string > updateOrder = determineEphemerisUpdateorder(
+                    propagatedBodies, centralBodies, centralBodies );
+
+        // Iterate over central bodies and propagated bodies and check for dependencies
+        for( int i = updateOrder.size( ) - 1; i >= 0 ; i-- )
+        {
+            int currentBodyIndex = std::distance(
+                        propagatedBodies.begin( ),
+                        std::find( propagatedBodies.begin( ), propagatedBodies.end( ), updateOrder.at( i ) ) );
+            for( unsigned int j = 0; j < propagatedBodies.size( ); j++ )
+            {
+                if( centralBodies.at( currentBodyIndex ) == propagatedBodies.at( j ) )
+                {
+
+                    statePartialAdditionIndices_.push_back(
+                                std::make_pair( stateTypeStartIndices_[ propagators::transational_state ] +
+                                currentBodyIndex * propagators::getSingleIntegrationSize( propagators::transational_state ),
+                                stateTypeStartIndices_[ propagators::transational_state ] +
+                            j * propagators::getSingleIntegrationSize( propagators::transational_state ) ) );
+                }
+            }
+        }
+    }
+
+    
+    //! Map with list of StateDerivativePartialsMaps, with state type as key.
+    /*!
+     *  List partials of state derivative models from which the variational equations
+     *  are set up. The key is the type of dynamics for which partials are taken, the values are StateDerivativePartialsMap
+     *  (see StateDerivativePartialsMap definition for details)
+     */
+    std::map< propagators::IntegratedStateType, orbit_determination::partial_derivatives::StateDerivativePartialsMap >
+    stateDerivativePartialList_;
+    
+    //! Map of start entry in sensitivity matrix of each type of estimated dynamics.
+    std::map< IntegratedStateType, int > stateTypeStartIndices_;
+    
+    //! List of all functions returning current partial derivative w.r.t. a current dynamical state
+    /*!
+     *  List of all functions returning current partial derivative w.r.t. a current dynamical state (map key). The
+     *  vector entries correspond to the entries in the outer vector of StateDerivativePartialsMaps in
+     *  stateDerivativePartialList_. The multimaps inside the vector provide the functions (as values) adding the
+     *  partials to a given matrix block and the start column and number of columns in matrix partial (as keys).
+     */
+    std::map< IntegratedStateType,
+    std::vector< std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > > > >
+    statePartialList_;
+    
+    //! Pre-defined iterator for efficiency.
+    std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > >::iterator
+    statePartialIterator_;
+    
+    //! Vector of pair providing indices of column blocks of variational equations to add to other column blocks
+    /*!
+     * Vector of pair providing indices of column blocks of variational equations to add to other column blocks,
+     * which is needed by the hierarchical estimation fo dynamics. The second pair entry is the start of the column
+     * block (of size 3) to where it should be copied. The first entry denotes from where it should be copied.
+     * \sa setTranslationalStatePartialFrameScalingFunctions
+     */
+    std::vector< std::pair< int, int > > statePartialAdditionIndices_;
+
+    
+    //! List of all functions returning current partial derivative w.r.t. a parameter
+    /*!
+     *  List of all functions returning current partial derivative w.r.t. a parameter.
+     *  Map key denotes associated dynamics type w.r.t which partial is taken. The
+     *  vector entries correspond to the entries in the outer vector of StateDerivativePartialsMaps in
+     *  stateDerivativePartialList_. The multimaps inside the vector provide the functions (as values) adding the
+     *  partials to a given matrix block and the start column and number of columns in matrix partial (as keys).
+     */
+    std::map< IntegratedStateType, std::vector< std::multimap< std::pair< int, int >,
+    boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > > > > parameterPartialList_;
+    
+    //! Pre-declared iterator over all parameter partial functions.
+    std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > >
+    ::iterator functionIterator;
+
+    //! Pre-declared iterator over all state types
+    std::map< propagators::IntegratedStateType, orbit_determination::partial_derivatives::StateDerivativePartialsMap >
+    ::iterator stateDerivativeTypeIterator_;
+    
+    //! List of identifiers for points/bodies for which initial dynamical state is to be estimated.
+    std::map< propagators::IntegratedStateType, std::vector< std::pair< std::string, std::string > > >
+    dynamicalStatesToEstimate_;
+
+    
+    //! Number of parameter values in estimation (i.e. number of columns in sensitivity matrix)
+    int numberOfParameterValues_;
+    
+    //! Total size of (single-arc) state vector of dynamics that is to be estimated.
+    int totalDynamicalStateSize_;
+
+    //! Total matrix of partial derivatives of state derivatives w.r.t. current states.
+    Eigen::MatrixXd variationalMatrix_;
+
+    //! Total matrix of partial derivatives of state derivatives w.r.t. parameter vectors.
+    Eigen::MatrixXd variationalParameterMatrix_;
+};
+
+
+}
+
+}
+
+#endif // TUDAT_VARIATIONALEQUATIONS_H
diff --git a/Tudat/Astrodynamics/Propagators/variationalEquationsSolver.cpp b/Tudat/Astrodynamics/Propagators/variationalEquationsSolver.cpp
new file mode 100644
index 0000000..cbb70b3
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/variationalEquationsSolver.cpp
@@ -0,0 +1,39 @@
+#include "Tudat/Astrodynamics/Propagators/variationalEquationsSolver.h"
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+//! Function to create interpolators for state transition and sensitivity matrices from numerical results.
+void createStateTransitionAndSensitivityMatrixInterpolator(
+        boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >& stateTransitionMatrixInterpolator,
+        boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >& sensitivityMatrixInterpolator,
+        std::vector< std::map< double, Eigen::MatrixXd > >& variationalEquationsSolution,
+        const bool clearRawSolution )
+{
+    // Create interpolator for state transition matrix.
+    stateTransitionMatrixInterpolator=
+            boost::make_shared< interpolators::LagrangeInterpolator< double, Eigen::MatrixXd > >(
+                utilities::createVectorFromMapKeys< Eigen::MatrixXd, double >( variationalEquationsSolution[ 0 ] ),
+                utilities::createVectorFromMapValues< Eigen::MatrixXd, double >( variationalEquationsSolution[ 0 ] ), 4 );
+    if( clearRawSolution )
+    {
+        variationalEquationsSolution[ 0 ].clear( );
+    }
+
+    // Create interpolator for sensitivity matrix.
+    sensitivityMatrixInterpolator =
+            boost::make_shared< interpolators::LagrangeInterpolator< double, Eigen::MatrixXd > >(
+                utilities::createVectorFromMapKeys< Eigen::MatrixXd, double >( variationalEquationsSolution[ 1 ] ),
+                utilities::createVectorFromMapValues< Eigen::MatrixXd, double >( variationalEquationsSolution[ 1 ] ), 4 );
+    if( clearRawSolution )
+    {
+        variationalEquationsSolution[ 1 ].clear( );
+    }
+}
+
+}
+
+}
diff --git a/Tudat/Astrodynamics/Propagators/variationalEquationsSolver.h b/Tudat/Astrodynamics/Propagators/variationalEquationsSolver.h
new file mode 100644
index 0000000..dadb915
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/variationalEquationsSolver.h
@@ -0,0 +1,651 @@
+#ifndef TUDAT_VARIATIONALEQUATIONSSOLVER_H
+#define TUDAT_VARIATIONALEQUATIONSSOLVER_H
+
+#include <boost/make_shared.hpp>
+#include <boost/tuple/tuple.hpp>
+#include <boost/tuple/tuple_comparison.hpp>
+#include <boost/tuple/tuple_io.hpp>
+
+#include "Tudat/Basics/utilities.h"
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
+#include "Tudat/Mathematics/Interpolators/interpolator.h"
+
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/estimatableParameter.h"
+#include "Tudat/Astrodynamics/Propagators/stateTransitionMatrixInterface.h"
+#include "Tudat/Astrodynamics/Propagators/dynamicsSimulator.h"
+#include "Tudat/Astrodynamics/Ephemerides/tabulatedEphemeris.h"
+#include "Tudat/SimulationSetup/createStateDerivativePartials.h"
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+
+//! Base class to manage and execute the numerical integration of equations of motion and variational equations.
+/*!
+ *  Base class to manage and execute the numerical integration of equations of motion and variational equations.
+ *  Governing equations are set once, but can be re-integrated for different initial conditions using the same
+ *  instance of the class. Derived classes define the specific kind of integration that is performed
+ *  (single-arc/multi-arc; dynamics/variational equations, etc.)
+ */
+template< typename StateScalarType = double, typename TimeType = double, typename ParameterType = double >
+class VariationalEquationsSolver
+{
+public:
+
+    typedef Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > MatrixType;
+    typedef Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > VectorType;
+
+    //! Constructor
+    /*!
+     *  Constructor, sets up object for automatic evaluation and numerical integration of variational equations and
+     *  equations of motion.
+     *  \param bodyMap Map of bodies (with names) of all bodies in integration.
+     *  \param integratorSettings Settings for numerical integrator of combined propagation of variational equations
+     *  and equations of motion.
+     *  \param propagatorSettings Settings for propagation of equations of motion.
+     *  \param parametersToEstimate Object containing all parameters that are to be estimated and their current
+     *  settings and values.
+     *  \param variationalOnlyIntegratorSettings Settings for numerical integrator when integrating only variational
+     *  equations.
+     *  \param clearNumericalSolution Boolean to determine whether to clear the raw numerical solution member variables
+     *  (default true) after propagation and resetting of state transition interface.
+     */
+    VariationalEquationsSolver(
+            const simulation_setup::NamedBodyMap& bodyMap,
+            const boost::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > > integratorSettings,
+            const boost::shared_ptr< PropagatorSettings< StateScalarType > > propagatorSettings,
+            const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > parametersToEstimate,
+            const boost::shared_ptr< numerical_integrators::IntegratorSettings< double > > variationalOnlyIntegratorSettings=
+            boost::shared_ptr< numerical_integrators::IntegratorSettings< double > >( ),
+            const bool clearNumericalSolution = 1 ):
+        parametersToEstimate_( parametersToEstimate ),
+        bodyMap_( bodyMap ),
+        propagatorSettings_( propagatorSettings ), integratorSettings_( integratorSettings ),
+        variationalOnlyIntegratorSettings_( variationalOnlyIntegratorSettings ),
+        stateTransitionMatrixSize_( parametersToEstimate_->getInitialDynamicalStateParameterSize( ) ),
+        parameterVectorSize_( parametersToEstimate_->getParameterSetSize( ) ),
+        clearNumericalSolution_( clearNumericalSolution )
+    { }
+
+    //! Destructor
+    virtual ~VariationalEquationsSolver( ){ }
+
+    //! Pure virtual function to integrate variational equations and equations of motion.
+    /*!
+     *  Pure virtual function to integrate variational equations and equations of motion, to be implemented in derived
+     *  class
+     *  \param initialStateEstimate Initial state of the equations of motion that is to be used.
+     *  \param integrateEquationsConcurrently Variable determining whether the equations of motion are to be
+     *  propagated concurrently with variational equations of motion (if true), or before variational equations (if false).
+     */
+    virtual void integrateVariationalAndDynamicalEquations(
+            const VectorType& initialStateEstimate, const bool integrateEquationsConcurrently ) = 0;
+
+    //! Pure virtual function to integrate equations of motion only.
+    /*!
+     *  Pure virtual function to integrate equations of motion only, to be implemented in derived
+     *  class
+     *  \param initialStateEstimate Initial state of the equations of motion that is to be used.
+     */
+    virtual void integrateDynamicalEquationsOfMotionOnly(
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& initialStateEstimate ) = 0;
+
+
+    //! Function to get the list of objects representing the parameters that are to be integrated.
+    /*!
+     *  Function to get the list of objects representing the parameters that are to be integrated.
+     *  \return List of objects representing the parameters that are to be integrated.
+     */
+    boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > getParametersToEstimate( )
+    {
+        return parametersToEstimate_;
+    }
+
+    //! Function to reset parameter estimate and re-integrate equations of motion and, if desired, variational equations.
+    /*!
+     *  Function to reset parameter estimate and re-integrate equations of motion and, if desired, variational equations
+     *  using the new physical parameters/body initial states.
+     *  \param newParameterEstimate New estimate of parameters that are to be estimated, in same order as defined
+     *  in parametersToEstimate_ member.
+     *  \param areVariationalEquationsToBeIntegrated Boolean defining whether the variational equations are to be
+     *  reintegrated with the new parameter values.
+     */
+    void resetParameterEstimate( const Eigen::Matrix< ParameterType, Eigen::Dynamic, 1 > newParameterEstimate,
+                                 const bool areVariationalEquationsToBeIntegrated = true )
+
+    {
+        // Reset values of parameters.
+        parametersToEstimate_->template resetParameterValues< ParameterType >( newParameterEstimate );
+        propagatorSettings_->resetInitialStates(
+                    estimatable_parameters::getInitialStateVectorOfBodiesToEstimate( parametersToEstimate_ ) );
+
+        dynamicsStateDerivative_->template updateStateDerivativeModelSettings(
+                    propagatorSettings_->getInitialStates( ), 0 );
+
+        // Check if re-integration of variational equations is requested
+        if( areVariationalEquationsToBeIntegrated )
+        {
+            // Integrate variational and state equations.
+            this->integrateVariationalAndDynamicalEquations( propagatorSettings_->getInitialStates( ), 1 );
+        }
+        else
+        {
+            this->integrateDynamicalEquationsOfMotionOnly( propagatorSettings_->getInitialStates( ) );
+        }
+    }
+
+    //! Function to get the state transition matric interface object.
+    /*!
+     *  Function to get the state transition matric interface object.
+     *  \return The state transition matric interface object.
+     */
+    boost::shared_ptr< CombinedStateTransitionAndSensitivityMatrixInterface > getStateTransitionMatrixInterface( )
+    {
+        return stateTransitionInterface_;
+    }
+
+
+protected:
+
+
+    //! Create initial matrix of numerical soluation to variational + dynamical equations.
+    /*!
+     *  Create initial matrix of numerical soluation to variational + dynamical equations. The structure of the matrix is
+     *  [Phi;S;y], with Phi the state transition matrix, S the sensitivity matrix y the state vector.
+     *  \param initialStateEstimate vector of initial state (position/velocity) of bodies to be integrated numerically.
+     *  order determined by order of bodiesToIntegrate_.
+     *  \return Initial matrix of numerical soluation to variation + state equations.
+     */
+    MatrixType createInitialConditions( const VectorType initialStateEstimate )
+    {
+        // Initialize initial conditions to zeros.
+        MatrixType varSystemInitialState = MatrixType( stateTransitionMatrixSize_,
+                                                       parameterVectorSize_ + 1 ).setZero( );
+
+        // Set initial state transition matrix to identity
+        varSystemInitialState.block( 0, 0, stateTransitionMatrixSize_, stateTransitionMatrixSize_ ).setIdentity( );
+
+        // Set initial body states to current estimate of initial body states.
+        varSystemInitialState.block( 0, parameterVectorSize_,
+                                     stateTransitionMatrixSize_, 1 ) = initialStateEstimate;
+
+        return varSystemInitialState;
+    }
+
+    //! Create initial matrix of numerical soluation to variational equations
+    /*!
+     *  Create initial matrix of numerical soluation to variational equations, with structure [Phi;S]. Initial state
+     *  transition matrix Phi is identity matrix. Initial sensitivity matrix S is all zeros.
+     *  \return Initial matrix solution to variational equations.
+     */
+    Eigen::MatrixXd createInitialVariationalEquationsSolution( )
+    {
+        // Initialize initial conditions to zeros.
+        Eigen::MatrixXd varSystemInitialState = Eigen::MatrixXd::Zero(
+                    stateTransitionMatrixSize_, parameterVectorSize_ );
+
+        // Set initial state transition matrix to identity
+        varSystemInitialState.block( 0, 0, stateTransitionMatrixSize_, stateTransitionMatrixSize_ ).setIdentity( );
+
+        return varSystemInitialState;
+    }
+
+    //! Object containing all parameters that are to be estimated and their current  settings and values.
+    boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > parametersToEstimate_ ;
+
+    //! Map of bodies (with names) of all bodies in integration.
+    simulation_setup::NamedBodyMap bodyMap_;
+
+    //! Settings for propagation of equations of motion.
+    boost::shared_ptr< PropagatorSettings< StateScalarType > > propagatorSettings_;
+
+    //! Settings for numerical integrator of combined propagation of variational equations and equations of motion.
+    boost::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > > integratorSettings_;
+
+    //! Settings for numerical integrator when integrating only variational equations.
+    boost::shared_ptr< numerical_integrators::IntegratorSettings< double > > variationalOnlyIntegratorSettings_;
+
+    //! Size (rows and columns are equal) of state transition matrix.
+    int stateTransitionMatrixSize_;
+
+    //! Number of rows in sensitivity matrix
+    int parameterVectorSize_;
+
+    //! Boolean to determine whether to clear the raw numerical solution member variables after propagation
+    /*!
+     *  Boolean to determine whether to clear the raw numerical solution member variables after propagation
+     *  and resetting of state transition interface.
+     */
+    bool clearNumericalSolution_;
+
+    //! Object used for interpolating numerical results of state transition and sensitivity matrix.
+    boost::shared_ptr< CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionInterface_;  
+
+    //! Object used to compute the full state derivative in equations of motion and variational equations.
+    /*!
+     *  Object used to compute the full state derivative in equations of motion and variational equations,
+     *  including relevant updates of environment from current state and time. Object may be used for
+     *  either full or separate propagation of equations.
+     */
+    boost::shared_ptr< DynamicsStateDerivativeModel< TimeType, StateScalarType > > dynamicsStateDerivative_;
+
+};
+
+//! Function to separate the time histories of the sensitivity and state transition matrices from a full numerical solution.
+/*!
+ *  Function to separate the time histories of the sensitivity and state transition matrices from a full numerical solution,
+ *  in which the solution is represented as a single matrix block per time value.
+ *  NOTE: numericalIntegrationResult contents are deleted by this function (all information is conserved in
+ *  variationalEquationsSolution.
+ *  \param numericalIntegrationResult Full time history from which separate matrix histories are to be retrieved.
+ *  \param variationalEquationsSolution Vector of two matrix histories (returned by reference). First vector entry
+ *  is state transition matrix history, second entry is sensitivity matrix history.
+ *  \param stateTransitionStartIndices First row and column (first and second) of state transition matrix in entries of
+ *  numericalIntegrationResult.
+ *  \param sensitivityStartIndices First row and column (first and second) of sensitivity matrix in entries of
+ *  numericalIntegrationResult.
+ *  \param stateTransitionMatrixSize Size (rows and columns are equal) of state transition matrix.
+ *  \param parameterSetSize Number of rows in sensitivity matrix
+ */
+template< typename TimeType, typename StateScalarType >
+void setVariationalEquationsSolution(
+        std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > >&
+        numericalIntegrationResult,
+        std::vector< std::map< double, Eigen::MatrixXd > >& variationalEquationsSolution,
+        const std::pair< int, int > stateTransitionStartIndices,
+        const std::pair< int, int > sensitivityStartIndices,
+        const int stateTransitionMatrixSize,
+        const int parameterSetSize )
+{
+    variationalEquationsSolution.clear( );
+    variationalEquationsSolution.resize( 2 );
+
+    for( typename std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > >::iterator
+         integrationIterator = numericalIntegrationResult.begin( );
+         integrationIterator != numericalIntegrationResult.end( ); )
+    {
+        // Set result for state transition matrix in each time step.
+        variationalEquationsSolution[ 0 ][ integrationIterator->first ] =
+                ( integrationIterator->second.block( stateTransitionStartIndices.first, stateTransitionStartIndices.second,
+                                                     stateTransitionMatrixSize,
+                                                     stateTransitionMatrixSize ) ).template cast< double >( );
+
+        // Set result for sensitivity matrix in each time step.
+        variationalEquationsSolution[ 1 ][ integrationIterator->first ] =
+                ( integrationIterator->second.block( sensitivityStartIndices.first, sensitivityStartIndices.second,
+                                                     stateTransitionMatrixSize,
+                                                     parameterSetSize -
+                                                     stateTransitionMatrixSize ) ).template cast< double >( );
+        numericalIntegrationResult.erase( integrationIterator++ );
+    }
+}
+
+//! Function to create interpolators for state transition and sensitivity matrices from numerical results.
+/*!
+ * Function to create interpolators for state transition and sensitivity matrices from numerical results.
+ * \param stateTransitionMatrixInterpolator Interpolator object for state transition matrix (returned by reference).
+ * \param sensitivityMatrixInterpolator Interpolator object for sensitivity matrix (returned by reference).
+ * \param variationalEquationsSolution Vector of two matrix histories. First vector entry
+ *  is state transition matrix history, second entry is sensitivity matrix history.
+ * \param clearRawSolution Boolean denoting whether to clear entries of variationalEquationsSolution after creation
+ * of interpolators.
+ */
+void createStateTransitionAndSensitivityMatrixInterpolator(
+        boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >&
+        stateTransitionMatrixInterpolator,
+        boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >&
+        sensitivityMatrixInterpolator,
+        std::vector< std::map< double, Eigen::MatrixXd > >& variationalEquationsSolution,
+        const bool clearRawSolution = 1 );
+
+//! Function to check the consistency between propagation settings of equations of motion, and estimated parameters.
+/*!
+ *  Function to check the consistency between propagation settings of equations of motion, and estimated parameters.
+ *  In particular, it is presently required that the set of propagated states is equal to the set of estimated states.
+ *  \param propagatorSettings Settings for propagation of equations of motion.
+ *  \param parametersToEstimate Object containing all parameters that are to be estimated and their current
+ *  settings and values.
+ */
+template< typename StateScalarType = double, typename TimeType = double, typename ParameterType = double >
+bool checkPropagatorSettingsAndParameterEstimationConsistency(
+        const boost::shared_ptr< PropagatorSettings< StateScalarType > > propagatorSettings,
+        const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > parametersToEstimate )
+{
+    bool isInputConsistent = 1;
+
+    // Check type of dynamics
+    switch( propagatorSettings->stateType_ )
+    {
+    case transational_state:
+    {
+        boost::shared_ptr< TranslationalStatePropagatorSettings< StateScalarType > > translationalPropagatorSettings =
+                boost::dynamic_pointer_cast< TranslationalStatePropagatorSettings< StateScalarType > >( propagatorSettings );
+
+        // Retrieve estimated and propagated translational states, and check equality.
+        std::vector< std::string > propagatedBodies = translationalPropagatorSettings->bodiesToIntegrate_;
+        std::vector< std::string > estimatedBodies = estimatable_parameters::getListOfBodiesWithTranslationalStateToEstimate(
+                    parametersToEstimate );
+        if( propagatedBodies.size( ) != estimatedBodies.size( ) )
+        {
+            std::cerr<<"Error, propagated and estimated body vector sizes are inconsistent"<<
+                       propagatedBodies.size( )<<" "<<estimatedBodies.size( )<<std::endl;
+            isInputConsistent = 0;
+        }
+        else
+        {
+            for( unsigned int i = 0; i < propagatedBodies.size( ); i++ )
+            {
+                if( propagatedBodies.at( i ) != estimatedBodies.at( i ) )
+                {
+                    std::cerr<<"Error, propagated and estimated body vectors inconsistent at index "<<i<<": "<<
+                               propagatedBodies.at( i )<<" "<<estimatedBodies.at( i )<<std::endl;
+                    isInputConsistent = 0;
+                }
+            }
+
+        }
+        break;
+    }
+    default:
+        std::cerr<<"Error, cannot yet check consistency of propagator settings for type: "<<
+                   propagatorSettings->stateType_<<std::endl;
+    }
+    return isInputConsistent;
+}
+
+//! Class to manage and execute the numerical integration of variational equations of a dynamical system in a single arc.
+/*!
+ *  Class to manage and execute the numerical integration of variational equations of a dynamical system, in addition
+ *  to the dynamics itself, in a single arc: i.e. the governing equations a single initial time, and are propagated once
+ *  for the full prescribed time interval. This is in contrast to multi-arc dynamics, where the time interval is cut into
+ *  pieces. In this class, the governing equations are set once, but can be re-integrated for
+ *  different initial conditions using the same instance of the class.
+ */
+template< typename StateScalarType = double, typename TimeType = double, typename ParameterType = double >
+class SingleArcVariationalEquationsSolver: public VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >
+{
+public:
+
+    //! Local typedefs for vector and matrix of given scalar type
+    typedef Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > MatrixType;
+    typedef Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > VectorType;
+
+    //! Base class using statements
+    using VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >::parametersToEstimate_;
+    using VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >::bodyMap_;
+    using VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >::dynamicsStateDerivative_;
+    using VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >::propagatorSettings_;
+    using VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >::integratorSettings_;
+    using VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >::stateTransitionMatrixSize_;
+    using VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >::parameterVectorSize_;
+    using VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >::variationalOnlyIntegratorSettings_;
+    using VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >::stateTransitionInterface_;
+
+    //! Constructor
+    /*!
+     *  Constructor, sets up object for automatic evaluation and numerical integration of variational equations and
+     *  equations of motion.
+     *  \param bodyMap Map of bodies (with names) of all bodies in integration.
+     *  \param integratorSettings Settings for numerical integrator of combined propagation of variational equations
+     *  and equations of motion.
+     *  \param propagatorSettings Settings for propagation of equations of motion.
+     *  \param parametersToEstimate Object containing all parameters that are to be estimated and their current
+     *  settings and values.
+     *  \param integrateDynamicalAndVariationalEquationsConcurrently Boolean defining whether variational and dynamical
+     *  equations are to be propagated concurrently (if true) or sequentially (of false)
+     *  \param variationalOnlyIntegratorSettings Settings for numerical integrator when integrating only variational
+     *  equations.
+     *  \param clearNumericalSolution Boolean to determine whether to clear the raw numerical solution member variables
+     *  (default true) after propagation and resetting of state transition interface.
+     *  \param integrateEquationsOnCreation Boolean to denote whether equations should be integrated immediately at the
+     *  end of this contructor.
+     */
+    SingleArcVariationalEquationsSolver(
+            const simulation_setup::NamedBodyMap& bodyMap,
+            const boost::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > > integratorSettings,
+            const boost::shared_ptr< PropagatorSettings< StateScalarType > > propagatorSettings,
+            const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > parametersToEstimate,
+            const bool integrateDynamicalAndVariationalEquationsConcurrently = 1,
+            const boost::shared_ptr< numerical_integrators::IntegratorSettings< double > > variationalOnlyIntegratorSettings
+            = boost::shared_ptr< numerical_integrators::IntegratorSettings< double > >( ),
+            const bool clearNumericalSolution = 1,
+            const bool integrateEquationsOnCreation = 1 ):
+        VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >(
+            bodyMap, integratorSettings, propagatorSettings, parametersToEstimate,
+            variationalOnlyIntegratorSettings, clearNumericalSolution )
+    {
+        // Check input consistency
+        if( !checkPropagatorSettingsAndParameterEstimationConsistency< StateScalarType, TimeType, ParameterType >(
+                    propagatorSettings, parametersToEstimate ) )
+        {
+            throw std::runtime_error(
+                        "Error when making single arc variational equations solver, estimated and propagated bodies are inconsistent" );
+        }
+        else
+        {
+            // Create simulation object for dynamics only.
+            dynamicsSimulator_ =  boost::make_shared< SingleArcDynamicsSimulator< StateScalarType, TimeType > >(
+                        bodyMap, integratorSettings, propagatorSettings, false, clearNumericalSolution );
+            dynamicsStateDerivative_ = dynamicsSimulator_->getDynamicsStateDerivative( );
+
+            // Create state derivative partials
+            std::map< IntegratedStateType, orbit_determination::partial_derivatives::StateDerivativePartialsMap >
+                    stateDerivativePartials =
+                    orbit_determination::partial_derivatives::createStateDerivativePartials
+                    < StateScalarType, TimeType, ParameterType >(
+                        dynamicsStateDerivative_->getStateDerivativeModels( ), bodyMap, parametersToEstimate );
+
+            // Create variational equations objects.
+            variationalEquationsObject_ = boost::make_shared< VariationalEquations >(
+                        stateDerivativePartials, parametersToEstimate_,
+                        dynamicsStateDerivative_->getStateTypeStartIndices( ) );
+            dynamicsStateDerivative_->addVariationalEquations( variationalEquationsObject_ );
+
+            // Resize solution of variational equations to 2 (state transition and sensitivity matrices)
+            variationalEquationsSolution_.resize( 2 );
+
+            // Integrate variational equations from initial state estimate.
+            if( integrateEquationsOnCreation )
+            {
+                if( integrateDynamicalAndVariationalEquationsConcurrently )
+                {
+                    integrateVariationalAndDynamicalEquations( propagatorSettings->getInitialStates( ), 1 );
+                }
+                else
+                {
+                    integrateVariationalAndDynamicalEquations( propagatorSettings->getInitialStates( ), 0 );
+                }
+            }
+        }
+    }
+
+    //! Destructor
+    ~SingleArcVariationalEquationsSolver( ){ }
+
+    //! Function to integrate equations of motion only.
+    /*!
+     *  Function to integrate equations of motion only (in single arc).  If dynamical
+     *  solution is to be processed, the environment is also updtaed to teh new solution.
+     *  \param initialStateEstimate Initial state of the equations of motion that is to be used (in same order as in
+     *  parametersToEstimate_)
+     */
+    void integrateDynamicalEquationsOfMotionOnly(
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& initialStateEstimate )
+    {
+        dynamicsStateDerivative_->setPropagationSettings( std::vector< IntegratedStateType >( ), 1, 0 );
+        dynamicsSimulator_->integrateEquationsOfMotion( initialStateEstimate );
+    }
+
+    //! Function to integrate variational equations and equations of motion.
+    /*!
+     *  Function to integrate variational equations and equations of motion (in single arc). At the end of this function,
+     *  the stateTransitionInterface_ is reset with the new state transition and sensitivity matrices. If dynamical
+     *  solution is to be processed, the environment is also updtaed to the new solution.
+     *  \param initialStateEstimate Initial state of the equations of motion that is to be used (in same order as in
+     *  parametersToEstimate_).
+     *  \param integrateEquationsConcurrently Variable determining whether the equations of motion are to be
+     *  propagated concurrently with variational equations of motion (if true), or before variational equations (if false).
+     */
+    void integrateVariationalAndDynamicalEquations(
+            const VectorType& initialStateEstimate, const bool integrateEquationsConcurrently )
+    {
+        variationalEquationsSolution_[ 0 ].clear( );
+        variationalEquationsSolution_[ 1 ].clear( );
+
+
+        if( integrateEquationsConcurrently )
+        {
+
+            // Create initial conditions from new estimate.
+            MatrixType initialVariationalState = this->createInitialConditions(
+                        dynamicsStateDerivative_->convertFromOutputSolution(
+                            initialStateEstimate, integratorSettings_->initialTime_ ) );
+
+
+            // Integrate variational and state equations.
+            dynamicsStateDerivative_->setPropagationSettings( std::vector< IntegratedStateType >( ), 1, 1 );
+            std::map< TimeType, Eigen::VectorXd > dependentVariableHistory;
+            std::map< TimeType, MatrixType > rawNumericalSolution;
+            integrateEquations< MatrixType, TimeType >(
+                        dynamicsSimulator_->getStateDerivativeFunction( ), rawNumericalSolution,
+                        initialVariationalState, integratorSettings_,
+                        boost::bind( &PropagationTerminationCondition::checkStopCondition,
+                                     dynamicsSimulator_->getPropagationTerminationCondition( ), _1 ),
+                        dependentVariableHistory );
+
+            std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > equationsOfMotionNumericalSolution;
+            utilities::createVectorBlockMatrixHistory(
+                        rawNumericalSolution, equationsOfMotionNumericalSolution,
+                        std::make_pair( 0, parameterVectorSize_ ), stateTransitionMatrixSize_ );
+
+            equationsOfMotionNumericalSolution = convertNumericalStateSolutionsToOutputSolutions(
+                        equationsOfMotionNumericalSolution, dynamicsStateDerivative_ );
+            dynamicsSimulator_->manuallySetAndProcessRawNumericalEquationsOfMotionSolution(
+                        equationsOfMotionNumericalSolution );
+
+            // Reset solution for state transition and sensitivity matrices.
+            setVariationalEquationsSolution< TimeType, StateScalarType >(
+                        rawNumericalSolution, variationalEquationsSolution_,
+                        std::make_pair( 0, 0 ), std::make_pair( 0, stateTransitionMatrixSize_ ),
+                        stateTransitionMatrixSize_, parameterVectorSize_ );
+        }
+        else
+        {
+
+            dynamicsStateDerivative_->setPropagationSettings( std::vector< IntegratedStateType >( ), 1, 0 );
+            dynamicsSimulator_->integrateEquationsOfMotion( initialStateEstimate );
+
+            // Integrate variational equations.
+            dynamicsStateDerivative_->setPropagationSettings( boost::assign::list_of( transational_state ), 0, 1 );
+            Eigen::MatrixXd initialVariationalState = this->createInitialVariationalEquationsSolution( );
+            std::map< double, Eigen::MatrixXd > rawNumericalSolution;
+            std::map< TimeType, Eigen::VectorXd > dependentVariableHistory;
+
+            integrateEquations< Eigen::MatrixXd, double >(
+                        dynamicsSimulator_->getDoubleStateDerivativeFunction( ), rawNumericalSolution, initialVariationalState,
+                        variationalOnlyIntegratorSettings_,
+                        boost::bind( &PropagationTerminationCondition::checkStopCondition,
+                                     dynamicsSimulator_->getPropagationTerminationCondition( ), _1 ),
+                        dependentVariableHistory );
+
+            setVariationalEquationsSolution< double, double >(
+                        rawNumericalSolution, variationalEquationsSolution_, std::make_pair( 0, 0 ),
+                        std::make_pair( 0, stateTransitionMatrixSize_ ),
+                        stateTransitionMatrixSize_, parameterVectorSize_ );
+
+        }
+
+        // Reset solution for state transition and sensitivity matrices.
+        resetVariationalEquationsInterpolators( );
+
+    }
+
+    //! Function to return the numerical solution history of numerically integrated variational equations.
+    /*!
+     *  Function to return the numerical solution history of numerically integrated variational equations.
+     *  \return Vector of mapa of state transition matrix history (first vector entry)
+     *  and sensitivity matrix history (second vector entry)
+     */
+    std::vector< std::map< double, Eigen::MatrixXd > >& getNumericalVariationalEquationsSolution( )
+    {
+        return variationalEquationsSolution_;
+    }
+
+    //! Function to return object used for numerically propagating and managing the solution of the equations of motion.
+    /*!
+     * Function to return object used for numerically propagating and managing the solution of the equations of motion.
+     * \return Object used for numerically propagating and managing the solution of the equations of motion.
+     */
+    boost::shared_ptr< SingleArcDynamicsSimulator< StateScalarType, TimeType > > getDynamicsSimulator( )
+    {
+        return dynamicsSimulator_;
+    }
+
+protected:
+
+private:
+
+
+    //! Reset solutions of variational equations.
+    /*!
+     *  Reset solutions of variational equations (stateTransitionMatrixInterpolator_ and sensitivityMatrixInterpolator_),
+     *  i.e. use numerical integration results to create new look-up tables
+     *  and interpolators of state transition and sensitivity matrix through the createInterpolatorsForVariationalSolution
+     *  function
+     */
+    void resetVariationalEquationsInterpolators( )
+    {
+        using namespace interpolators;
+        using namespace utilities;
+
+        // Create interpolators.
+        boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+                stateTransitionMatrixInterpolator;
+        boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+                sensitivityMatrixInterpolator;
+        createStateTransitionAndSensitivityMatrixInterpolator(
+                    stateTransitionMatrixInterpolator, sensitivityMatrixInterpolator, variationalEquationsSolution_,
+                    this->clearNumericalSolution_ );
+
+        // Create (if non-existent) or reset state transition matrix interface
+        if( stateTransitionInterface_ == NULL )
+        {
+            stateTransitionInterface_ = boost::make_shared< SingleArcCombinedStateTransitionAndSensitivityMatrixInterface >(
+                        stateTransitionMatrixInterpolator, sensitivityMatrixInterpolator,
+                        propagatorSettings_->getStateSize( ), parameterVectorSize_ );
+        }
+        else
+        {
+            boost::dynamic_pointer_cast< SingleArcCombinedStateTransitionAndSensitivityMatrixInterface >(
+                        stateTransitionInterface_ )->updateMatrixInterpolators(
+                        stateTransitionMatrixInterpolator, sensitivityMatrixInterpolator );
+        }
+    }
+
+    //! Object used for numerically propagating and managing the solution of the equations of motion.
+    boost::shared_ptr< SingleArcDynamicsSimulator< StateScalarType, TimeType > > dynamicsSimulator_;
+
+    //!  Object that is used to evaluate the variational equations at the given state and time.
+    boost::shared_ptr< VariationalEquations > variationalEquationsObject_;
+
+    //! Map of history of numerically integrated variational equations.
+    /*!
+     *  Map of history of numerically integrated variational equations. Key of map denotes time, values are
+     *  state transition matrix Phi (first vector entry) and sensitivity matrix S (second vector entry)
+     */
+    std::vector< std::map< double, Eigen::MatrixXd > > variationalEquationsSolution_;
+
+};
+
+}
+
+}
+
+
+
+
+#endif // TUDAT_VARIATIONALEQUATIONSSOLVER_H
diff --git a/Tudat/Astrodynamics/ReferenceFrames/UnitTests/unitTestAerodynamicAngleCalculator.cpp b/Tudat/Astrodynamics/ReferenceFrames/UnitTests/unitTestAerodynamicAngleCalculator.cpp
index 3b9aa82..014a5f7 100644
--- a/Tudat/Astrodynamics/ReferenceFrames/UnitTests/unitTestAerodynamicAngleCalculator.cpp
+++ b/Tudat/Astrodynamics/ReferenceFrames/UnitTests/unitTestAerodynamicAngleCalculator.cpp
@@ -53,7 +53,7 @@ void testAerodynamicAngleCalculation(
                 boost::lambda::constant( bankAngle ), 1 );
 
     // Update angle calculator.
-    aerodynamicAngleCalculator.update( );
+    aerodynamicAngleCalculator.update( true );
 
     // Compare expected against computed angles.
     BOOST_CHECK_SMALL(
diff --git a/Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.cpp b/Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.cpp
index 175c237..ffa2f4b 100644
--- a/Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.cpp
+++ b/Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.cpp
@@ -25,41 +25,62 @@ namespace reference_frames
 {
 
 //! Function to update the orientation angles to the current state.
-void AerodynamicAngleCalculator::update( )
+void AerodynamicAngleCalculator::update( const bool updateBodyOrientation  )
 {
     // Clear all current rotation matrices.
     currentRotationMatrices_.clear( );
 
     // Get current body-fixed state.
-    currentBodyFixedState_ = bodyFixedStateFunction_( );
-    Eigen::Vector3d sphericalCoordinates = coordinate_conversions::convertCartesianToSpherical(
-                currentBodyFixedState_.segment( 0, 3 ) );
-
-    // Calculate latitude and longitude.
-    currentAerodynamicAngles_[ latitude_angle ] =
-            mathematical_constants::PI / 2.0 - sphericalCoordinates( 1 );
-    currentAerodynamicAngles_[ longitude_angle ] = sphericalCoordinates( 2 );
-
-    // Calculate vertical <-> aerodynamic <-> body-fixed angles if neede.
-    if( calculateVerticalToAerodynamicFrame_ )
+    if( currentBodyFixedState_ != bodyFixedStateFunction_( ) )
     {
-        Eigen::Vector3d verticalFrameVelocity =
-                getRotatingPlanetocentricToLocalVerticalFrameTransformationQuaternion(
-                    currentAerodynamicAngles_.at( longitude_angle ),
-                    currentAerodynamicAngles_.at( latitude_angle ) ) *
-                currentBodyFixedState_.segment( 3, 3 );
+        currentBodyFixedState_ = bodyFixedStateFunction_( );
+        Eigen::Vector3d sphericalCoordinates = coordinate_conversions::convertCartesianToSpherical< double >(
+                    currentBodyFixedState_.segment( 0, 3 ) );
 
-        currentAerodynamicAngles_[ heading_angle ] =
-                orbital_element_conversions::calculateHeadingAngle( verticalFrameVelocity );
-        currentAerodynamicAngles_[ flight_path_angle ] =
-                orbital_element_conversions::calculateFlightPathAngle( verticalFrameVelocity );
+        // Calculate latitude and longitude.
+        currentAerodynamicAngles_[ latitude_angle ] =
+                mathematical_constants::PI / 2.0 - sphericalCoordinates( 1 );
+        currentAerodynamicAngles_[ longitude_angle ] = sphericalCoordinates( 2 );
 
+        // Calculate vertical <-> aerodynamic <-> body-fixed angles if neede.
+        if( calculateVerticalToAerodynamicFrame_ )
+        {
+            Eigen::Vector3d verticalFrameVelocity =
+                    getRotatingPlanetocentricToLocalVerticalFrameTransformationQuaternion(
+                        currentAerodynamicAngles_.at( longitude_angle ),
+                        currentAerodynamicAngles_.at( latitude_angle ) ) *
+                    currentBodyFixedState_.segment( 3, 3 );
+
+            currentAerodynamicAngles_[ heading_angle ] = calculateHeadingAngle( verticalFrameVelocity );
+            currentAerodynamicAngles_[ flight_path_angle ] =
+                    calculateFlightPathAngle( verticalFrameVelocity );
+        }
+    }
+
+    if( updateBodyOrientation )
+    {
         currentAerodynamicAngles_[ angle_of_attack ] = angleOfAttackFunction_( );
         currentAerodynamicAngles_[ angle_of_sideslip ] = angleOfSideslipFunction_( );
         currentAerodynamicAngles_[ bank_angle ] = bankAngleFunction_( );
     }
+    else
+    {
+        if( currentAerodynamicAngles_.count( angle_of_attack ) == 0 )
+        {
+            currentAerodynamicAngles_[ angle_of_attack ] = 0.0;
+        }
+        if( currentAerodynamicAngles_.count( angle_of_sideslip ) == 0 )
+        {
+            currentAerodynamicAngles_[ angle_of_sideslip ] = 0.0;
+        }
+        if( currentAerodynamicAngles_.count( bank_angle ) == 0 )
+        {
+            currentAerodynamicAngles_[ bank_angle ] = 0.0;
+        }
+    }
 }
 
+
 //! Function to get the rotation quaternion between two frames
 Eigen::Quaterniond AerodynamicAngleCalculator::getRotationQuaternionBetweenFrames(
         const AerodynamicsReferenceFrames originalFrame,
diff --git a/Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.h b/Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.h
index a7e4a42..c38eb7d 100644
--- a/Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.h
+++ b/Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.h
@@ -92,7 +92,7 @@ public:
      *  The current state is retrieved from the bodyFixedStateFunction_ member variable
      *  function pointer.
      */
-    void update( );
+    void update( const bool updateBodyOrientation );
 
     //! Function to get the rotation quaternion between two frames
     /*!
@@ -117,16 +117,24 @@ public:
     double getAerodynamicAngle( const AerodynamicsReferenceFrameAngles angleId );
 
     void setOrientationAngleFunctions(
-            const boost::function< double( ) > angleOfAttackFunction =
-            boost::lambda::constant ( 0.0 ),
-            const boost::function< double( ) > angleOfSideslipFunction =
-            boost::lambda::constant ( 0.0 ),
-            const boost::function< double( ) > bankAngleFunction =
-            boost::lambda::constant ( 0.0 ) )
+            const boost::function< double( ) > angleOfAttackFunction = boost::function< double( ) >( ),
+            const boost::function< double( ) > angleOfSideslipFunction = boost::function< double( ) >( ),
+            const boost::function< double( ) > bankAngleFunction =  boost::function< double( ) >( ) )
     {
-        angleOfAttackFunction_ = angleOfAttackFunction;
-        angleOfSideslipFunction_ = angleOfSideslipFunction;
-        bankAngleFunction_ = bankAngleFunction;
+        if( !angleOfAttackFunction.empty( ) )
+        {
+            angleOfAttackFunction_ = angleOfAttackFunction;
+        }
+
+        if( !angleOfSideslipFunction.empty( ) )
+        {
+            angleOfSideslipFunction_ = angleOfSideslipFunction;
+        }
+
+        if( !bankAngleFunction.empty( ) )
+        {
+            bankAngleFunction_ = bankAngleFunction;
+        }
     }
 
 private:
diff --git a/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.cpp b/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.cpp
index 155d0c1..6aebddb 100644
--- a/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.cpp
+++ b/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.cpp
@@ -358,6 +358,17 @@ Eigen::Quaterniond getAirspeedBasedAerodynamicToBodyFrameTransformationQuaternio
             angleOfAttack, angleOfSideslip ).inverse( );
 }
 
+//! Calculate current heading angle.
+double calculateHeadingAngle( const Eigen::Vector3d& velocityInVerticalFrame )
+{
+    return std::atan2( velocityInVerticalFrame( 1 ), velocityInVerticalFrame( 0 ) );
+}
+
+//! Calculatre current flight path angle.
+double calculateFlightPathAngle( const Eigen::Vector3d& velocityInVerticalFrame )
+{
+    return -std::asin( velocityInVerticalFrame( 2 ) / velocityInVerticalFrame.norm( ) );
+}
 
 } // namespace reference_frames
 } // namespace tudat
diff --git a/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h b/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h
index cf2164d..87f1e59 100644
--- a/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h
+++ b/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h
@@ -398,6 +398,23 @@ Eigen::Matrix3d getAirspeedBasedAerodynamicToBodyFrameTransformationMatrix(
 Eigen::Quaterniond getAirspeedBasedAerodynamicToBodyFrameTransformationQuaternion(
         const double angleOfAttack, const double angleOfSideslip );
 
+//! Calculate current heading angle.
+/*!
+ * Calculate heading angle from velocity in vertical (LVLH) frame.
+ * \param velocityInVerticalFrame Current Cartesian velocity in vertical frame.
+ * \return Current heading angle.
+ */
+double calculateHeadingAngle( const Eigen::Vector3d& velocityInVerticalFrame );
+
+//! Calculate current flight path angle. Angle is defined positive upwards.
+/*!
+ *  Calculate flight path angle from velocity in vertical (LVLH) frame.
+ *  Angle is defined positive upwards.
+ *  \param velocityInVerticalFrame Current Cartesian velocity in vertical frame.
+ *  \return Current flight path angle.
+ */
+double calculateFlightPathAngle( const Eigen::Vector3d& velocityInVerticalFrame );
+
 
 } // namespace reference_frames
 } // namespace tudat
diff --git a/Tudat/Astrodynamics/Relativity/CMakeLists.txt b/Tudat/Astrodynamics/Relativity/CMakeLists.txt
new file mode 100644
index 0000000..968380e
--- /dev/null
+++ b/Tudat/Astrodynamics/Relativity/CMakeLists.txt
@@ -0,0 +1,39 @@
+ #    Copyright (c) 2010-2012 Delft University of Technology.
+ #
+ #    This software is protected by national and international copyright.
+ #    Any unauthorized use, reproduction or modification is unlawful and
+ #    will be prosecuted. Commercial and non-private application of the
+ #    software in any form is strictly prohibited unless otherwise granted
+ #    by the authors.
+ #
+ #    The code is provided without any warranty; without even the implied
+ #    warranty of merchantibility or fitness for a particular purpose.
+ #
+ #    Changelog
+ #      YYMMDD    Author            Comment
+ #      110820    S.M. Persson      File created.
+ #      111025    K. Kumar          Adapted file to work with Revision 194.
+ #      111026    K. Kumar          Adapted file so all headers show in project tree in Qt Creator.
+ #      120321    K. Kumar          Added header, source and unit test files for state-derivative
+ #                                  of CRTBP.
+ #
+
+# Set the source files.
+set(RELATIVITY_SOURCES
+  "${SRCROOT}${RELATIVITYDIR}/relativisticLightTimeCorrection.cpp"
+)
+
+# Set the header files.
+set(RELATIVITY_HEADERS 
+  "${SRCROOT}${RELATIVITYDIR}/relativisticLightTimeCorrection.h"
+)
+
+# Add static libraries.
+add_library(tudat_relativity STATIC ${RELATIVITY_SOURCES} ${RELATIVITY_HEADERS})
+setup_tudat_library_target(tudat_relativity "${SRCROOT}${RELATIVITYDIR}")
+
+
+# Add unit tests
+add_executable(test_ShapiroTimeDelay "${SRCROOT}${RELATIVITYDIR}/UnitTests/unitTestShapiroTimeDelay.cpp")
+setup_custom_test_program(test_ShapiroTimeDelay "${SRCROOT}${RELATIVITYDIR}")
+target_link_libraries(test_ShapiroTimeDelay tudat_relativity tudat_gravitation tudat_observation_models tudat_ephemerides ${Boost_LIBRARIES})
diff --git a/Tudat/Astrodynamics/Relativity/UnitTests/unitTestShapiroTimeDelay.cpp b/Tudat/Astrodynamics/Relativity/UnitTests/unitTestShapiroTimeDelay.cpp
new file mode 100644
index 0000000..0178e61
--- /dev/null
+++ b/Tudat/Astrodynamics/Relativity/UnitTests/unitTestShapiroTimeDelay.cpp
@@ -0,0 +1,68 @@
+
+
+#define BOOST_TEST_MAIN
+
+#include <boost/assign/list_of.hpp>
+#include <boost/test/unit_test.hpp>
+#include <boost/make_shared.hpp>
+#include <boost/bind.hpp>
+
+#include "Tudat/Astrodynamics/Relativity/relativisticLightTimeCorrection.h"
+#include "Tudat/Astrodynamics/Ephemerides/constantEphemeris.h"
+#include "Tudat/Astrodynamics/ObservationModels/ObservableCorrections/firstOrderRelativisticLightTimeCorrection.h"
+
+namespace tudat
+{
+
+namespace unit_tests
+{
+
+using namespace tudat::observation_models;
+using namespace tudat::relativity;
+using namespace tudat::ephemerides;
+
+BOOST_AUTO_TEST_SUITE( test_shapiro_delay )
+
+BOOST_AUTO_TEST_CASE( testShapiroDelay )
+{
+    basic_mathematics::Vector6d groundStationState;
+    groundStationState<<0.0, 0.0, 6378.0, 0.0, 0.0, 0.0;
+    basic_mathematics::Vector6d satelliteState;
+    satelliteState << 0.0, 0.0, 26600.0, 0.0, 0.0, 0.0;
+    basic_mathematics::Vector6d centralBodyPosition = basic_mathematics::Vector6d::Zero( );
+
+    boost::shared_ptr< ConstantEphemeris > ephemeris = boost::make_shared< ConstantEphemeris >(
+                boost::lambda::constant( centralBodyPosition ) );
+
+    double earthGravitationalParameter = 398600.44189E9;
+
+    double directCalculation = calculateFirstOrderLightTimeCorrectionFromCentralBody(
+                earthGravitationalParameter, groundStationState.segment( 0, 3 ),
+                satelliteState.segment( 0, 3 ), centralBodyPosition.segment( 0, 3 ) );
+
+    std::vector< boost::function< basic_mathematics::Vector6d( const double ) > > perturbingBodyStateFunctions;
+    std::vector< boost::function< double( ) > > perturbingBodyGravitationalParameterFunctions;
+
+    perturbingBodyStateFunctions.push_back( boost::bind( &Ephemeris::getCartesianStateFromEphemeris, ephemeris, _1,
+                                                         basic_astrodynamics::JULIAN_DAY_ON_J2000 ) );
+    perturbingBodyGravitationalParameterFunctions.push_back( boost::lambda::constant( earthGravitationalParameter ) );
+
+    FirstOrderLightTimeCorrectionCalculator correctionCalculator(
+                perturbingBodyStateFunctions, perturbingBodyGravitationalParameterFunctions,
+                boost::assign::list_of( "Earth" ), "Satellite", "Earth" );
+
+    double classInterfaceCalculation = correctionCalculator.calculateLightTimeCorrection(
+                groundStationState, satelliteState, 0.0, 0.0 );
+
+    // Living reviews in relativity, GPS.
+    double expectedResult = 6.3E-3;
+
+    BOOST_CHECK_CLOSE_FRACTION( 0.5 * classInterfaceCalculation * physical_constants::SPEED_OF_LIGHT, expectedResult, 6.0E-2 );
+    BOOST_CHECK_CLOSE_FRACTION( 0.5 * directCalculation * physical_constants::SPEED_OF_LIGHT, expectedResult, 6.0E-2 );
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+}
+
+}
diff --git a/Tudat/Astrodynamics/Relativity/relativisticLightTimeCorrection.cpp b/Tudat/Astrodynamics/Relativity/relativisticLightTimeCorrection.cpp
new file mode 100644
index 0000000..0777f0c
--- /dev/null
+++ b/Tudat/Astrodynamics/Relativity/relativisticLightTimeCorrection.cpp
@@ -0,0 +1,35 @@
+#include <iostream>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+
+#include "Tudat/Astrodynamics/Relativity/relativisticLightTimeCorrection.h"
+
+namespace tudat
+{
+
+namespace relativity
+{
+
+//! Function to calculate first order relativistic light time correction due to a gravitating point mass.
+double calculateFirstOrderLightTimeCorrectionFromCentralBody( const double bodyGravitationalParameter,
+                                                              const Eigen::Vector3d& transmitterPosition,
+                                                              const Eigen::Vector3d& receiverPosition,
+                                                              const Eigen::Vector3d& centralBodyPosition,
+                                                              const double ppnParameterGamma )
+{
+    // Calculate Euclidean geometric distances between transmitter, receiver and gravitating body.
+    double distanceToReceiver = ( receiverPosition - centralBodyPosition ).norm( );
+    double distanceToTransmitter = ( transmitterPosition - centralBodyPosition ).norm( );
+    double linkEuclideanDistance = ( transmitterPosition - receiverPosition ).norm( );
+
+    // Calculate and return light time correction.
+    return ( 1.0 + ppnParameterGamma ) * bodyGravitationalParameter * physical_constants::INVERSE_CUBIC_SPEED_OF_LIGHT * std::log(
+                ( distanceToReceiver + distanceToTransmitter + linkEuclideanDistance ) /
+                ( distanceToReceiver + distanceToTransmitter - linkEuclideanDistance ) );
+
+}
+
+}
+
+}
+
diff --git a/Tudat/Astrodynamics/Relativity/relativisticLightTimeCorrection.h b/Tudat/Astrodynamics/Relativity/relativisticLightTimeCorrection.h
new file mode 100644
index 0000000..9fb6615
--- /dev/null
+++ b/Tudat/Astrodynamics/Relativity/relativisticLightTimeCorrection.h
@@ -0,0 +1,40 @@
+#ifndef RELATIVISTICLIGHTTIMECORRECTIONS_H
+#define RELATIVISTICLIGHTTIMECORRECTIONS_H
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+#include <cmath>
+#include <vector>
+
+#include <boost/function.hpp>
+#include <boost/lambda/lambda.hpp>
+
+#include <Eigen/Core>
+
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+
+namespace tudat
+{
+
+namespace relativity
+{
+
+//! Function to calculate first order relativistic light time correction due to a gravitating point mass.
+/*!
+ *  Function to calculate first order relativistic light time correction due to a gravitating point mass,
+ *  according to Eq. (11.17) of 2010 IERS conventions.
+ *  \param bodyGravitationalParameter Gravitational parameter of gravitating body.
+ *  \param transmitterPosition Position of origin of electromagnetic signal (at time of transmission).
+ *  \param receiverPosition Position of target of electromagentic signal (at time of reception)
+ *  \param centralBodyPosition Position of perturbing body (at certain time during signal propagation).
+ *  \param ppnParameterGamma Parametric post-Newtonian parameter gamma, a measure for the space-time curvature due to a unit rest mass (1.0 in GR)
+ *  \return Light time correction (in seconds) due to the gravitating point mass.
+ */
+double calculateFirstOrderLightTimeCorrectionFromCentralBody( const double bodyGravitationalParameter,
+                                                              const Eigen::Vector3d& transmitterPosition,
+                                                              const Eigen::Vector3d& receiverPosition,
+                                                              const Eigen::Vector3d& centralBodyPosition,
+                                                              const double ppnParameterGamma = 1.0 );
+}
+
+}
+#endif // RELATIVISTICLIGHTTIMECORRECTIONS_H
diff --git a/Tudat/Basics/CMakeLists.txt b/Tudat/Basics/CMakeLists.txt
index 3f401b2..50c41a9 100644
--- a/Tudat/Basics/CMakeLists.txt
+++ b/Tudat/Basics/CMakeLists.txt
@@ -40,6 +40,7 @@ set(BASICSDIR_SOURCES
 
 # Add header files.
 set(BASICSDIR_HEADERS 
+  "${SRCROOT}${BASICSDIR}/utilities.h"
   "${SRCROOT}${BASICSDIR}/testMacros.h"
   "${SRCROOT}${BASICSDIR}/utilityMacros.h"
 )
diff --git a/Tudat/Basics/utilities.h b/Tudat/Basics/utilities.h
new file mode 100644
index 0000000..c8b09e6
--- /dev/null
+++ b/Tudat/Basics/utilities.h
@@ -0,0 +1,110 @@
+#ifndef UTILITIES_H
+#define UTILITIES_H
+
+#include <map>
+#include <boost/function.hpp>
+#include <Eigen/Core>
+
+namespace tudat
+{
+
+namespace utilities
+{
+
+//! Function to create a vector from the values of a map
+/*!
+ *  Function to create a vector from the values of a map. The output vector is in the order of the map entries, i.e. as provided by a forward iterator.
+ *  The map keys are not used for the return vector.
+ *  \param inputMap Original map from which the vector is to be created
+ *  \return Vector created from the map values
+ */
+template< typename VectorArgument, typename KeyType >
+std::vector< VectorArgument > createVectorFromMapValues( const std::map< KeyType, VectorArgument >& inputMap )
+{
+    // Create and size return vector.
+    std::vector< VectorArgument > outputVector;
+    outputVector.resize( inputMap.size( ) );
+
+    // Iterate over all map entries and create vector
+    int currentIndex = 0;
+    for( typename std::map< KeyType, VectorArgument >::const_iterator mapIterator = inputMap.begin( );
+         mapIterator != inputMap.end( ); mapIterator++ )
+    {
+        outputVector[ currentIndex ] = mapIterator->second;
+        currentIndex++;
+    }
+
+    return outputVector;
+
+}
+
+//! Function to create a vector from the keys of a map
+/*!
+ *  Function to create a vector from the keys of a map. The output vector is in the order of the map entries, i.e. as provided by a forward iterator.
+ *  The map values are not used for the return vector.
+ *  \param inputMap Original map from which the vector is to be created
+ *  \return Vector created from the map keys
+ */
+template< typename VectorArgument, typename KeyType >
+std::vector< KeyType > createVectorFromMapKeys( const std::map< KeyType, VectorArgument >& inputMap )
+{
+    // Create and size return vector.
+    std::vector< KeyType > outputVector;
+    outputVector.resize( inputMap.size( ) );
+
+    // Iterate over all map entries and create vector
+    int currentIndex = 0;
+    for( typename std::map< KeyType, VectorArgument >::const_iterator mapIterator = inputMap.begin( );
+         mapIterator != inputMap.end( ); mapIterator++ )
+    {
+        outputVector[ currentIndex ] = mapIterator->first;
+        currentIndex++;
+    }
+
+    return outputVector;
+}
+
+//! Function to sum the return values of two boost function with empty input argument list.
+/*!
+ * Function to sum the return values of two boost function with empty input argument list.
+ * \param function1 First function to be added.
+ * \param function2 Second function to be added.
+ * \return Sum of return values of function1 and function2
+ */
+template< typename S >
+S sumFunctionReturn( const boost::function< S( ) > function1, const boost::function< S( ) > function2 )
+{
+    return function1( ) + function2( );
+}
+
+//! Function to create a vector block history from full matrix history.
+/*!
+ *  Function to create a vector matrix block history from full matrix history.
+ *  \param matrixHistory Full matrix history
+ *  \param blockMatrixHistory Block vector history (return by reference).
+ *  \param startIndices Starting point (row,column) in matrix of return vector blocks.
+ *  \param segmentSize Number of rows in vector.
+ */
+template< typename S, typename T >
+void createVectorBlockMatrixHistory(
+        const std::map< S, Eigen::Matrix< T, Eigen::Dynamic, Eigen::Dynamic > >& matrixHistory,
+        std::map< S, Eigen::Matrix< T, Eigen::Dynamic, 1 > >& blockMatrixHistory,
+        const std::pair< int, int > startIndices, const int segmentSize )
+{
+    blockMatrixHistory.clear( );
+
+    // Loop over integration output and put results in corresponding data structures.
+    for( typename std::map< S, Eigen::Matrix< T, Eigen::Dynamic, Eigen::Dynamic > >::const_iterator matrixIterator = matrixHistory.begin( );
+         matrixIterator != matrixHistory.end( ); matrixIterator++ )
+    {
+        // Set numerically integrated states of bodies.
+        blockMatrixHistory[ matrixIterator->first ] =
+                matrixIterator->second.block( startIndices.first, startIndices.second, segmentSize, 1 );
+    }
+}
+
+}
+
+}
+
+#endif // UTILITIES_H
diff --git a/Tudat/CMakeLists.txt b/Tudat/CMakeLists.txt
index 0de39e5..564a7c2 100755
--- a/Tudat/CMakeLists.txt
+++ b/Tudat/CMakeLists.txt
@@ -204,7 +204,7 @@ endif()
 # Set whether to use the NRLMSISE-00 library integration with Tudat or not. If it not supplied by the
 # user (either directly as an argument or through the "UserSettings.txt" file, the default setting
 # is "OFF".
-option(USE_NRLMSISE00 "build Tudat with NRLMSISE-00 enabled" OFF)
+option(USE_NRLMSISE00 "build Tudat with NRLMSISE-00 enabled" ON)
 if(NOT USE_NRLMSISE00)
   message(STATUS "NRLMSISE-00 disabled!")
   add_definitions(-DUSE_NRLMSISE00=0)
@@ -222,25 +222,31 @@ else()
   endif( )
 endif()
 
-
+# Create lists of static libraries for ease of use
 list(APPEND TUDAT_EXTERNAL_LIBRARIES "")
 if(USE_CSPICE)
   list(APPEND TUDAT_EXTERNAL_LIBRARIES tudat_spice_interface cspice)
 endif()
 
-
 if(USE_NRLMSISE00)
   list(APPEND TUDAT_EXTERNAL_LIBRARIES nrlmsise00)
 endif()
 
 list(APPEND TUDAT_PROPAGATION_LIBRARIES tudat_simulation_setup tudat_propagators
-    tudat_aerodynamics tudat_geometric_shapes tudat_gravitation tudat_mission_segments
+    tudat_aerodynamics tudat_geometric_shapes tudat_relativity tudat_gravitation tudat_mission_segments
+    tudat_electro_magnetism tudat_ephemerides tudat_numerical_integrators tudat_reference_frames
+    tudat_basic_astrodynamics tudat_input_output tudat_basic_mathematics tudat_propagators ${TUDAT_EXTERNAL_LIBRARIES})
+
+list(APPEND TUDAT_ESTIMATION_LIBRARIES tudat_simulation_setup tudat_observation_models tudat_acceleration_partials
+    tudat_estimatable_parameters tudat_orbit_determination  tudat_propagators
+    tudat_aerodynamics tudat_geometric_shapes tudat_relativity tudat_gravitation tudat_mission_segments
     tudat_electro_magnetism tudat_ephemerides tudat_numerical_integrators tudat_reference_frames
     tudat_basic_astrodynamics tudat_input_output tudat_basic_mathematics tudat_propagators ${TUDAT_EXTERNAL_LIBRARIES})
 
 
 
 
+
 # Set sub-directories.
 set(SUBDIRS ${APPLICATIONSDIR} ${ASTRODYNAMICSDIR} ${BASICSDIR} ${INPUTOUTPUTDIR} ${MATHEMATICSDIR} ${EXTERNALDIR} ${SIMULATIONSETUPDIR})
 
diff --git a/Tudat/Mathematics/BasicMathematics/UnitTests/unitTestLegendrePolynomials.cpp b/Tudat/Mathematics/BasicMathematics/UnitTests/unitTestLegendrePolynomials.cpp
index fa9a626..5c88449 100644
--- a/Tudat/Mathematics/BasicMathematics/UnitTests/unitTestLegendrePolynomials.cpp
+++ b/Tudat/Mathematics/BasicMathematics/UnitTests/unitTestLegendrePolynomials.cpp
@@ -44,6 +44,7 @@
 
 #include <boost/test/floating_point_comparison.hpp>
 #include <boost/test/unit_test.hpp>
+#include <boost/make_shared.hpp>
 
 #include <Eigen/Core>
 
@@ -74,6 +75,7 @@ BOOST_AUTO_TEST_CASE( test_LegendrePolynomial )
 {
     // Declare test values vector.
     Vector12d computedTestValues;
+    Vector12d computedTestValuesDirect;
 
     // Define degree and order vectors.
     const Vector12i degree
@@ -81,8 +83,11 @@ BOOST_AUTO_TEST_CASE( test_LegendrePolynomial )
     const Vector12i order
             = ( Eigen::VectorXi( 12 ) << 0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 150 ).finished( );
 
+    basic_mathematics::LegendreCache legendreCache = basic_mathematics::LegendreCache( 150, 150, 0 );
+
     // Define polynomial parameter.
     const double polynomialParameter = 0.5;
+    legendreCache.update( polynomialParameter );
 
     // Loop through degrees and orders.
     for ( int index = 0; index < degree.size( ); index++ )
@@ -91,6 +96,10 @@ BOOST_AUTO_TEST_CASE( test_LegendrePolynomial )
         computedTestValues( index ) = basic_mathematics::computeLegendrePolynomial(
                     degree( index ),
                     order( index ),
+                    legendreCache );
+        computedTestValuesDirect( index ) = basic_mathematics::computeLegendrePolynomial(
+                    degree( index ),
+                    order( index ),
                     polynomialParameter );
     }
 
@@ -118,12 +127,16 @@ BOOST_AUTO_TEST_CASE( test_LegendrePolynomial )
 
     // Check if test values match expected values.
     TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedValues, computedTestValues, 1.0e-14 );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedValues, computedTestValuesDirect, 1.0e-14 );
 }
 
 BOOST_AUTO_TEST_CASE( test_GeodesyLegendrePolynomial )
 {
     // Declare test values vector.
     Vector10d computedTestValues;
+    Vector10d computedTestValuesDirect;
+
+    basic_mathematics::LegendreCache legendreCache = basic_mathematics::LegendreCache( 4, 4, 1 );
 
     // Define degree and order vectors.
     const Vector10i degree = ( Eigen::VectorXi( 10 ) << 0, 1, 1, 2, 2, 2, 3, 3, 3, 3 ).finished( );
@@ -132,14 +145,17 @@ BOOST_AUTO_TEST_CASE( test_GeodesyLegendrePolynomial )
     // Define polynomial parameter.
     const double polynomialParameter = 0.5;
 
+    legendreCache.update( polynomialParameter );
     // Loop through degrees and orders.
     for ( int index = 0; index < degree.size( ); index++ )
     {
         // Compute test value of Legendre polynomial.
         computedTestValues( index ) = basic_mathematics::computeGeodesyLegendrePolynomial(
                     degree( index ),
-                    order( index ),
-                    polynomialParameter );
+                    order( index ), legendreCache );
+        computedTestValuesDirect( index )  = basic_mathematics::computeGeodesyLegendrePolynomial(
+                    degree( index ),
+                    order( index ), polynomialParameter );
     }
 
     // Set expected values. These values have been obtained from the MATLAB subfunction
@@ -160,6 +176,8 @@ BOOST_AUTO_TEST_CASE( test_GeodesyLegendrePolynomial )
 
     // Check if test values match expected values.
     TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedValues, computedTestValues, 1.0e-15 );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedValues, computedTestValuesDirect, 1.0e-15 );
+
 }
 
 BOOST_AUTO_TEST_CASE( test_LegendrePolynomialDerivative )
diff --git a/Tudat/Mathematics/BasicMathematics/UnitTests/unitTestSphericalHarmonics.cpp b/Tudat/Mathematics/BasicMathematics/UnitTests/unitTestSphericalHarmonics.cpp
index 30b6a35..5b750a4 100644
--- a/Tudat/Mathematics/BasicMathematics/UnitTests/unitTestSphericalHarmonics.cpp
+++ b/Tudat/Mathematics/BasicMathematics/UnitTests/unitTestSphericalHarmonics.cpp
@@ -128,11 +128,34 @@ BOOST_AUTO_TEST_CASE( test_SphericalHarmonics_PotentialGradient )
                                                      -2.717133139910520
                                                      ).finished( );
 
+    boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache > sphericalHarmonicsCache =
+            boost::make_shared< basic_mathematics::SphericalHarmonicsCache >( 4, 4 );
+    sphericalHarmonicsCache->update(
+                sphericalPosition( 0 ), std::sin( sphericalPosition( 1 ) ), sphericalPosition( 2 ), referenceRadius );
+
     // Compute to be tested potential gradient.
     Eigen::MatrixXd testPotentialGradient( 10, 3 );
+    Eigen::MatrixXd testPotentialGradient2( 10, 3 );
+    Eigen::MatrixXd testPotentialGradient3( 10, 3 );
+
+    // Compute potential gradients (using each of the three functions).
     for ( int index = 0; index < degree.size( ); index++ )
     {
-        Eigen::Vector3d placeholder = basic_mathematics::computePotentialGradient(
+        testPotentialGradient.block( index, 0, 1, 3 ) = basic_mathematics::computePotentialGradient(
+                    sphericalPosition( 0 ),
+                    std::pow( referenceRadius / sphericalPosition( 0 ), degree( index ) + 1 ),
+                    std::cos( static_cast< double >( order( index ) ) * sphericalPosition( 2 ) ),
+                    std::sin( static_cast< double >( order( index ) ) * sphericalPosition( 2 ) ),
+                    std::cos( sphericalPosition( 1 ) ),
+                    preMultiplier,
+                    degree( index ),
+                    order( index ),
+                    cosineHarmonicCoefficient( index ),
+                    sineHarmonicCoefficient( index ),
+                    legendrePolynomial( index ),
+                    legendrePolynomialDerivative( index ) ).transpose( );
+
+        testPotentialGradient2.block( index, 0, 1, 3 ) = basic_mathematics::computePotentialGradient(
                     sphericalPosition,
                     referenceRadius,
                     preMultiplier,
@@ -141,10 +164,19 @@ BOOST_AUTO_TEST_CASE( test_SphericalHarmonics_PotentialGradient )
                     cosineHarmonicCoefficient( index ),
                     sineHarmonicCoefficient( index ),
                     legendrePolynomial( index ),
-                    legendrePolynomialDerivative( index ) );
+                    legendrePolynomialDerivative( index ) ).transpose( );
+
+        testPotentialGradient3.block( index, 0, 1, 3 ) = basic_mathematics::computePotentialGradient(
+                    sphericalPosition,
+                    preMultiplier,
+                    degree( index ),
+                    order( index ),
+                    cosineHarmonicCoefficient( index ),
+                    sineHarmonicCoefficient( index ),
+                    legendrePolynomial( index ),
+                    legendrePolynomialDerivative( index ), sphericalHarmonicsCache ).transpose( );
+
 
-        // Transpose test values matrix.
-        testPotentialGradient.row( index ) = placeholder.transpose( );
     }
 
     // Define expected radius gradient values.
@@ -197,6 +229,9 @@ BOOST_AUTO_TEST_CASE( test_SphericalHarmonics_PotentialGradient )
 
     // Check if test values match expected values.
     TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPotentialGradient, expectedValues, 1.0e-15 );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPotentialGradient2, expectedValues, 1.0e-15 );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( testPotentialGradient3, expectedValues, 1.0e-15 );
+
 }
 
 BOOST_AUTO_TEST_SUITE_END( )
diff --git a/Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.h b/Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.h
index 8556c4a..1550d39 100644
--- a/Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.h
+++ b/Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.h
@@ -102,6 +102,51 @@ ScalarType computeModulo( const ScalarType dividend, const ScalarType divisor )
     return dividend - divisor * std::floor( dividend / divisor );
 }
 
+//! Raise floating point variable to integer power.
+template< typename ScalarType >
+ScalarType raiseToIntegerPower( const ScalarType baseValue,
+                            const int integerPower )
+{
+    // Declare local variable.
+    // Declare result of raising base to integer power.
+    // Initialise with value.
+    ScalarType resultOfRaisingBaseToIntegerPower = 1;
+    // Declare absolute value of integerPower.
+    int absoluteValueOfIntegerPower
+            = std::abs( integerPower );
+    // Declare copy of base value.
+    ScalarType copyOfBaseValue = baseValue;
+
+    // Compute the result here using exponentiation by squares.
+    // Stop loop when absolute value of integer power is equal to zero.
+    while ( absoluteValueOfIntegerPower )
+    {
+        // Check that absolute value of integer power.
+        if ( absoluteValueOfIntegerPower & 1 )
+        {
+            // Compute intermediate result.
+            resultOfRaisingBaseToIntegerPower *= copyOfBaseValue;
+        }
+
+        // Divide integer power by two.
+        absoluteValueOfIntegerPower >>= 1;
+
+        // Square base value.
+        copyOfBaseValue *= copyOfBaseValue;
+    }
+
+    // Check if sign of integerPower is negative.
+    if ( integerPower < 0 )
+    {
+        // Switch sign of result.
+        resultOfRaisingBaseToIntegerPower
+                = 1.0 / resultOfRaisingBaseToIntegerPower;
+    }
+
+    // Return result of raising base to integer power.
+    return resultOfRaisingBaseToIntegerPower;
+}
+
 } // namespace basic_mathematics
 } // namespace tudat
 
diff --git a/Tudat/Mathematics/BasicMathematics/coordinateConversions.cpp b/Tudat/Mathematics/BasicMathematics/coordinateConversions.cpp
index 4e56e6b..6c1c524 100644
--- a/Tudat/Mathematics/BasicMathematics/coordinateConversions.cpp
+++ b/Tudat/Mathematics/BasicMathematics/coordinateConversions.cpp
@@ -101,33 +101,6 @@ Eigen::Vector3d convertSphericalToCartesian( const Eigen::Vector3d& sphericalCoo
     return convertedCartesianCoordinates_;
 }
 
-//! Convert Cartesian (x,y,z) to spherical (radius, zenith, azimuth) coordinates.
-Eigen::Vector3d convertCartesianToSpherical( const Eigen::Vector3d& cartesianCoordinates )
-{
-    // Create output Vector3d.
-    Eigen::Vector3d convertedSphericalCoordinates_ = Eigen::Vector3d::Zero( 3 );
-
-    // Compute transformation of Cartesian coordinates to spherical coordinates.
-    convertedSphericalCoordinates_( 0 ) = cartesianCoordinates.norm( );
-
-    // Check if coordinates are at origin.
-    if ( convertedSphericalCoordinates_( 0 ) < std::numeric_limits< double >::epsilon( ) )
-    {
-        convertedSphericalCoordinates_( 1 ) = 0.0;
-        convertedSphericalCoordinates_( 2 ) = 0.0;
-    }
-    // Else compute coordinates using trigonometric relationships.
-    else
-    {
-        convertedSphericalCoordinates_( 1 ) = std::acos( cartesianCoordinates( 2 )
-                                                         / convertedSphericalCoordinates_( 0 ) );
-        convertedSphericalCoordinates_( 2 ) = std::atan2( cartesianCoordinates( 1 ),
-                                                          cartesianCoordinates( 0 ) );
-    }
-
-    return convertedSphericalCoordinates_;
-}
-
 
 //! Convert cylindrical to Cartesian coordinates.
 Eigen::Vector3d convertCylindricalToCartesian( const double radius,
diff --git a/Tudat/Mathematics/BasicMathematics/coordinateConversions.h b/Tudat/Mathematics/BasicMathematics/coordinateConversions.h
index 97cc200..bef13b2 100644
--- a/Tudat/Mathematics/BasicMathematics/coordinateConversions.h
+++ b/Tudat/Mathematics/BasicMathematics/coordinateConversions.h
@@ -69,6 +69,7 @@
 #include <Eigen/Core>
 
 #include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+#include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
 
 namespace tudat
 {
@@ -107,7 +108,33 @@ Eigen::Vector3d convertSphericalToCartesian( const Eigen::Vector3d& sphericalCoo
  * \return Vector containing sphericalCoordinates radius, zenith and azimuth (in that
  *          order), as calculated from sphericalCoordinates.
 */
-Eigen::Vector3d convertCartesianToSpherical( const Eigen::Vector3d& cartesianCoordinates );
+template< typename ScalarType = double >
+Eigen::Matrix< ScalarType, 3, 1 > convertCartesianToSpherical( const Eigen::Matrix< ScalarType, 3, 1 > & cartesianCoordinates )
+
+{
+    // Create output Vector3d.
+    Eigen::Matrix< ScalarType, 3, 1 > convertedSphericalCoordinates_ = Eigen::Matrix< ScalarType, 3, 1 >::Zero( );
+
+    // Compute transformation of Cartesian coordinates to spherical coordinates.
+    convertedSphericalCoordinates_( 0 ) = cartesianCoordinates.norm( );
+
+    // Check if coordinates are at origin.
+    if ( convertedSphericalCoordinates_( 0 ) < std::numeric_limits< ScalarType >::epsilon( ) )
+    {
+        convertedSphericalCoordinates_( 1 ) = mathematical_constants::getFloatingInteger< ScalarType >( 0 );
+        convertedSphericalCoordinates_( 2 ) = mathematical_constants::getFloatingInteger< ScalarType >( 0 );
+    }
+    // Else compute coordinates using trigonometric relationships.
+    else
+    {
+        convertedSphericalCoordinates_( 1 ) = std::acos( cartesianCoordinates( 2 )
+                                                         / convertedSphericalCoordinates_( 0 ) );
+        convertedSphericalCoordinates_( 2 ) = std::atan2( cartesianCoordinates( 1 ),
+                                                          cartesianCoordinates( 0 ) );
+    }
+
+    return convertedSphericalCoordinates_;
+}
 
 //! Spherical coordinate indices.
 /*!
diff --git a/Tudat/Mathematics/BasicMathematics/legendrePolynomials.cpp b/Tudat/Mathematics/BasicMathematics/legendrePolynomials.cpp
index 8a636d4..56076e8 100644
--- a/Tudat/Mathematics/BasicMathematics/legendrePolynomials.cpp
+++ b/Tudat/Mathematics/BasicMathematics/legendrePolynomials.cpp
@@ -48,16 +48,101 @@ namespace tudat
 namespace basic_mathematics
 {
 
-// Define maximum size of Legendre polynomials back-end cache.
-#ifndef MAXIMUM_CACHE_ENTRIES
-#define MAXIMUM_CACHE_ENTRIES 12000
-#endif
+
+
+//! Default constructor, initializes cache object with 0 maximum degree and order.
+LegendreCache::LegendreCache( const bool useGeodesyNormalization )
+{
+    useGeodesyNormalization_  = useGeodesyNormalization;
+
+    if( useGeodesyNormalization_ )
+    {
+        legendrePolynomialFunction_ = geodesyNormalizedLegendrePolynomialFunction;
+    }
+    else
+    {
+        legendrePolynomialFunction_ = regularLegendrePolynomialFunction;
+    }
+
+    resetMaximumDegreeAndOrder( 0, 0 );
+
+}
+
+//! Constructor
+LegendreCache::LegendreCache( const int maximumDegree, const int maximumOrder, const bool useGeodesyNormalization  )
+{
+    useGeodesyNormalization_  = useGeodesyNormalization;
+
+    if( useGeodesyNormalization_ )
+    {
+        legendrePolynomialFunction_ = geodesyNormalizedLegendrePolynomialFunction;
+    }
+    else
+    {
+        legendrePolynomialFunction_ = regularLegendrePolynomialFunction;
+    }
+
+    resetMaximumDegreeAndOrder( maximumDegree, maximumOrder );
+}
+
+//! Get Legendre polynomial from cache when possible, and from direct computation otherwise.
+void LegendreCache::update( const double polynomialParameter  )
+{
+    currentPolynomialParameter_ = polynomialParameter;
+    currentPolynomialParameterComplement_ = std::sqrt( 1.0 - polynomialParameter * polynomialParameter ); // cosine of latitude is always positive!
+
+    LegendreCache& thisReference = *this;
+    for( int i = 0; i <= maximumDegree_; i++ )
+    {
+        for( int j = 0; ( ( j <= i ) && ( j <= maximumOrder_ ) ) ; j++ )
+        {
+            legendreValues_[ i * ( maximumOrder_ + 1 ) + j ] = legendrePolynomialFunction_( i, j, thisReference );
+        }
+    }
+}
+
+//! Update maximum degree and order of cache
+void LegendreCache::resetMaximumDegreeAndOrder( const int maximumDegree, const int maximumOrder )
+{
+    maximumDegree_ = maximumDegree;
+    maximumOrder_ = maximumOrder;
+    legendreValues_.resize( ( maximumDegree_ + 1 ) * ( maximumOrder_ + 1 ) );
+
+    currentPolynomialParameter_ = TUDAT_NAN;
+    currentPolynomialParameterComplement_ = TUDAT_NAN;
+}
+
+
+//! Get Legendre polynomial value from the cache.
+double LegendreCache::getLegendrePolynomial(
+        const int degree, const int order )
+{
+    if( degree > maximumDegree_ || order > maximumOrder_ )
+    {
+        std::cerr<<"Error when requesting legendre cache, maximum degree or order exceeded "<<
+                   degree<<" "<<maximumDegree_<<" "<<order<<" "<<maximumOrder_<<std::endl;
+        return TUDAT_NAN;
+    }
+    else if( order > degree )
+    {
+        return 0.0;
+    }
+    else
+    {
+        return legendreValues_[ degree * ( maximumOrder_ + 1  ) + order ];
+    };
+}
 
 //! Compute unnormalized associated Legendre polynomial.
 double computeLegendrePolynomial( const int degree,
                                   const int order,
-                                  const double polynomialParameter )
+                                  LegendreCache& legendreCache )
 {
+    if( legendreCache.getUseGeodesyNormalization( ) )
+    {
+        throw std::runtime_error( "Error when computing Legendre polynomial, input uses normalization" );
+    }
+
     // If degree or order is negative...
     if ( degree < 0 || order < 0 )
     {
@@ -82,19 +167,19 @@ double computeLegendrePolynomial( const int degree,
     else if ( degree <= 1 && order <= 1 )
     {
         // Compute polynomial explicitly.
-        return computeLegendrePolynomialExplicit( degree, order, polynomialParameter );
+        return computeLegendrePolynomialExplicit( degree, order, legendreCache.getCurrentPolynomialParameter( ) );
     }
 
     // Else if degree and order are sectoral...
     else if ( degree == order )
     {
         // Obtain polynomial of degree one and order one.
-        const double degreeOneOrderOnePolynomial = legendreCache.getOrElseUpdate(
-                    1, 1, polynomialParameter, &computeLegendrePolynomial );
+        const double degreeOneOrderOnePolynomial = legendreCache.getLegendrePolynomial(
+                    1, 1 );
 
         // Obtain prior sectoral polynomial.
-        const double priorSectoralPolynomial = legendreCache.getOrElseUpdate(
-                    degree - 1, order - 1, polynomialParameter, &computeLegendrePolynomial );
+        const double priorSectoralPolynomial = legendreCache.getLegendrePolynomial(
+                    degree - 1, order - 1 );
 
         // Compute polynomial.
         return computeLegendrePolynomialDiagonal(
@@ -105,27 +190,44 @@ double computeLegendrePolynomial( const int degree,
     else
     {
         // Obtain prior degree polynomial.
-        const double oneDegreePriorPolynomial = legendreCache.getOrElseUpdate(
-                    degree - 1, order, polynomialParameter, &computeLegendrePolynomial );
+        const double oneDegreePriorPolynomial = legendreCache.getLegendrePolynomial(
+                    degree - 1, order );
 
         // Obtain two degrees prior polynomial.
-        const double twoDegreesPriorPolynomial = legendreCache.getOrElseUpdate(
-                    degree - 2, order, polynomialParameter, &computeLegendrePolynomial );
+        const double twoDegreesPriorPolynomial = legendreCache.getLegendrePolynomial(
+                    degree - 2, order );
 
         // Compute polynomial.
         return computeLegendrePolynomialVertical( degree,
                                                   order,
-                                                  polynomialParameter,
+                                                  legendreCache.getCurrentPolynomialParameter( ),
                                                   oneDegreePriorPolynomial,
                                                   twoDegreesPriorPolynomial );
     }
 }
 
+
+double computeLegendrePolynomial( const int degree,
+                                  const int order,
+                                  const double legendreParameter )
+{
+    LegendreCache legendreCache( degree, order, 0 );
+    legendreCache.update( legendreParameter );
+    return computeLegendrePolynomial( degree, order, legendreCache );
+}
+
+
 //! Compute geodesy-normalized associated Legendre polynomial.
 double computeGeodesyLegendrePolynomial( const int degree,
                                          const int order,
-                                         const double polynomialParameter )
+                                         LegendreCache& geodesyLegendreCache )
 {
+
+    if( !geodesyLegendreCache.getUseGeodesyNormalization( ) )
+    {
+        throw std::runtime_error( "Error when computing Legendre polynomial, input uses no normalization" );
+    }
+
     // If degree or order is negative...
     if ( degree < 0 || order < 0 )
     {
@@ -150,19 +252,19 @@ double computeGeodesyLegendrePolynomial( const int degree,
     else if ( degree <= 1 && order <= 1 )
     {
         // Compute polynomial explicitly.
-        return computeGeodesyLegendrePolynomialExplicit( degree, order, polynomialParameter );
+        return computeGeodesyLegendrePolynomialExplicit( degree, order, geodesyLegendreCache.getCurrentPolynomialParameter( ) );
     }
 
     // Else if degree and order are sectoral...
     else if ( degree == order )
     {
         // Obtain polynomial of degree one and order one.
-        double degreeOneOrderOnePolynomial = geodesyLegendreCache.getOrElseUpdate(
-                    1, 1, polynomialParameter, &computeGeodesyLegendrePolynomial );
+        double degreeOneOrderOnePolynomial = geodesyLegendreCache.getLegendrePolynomial(
+                    1, 1 );
 
         // Obtain prior sectoral polynomial.
-        double priorSectoralPolynomial = geodesyLegendreCache.getOrElseUpdate(
-                    degree - 1, order - 1, polynomialParameter, &computeGeodesyLegendrePolynomial );
+        double priorSectoralPolynomial = geodesyLegendreCache.getLegendrePolynomial(
+                    degree - 1, order - 1 );
 
         // Compute polynomial.
         return computeGeodesyLegendrePolynomialDiagonal(
@@ -173,22 +275,31 @@ double computeGeodesyLegendrePolynomial( const int degree,
     else
     {
         // Obtain prior degree polynomial.
-        double oneDegreePriorPolynomial = geodesyLegendreCache.getOrElseUpdate(
-                    degree - 1, order, polynomialParameter, &computeGeodesyLegendrePolynomial );
+        double oneDegreePriorPolynomial = geodesyLegendreCache.getLegendrePolynomial(
+                    degree - 1, order );
 
         // Obtain two degrees prior polynomial.
-        double twoDegreesPriorPolynomial = geodesyLegendreCache.getOrElseUpdate(
-                    degree - 2, order, polynomialParameter, &computeGeodesyLegendrePolynomial );
+        double twoDegreesPriorPolynomial = geodesyLegendreCache.getLegendrePolynomial(
+                    degree - 2, order );
 
         // Compute polynomial.
         return computeGeodesyLegendrePolynomialVertical( degree,
                                                          order,
-                                                         polynomialParameter,
+                                                         geodesyLegendreCache.getCurrentPolynomialParameter( ),
                                                          oneDegreePriorPolynomial,
                                                          twoDegreesPriorPolynomial );
     }
 }
 
+double computeGeodesyLegendrePolynomial( const int degree,
+                                         const int order,
+                                         const double legendreParameter )
+{
+    LegendreCache legendreCache( degree, order, 1 );
+    legendreCache.update( legendreParameter );
+    return computeGeodesyLegendrePolynomial( degree, order, legendreCache );
+}
+
 //! Compute derivative of unnormalized Legendre polynomial.
 double computeLegendrePolynomialDerivative( const int order,
                                             const double polynomialParameter,
@@ -407,120 +518,14 @@ double computeGeodesyLegendrePolynomialVertical( const int degree,
 {
     // Return polynomial.
     return std::sqrt( ( 2.0 * static_cast< double >( degree ) + 1.0 )
-                      / ( static_cast< double >( degree + order ) )
-                      / ( static_cast< double >( degree - order ) ) )
-            * ( std::sqrt( 2.0 * static_cast< double >( degree ) - 1.0 ) * polynomialParameter
-                * oneDegreePriorPolynomial
+                      / ( ( static_cast< double >( degree + order ) ) * ( static_cast< double >( degree - order ) ) ) )
+            * ( std::sqrt( 2.0 * static_cast< double >( degree ) - 1.0 ) * polynomialParameter * oneDegreePriorPolynomial
                 - std::sqrt( ( static_cast< double >( degree + order ) - 1.0 )
                              * ( static_cast< double >( degree - order ) - 1.0 )
                              / ( 2.0 * static_cast< double >( degree ) - 3.0 ) )
                 * twoDegreesPriorPolynomial );
 }
 
-//! Define overloaded 'equals' operator for use with 'Point' structure.
-bool operator==( const Point& polynomialArguments1, const Point& polynomialArguments2 )
-{
-    bool equal = polynomialArguments1.degree == polynomialArguments2.degree
-            && polynomialArguments1.order == polynomialArguments2.order
-            && polynomialArguments1.polynomialParameter
-            == polynomialArguments2.polynomialParameter;
-
-    return equal;
-}
-
-//! Set hash value.
-std::size_t hash_value( Point const& polynomialArguments )
-{
-    std::size_t seed = 0;
-    boost::hash_combine( seed, polynomialArguments.degree );
-    boost::hash_combine( seed, polynomialArguments.order );
-    boost::hash_combine( seed, polynomialArguments.polynomialParameter );
-
-    return seed;
-}
-
-//! Get Legendre polynomial from cache when possible, and from direct computation otherwise.
-double LegendreCache::getOrElseUpdate(
-        const int degree, const int order, const double polynomialParameter,
-        const LegendrePolynomialFunction legendrePolynomialFunction )
-{
-    // Initialize structure with polynomial arguments.
-    Point polynomialArguments( degree, order, polynomialParameter );
-
-    // Initialize cache iterator.
-    CacheTable::iterator cachedEntry = backendCache.find( polynomialArguments );
-
-    // If the requested polynomial was not found in cache, compute polynomial.
-    if ( cachedEntry == backendCache.end( ) )
-    {
-        double legendrePolynomial = legendrePolynomialFunction( degree, order,
-                                                                polynomialParameter );
-        // If cache is full, remove the oldest element.
-        if ( history.full( ) )
-        {
-            backendCache.erase( backendCache.find( history[ 0 ] ) );
-            history.pop_front( );
-        }
-
-        // Insert computed polynomial into cache.
-        backendCache.insert( std::pair< Point, double >( polynomialArguments,
-                                                         legendrePolynomial ) );
-        history.push_back( polynomialArguments );
-
-        // Return polynomial value from computation.
-        return legendrePolynomial;
-    }
-
-    // Else the requested polynomial was found in cache; return polynomial value from cache entry.
-    else
-    {
-        return cachedEntry->second;
-    }
-}
-
-//! Initialize LegendreCache objects.
-LegendreCache::LegendreCache( ) : history( MAXIMUM_CACHE_ENTRIES ) { }
-
-//! Write contents of Legendre polynomial structure to string.
-std::string writeLegendrePolynomialStructureToString( const Point legendrePolynomialStructure )
-{
-    std::stringstream buffer;
-
-    buffer << "(" << legendrePolynomialStructure.degree << ", "
-           << legendrePolynomialStructure.order << ", "
-           << legendrePolynomialStructure.polynomialParameter << ")";
-
-    return buffer.str( );
-}
-
-//! Dump Legendre polynomial cache data to stream (table and history).
-void dumpLegendrePolynomialCacheData( std::ostream& outputStream,
-                                      boost::unordered_map< Point, double > cacheTable,
-                                      boost::circular_buffer< Point > cacheHistory )
-{
-    outputStream << "Table:\n";
-
-    for ( boost::unordered_map< Point, double >::iterator iteratorCacheTable = cacheTable.begin( );
-          iteratorCacheTable != cacheTable.end( ); iteratorCacheTable++ )
-    {
-        outputStream << "\t" << writeLegendrePolynomialStructureToString(
-                            iteratorCacheTable->first ).c_str( ) << " => "
-                     << iteratorCacheTable->second << std::endl;
-    }
-
-    outputStream << "History:\n";
-
-    for ( boost::circular_buffer< Point >::iterator iteratorCacheHistory = cacheHistory.begin( );
-          iteratorCacheHistory != cacheHistory.end( ); iteratorCacheHistory++ )
-    {
-        outputStream << "\t"
-                     << writeLegendrePolynomialStructureToString( *iteratorCacheHistory ).c_str( )
-                     << ", ";
-    }
-
-    outputStream << std::endl;
-}
-
 //! Function to calculate the normalization factor for Legendre polynomials to geodesy-normalized.
 double calculateLegendreGeodesyNormalizationFactor( const int degree, const int order )
 {
diff --git a/Tudat/Mathematics/BasicMathematics/legendrePolynomials.h b/Tudat/Mathematics/BasicMathematics/legendrePolynomials.h
index 075897b..bc2d9c0 100644
--- a/Tudat/Mathematics/BasicMathematics/legendrePolynomials.h
+++ b/Tudat/Mathematics/BasicMathematics/legendrePolynomials.h
@@ -55,16 +55,189 @@
 #include <cstddef>
 #include <iostream>
 
+#include <boost/bind.hpp>
+
 #include <boost/circular_buffer.hpp>
 #include <boost/function.hpp>
 #include <boost/shared_ptr.hpp>
 #include <boost/unordered_map.hpp>
+#include <boost/enable_shared_from_this.hpp>
+
+#include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
 
 namespace tudat
 {
 namespace basic_mathematics
 {
 
+//! Class for creating and accessing a back-end cache of Legendre polynomials.
+class LegendreCache
+{
+
+public:
+
+    //! Define Legendre polynomial function pointer.
+    typedef boost::function< double ( int, int, LegendreCache& ) > LegendrePolynomialFunction;
+
+    //! Default constructor, initializes cache object with 0 maximum degree and order.
+    /*!
+     * Default constructor, initializes cache object with 0 mazimum degree and order.
+     * \param useGeodesyNormalization Parameter defining whether the cache is used for a normalized or unnormalized
+     * gravity field.
+     */
+    LegendreCache( const bool useGeodesyNormalization = 1 );
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param maximumDegree Maximum degree to which to update cache
+     * \param maximumOrder Maximum order to which to update cache
+     * \param useGeodesyNormalization Parameter defining whether the cache is used for a normalized or unnormalized
+     * gravity field.
+     */
+    LegendreCache( const int maximumDegree, const int maximumOrder, const bool useGeodesyNormalization = 1 );
+
+    //! Update maximum degree and order of cache
+    /*!
+     * Update maximum degree and order of cache
+     * \param maximumDegree Maximum degree to which to update cache
+     * \param maximumOrder Maximum order to which to update cache
+     */
+    void resetMaximumDegreeAndOrder( const int maximumDegree, const int maximumOrder );
+
+    //! Update cache with new polynomial parameter (sine of latitude)
+    /*!
+     * Update cache with new polynomial parameter (sine of latitude).
+     * \param polynomialParameter Parameter used as input argument for Legendre polynomials, in astrodynamics
+     * applications, this is typically the sine of the body-fixed latitude.
+     */
+   void update( const double polynomialParameter );
+
+    //! Function to return the current polynomial parameter (typically sine of latitude)
+    /*!
+     * Function to return the current polynomial parameter (typically sine of latitude)
+     * \return Current polynomial parameter
+     */
+    double getCurrentPolynomialParameter( )
+    {
+        return currentPolynomialParameter_;
+    }
+
+    //! Function to return the complement to the current polynomial parameter (typically cosine of latitude)
+    /*!
+     *  Function to return the complement to the current polynomial parameter (typically cosine of latitude)
+     * \return Complement to the current polynomial parameter
+     */
+    double getCurrentPolynomialParameterComplement( )
+    {
+        return currentPolynomialParameterComplement_;
+    }
+
+    //! Get Legendre polynomial value from the cache.
+    /*!
+    * Get Legendre polynomial value from the cache, as computed by last call to update function.
+    * \param degree Degree of requested Legendre polynomial.
+    * \param order Order of requested Legendre polynomial.
+    * \return Legendre polynomial value.
+    */
+    double getLegendrePolynomial( const int degree, const int order );
+
+    //! Function to get the maximum degree of cache.
+    /*!
+     * Function to get the maximum degree of cache
+     * \return Maximum degree of cache.
+     */
+    int getMaximumDegree( )
+    {
+        return maximumDegree_;
+    }
+
+    //! Function to get the maximum order of cache.
+    /*!
+     * Function to get the maximum order of cache.
+     * \return Maximum order of cache.
+     */
+    int getMaximumOrder( )
+    {
+        return maximumOrder_;
+    }
+
+    //! Function to get whether the Legendre polynomials are geodesy-normalized or unnormalized
+    /*!
+     * Function to get whether the Legendre polynomials are geodesy-normalized or unnormalized
+     * \return Boolean denoting to get whether the Legendre polynomials are geodesy-normalized or unnormalized
+     */
+    bool getUseGeodesyNormalization( )
+    {
+        return useGeodesyNormalization_;
+    }
+
+
+private:
+
+    //! Maximum degree of cache.
+    int maximumDegree_;
+
+    //! Maximum order of cache.
+    int maximumOrder_;
+
+    //! Current polynomial parameter (sine of latitude).
+    double currentPolynomialParameter_;
+
+    //! Current 'complement' to polynomial parameter (cosine of latitude).
+    double currentPolynomialParameterComplement_;
+
+    //! List of current values of Legendre polynomials at degree and order (n,m)
+    /*!
+     * List of current values of Legendre polynomials at degree and order (n,m). The corresponding polynomial is at entry
+     * n * ( maximumOrder_ + 1 ) + m.
+     */
+    std::vector< double > legendreValues_;
+
+    //! Function from which to compute the Legendre polynomials.
+    LegendrePolynomialFunction legendrePolynomialFunction_;
+
+    //! Boolean denoting whether the Legendre polynomials are geodesy-normalized or unnormalized
+    bool useGeodesyNormalization_;
+
+    std::vector< double > referenceRadiusRatioPowers_;
+
+
+};
+
+
+
+//! Compute unnormalized associated Legendre polynomial.
+/*!
+ * This function returns an unnormalized associated Legendre polynomial \f$ P _{ n, m }( u ) \f$
+ * with degree \f$ n \f$, order \f$ m \f$ and polynomial parameter \f$ u \f$.
+ * \f$ P _{ n, m }( u ) \f$ obeys the definition given by Vallado [2001]:
+ * \f[
+ *     P _{ n, m } ( u ) = ( 1 - u ^ 2 ) ^ { m / 2 } \frac{ d ^ m }{ du ^ m } \left[ P_n ( u )
+ *     \right] \textrm{ for }n \geq 0, 0 \leq m \leq n
+ * \f]
+ * in which \f$ P_{ n, m }( u ) \f$ is the ordinary Legendre polynomial with degree \f$ n \f$,
+ * order \f$ m \f$ and polynomial parameter \f$ u \f$.
+ *
+ * For \f$ n \geq 0, m \geq n \f$ the \f$ P _{ n, m }( u ) \f$ has been defined here as
+ * follows:
+ * \f[
+ *     P _{ n, m } ( u ) = 0 \textrm{ for }n \geq 0, m \geq n
+ * \f]
+ *
+ * This function has been optimized for repeated calls with varying 'degree' and 'order' arguments
+ * (but with identical 'polynomialParameter' argument). To this end the function maintains a
+ * back-end cache with intermediate results which is automatically carried over between calls.
+ * \param degree Degree of requested Legendre polynomial.
+ * \param order Order of requested Legendre polynomial.
+ * \param legendreCache Legendre cache from which to retrieve Legendre polynomial.
+ * \return Unnormalized Legendre polynomial.
+*/
+double computeLegendrePolynomial( const int degree,
+                                  const int order,
+                                  LegendreCache& legendreCache );
+
+
 //! Compute unnormalized associated Legendre polynomial.
 /*!
  * This function returns an unnormalized associated Legendre polynomial \f$ P _{ n, m }( u ) \f$
@@ -88,12 +261,13 @@ namespace basic_mathematics
  * back-end cache with intermediate results which is automatically carried over between calls.
  * \param degree Degree of requested Legendre polynomial.
  * \param order Order of requested Legendre polynomial.
- * \param polynomialParameter Free variable  of requested Legendre polynomial.
+ * \param legendreParameter Free variable  of requested Legendre polynomial.
  * \return Unnormalized Legendre polynomial.
 */
 double computeLegendrePolynomial( const int degree,
                                   const int order,
-                                  const double polynomialParameter );
+                                  const double legendreParameter );
+
 
 //! Compute geodesy-normalized associated Legendre polynomial.
 /*!
@@ -131,12 +305,55 @@ double computeLegendrePolynomial( const int degree,
  * back-end cache with intermediate results which is automatically carried over between calls.
  * \param degree Degree of requested Legendre polynomial.
  * \param order Order of requested Legendre polynomial.
- * \param polynomialParameter Free variable of requested Legendre polynomial.
+ * \param geodesyLegendreCache Legendre cache from which to retrieve Legendre polynomial.
+ * \return Geodesy-normalized Legendre polynomial.
+*/
+double computeGeodesyLegendrePolynomial( const int degree,
+                                         const int order,
+                                         LegendreCache& geodesyLegendreCache );
+
+//! Compute geodesy-normalized associated Legendre polynomial.
+/*!
+ * This function returns a normalized associated Legendre polynomial
+ * \f$ \bar{ P }_{ n, m }( u ) \f$ with degree \f$ n \f$, order \f$ m \f$ and polynomial
+ * parameter \f$ u \f$. The normalization obeys the definition:
+ * \f[
+ *     \bar{ P }_{ n, m } ( u ) = \Pi_{ n, m } P_{ n, m } ( u )
+ * \f]
+ * in which \f$ \Pi_{ n, m } \f$ is the normalization factor which is commonly used in geodesy and
+ * is given by Heiskanen & Moritz [1967] as:
+ * \f[
+ *     \Pi_{ n, m } = \sqrt{ \frac{ ( 2 - \delta_{ 0, m } ) ( 2 n + 1 ) ( n - m )! }
+ *     { ( n + m )! } }
+ * \f]
+ * in which \f$ n \f$ is the degree, \f$ m \f$ is the order and \f$ \delta_{ 0, m } \f$ is the
+ * Kronecker delta.
+
+ * \f$ P _{ n, m }( u ) \f$ obeys the definition given by Vallado [2001]:
+ * \f[
+ *     P _{ n, m } ( u ) = ( 1 - u ^ 2 ) ^ { m / 2 } \frac{ d ^ m }{ du ^ m } \left[ P_n ( u )
+ *     \right]
+ * \f]
+ * in which \f$ P_{ n, m }( u ) \f$ is the ordinary Legendre polynomial with degree \f$ n \f$,
+ *  order \f$ m \f$ and polynomial parameter \f$ u \f$.
+ *
+ * For \f$ n \geq 0, m \geq n \f$ the \f$ P _{ n, m }( u ) \f$ has been defined here as
+ * follows:
+ * \f[
+ *     P _{ n, m } ( u ) = 0 \textrm{ for }n \geq 0, m \geq n
+ * \f]
+ *
+ * This function has been optimized for repeated calls with varying 'degree' and 'order' arguments
+ * (but with identical 'polynomialParameter' argument). To this end the function maintains a
+ * back-end cache with intermediate results which is automatically carried over between calls.
+ * \param degree Degree of requested Legendre polynomial.
+ * \param order Order of requested Legendre polynomial.
+ * \param legendreParameter Free variable of requested Legendre polynomial.
  * \return Geodesy-normalized Legendre polynomial.
 */
 double computeGeodesyLegendrePolynomial( const int degree,
                                          const int order,
-                                         const double polynomialParameter );
+                                         const double legendreParameter );
 
 //! Compute derivative of unnormalized Legendre polynomial.
 /*!
@@ -320,111 +537,11 @@ double computeGeodesyLegendrePolynomialVertical( const int degree,
                                                  const double oneDegreePriorPolynomial,
                                                  const double twoDegreesPriorPolynomial );
 
-//! Declare structure for arguments of Legendre polynomial (for use in back-end cache).
-struct Point
-{
-public:
-
-    //! Self-referential structure.
-    Point( const int aDegree, const int anOrder, const double aPolynomialParameter )
-        : degree( aDegree ),
-          order( anOrder ),
-          polynomialParameter( aPolynomialParameter )
-    { }
-
-    //! Degree of Legendre polynomial.
-    int degree;
 
-    //! Order of Legendre polynomial.
-    int order;
-
-    //! Polynomial parameter of Legendre polynomial.
-    double polynomialParameter; 
-
-protected:
-
-private:
-};
-
-//! Typedef for shared-pointer to Point object.
-typedef boost::shared_ptr< Point > PointPointer;
-
-//! Define overloaded 'equals' operator for use with 'Point' structure.
-bool operator==( const Point& polynomialArguments1, const Point& polynomialArguments2 );
-
-//! Set hash value.
-std::size_t hash_value( Point const& polynomialArguments );
-
-//! Class for creating and accessing a back-end cache of Legendre polynomials.
-class LegendreCache
-{
-private:
-
-    //! Define Legendre polynomial function pointer.
-    typedef boost::function< double ( int, int, double ) > LegendrePolynomialFunction;
-
-    //! Define map variables type.
-    typedef boost::unordered_map< Point, double > CacheTable;
-
-    //! Define buffer variables type.
-    typedef boost::circular_buffer< Point > CacheHistory;
-
-public:
-
-    //! Initialize LegendreCache instance.
-    LegendreCache( );
-
-    //! Get Legendre polynomial value from either cache or from computation.
-    /*!
-    * \param degree Degree of requested Legendre polynomial.
-    * \param order Order of requested Legendre polynomial.
-    * \param polynomialParameter Free variable  of requested Legendre polynomial.
-    * \param legendrePolynomialFunction Function which takes degree, order and
-    *          polynomialParameter as arguments. The function must return the corresponding
-    *          Legendre polynomial value.
-    * \return Legendre polynomial value.
-    */
-    double getOrElseUpdate( const int degree, const int order, const double polynomialParameter,
-                            const LegendrePolynomialFunction legendrePolynomialFunction );
-
-private:
-
-    //! Hashmap which links a specific degree, order and polynomial parameter to its
-    //! corresponding Legendre polynomial value.
-    CacheTable backendCache;
-
-    //! History buffer.
-    CacheHistory history;
-};
-
-//! Typedef shared-pointer to LegendreCache object.
-typedef boost::shared_ptr< LegendreCache > LegendreCachePointer;
-
-//! Global instances of LegendreCache class for unnormalized polynomials.
-static LegendreCache legendreCache;
-
-//! Global instances of LegendreCache class for geodesy-normalized polynomials.
-static LegendreCache geodesyLegendreCache;
-
-//! Write contents of Legendre polynomial structure to string.
-/*!
- * Writes contents of Legendre polynomial structure, containing degree, order, and value of
- * polynomial parameter, to string.
- * \param legendrePolynomialStructure Structure containing legendre polynomial data.
- * \return String containing degree, order, and value of polynomial paramter stored in structure.
- */
-std::string writeLegendrePolynomialStructureToString( const Point legendrePolynomialStructure );
-
-//! Dump Legendre polynomial cache data to stream (table and history).
-/*!
- * Dumps cached table and history data for Legendre polynomials to given output stream.
- * \param outputStream Output stream.
- * \param cacheTable Cache table containing current values of Legendre polynomials.
- * \param cacheHistory Cached history of Legendre polynomials.
- */
-void dumpLegendrePolynomialCacheData( std::ostream& outputStream,
-                                      boost::unordered_map< Point, double > cacheTable,
-                                      boost::circular_buffer< Point > cacheHistory );
+//! Predefine boost function for geodesy-normalized Legendre polynomial.
+static const LegendreCache::LegendrePolynomialFunction geodesyNormalizedLegendrePolynomialFunction =
+        boost::bind( static_cast< double(&)( const int,  const int,  LegendreCache&  )>(
+                         &computeGeodesyLegendrePolynomial ), _1, _2, _3 );
 
 //! Function to calculate the normalization factor for Legendre polynomials to geodesy-normalized.
 /*!
@@ -438,6 +555,10 @@ void dumpLegendrePolynomialCacheData( std::ostream& outputStream,
  */
 double calculateLegendreGeodesyNormalizationFactor( const int degree, const int order );
 
+//! Predefine boost function for unnormalized Legendre polynomial.
+const LegendreCache::LegendrePolynomialFunction regularLegendrePolynomialFunction =
+        boost::bind( static_cast< double(&)( const int,  const int,  LegendreCache& )>(
+                         &computeLegendrePolynomial ), _1, _2, _3 );
 
 } // namespace basic_mathematics
 } // namespace tudat
diff --git a/Tudat/Mathematics/BasicMathematics/linearAlgebra.cpp b/Tudat/Mathematics/BasicMathematics/linearAlgebra.cpp
index e15eaed..82115ae 100644
--- a/Tudat/Mathematics/BasicMathematics/linearAlgebra.cpp
+++ b/Tudat/Mathematics/BasicMathematics/linearAlgebra.cpp
@@ -103,6 +103,34 @@ double computeAngleBetweenVectors( const Eigen::VectorXd& vector0, const Eigen::
     return std::acos( dotProductOfNormalizedVectors );
 }
 
+//! Computes the difference between two 3d vectors.
+Eigen::Vector3d computeVectorDifference( const Eigen::Vector3d& vector0,
+                                         const Eigen::Vector3d& vector1 )
+{
+    return ( vector0 - vector1 );
+}
+
+//! Computes norm of the the difference between two 3d vectors.
+double computeNormOfVectorDifference( const Eigen::Vector3d& vector0,
+                                      const Eigen::Vector3d& vector1 )
+{
+    return ( vector0 - vector1 ).norm( );
+}
+
+//! Computes the norm of a 3d vector
+double getVectorNorm( const Eigen::Vector3d& vector )
+{
+    return vector.norm( );
+}
+
+//! Computes the norm of a 3d vector from a vector-returning function.
+double getVectorNormFromFunction( const boost::function< Eigen::Vector3d( ) > vectorFunction )
+{
+    return getVectorNorm( vectorFunction( ) );
+}
+
+
+
 } // namespace linear_algebra
 
 } // namespace tudat
diff --git a/Tudat/Mathematics/BasicMathematics/linearAlgebra.h b/Tudat/Mathematics/BasicMathematics/linearAlgebra.h
index c7b5e76..eb09ed6 100644
--- a/Tudat/Mathematics/BasicMathematics/linearAlgebra.h
+++ b/Tudat/Mathematics/BasicMathematics/linearAlgebra.h
@@ -35,6 +35,8 @@
 #ifndef TUDAT_LINEAR_ALGEBRA_H
 #define TUDAT_LINEAR_ALGEBRA_H
 
+#include <boost/function.hpp>
+
 #include <Eigen/Core>
 
 namespace tudat
@@ -72,6 +74,43 @@ double computeCosineOfAngleBetweenVectors( const Eigen::VectorXd& vector0,
 double computeAngleBetweenVectors( const Eigen::VectorXd& vector0,
                                    const Eigen::VectorXd& vector1 );
 
+//! Computes the difference between two 3d vectors.
+/*!
+ * Computes the difference between two 3d vectors (first input minus second input, i.e vector from second input to
+ * first input).
+ * \param vector0 First vector.
+ * \param vector1 Second vector.
+ * \return Difference between vectors
+ */
+Eigen::Vector3d computeVectorDifference( const Eigen::Vector3d& vector0,
+                                         const Eigen::Vector3d& vector1 );
+
+//! Computes norm of the the difference between two 3d vectors.
+/*!
+ * Computes the norm of the difference between two 3d vectors (i.e. distance between vectors)
+ * \param vector0 First vector.
+ * \param vector1 Second vector.
+ * \return Norm of difference between vectors
+ */
+double computeNormOfVectorDifference( const Eigen::Vector3d& vector0,
+                                      const Eigen::Vector3d& vector1 );
+
+//! Computes the norm of a 3d vector
+/*!
+ * Computes the norm of a 3d vector
+ * \param vector Vector for which the norm is to be computed
+ * \return Vector norm
+ */
+double getVectorNorm( const Eigen::Vector3d& vector );
+
+//! Computes the norm of a 3d vector from a vector-returning function.
+/*!
+ * Computes the norm of a 3d vector from a vector-returning function.
+ * \param vectorFunction Function returning the vector for which the norm is to be computed
+ * \return Vector norm
+ */
+double getVectorNormFromFunction( const boost::function< Eigen::Vector3d( ) > vectorFunction );
+
 //! Flip matrix rows.
 /*!
  * Flips all rows of an Eigen-matrix, i.e., order of rows is reversed.
@@ -94,6 +133,8 @@ static inline void flipMatrixRows( Eigen::MatrixXd& matrixToFlip )
     }
 }
 
+double computeNormOfVectorDifference( const Eigen::Vector3d& vector0,
+                                      const Eigen::Vector3d& vector1 );
 } // namespace linear_algebra
 
 } // namespace tudat
diff --git a/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.cpp b/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.cpp
index f9e02e6..20031c8 100644
--- a/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.cpp
+++ b/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.cpp
@@ -37,13 +37,60 @@
 #include <Eigen/Core>
 
 #include "Tudat/Mathematics/BasicMathematics/sphericalHarmonics.h"
+#include "Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.h"
 
 namespace tudat
 {
 namespace basic_mathematics
 {
 
-// Compute the gradient of a single term of a spherical harmonics potential field.
+//! Update maximum degree and order of cache
+void SphericalHarmonicsCache::resetMaximumDegreeAndOrder( const int maximumDegree, const int maximumOrder )
+{
+    maximumDegree_ = maximumDegree;
+    maximumOrder_ = maximumOrder;
+
+    legendreCache_->resetMaximumDegreeAndOrder( maximumDegree_, maximumOrder_ );
+
+    sinesOfLongitude_.resize( maximumOrder_ + 1 );
+    cosinesOfLongitude_.resize( maximumOrder_ + 1 );
+    referenceRadiusRatioPowers_.resize( maximumDegree_ + 2 );
+}
+
+
+//! Compute the gradient of a single term of a spherical harmonics potential field.
+Eigen::Vector3d computePotentialGradient(
+        const double distance,
+        const double radiusPowerTerm,
+        const double cosineOfOrderLongitude,
+        const double sineOfOrderLongitude,
+        const double cosineOfLatitude,
+        const double preMultiplier,
+        const int degree,
+        const int order,
+        const double cosineHarmonicCoefficient,
+        const double sineHarmonicCoefficient,
+        const double legendrePolynomial,
+        const double legendrePolynomialDerivative )
+{
+    // Return result.
+    return ( Eigen::Vector3d( ) <<
+             - preMultiplier / distance
+             * radiusPowerTerm
+             * ( static_cast< double >( degree ) + 1.0 ) * legendrePolynomial
+             * ( cosineHarmonicCoefficient * cosineOfOrderLongitude
+                 + sineHarmonicCoefficient * sineOfOrderLongitude ),
+             preMultiplier * radiusPowerTerm
+             * legendrePolynomialDerivative * cosineOfLatitude * (
+                 cosineHarmonicCoefficient * cosineOfOrderLongitude
+                 + sineHarmonicCoefficient * sineOfOrderLongitude ),
+             preMultiplier * radiusPowerTerm
+             * static_cast< double >( order ) * legendrePolynomial
+             * ( sineHarmonicCoefficient * cosineOfOrderLongitude
+                 - cosineHarmonicCoefficient * sineOfOrderLongitude ) ).finished( );
+}
+
+//! Compute the gradient of a single term of a spherical harmonics potential field.
 Eigen::Vector3d computePotentialGradient(
         const Eigen::Vector3d& sphericalPosition,
         const double referenceRadius,
@@ -55,41 +102,35 @@ Eigen::Vector3d computePotentialGradient(
         const double legendrePolynomial,
         const double legendrePolynomialDerivative )
 {
-    // Initialize return variable.
-    Eigen::Vector3d potentialGradient;
-
-    // Compute radius power term.
-    const double radiusPowerTerm = std::pow( referenceRadius / sphericalPosition( radiusIndex ),
-                                             static_cast< double >( degree ) + 1.0 );
-
-    // Calculate derivative with respect to radius.
-    potentialGradient( radiusIndex ) = - preMultiplier / sphericalPosition( radiusIndex )
-            * radiusPowerTerm
-            * ( static_cast< double >( degree ) + 1.0 ) * legendrePolynomial
-            * ( cosineHarmonicCoefficient
-                * std::cos( static_cast< double >( order ) * sphericalPosition( longitudeIndex ) )
-                + sineHarmonicCoefficient
-                * std::sin( static_cast< double >( order )
-                            * sphericalPosition( longitudeIndex ) ) );
-
-    // Calculate derivative with respect to latitude.
-    potentialGradient( latitudeIndex ) = preMultiplier * radiusPowerTerm
-            * legendrePolynomialDerivative
-            * std::cos( sphericalPosition( latitudeIndex ) ) * ( cosineHarmonicCoefficient
-            * std::cos( static_cast< double >( order ) * sphericalPosition ( longitudeIndex ) )
-            + sineHarmonicCoefficient * std::sin( static_cast< double >( order )
-                                                  * sphericalPosition( longitudeIndex ) ) );
-
-    // Calculate derivative with respect to longitude.
-    potentialGradient( longitudeIndex ) = preMultiplier * radiusPowerTerm
-            * static_cast< double >( order ) * legendrePolynomial
-            * ( sineHarmonicCoefficient * std::cos( static_cast< double >( order )
-                                                    * sphericalPosition( longitudeIndex ) )
-            - cosineHarmonicCoefficient * std::sin( static_cast< double >( order )
-                                                    * sphericalPosition( longitudeIndex ) ) );
+    return computePotentialGradient(
+                sphericalPosition( radiusIndex ),
+                basic_mathematics::raiseToIntegerPower
+                ( referenceRadius / sphericalPosition( radiusIndex ), static_cast< double >( degree ) + 1.0 ),
+                std::cos( static_cast< double >( order ) * sphericalPosition( longitudeIndex ) ),
+                std::sin( static_cast< double >( order ) * sphericalPosition( longitudeIndex ) ),
+                std::cos( sphericalPosition( latitudeIndex ) ), preMultiplier, degree, order,
+                cosineHarmonicCoefficient, sineHarmonicCoefficient, legendrePolynomial,legendrePolynomialDerivative );
+}
 
-    // Return result.
-    return potentialGradient;
+//! Compute the gradient of a single term of a spherical harmonics potential field.
+Eigen::Vector3d computePotentialGradient( const Eigen::Vector3d& sphericalPosition,
+                                          const double preMultiplier,
+                                          const int degree,
+                                          const int order,
+                                          const double cosineHarmonicCoefficient,
+                                          const double sineHarmonicCoefficient,
+                                          const double legendrePolynomial,
+                                          const double legendrePolynomialDerivative,
+                                          const boost::shared_ptr< SphericalHarmonicsCache > sphericalHarmonicsCache )
+{
+    return computePotentialGradient(
+                sphericalPosition( radiusIndex ),
+                sphericalHarmonicsCache->getReferenceRadiusRatioPowers( degree + 1 ),
+                sphericalHarmonicsCache->getCosineOfMultipleLongitude( order ),
+                sphericalHarmonicsCache->getSineOfMultipleLongitude( order ),
+                sphericalHarmonicsCache->getLegendreCache( )->getCurrentPolynomialParameterComplement( ),
+                preMultiplier, degree, order,
+                cosineHarmonicCoefficient, sineHarmonicCoefficient, legendrePolynomial,legendrePolynomialDerivative );
 }
 
 } // namespace basic_mathematics
diff --git a/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.h b/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.h
index 67ea431..c6bba5e 100644
--- a/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.h
+++ b/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.h
@@ -37,17 +37,328 @@
 
 #include <Eigen/Core>
 
+#include <boost/make_shared.hpp>
+
+#include "Tudat/Mathematics/BasicMathematics/legendrePolynomials.h"
+
 namespace tudat
 {
 namespace basic_mathematics
 {
 
+//! Cache object in which variables that are required for the computation of spherical harmonic potential are stored.
+/*!
+ *  Cache object in which variables that are required for the computation of spherical harmonic potential are stored.
+ *  The variables are the Legendre polynomials at the required degree and order, the cosine of teh latitude, the
+ *  sine and cosine of the order times the longitude, and the ratio of the distance and the reference radius to the
+ *  power degree + 1.
+ */
+class SphericalHarmonicsCache
+{
+public:
+
+
+    //! Default constructor, initializes cache object with 0 maximum degree and order.
+    /*!
+     * Default constructor, initializes cache object with 0 mazimum degree and order.
+     * \param useGeodesyNormalization Parameter defining whether the cache is used for a normalized or unnormalized
+     * gravity field.
+     */
+    SphericalHarmonicsCache( const bool useGeodesyNormalization = 1 )
+    {
+        legendreCache_ = boost::make_shared< LegendreCache >( useGeodesyNormalization );
+
+        currentLongitude_ = TUDAT_NAN;
+        referenceRadiusRatio_ = TUDAT_NAN;
+
+        resetMaximumDegreeAndOrder( 0, 0 );
+    }
+
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param maximumDegree Maximum degree to which to update cache
+     * \param maximumOrder Maximum order to which to update cache
+     * \param useGeodesyNormalization Parameter defining whether the cache is used for a normalized or unnormalized
+     * gravity field.
+     */
+    SphericalHarmonicsCache( const int maximumDegree, const int maximumOrder, const bool useGeodesyNormalization = 1 )
+    {
+        legendreCache_ = boost::make_shared< LegendreCache >( maximumDegree, maximumOrder, useGeodesyNormalization );
+
+        currentLongitude_ = TUDAT_NAN;
+        referenceRadiusRatio_ = TUDAT_NAN;
+
+        resetMaximumDegreeAndOrder( maximumDegree, maximumOrder );
+    }
+
+    //! Update maximum degree and order of cache
+    /*!
+     * Update maximum degree and order of cache
+     * \param maximumDegree Maximum degree to which to update cache
+     * \param maximumOrder Maximum order to which to update cache
+     */
+    void resetMaximumDegreeAndOrder( const int maximumDegree, const int maximumOrder );
+
+
+    //! Update cached variables to current state.
+    /*!
+     * Update cached variables to current state.
+     * \param radius Distance from origin
+     * \param polynomialParameter Input parameter to Legendre polynomials (sine of latitude)
+     * \param longitude Current latitude
+     * \param referenceRadius Reference (typically equatorial) radius of gravity field.
+     */
+    void update( const double radius, const double polynomialParameter,
+                 const double longitude, const double referenceRadius )
+    {
+        legendreCache_->update( polynomialParameter );
+        updateSines( longitude );
+        updateRadiusPowers( referenceRadius / radius );
+    }
+
+    //! Function to retrieve the current sine of m times the longitude.
+    /*!
+     * Function to retrieve the current sine of order times the longitude.
+     * \param order Order as input to sine( order * longitude )
+     * \return Sine( order * longitude )
+     */
+    double getSineOfMultipleLongitude( const int order )
+    {
+        return sinesOfLongitude_[ order ];
+    }
+
+    //! Function to retrieve the current cosine of m times the longitude.
+    /*!
+     * Function to retrieve the current cosine of order times the longitude.
+     * \param order Order as input to cosine( order * longitude )
+     * \return Cosine( order * longitude )
+     */
+    double getCosineOfMultipleLongitude( const int order )
+    {
+        return cosinesOfLongitude_[ order ];
+    }
+
+    //! Function to get an integer power of the distance divided by the reference radius.
+    /*!
+     * Function to get an integer power of the distance divided by the reference radius.
+     * \param degreePlusOne Power to which the ratio of distance and reference radius is to be computed (typically
+     * degree + 1).
+     * \return Ratio of distance and reference radius to power of input argument.
+     */
+    double getReferenceRadiusRatioPowers( const int degreePlusOne )
+    {
+        return referenceRadiusRatioPowers_[ degreePlusOne ];
+    }
+
+    //! Function to get the maximum degree of cache.
+    /*!
+     * Function to get the maximum degree of cache
+     * \return Maximum degree of cache.
+     */
+    int getMaximumDegree( )
+    {
+        return maximumDegree_;
+    }
+
+    //! Function to get the maximum order of cache.
+    /*!
+     * Function to get the maximum order of cache.
+     * \return Maximum order of cache.
+     */
+    int getMaximumOrder( )
+    {
+        return maximumOrder_;
+    }
+
+    //! Function to get current longitude
+    /*!
+     * Function to get current longitude
+     * \return Current longitude
+     */
+    double getCurrentLongitude( )
+    {
+        return currentLongitude_;
+    }
+
+    //! Function to get object for caching and computing Legendre polynomials.
+    /*!
+     * Function to get object for caching and computing Legendre polynomials.
+     * \return Object for caching and computing Legendre polynomials.
+     */
+    boost::shared_ptr< LegendreCache > getLegendreCache( )
+    {
+        return legendreCache_;
+    }
+
+private:
+
+    //! Update cached values of sines and cosines of longitude/
+    /*!
+     * Update cached values of sines and cosines of longitude/
+     * \param longitude Current longitude.
+     */
+    void updateSines( const double longitude )
+    {
+        //! Check if update is needed.
+        if( !( currentLongitude_ == longitude ) )
+        {
+            currentLongitude_ = longitude;
+            for( unsigned int i = 0; i < sinesOfLongitude_.size( ); i++ )
+            {
+                sinesOfLongitude_[ i ] = std::sin( static_cast< double >( i ) * longitude );
+                cosinesOfLongitude_[ i ] = std::cos( static_cast< double >( i ) * longitude );
+            }
+        }
+    }
+
+    //! Update cached values of powers of distance over reference radius.
+    /*!
+     * Update cached values of powers of distance over reference radius.
+     * \param referenceRadiusRatio Distance divided by reference radius.
+     */
+    void updateRadiusPowers( const double referenceRadiusRatio )
+    {
+        //! Check if update is needed.
+        if( !( referenceRadiusRatio_ == referenceRadiusRatio ) )
+        {
+            referenceRadiusRatio_ = referenceRadiusRatio;
+            double currentRatioPower = 1.0;
+            for( int i = 0; i <= maximumDegree_ + 1; i++ )
+            {
+                referenceRadiusRatioPowers_[ i ] = currentRatioPower;
+                currentRatioPower *= referenceRadiusRatio_;
+            }
+        }
+    }
+
+    //! Maximum degree of cache.
+    int maximumDegree_;
+
+    //! Maximum order of cache.
+    int maximumOrder_;
+
+    //! Current longitude.
+    double currentLongitude_;
+
+    //! Current ratio of distance to reference radius
+    double referenceRadiusRatio_;
+
+    //! List of sines of order times longitude.
+    /*!
+     *  List of sines of order times longitude. Entry i denotes sin(i times longitude).
+     */
+    std::vector< double > sinesOfLongitude_;
+
+    //! List of cosines of order times longitude.
+    /*!
+     *  List of cosines of order times longitude. Entry i denotes cos(i times longitude).
+     */
+    std::vector< double > cosinesOfLongitude_;
+
+    //! List of powers of distance divided by reference radius.
+    /*!
+     * List of powers of distance divided by reference radius. Entry i denoted (distance/reference radius) to the power i.
+     */
+    std::vector< double > referenceRadiusRatioPowers_;
+
+    //! Object for caching and computing Legendre polynomials.
+    boost::shared_ptr< LegendreCache > legendreCache_;
+
+
+
+};
+
 //! Spherical coordinate indices.
 enum SphericalCoordinatesIndices{ radiusIndex, latitudeIndex, longitudeIndex };
 
 //! Compute the gradient of a single term of a spherical harmonics potential field.
 /*!
  * This function returns a vector with the derivatives of a generic potential field (defined by
+ * spherical harmonics) from pre-computed quatities.
+ * \param distance Distance to center of body with gravity field at which the potential gradient is to be calculated
+ * \param radiusPowerTerm Distance divided by the reference radius of the gravity field, to the power (degree + 1)
+ * \param cosineOfOrderLongitude Cosine of order times the longitude at which the potential is to be calculated
+ * \param sineOfOrderLongitude Sine of order times the longitude at which the potential is to be calculated
+ * \param cosineOfLatitude Cosine of the latitude at which the potential is to be calculated
+ * \param preMultiplier Generic multiplication factor.
+ * \param degree Degree of the harmonic for which the gradient is to be computed.
+ * \param order Order of the harmonic for which the gradient is to be computed.
+ * \param cosineHarmonicCoefficient Coefficient which characterizes relative strengh of a harmonic
+ *          term.
+ * \param sineHarmonicCoefficient Coefficient which characterizes relative strengh of a harmonic
+ *          term.
+ * \param legendrePolynomial Value of associated Legendre polynomial with the same degree and order
+ *          as the to be computed harmonic, and with the sine of the latitude coordinate as
+ *          polynomial parameter. Make sure that the Legendre polynomial has the same
+ *          normalization as the harmonic coefficients.
+ * \param legendrePolynomialDerivative Value of the derivative of parameter 'legendrePolynomial'
+ *          with respect to the sine of the latitude angle.
+ * \return Vector with derivatives of potential field.
+ *          The order is important!
+ *          gradient( 0 ) = derivative with respect to radial distance,
+ *          gradient( 1 ) = derivative with respect to latitude angle,
+ *          gradient( 2 ) = derivative with respect to longitude angle.
+ */
+Eigen::Vector3d computePotentialGradient(
+        const double distance,
+        const double radiusPowerTerm,
+        const double cosineOfOrderLongitude,
+        const double sineOfOrderLongitude,
+        const double cosineOfLatitude,
+        const double preMultiplier,
+        const int degree,
+        const int order,
+        const double cosineHarmonicCoefficient,
+        const double sineHarmonicCoefficient,
+        const double legendrePolynomial,
+        const double legendrePolynomialDerivative );
+
+
+
+//! Compute the gradient of a single term of a spherical harmonics potential field.
+/*!
+ * This function returns a vector with the derivatives of a generic potential field (defined by
+ * spherical harmonics). *
+ * \param sphericalPosition Vector with spherical coordinates.
+ *          The order is important!
+ *          sphericalPosition( 0 ) = radial coordinate,
+ *          sphericalPosition( 1 ) = latitude coordinate,
+ *          sphericalPosition( 2 ) = longitude coordinate.
+ * \param referenceRadius Radius of harmonics reference sphere.
+ * \param preMultiplier Generic multiplication factor.
+ * \param degree Degree of the harmonic for which the gradient is to be computed.
+ * \param order Order of the harmonic for which the gradient is to be computed.
+ * \param cosineHarmonicCoefficient Coefficient which characterizes relative strengh of a harmonic
+ *          term.
+ * \param sineHarmonicCoefficient Coefficient which characterizes relative strengh of a harmonic
+ *          term.
+ * \param legendrePolynomial Value of associated Legendre polynomial with the same degree and order
+ *          as the to be computed harmonic, and with the sine of the latitude coordinate as
+ *          polynomial parameter. Make sure that the Legendre polynomial has the same
+ *          normalization as the harmonic coefficients.
+ * \param legendrePolynomialDerivative Value of the derivative of parameter 'legendrePolynomial'
+ *          with respect to the sine of the latitude angle.
+ * \return Vector with derivatives of potential field.
+ *          The order is important!
+ *          gradient( 0 ) = derivative with respect to radial distance,
+ *          gradient( 1 ) = derivative with respect to latitude angle,
+ *          gradient( 2 ) = derivative with respect to longitude angle.
+ */
+Eigen::Vector3d computePotentialGradient( const Eigen::Vector3d& sphericalPosition,
+                                          const double referenceRadius,
+                                          const double preMultiplier,
+                                          const int degree,
+                                          const int order,
+                                          const double cosineHarmonicCoefficient,
+                                          const double sineHarmonicCoefficient,
+                                          const double legendrePolynomial,
+                                          const double legendrePolynomialDerivative );
+
+//! Compute the gradient of a single term of a spherical harmonics potential field.
+/*!
+ * This function returns a vector with the derivatives of a generic potential field (defined by
  * spherical harmonics). It is assumed that the potential field of a single harmonic is
  * characterized by:
  * \f[
@@ -80,7 +391,6 @@ enum SphericalCoordinatesIndices{ radiusIndex, latitudeIndex, longitudeIndex };
  *          sphericalPosition( 0 ) = radial coordinate,
  *          sphericalPosition( 1 ) = latitude coordinate,
  *          sphericalPosition( 2 ) = longitude coordinate.
- * \param referenceRadius Radius of harmonics reference sphere.
  * \param preMultiplier Generic multiplication factor.
  * \param degree Degree of the harmonic for which the gradient is to be computed.
  * \param order Order of the harmonic for which the gradient is to be computed.
@@ -94,6 +404,8 @@ enum SphericalCoordinatesIndices{ radiusIndex, latitudeIndex, longitudeIndex };
  *          normalization as the harmonic coefficients.
  * \param legendrePolynomialDerivative Value of the derivative of parameter 'legendrePolynomial'
  *          with respect to the sine of the latitude angle.
+ * \param sphericalHarmonicsCache Cache object containing current values of trigonometric funtions of latitude anf longitude,
+ *          as well as legendre polynomials at current state.
  * \return Vector with derivatives of potential field.
  *          The order is important!
  *          gradient( 0 ) = derivative with respect to radial distance,
@@ -101,14 +413,14 @@ enum SphericalCoordinatesIndices{ radiusIndex, latitudeIndex, longitudeIndex };
  *          gradient( 2 ) = derivative with respect to longitude angle.
  */
 Eigen::Vector3d computePotentialGradient( const Eigen::Vector3d& sphericalPosition,
-                                          const double referenceRadius,
                                           const double preMultiplier,
                                           const int degree,
                                           const int order,
                                           const double cosineHarmonicCoefficient,
                                           const double sineHarmonicCoefficient,
                                           const double legendrePolynomial,
-                                          const double legendrePolynomialDerivative );
+                                          const double legendrePolynomialDerivative,
+                                          const boost::shared_ptr< SphericalHarmonicsCache > sphericalHarmonicsCache );
 
 } // namespace basic_mathematics
 } // namespace tudat
diff --git a/Tudat/Mathematics/Interpolators/createInterpolator.h b/Tudat/Mathematics/Interpolators/createInterpolator.h
index 92d69fe..79f5c30 100644
--- a/Tudat/Mathematics/Interpolators/createInterpolator.h
+++ b/Tudat/Mathematics/Interpolators/createInterpolator.h
@@ -101,13 +101,16 @@ public:
      * \param useLongDoubleTimeStep Boolean denoting whether time step is to be a long double,
      * time step is a double if false.
      * \param selectedLookupScheme Selected type of lookup scheme for independent variables.
+     * \param boundaryHandling Variable denoting the method by which the boundary interpolation is handled.
      */
     LagrangeInterpolatorSettings(
             const int interpolatorOrder,
             const bool useLongDoubleTimeStep = 0,
-            const AvailableLookupScheme selectedLookupScheme = huntingAlgorithm ):
+            const AvailableLookupScheme selectedLookupScheme = huntingAlgorithm,
+            const LagrangeInterpolatorBoundaryHandling boundaryHandling = lagrange_cubic_spline_boundary_interpolation ):
         InterpolatorSettings( lagrange_interpolator, selectedLookupScheme ),
-        interpolatorOrder_( interpolatorOrder ), useLongDoubleTimeStep_( useLongDoubleTimeStep )
+        interpolatorOrder_( interpolatorOrder ), useLongDoubleTimeStep_( useLongDoubleTimeStep ),
+        boundaryHandling_( boundaryHandling )
     { }
 
     //! Destructor
@@ -133,6 +136,12 @@ public:
         return useLongDoubleTimeStep_;
     }
 
+    LagrangeInterpolatorBoundaryHandling getBoundaryHandling( )
+    {
+        return boundaryHandling_;
+    }
+
+
 protected:
 
     //! Order of the Lagrange interpolator that is to be created.
@@ -141,6 +150,8 @@ protected:
     //!  Boolean denoting whether time step is to be a long double.
     bool useLongDoubleTimeStep_;
 
+    LagrangeInterpolatorBoundaryHandling boundaryHandling_;
+
 };
 
 
@@ -193,14 +204,16 @@ createOneDimensionalInterpolator(
                 createdInterpolator = boost::make_shared< LagrangeInterpolator
                         < IndependentVariableType, DependentVariableType, double > >(
                             dataToInterpolate, lagrangeInterpolatorSettings->getInterpolatorOrder( ),
-                            interpolatorSettings->getSelectedLookupScheme( ) );
+                            interpolatorSettings->getSelectedLookupScheme( ),
+                            lagrangeInterpolatorSettings->getBoundaryHandling( ) );
             }
             else
             {
                 createdInterpolator = boost::make_shared< LagrangeInterpolator
                         < IndependentVariableType, DependentVariableType, long double > >(
                             dataToInterpolate, lagrangeInterpolatorSettings->getInterpolatorOrder( ),
-                            interpolatorSettings->getSelectedLookupScheme( ) );
+                            interpolatorSettings->getSelectedLookupScheme( ),
+                            lagrangeInterpolatorSettings->getBoundaryHandling( ) );
             }
         }
         else
diff --git a/Tudat/Mathematics/NumericalIntegrators/createNumericalIntegrator.h b/Tudat/Mathematics/NumericalIntegrators/createNumericalIntegrator.h
index 17ee3a7..3aa2b12 100644
--- a/Tudat/Mathematics/NumericalIntegrators/createNumericalIntegrator.h
+++ b/Tudat/Mathematics/NumericalIntegrators/createNumericalIntegrator.h
@@ -1,5 +1,7 @@
-#ifndef CREATENUMERICALINTEGRATOR_H
-#define CREATENUMERICALINTEGRATOR_H
+#ifndef TUDAT_CREATENUMERICALINTEGRATOR_H
+#define TUDAT_CREATENUMERICALINTEGRATOR_H
+
+#include <iostream>
 
 #include <boost/make_shared.hpp>
 #include <boost/shared_ptr.hpp>
@@ -29,10 +31,9 @@ enum AvailableIntegrators
 
 //! Class to define settings of numerical integrator
 /*!
- *  Class to define settings of numerical integrator, for instance for use in numerical integration
- *  of equations of motion/ variational equations. This class can be used for simple integrators
- *  such as fixed step RK and Euler. Integrators that require more settings to define have their own
- *  derived class (see below).
+ *  Class to define settings of numerical integrator, for instance for use in numerical integration of equations of motion/
+ *  variational equations. This class can be used for simple integrators such as fixed step RK and Euler. Integrators that
+ *  require more settings to define have their own derived class (see below).
  */
 template< typename TimeType = double >
 class IntegratorSettings
@@ -44,17 +45,16 @@ public:
      *  Constructor for integrator settings.
      *  \param integratorType Type of numerical integrator
      *  \param initialTime Start time (independent variable) of numerical integration.
-     *  \param endTime Stop time (independent variable) of numerical integration.
-     *  \param initialTimeStep Initial time (independent variable) step used in numerical
-     *  integration. Adapted during integration for variable step size integrators.
-     *  \param printFrequency Frequency at which to save the numerical integrated states (in units
-     *  of i.e. per n integration time steps, with n = printFrequency).
+     *  \param initialTimeStep Initial time (independent variable) step used in numerical integration. Adapted during integration
+     *  for variable step size integrators.
+     *  \param saveFrequency Frequency at which to save the numerical integrated states (in units of i.e. per n integration
+     *  time steps, with n = saveFrequency).
      */
     IntegratorSettings( const AvailableIntegrators integratorType, const TimeType initialTime,
-                        const TimeType endTime, const TimeType initialTimeStep,
-                        const int printFrequency = 1 ): integratorType_( integratorType ),
-        initialTime_( initialTime ), endTime_( endTime ), initialTimeStep_( initialTimeStep ),
-        printFrequency_( printFrequency ){ }
+                        const TimeType initialTimeStep,
+                        const int saveFrequency = 1 ): integratorType_( integratorType ),
+        initialTime_( initialTime ), initialTimeStep_( initialTimeStep ),
+        saveFrequency_( saveFrequency ){ }
 
     //! Virtual destructor.
     /*!
@@ -74,31 +74,25 @@ public:
      */
     TimeType initialTime_;
 
-    //! Stop time of numerical integration.
-    /*!
-     *  Stop time (independent variable) of numerical integration.
-     */
-    TimeType endTime_;
-
     //! Initial time step used in numerical integration
     /*!
-     *  Initial time (independent variable) step used in numerical integration. Adapted during
-     *  integration for variable step size integrators.
+     *  Initial time (independent variable) step used in numerical integration. Adapted during integration
+     *  for variable step size integrators.
      */
     TimeType initialTimeStep_;
 
     //! Frequency which with to save numerical integration result.
     /*!
-     *  Frequency at which to save the numerical integrated states (in units of i.e. per n
-     *  integration time steps, with n = printFrequency).
+     *  Frequency at which to save the numerical integrated states (in units of i.e. per n integration
+     *  time steps, with n = saveFrequency).
      */
-    int printFrequency_;
+    int saveFrequency_;
 };
 
 //! Class to define settings of variable step RK numerical integrator
 /*!
- *  Class to define settings of variable step RK numerical integrator, for instance for use in
- *  numerical integration of equations of motion/ variational equations.
+ *  Class to define settings of variable step RK  numerical integrator, for instance for use in numerical integration of equations of motion/
+ *  variational equations.
  */
 template< typename TimeType = double >
 class RungeKuttaVariableStepSizeSettings: public IntegratorSettings< TimeType >
@@ -110,38 +104,34 @@ public:
      *  Constructor for variable step RK integrator settings.
      *  \param integratorType Type of numerical integrator (must be an RK variable step type)
      *  \param initialTime Start time (independent variable) of numerical integration.
-     *  \param endTime Stop time (independent variable) of numerical integration.
      *  \param initialTimeStep Initial time (independent variable) step used in numerical integration.
      *  Adapted during integration
      *  \param coefficientSet Coefficient set (butcher tableau) to use in integration.
-     *  \param minimumStepSize Minimum step size for integration. Integration stops (exception
-     *  thrown) if time step comes below this value.
+     *  \param minimumStepSize Minimum step size for integration. Integration stops (exception thrown) if time step
+     *  comes below this value.
      *  \param maximumStepSize Maximum step size for integration.
      *  \param relativeErrorTolerance Relative error tolerance for step size control
      *  \param absoluteErrorTolerance Absolute error tolerance for step size control
-     *  \param printFrequency Frequency at which to save the numerical integrated states (in units
-     *  of i.e. per n integration time steps, with n = printFrequency).
+     *  \param saveFrequency Frequency at which to save the numerical integrated states (in units of i.e. per n integration
+     *  time steps, with n = saveFrequency).
      *  \param safetyFactorForNextStepSize Safety factor for step size control
-     *  \param maximumFactorIncreaseForNextStepSize Maximum increase factor in time step in
-     *  subsequent iterations.
-     *  \param minimumFactorDecreaseForNextStepSize Maximum decrease factor in time step in
-     *  subsequent iterations.
+     *  \param maximumFactorIncreaseForNextStepSize Maximum increase factor in time step in subsequent iterations.
+     *  \param minimumFactorDecreaseForNextStepSize Maximum decrease factor in time step in subsequent iterations.
 
      */
     RungeKuttaVariableStepSizeSettings(
             const AvailableIntegrators integratorType,
             const TimeType initialTime,
-            const TimeType endTime,
             const TimeType initialTimeStep,
             const numerical_integrators::RungeKuttaCoefficients::CoefficientSets coefficientSet,
             const TimeType minimumStepSize, const TimeType maximumStepSize,
             const TimeType relativeErrorTolerance = 1.0E-12,
             const TimeType absoluteErrorTolerance = 1.0E-12,
-            const int printFrequency = 1,
+            const int saveFrequency = 1,
             const TimeType safetyFactorForNextStepSize = 0.8,
             const TimeType maximumFactorIncreaseForNextStepSize = 4.0,
             const TimeType minimumFactorDecreaseForNextStepSize = 0.1 ):
-        IntegratorSettings< TimeType >( integratorType, initialTime, endTime, initialTimeStep, printFrequency ),
+        IntegratorSettings< TimeType >( integratorType, initialTime, initialTimeStep, saveFrequency ),
         coefficientSet_( coefficientSet ), minimumStepSize_( minimumStepSize ), maximumStepSize_( maximumStepSize ),
         relativeErrorTolerance_( relativeErrorTolerance ), absoluteErrorTolerance_( absoluteErrorTolerance ),
         safetyFactorForNextStepSize_( safetyFactorForNextStepSize ),
@@ -159,8 +149,7 @@ public:
 
     //! Minimum step size for integration.
     /*!
-     *  Minimum step size for integration. Integration stops (exception thrown) if time step comes
-     *  below this value.
+     *  Minimum step size for integration. Integration stops (exception thrown) if time step comes below this value.
      */
     const TimeType minimumStepSize_;
 
@@ -185,17 +174,15 @@ public:
 
 //! Function to create a numerical integrator.
 /*!
- *  Function to create a numerical integrator from given integrator settings, state derivative
- *  function and initial state.
- *  \param stateDerivativeFunction Function returning the state derivative from current time and
- *  state.
+ *  Function to create a numerical integrator from given integrator settings, state derivative function and initial state.
+ *  \param stateDerivativeFunction Function returning the state derivative from current time and state.
  *  \param initialState Initial state for numerical integration
  *  \param integratorSettings Settings for numerical integrator.
  *  \return Numerical integrator object
  */
 template< typename IndependentVariableType, typename DependentVariableType >
-boost::shared_ptr< numerical_integrators::NumericalIntegrator< IndependentVariableType,
-        DependentVariableType, DependentVariableType > > createIntegrator(
+boost::shared_ptr< numerical_integrators::NumericalIntegrator< IndependentVariableType, DependentVariableType,
+DependentVariableType > > createIntegrator(
         boost::function< DependentVariableType(
             const IndependentVariableType, const DependentVariableType& ) > stateDerivativeFunction,
         const DependentVariableType initialState,
@@ -224,9 +211,9 @@ boost::shared_ptr< numerical_integrators::NumericalIntegrator< IndependentVariab
     case rungeKuttaVariableStepSize:
     {
         // Check input consistency
-        boost::shared_ptr< RungeKuttaVariableStepSizeSettings< IndependentVariableType > >
-                variableStepIntegratorSettings = boost::dynamic_pointer_cast
-                < RungeKuttaVariableStepSizeSettings< IndependentVariableType > >( integratorSettings );
+        boost::shared_ptr< RungeKuttaVariableStepSizeSettings< IndependentVariableType > > variableStepIntegratorSettings =
+                boost::dynamic_pointer_cast< RungeKuttaVariableStepSizeSettings< IndependentVariableType > >(
+                    integratorSettings );
         if( variableStepIntegratorSettings == NULL )
         {
            std::runtime_error( "Error, type of integrator settings not compatible with selected integrator" );
@@ -305,4 +292,4 @@ DependentVariableType > > createFixedStepSizeIntegrator(
 
 }
 
-#endif // CREATENUMERICALINTEGRATOR_H
+#endif // TUDAT_CREATENUMERICALINTEGRATOR_H
diff --git a/Tudat/Mathematics/NumericalIntegrators/numericalIntegrator.h b/Tudat/Mathematics/NumericalIntegrators/numericalIntegrator.h
index f469893..cbee8fe 100644
--- a/Tudat/Mathematics/NumericalIntegrators/numericalIntegrator.h
+++ b/Tudat/Mathematics/NumericalIntegrators/numericalIntegrator.h
@@ -153,6 +153,16 @@ public:
      */
     virtual StateType performIntegrationStep( const IndependentVariableType stepSize ) = 0;
 
+    //! Function to return the function that computes and returns the state derivative
+    /*!
+     * Function to return the function that computes and returns the state derivative
+     * \return Function that returns the state derivative
+     */
+    StateDerivativeFunction getStateDerivativeFunction( )
+    {
+        return stateDerivativeFunction_;
+    }
+
 protected:
 
     //! Function that returns the state derivative.
diff --git a/Tudat/SimulationSetup/CMakeLists.txt b/Tudat/SimulationSetup/CMakeLists.txt
index 4731714..6448bc9 100644
--- a/Tudat/SimulationSetup/CMakeLists.txt
+++ b/Tudat/SimulationSetup/CMakeLists.txt
@@ -12,6 +12,9 @@
 # Add source files.
 set(SIMULATION_SETUP_SOURCES
   "${SRCROOT}${SIMULATIONSETUPDIR}/createAccelerationModels.cpp"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createAccelerationPartials.cpp"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createStateDerivativePartials.cpp"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createEstimatableParameters.cpp"
   "${SRCROOT}${SIMULATIONSETUPDIR}/createAtmosphereModel.cpp"
   "${SRCROOT}${SIMULATIONSETUPDIR}/createEphemeris.cpp"
   "${SRCROOT}${SIMULATIONSETUPDIR}/createFlightConditions.cpp"
@@ -28,6 +31,9 @@ set(SIMULATION_SETUP_SOURCES
 # Add header files.
 set(SIMULATION_SETUP_HEADERS 
   "${SRCROOT}${SIMULATIONSETUPDIR}/accelerationSettings.h"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createAccelerationPartials.h"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createStateDerivativePartials.h"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createEstimatableParameters.h"
   "${SRCROOT}${SIMULATIONSETUPDIR}/createAccelerationModels.h"
   "${SRCROOT}${SIMULATIONSETUPDIR}/createAtmosphereModel.h"
   "${SRCROOT}${SIMULATIONSETUPDIR}/createEphemeris.h"
diff --git a/Tudat/SimulationSetup/UnitTests/unitTestAccelerationModelSetup.cpp b/Tudat/SimulationSetup/UnitTests/unitTestAccelerationModelSetup.cpp
index 0856100..6345f15 100644
--- a/Tudat/SimulationSetup/UnitTests/unitTestAccelerationModelSetup.cpp
+++ b/Tudat/SimulationSetup/UnitTests/unitTestAccelerationModelSetup.cpp
@@ -250,7 +250,7 @@ BOOST_AUTO_TEST_CASE( test_shGravityModelSetup )
     // Manually create acceleration model.
     boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > >
             manualAcceleration =
-            boost::make_shared< gravitation::SphericalHarmonicsGravitationalAccelerationModel< > >(
+            boost::make_shared< gravitation::SphericalHarmonicsGravitationalAccelerationModel >(
                 boost::bind( &Body::getPosition, bodyMap[ "Vehicle" ] ),
             gravitationalParameter,
             planetaryRadius, cosineCoefficients, sineCoefficients,
@@ -274,7 +274,7 @@ BOOST_AUTO_TEST_CASE( test_shGravityModelSetup )
 
     // Manually create acceleration.
     manualAcceleration =
-            boost::make_shared< gravitation::SphericalHarmonicsGravitationalAccelerationModel< > >(
+            boost::make_shared< gravitation::SphericalHarmonicsGravitationalAccelerationModel >(
                 boost::bind( &Body::getPosition, bodyMap[ "Vehicle" ] ),
             gravitationalParameter * 1.1,
             planetaryRadius, cosineCoefficients, sineCoefficients,
diff --git a/Tudat/SimulationSetup/UnitTests/unitTestEnvironmentModelSetup.cpp b/Tudat/SimulationSetup/UnitTests/unitTestEnvironmentModelSetup.cpp
index d1fe05c..b899afa 100644
--- a/Tudat/SimulationSetup/UnitTests/unitTestEnvironmentModelSetup.cpp
+++ b/Tudat/SimulationSetup/UnitTests/unitTestEnvironmentModelSetup.cpp
@@ -52,6 +52,7 @@
 
 namespace tudat
 {
+
 namespace unit_tests
 {
 
diff --git a/Tudat/SimulationSetup/accelerationSettings.h b/Tudat/SimulationSetup/accelerationSettings.h
index ba9d159..667062c 100644
--- a/Tudat/SimulationSetup/accelerationSettings.h
+++ b/Tudat/SimulationSetup/accelerationSettings.h
@@ -83,6 +83,59 @@ public:
     int maximumOrder_;
 };
 
+//! Class for providing acceleration settings for mutual spherical harmonics acceleration model.
+/*!
+ *  Class for providing accelerationsettings for mutual spherical harmonics acceleration model,
+ *  specifically the maximum degree and order up to which the fields of the bodies are be expanded.
+ *  Please note that the minimum degrees and orders are currently always set to zero.
+ */
+class MutualSphericalHarmonicAccelerationSettings: public AccelerationSettings
+{
+public:
+
+    //! Constructor to set maximum degrees and orders that are to be taken into account.
+    /*!
+     * Constructor to set maximum degrees and orders that are to be taken into account.
+     * \param maximumDegreeOfBodyExertingAcceleration Maximum degree of body exerting acceleration.
+     * \param maximumOrderOfBodyExertingAcceleration Maximum order of body exerting acceleration.
+     * \param maximumDegreeOfBodyUndergoingAcceleration Maximum degree of body undergoing acceleration.
+     * \param maximumOrderOfBodyUndergoingAcceleration Maximum order of body undergoing acceleration.
+     * \param maximumDegreeOfCentralBody Maximum degree of central body (only releveant for 3rd body acceleration).
+     * \param maximumOrderOfCentralBody Maximum order of central body (only releveant for 3rd body acceleration).
+     */
+    MutualSphericalHarmonicAccelerationSettings( const int maximumDegreeOfBodyExertingAcceleration,
+                                                 const int maximumOrderOfBodyExertingAcceleration,
+                                                 const int maximumDegreeOfBodyUndergoingAcceleration,
+                                                 const int maximumOrderOfBodyUndergoingAcceleration,
+                                                 const int maximumDegreeOfCentralBody = 0,
+                                                 const int maximumOrderOfCentralBody = 0 ):
+        AccelerationSettings( basic_astrodynamics::mutual_spherical_harmonic_gravity ),
+        maximumDegreeOfBodyExertingAcceleration_( maximumDegreeOfBodyExertingAcceleration ),
+        maximumOrderOfBodyExertingAcceleration_( maximumOrderOfBodyExertingAcceleration ),
+        maximumDegreeOfBodyUndergoingAcceleration_( maximumDegreeOfBodyUndergoingAcceleration ),
+        maximumOrderOfBodyUndergoingAcceleration_( maximumOrderOfBodyUndergoingAcceleration ),
+        maximumDegreeOfCentralBody_( maximumDegreeOfCentralBody ), maximumOrderOfCentralBody_( maximumOrderOfCentralBody ){ }
+
+    //! Maximum degree of body exerting acceleration.
+    int maximumDegreeOfBodyExertingAcceleration_;
+
+    //! Maximum order of body exerting acceleration.
+    int maximumOrderOfBodyExertingAcceleration_;
+
+    //! Maximum degree of body undergoing acceleration.
+    int maximumDegreeOfBodyUndergoingAcceleration_;
+
+    //! Maximum order of body undergoing acceleration.
+    int maximumOrderOfBodyUndergoingAcceleration_;
+
+    //! Maximum degree of central body (only releveant for 3rd body acceleration).
+    int maximumDegreeOfCentralBody_;
+
+    //! Maximum order of central body (only releveant for 3rd body acceleration).
+    int maximumOrderOfCentralBody_;
+};
+
+
 //! Typedef defining a list of acceleration settings, set up in the same manner as the
 //! AccelerationMap typedef.
 typedef std::map< std::string, std::map< std::string, std::vector< boost::shared_ptr<
diff --git a/Tudat/SimulationSetup/body.h b/Tudat/SimulationSetup/body.h
index 267e3d3..f34bba2 100644
--- a/Tudat/SimulationSetup/body.h
+++ b/Tudat/SimulationSetup/body.h
@@ -425,6 +425,7 @@ public:
         {
             std::cerr<<"Warning when settings gravity field model for body, mass function already found: resetting"<<std::endl;
         }
+
         currentMass_ = gravityFieldModel_->getGravitationalParameter( )
                        / physical_constants::GRAVITATIONAL_CONSTANT;
         bodyMassFunction_ = boost::lambda::constant( currentMass_ );
@@ -659,7 +660,6 @@ public:
         if( boost::dynamic_pointer_cast< gravitation::TimeDependentSphericalHarmonicsGravityField >(
                     gravityFieldModel_ ) != NULL )
         {
-            //std::cerr<<"Error, time. dep. update disabled due to circular dependency"<<std::endl;
             boost::dynamic_pointer_cast< gravitation::TimeDependentSphericalHarmonicsGravityField >(
                         gravityFieldModel_ )->updateCorrectionFunctions( );
         }
@@ -744,7 +744,7 @@ private:
     radiationPressureIterator_;
 };
 
-typedef std::map< std::string, boost::shared_ptr< Body > > NamedBodyMap;
+typedef std::unordered_map< std::string, boost::shared_ptr< Body > > NamedBodyMap;
 
 } // namespace simulation_setup
 
diff --git a/Tudat/SimulationSetup/createAccelerationModels.cpp b/Tudat/SimulationSetup/createAccelerationModels.cpp
index 62dddd6..e539788 100644
--- a/Tudat/SimulationSetup/createAccelerationModels.cpp
+++ b/Tudat/SimulationSetup/createAccelerationModels.cpp
@@ -18,6 +18,7 @@
 #include "Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.h"
 #include "Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.h"
 #include "Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h"
+#include "Tudat/Basics/utilities.h"
 #include "Tudat/SimulationSetup/accelerationSettings.h"
 #include "Tudat/SimulationSetup/createAccelerationModels.h"
 #include "Tudat/SimulationSetup/createFlightConditions.h"
@@ -34,12 +35,160 @@ using namespace basic_astrodynamics;
 using namespace electro_magnetism;
 using namespace ephemerides;
 
-//! Function to add to double-returning functions.
-double evaluateDoubleFunctions(
-        const boost::function< double( ) >& function1,
-        const boost::function< double( ) >& function2 )
+
+//! Function to create a direct (i.e. not third-body) gravitational acceleration (of any type)
+boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > createDirectGravitationalAcceleration(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings,
+        const std::string& nameOfCentralBody,
+        const bool isCentralBody )
+{
+    // Check if sum of gravitational parameters (i.e. inertial force w.r.t. central body) should be used.
+    bool sumGravitationalParameters = 0;
+    if( ( nameOfCentralBody == nameOfBodyExertingAcceleration ) && bodyUndergoingAcceleration != NULL )
+    {
+        sumGravitationalParameters = 1;
+    }
+
+
+    // Check type of acceleration model and create.
+    boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > accelerationModel;
+    switch( accelerationSettings->accelerationType_ )
+    {
+    case central_gravity:
+        accelerationModel = createCentralGravityAcceleratioModel(
+                    bodyUndergoingAcceleration,
+                    bodyExertingAcceleration,
+                    nameOfBodyUndergoingAcceleration,
+                    nameOfBodyExertingAcceleration,
+                    sumGravitationalParameters );
+        break;
+    case spherical_harmonic_gravity:
+        accelerationModel = createSphericalHarmonicsGravityAcceleration(
+                    bodyUndergoingAcceleration,
+                    bodyExertingAcceleration,
+                    nameOfBodyUndergoingAcceleration,
+                    nameOfBodyExertingAcceleration,
+                    accelerationSettings,
+                    sumGravitationalParameters );
+        break;
+    case mutual_spherical_harmonic_gravity:
+        accelerationModel = createMutualSphericalHarmonicsGravityAcceleration(
+                    bodyUndergoingAcceleration,
+                    bodyExertingAcceleration,
+                    nameOfBodyUndergoingAcceleration,
+                    nameOfBodyExertingAcceleration,
+                    accelerationSettings,
+                    sumGravitationalParameters,
+                    isCentralBody );
+        break;
+    default:
+        std::cerr<<"Error when making gravitional acceleration model, cannot parse type "<<
+                   accelerationSettings->accelerationType_<<std::endl;
+    }
+    return accelerationModel;
+}
+
+//! Function to create a third-body gravitational acceleration (of any type)
+boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > createThirdBodyGravitationalAcceleration(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const std::string& nameOfCentralBody,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings )
+{
+    // Check type of acceleration model and create.
+    boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > accelerationModel;
+    switch( accelerationSettings->accelerationType_ )
+    {
+    case central_gravity:
+        accelerationModel = boost::make_shared< ThirdBodyCentralGravityAcceleration >(
+                    boost::dynamic_pointer_cast< CentralGravitationalAccelerationModel3d >(
+                        createDirectGravitationalAcceleration(
+                            bodyUndergoingAcceleration, bodyExertingAcceleration,
+                            nameOfBodyUndergoingAcceleration, nameOfBodyExertingAcceleration,
+                            accelerationSettings, "", 0 ) ),
+                    boost::dynamic_pointer_cast< CentralGravitationalAccelerationModel3d >(
+                        createDirectGravitationalAcceleration(
+                            centralBody, bodyExertingAcceleration,
+                            nameOfCentralBody, nameOfBodyExertingAcceleration,
+                            accelerationSettings, "", 1 ) ), nameOfCentralBody );
+        break;
+    case spherical_harmonic_gravity:
+        accelerationModel = boost::make_shared< ThirdBodySphericalHarmonicsGravitationalAccelerationModel >(
+                    boost::dynamic_pointer_cast< SphericalHarmonicsGravitationalAccelerationModel >(
+                        createDirectGravitationalAcceleration(
+                            bodyUndergoingAcceleration, bodyExertingAcceleration,
+                            nameOfBodyUndergoingAcceleration, nameOfBodyExertingAcceleration,
+                            accelerationSettings, "", 0 ) ),
+                    boost::dynamic_pointer_cast< SphericalHarmonicsGravitationalAccelerationModel >(
+                        createDirectGravitationalAcceleration(
+                            centralBody, bodyExertingAcceleration, nameOfCentralBody, nameOfBodyExertingAcceleration,
+                            accelerationSettings, "", 1 ) ), nameOfCentralBody );
+        break;
+    case mutual_spherical_harmonic_gravity:
+        accelerationModel = boost::make_shared< ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel >(
+                    boost::dynamic_pointer_cast< MutualSphericalHarmonicsGravitationalAccelerationModel >(
+                        createDirectGravitationalAcceleration(
+                            bodyUndergoingAcceleration, bodyExertingAcceleration,
+                            nameOfBodyUndergoingAcceleration, nameOfBodyExertingAcceleration,
+                            accelerationSettings, "", 0 ) ),
+                    boost::dynamic_pointer_cast< MutualSphericalHarmonicsGravitationalAccelerationModel >(
+                        createDirectGravitationalAcceleration(
+                            centralBody, bodyExertingAcceleration, nameOfCentralBody, nameOfBodyExertingAcceleration,
+                            accelerationSettings, "", 1 ) ), nameOfCentralBody );
+        break;
+    default:
+        std::cerr<<"Error when making third body gravitional acceleration model, cannot parse type "<<
+                   accelerationSettings->accelerationType_<<std::endl;
+    }
+    return accelerationModel;
+}
+
+//! Function to create gravitational acceleration (of any type)
+boost::shared_ptr< AccelerationModel< Eigen::Vector3d > > createGravitationalAccelerationModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfCentralBody )
 {
-    return function1( ) + function2( );
+
+    boost::shared_ptr< AccelerationModel< Eigen::Vector3d > > accelerationModelPointer;
+    if( accelerationSettings->accelerationType_ != central_gravity &&
+            accelerationSettings->accelerationType_ != spherical_harmonic_gravity &&
+            accelerationSettings->accelerationType_ != mutual_spherical_harmonic_gravity )
+    {
+        std::cerr<<"Error when making gravitational acceleration, type is inconsistent"<<std::endl;
+    }
+
+    if( nameOfCentralBody == nameOfBodyExertingAcceleration || ephemerides::isFrameInertial( nameOfCentralBody ) )
+    {
+        accelerationModelPointer = createDirectGravitationalAcceleration( bodyUndergoingAcceleration,
+                                                                          bodyExertingAcceleration,
+                                                                          nameOfBodyUndergoingAcceleration,
+                                                                          nameOfBodyExertingAcceleration,
+                                                                          accelerationSettings,
+                                                                          nameOfCentralBody, false );
+    }
+    else
+    {
+        accelerationModelPointer = createThirdBodyGravitationalAcceleration( bodyUndergoingAcceleration,
+                                                                             bodyExertingAcceleration,
+                                                                             centralBody,
+                                                                             nameOfBodyUndergoingAcceleration,
+                                                                             nameOfBodyExertingAcceleration,
+                                                                             nameOfCentralBody, accelerationSettings );
+    }
+
+    return accelerationModelPointer;
 }
 
 
@@ -84,7 +233,7 @@ boost::shared_ptr< CentralGravitationalAccelerationModel3d > createCentralGravit
                     boost::bind( &gravitation::GravityFieldModel::getGravitationalParameter,
                                  bodyUndergoingAcceleration->getGravityFieldModel( ) );
             gravitationalParameterFunction =
-                    boost::bind( &evaluateDoubleFunctions,
+                    boost::bind( &utilities::sumFunctionReturn< double >,
                                  gravitationalParameterOfBodyExertingAcceleration,
                                  gravitationalParameterOfBodyUndergoingAcceleration );
         }
@@ -94,7 +243,8 @@ boost::shared_ptr< CentralGravitationalAccelerationModel3d > createCentralGravit
                 boost::make_shared< CentralGravitationalAccelerationModel3d >(
                     boost::bind( &Body::getPosition, bodyUndergoingAcceleration ),
                     gravitationalParameterFunction,
-                    boost::bind( &Body::getPosition, bodyExertingAcceleration ) );
+                    boost::bind( &Body::getPosition, bodyExertingAcceleration ),
+                    useCentralBodyFixedFrame );
     }
 
 
@@ -102,7 +252,7 @@ boost::shared_ptr< CentralGravitationalAccelerationModel3d > createCentralGravit
 }
 
 //! Function to create spherical harmonic gravity acceleration model.
-boost::shared_ptr< gravitation::SphericalHarmonicsGravitationalAccelerationModelXd >
+boost::shared_ptr< gravitation::SphericalHarmonicsGravitationalAccelerationModel >
 createSphericalHarmonicsGravityAcceleration(
         const boost::shared_ptr< Body > bodyUndergoingAcceleration,
         const boost::shared_ptr< Body > bodyExertingAcceleration,
@@ -112,7 +262,7 @@ createSphericalHarmonicsGravityAcceleration(
         const bool useCentralBodyFixedFrame )
 {
     // Declare pointer to return object
-    boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModelXd > accelerationModel;
+    boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModel > accelerationModel;
 
     // Dynamic cast acceleration settings to required type and check consistency.
     boost::shared_ptr< SphericalHarmonicAccelerationSettings > sphericalHarmonicsSettings =
@@ -181,14 +331,14 @@ createSphericalHarmonicsGravityAcceleration(
                         boost::bind( &gravitation::GravityFieldModel::getGravitationalParameter,
                                      bodyUndergoingAcceleration->getGravityFieldModel( ) );
                 gravitationalParameterFunction =
-                        boost::bind( &evaluateDoubleFunctions,
+                        boost::bind( &utilities::sumFunctionReturn< double >,
                                      gravitationalParameterOfBodyExertingAcceleration,
                                      gravitationalParameterOfBodyUndergoingAcceleration );
             }
 
             // Create acceleration object.
             accelerationModel =
-                    boost::make_shared< SphericalHarmonicsGravitationalAccelerationModelXd >
+                    boost::make_shared< SphericalHarmonicsGravitationalAccelerationModel >
                     ( boost::bind( &Body::getPosition, bodyUndergoingAcceleration ),
                       gravitationalParameterFunction,
                       sphericalHarmonicsGravityField->getReferenceRadius( ),
@@ -202,7 +352,125 @@ createSphericalHarmonicsGravityAcceleration(
                                    sphericalHarmonicsSettings->maximumOrder_ ),
                       boost::bind( &Body::getPosition, bodyExertingAcceleration ),
                       boost::bind( &Body::getCurrentRotationToGlobalFrame,
-                                   bodyExertingAcceleration ) );
+                                   bodyExertingAcceleration ), useCentralBodyFixedFrame );
+        }
+    }
+    return accelerationModel;
+}
+
+//! Function to create mutual spherical harmonic gravity acceleration model.
+boost::shared_ptr< gravitation::MutualSphericalHarmonicsGravitationalAccelerationModel >
+createMutualSphericalHarmonicsGravityAcceleration(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings,
+        const bool useCentralBodyFixedFrame,
+        const bool acceleratedBodyIsCentralBody )
+{
+    using namespace basic_astrodynamics;
+
+    // Declare pointer to return object
+    boost::shared_ptr< MutualSphericalHarmonicsGravitationalAccelerationModel > accelerationModel;
+
+    // Dynamic cast acceleration settings to required type and check consistency.
+    boost::shared_ptr< MutualSphericalHarmonicAccelerationSettings > mutualSphericalHarmonicsSettings =
+            boost::dynamic_pointer_cast< MutualSphericalHarmonicAccelerationSettings >( accelerationSettings );
+    if( mutualSphericalHarmonicsSettings == NULL )
+    {
+        std::cerr<<"Error, expected mutual spherical harmonics acceleration settings when making acceleration model on "<<
+                   nameOfBodyUndergoingAcceleration<<" due to "<<nameOfBodyExertingAcceleration<<std::endl;
+    }
+    else
+    {
+        // Get pointer to gravity field of central body and cast to required type.
+        boost::shared_ptr< SphericalHarmonicsGravityField > sphericalHarmonicsGravityFieldOfBodyExertingAcceleration =
+                boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >(
+                    bodyExertingAcceleration->getGravityFieldModel( ) );
+        boost::shared_ptr< SphericalHarmonicsGravityField > sphericalHarmonicsGravityFieldOfBodyUndergoingAcceleration =
+                boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >(
+                    bodyUndergoingAcceleration->getGravityFieldModel( ) );
+
+        if( sphericalHarmonicsGravityFieldOfBodyExertingAcceleration == NULL )
+        {
+            std::cerr<<"Error "<<nameOfBodyExertingAcceleration<<" does not have a spherical harmonics gravity field "<<
+                       "when making mutual spherical harmonics gravity acceleration on "<<
+                       nameOfBodyUndergoingAcceleration<<std::endl;
+        }
+        else if( sphericalHarmonicsGravityFieldOfBodyUndergoingAcceleration == NULL )
+        {
+            std::cerr<<"Error "<<nameOfBodyUndergoingAcceleration<<" does not have a spherical harmonics gravity field "<<
+                       "when making mutual spherical harmonics gravity acceleration on "<<
+                       nameOfBodyUndergoingAcceleration<<std::endl;
+        }
+        else
+        {
+            boost::function< double( ) > gravitationalParameterFunction;
+
+            // Create function returning summed gravitational parameter of the two bodies.
+            if( useCentralBodyFixedFrame == false )
+            {
+                gravitationalParameterFunction =
+                        boost::bind( &SphericalHarmonicsGravityField::getGravitationalParameter,
+                                     sphericalHarmonicsGravityFieldOfBodyExertingAcceleration );
+            }
+            else
+            {
+                // Create function returning summed gravitational parameter of the two bodies.
+                boost::function< double( ) > gravitationalParameterOfBodyExertingAcceleration =
+                        boost::bind( &gravitation::GravityFieldModel::getGravitationalParameter,
+                                     sphericalHarmonicsGravityFieldOfBodyExertingAcceleration );
+                boost::function< double( ) > gravitationalParameterOfBodyUndergoingAcceleration =
+                        boost::bind( &gravitation::GravityFieldModel::getGravitationalParameter,
+                                     sphericalHarmonicsGravityFieldOfBodyUndergoingAcceleration );
+                gravitationalParameterFunction =
+                        boost::bind( &utilities::sumFunctionReturn< double >,
+                                     gravitationalParameterOfBodyExertingAcceleration,
+                                     gravitationalParameterOfBodyUndergoingAcceleration );
+            }
+
+            // Create acceleration object.
+
+            int maximumDegreeOfUndergoingBody, maximumOrderOfUndergoingBody;
+            if( !acceleratedBodyIsCentralBody )
+            {
+                maximumDegreeOfUndergoingBody = mutualSphericalHarmonicsSettings->maximumDegreeOfBodyUndergoingAcceleration_;
+                maximumOrderOfUndergoingBody = mutualSphericalHarmonicsSettings->maximumOrderOfBodyUndergoingAcceleration_;
+            }
+            else
+            {
+                maximumDegreeOfUndergoingBody = mutualSphericalHarmonicsSettings->maximumDegreeOfCentralBody_;
+                maximumOrderOfUndergoingBody = mutualSphericalHarmonicsSettings->maximumOrderOfCentralBody_;
+            }
+
+            accelerationModel = boost::make_shared< MutualSphericalHarmonicsGravitationalAccelerationModel >(
+                        boost::bind( &Body::getPosition, bodyUndergoingAcceleration ),
+                        boost::bind( &Body::getPosition, bodyExertingAcceleration ),
+                        gravitationalParameterFunction,
+                        sphericalHarmonicsGravityFieldOfBodyExertingAcceleration->getReferenceRadius( ),
+                        sphericalHarmonicsGravityFieldOfBodyUndergoingAcceleration->getReferenceRadius( ),
+                        boost::bind( &SphericalHarmonicsGravityField::getCosineCoefficients,
+                                     sphericalHarmonicsGravityFieldOfBodyExertingAcceleration,
+                                     mutualSphericalHarmonicsSettings->maximumDegreeOfBodyExertingAcceleration_,
+                                     mutualSphericalHarmonicsSettings->maximumOrderOfBodyExertingAcceleration_ ),
+                        boost::bind( &SphericalHarmonicsGravityField::getSineCoefficients,
+                                     sphericalHarmonicsGravityFieldOfBodyExertingAcceleration,
+                                     mutualSphericalHarmonicsSettings->maximumDegreeOfBodyExertingAcceleration_,
+                                     mutualSphericalHarmonicsSettings->maximumOrderOfBodyExertingAcceleration_ ),
+                        boost::bind( &SphericalHarmonicsGravityField::getCosineCoefficients,
+                                     sphericalHarmonicsGravityFieldOfBodyUndergoingAcceleration,
+                                     maximumDegreeOfUndergoingBody,
+                                     maximumOrderOfUndergoingBody ),
+                        boost::bind( &SphericalHarmonicsGravityField::getSineCoefficients,
+                                     sphericalHarmonicsGravityFieldOfBodyUndergoingAcceleration,
+                                     maximumDegreeOfUndergoingBody,
+                                     maximumOrderOfUndergoingBody ),
+                        boost::bind( &Body::getCurrentRotationToGlobalFrame,
+                                     bodyExertingAcceleration ),
+                        boost::bind( &Body::getCurrentRotationToGlobalFrame,
+                                     bodyUndergoingAcceleration ),
+                        useCentralBodyFixedFrame );
         }
     }
     return accelerationModel;
@@ -237,6 +505,134 @@ createThirdBodyCentralGravityAccelerationModel(
     return accelerationModelPointer;
 }
 
+//! Function to create a third body spheric harmonic gravity acceleration model.
+boost::shared_ptr< gravitation::ThirdBodySphericalHarmonicsGravitationalAccelerationModel >
+createThirdBodySphericalHarmonicGravityAccelerationModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const std::string& nameOfCentralBody,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings )
+{
+    using namespace basic_astrodynamics;
+
+    // Declare pointer to return object
+    boost::shared_ptr< ThirdBodySphericalHarmonicsGravitationalAccelerationModel > accelerationModel;
+
+    // Dynamic cast acceleration settings to required type and check consistency.
+    boost::shared_ptr< SphericalHarmonicAccelerationSettings > sphericalHarmonicsSettings =
+            boost::dynamic_pointer_cast< SphericalHarmonicAccelerationSettings >( accelerationSettings );
+    if( sphericalHarmonicsSettings == NULL )
+    {
+        std::cerr<<"Error, expected spherical harmonics acceleration settings when making acceleration model on "<<
+                   nameOfBodyUndergoingAcceleration<<" due to "<<nameOfBodyExertingAcceleration<<std::endl;
+    }
+    else
+    {
+        // Get pointer to gravity field of central body and cast to required type.
+        boost::shared_ptr< SphericalHarmonicsGravityField > sphericalHarmonicsGravityField =
+                boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >(
+                    bodyExertingAcceleration->getGravityFieldModel( ) );
+        if( sphericalHarmonicsGravityField == NULL )
+        {
+            std::cerr<<"Error "<<nameOfBodyExertingAcceleration<<" does not have a spherical harmonics gravity field "<<
+                       "when making third body spherical harmonics gravity acceleration on "<<
+                       nameOfBodyUndergoingAcceleration<<std::endl;
+        }
+        else
+        {
+
+            accelerationModel =  boost::make_shared< ThirdBodySphericalHarmonicsGravitationalAccelerationModel >(
+                        boost::dynamic_pointer_cast< SphericalHarmonicsGravitationalAccelerationModel >(
+                            createSphericalHarmonicsGravityAcceleration(
+                                bodyUndergoingAcceleration, bodyExertingAcceleration, nameOfBodyUndergoingAcceleration,
+                                nameOfBodyExertingAcceleration, sphericalHarmonicsSettings, 0 ) ),
+                        boost::dynamic_pointer_cast< SphericalHarmonicsGravitationalAccelerationModel >(
+                            createSphericalHarmonicsGravityAcceleration(
+                                centralBody, bodyExertingAcceleration, nameOfCentralBody,
+                                nameOfBodyExertingAcceleration, sphericalHarmonicsSettings, 0 ) ), nameOfCentralBody );
+        }
+    }
+    return accelerationModel;
+}
+
+//! Function to create a third body mutual spheric harmonic gravity acceleration model.
+boost::shared_ptr< gravitation::ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel >
+createThirdBodyMutualSphericalHarmonicGravityAccelerationModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const std::string& nameOfCentralBody,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings )
+{
+    // Declare pointer to return object
+    boost::shared_ptr< ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel > accelerationModel;
+
+    // Dynamic cast acceleration settings to required type and check consistency.
+    boost::shared_ptr< MutualSphericalHarmonicAccelerationSettings > mutualSphericalHarmonicsSettings =
+            boost::dynamic_pointer_cast< MutualSphericalHarmonicAccelerationSettings >( accelerationSettings );
+    if( mutualSphericalHarmonicsSettings == NULL )
+    {
+        std::cerr<<"Error, expected mutual spherical harmonics acceleration settings when making acceleration model on "<<
+                   nameOfBodyUndergoingAcceleration<<" due to "<<nameOfBodyExertingAcceleration<<std::endl;
+    }
+    else
+    {
+        // Get pointer to gravity field of central body and cast to required type.
+        boost::shared_ptr< SphericalHarmonicsGravityField > sphericalHarmonicsGravityFieldOfBodyExertingAcceleration =
+                boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >(
+                    bodyExertingAcceleration->getGravityFieldModel( ) );
+        boost::shared_ptr< SphericalHarmonicsGravityField > sphericalHarmonicsGravityFieldOfBodyUndergoingAcceleration =
+                boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >(
+                    bodyUndergoingAcceleration->getGravityFieldModel( ) );
+        boost::shared_ptr< SphericalHarmonicsGravityField > sphericalHarmonicsGravityFieldOfCentralBody =
+                boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >(
+                    centralBody->getGravityFieldModel( ) );
+
+        if( sphericalHarmonicsGravityFieldOfBodyExertingAcceleration == NULL )
+        {
+            std::cerr<<"Error "<<nameOfBodyExertingAcceleration<<" does not have a spherical harmonics gravity field "<<
+                       "when making mutual spherical harmonics gravity acceleration on "<<
+                       nameOfBodyUndergoingAcceleration<<std::endl;
+        }
+        else if( sphericalHarmonicsGravityFieldOfBodyUndergoingAcceleration == NULL )
+        {
+            std::cerr<<"Error "<<nameOfBodyUndergoingAcceleration<<" does not have a spherical harmonics gravity field "<<
+                       "when making mutual spherical harmonics gravity acceleration on "<<
+                       nameOfBodyUndergoingAcceleration<<std::endl;
+        }
+        else if( sphericalHarmonicsGravityFieldOfCentralBody == NULL )
+        {
+            std::cerr<<"Error "<<nameOfCentralBody<<" does not have a spherical harmonics gravity field "<<
+                       "when making mutual spherical harmonics gravity acceleration on "<<
+                       nameOfBodyUndergoingAcceleration<<std::endl;
+        }
+        else
+        {
+            boost::shared_ptr< MutualSphericalHarmonicAccelerationSettings > accelerationSettingsForCentralBodyAcceleration =
+                    boost::make_shared< MutualSphericalHarmonicAccelerationSettings >(
+                        mutualSphericalHarmonicsSettings->maximumDegreeOfBodyExertingAcceleration_,
+                        mutualSphericalHarmonicsSettings->maximumOrderOfBodyExertingAcceleration_,
+                        mutualSphericalHarmonicsSettings->maximumDegreeOfCentralBody_,
+                        mutualSphericalHarmonicsSettings->maximumOrderOfCentralBody_ );
+            accelerationModel =  boost::make_shared< ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel >(
+                        boost::dynamic_pointer_cast< MutualSphericalHarmonicsGravitationalAccelerationModel >(
+                            createMutualSphericalHarmonicsGravityAcceleration(
+                                bodyUndergoingAcceleration, bodyExertingAcceleration, nameOfBodyUndergoingAcceleration,
+                                nameOfBodyExertingAcceleration, mutualSphericalHarmonicsSettings, 0, 0 ) ),
+                        boost::dynamic_pointer_cast< MutualSphericalHarmonicsGravitationalAccelerationModel >(
+                            createMutualSphericalHarmonicsGravityAcceleration(
+                                centralBody, bodyExertingAcceleration, nameOfCentralBody,
+                                nameOfBodyExertingAcceleration, accelerationSettingsForCentralBodyAcceleration, 0, 1 ) ),
+                        nameOfCentralBody );
+        }
+    }
+    return accelerationModel;
+}
 
 //! Function to create an aerodynamic acceleration model.
 boost::shared_ptr< aerodynamics::AerodynamicAcceleration > createAerodynamicAcceleratioModel(
@@ -344,10 +740,8 @@ createCannonballRadiationPressureAcceleratioModel(
     return boost::make_shared< CannonBallRadiationPressureAcceleration >(
                 boost::bind( &Body::getPosition, bodyExertingAcceleration ),
                 boost::bind( &Body::getPosition, bodyUndergoingAcceleration ),
-                boost::bind( &RadiationPressureInterface::getCurrentRadiationPressure,
-                             radiationPressureInterface ),
-                boost::bind( &RadiationPressureInterface::getRadiationPressureCoefficient,
-                             radiationPressureInterface ),
+                boost::bind( &RadiationPressureInterface::getCurrentRadiationPressure, radiationPressureInterface ),
+                boost::bind( &RadiationPressureInterface::getRadiationPressureCoefficient, radiationPressureInterface ),
                 boost::bind( &RadiationPressureInterface::getArea, radiationPressureInterface ),
                 boost::bind( &Body::getBodyMass, bodyUndergoingAcceleration ) );
 
@@ -371,63 +765,22 @@ boost::shared_ptr< AccelerationModel< Eigen::Vector3d > > createAccelerationMode
     switch( accelerationSettings->accelerationType_ )
     {
     case central_gravity:
-        // Check if body is a single-body central gravity acceleration (use third-body if not)
-        if( nameOfCentralBody == nameOfBodyExertingAcceleration ||
-                isFrameInertial( nameOfCentralBody ) )
-        {
-            // Check if gravitational parameter to use is sum of gravitational paramater of the
-            // two bodies.
-            bool useCentralBodyFixedFrame = 0;
-            if( nameOfCentralBody == nameOfBodyExertingAcceleration )
-            {
-                useCentralBodyFixedFrame = 1;
-            }
-
-            accelerationModelPointer = createCentralGravityAcceleratioModel(
-                        bodyUndergoingAcceleration,
-                        bodyExertingAcceleration,
-                        nameOfBodyUndergoingAcceleration,
-                        nameOfBodyExertingAcceleration, useCentralBodyFixedFrame );
-        }
-        // Create third body central gravity acceleration
-        else
-        {
-
-            accelerationModelPointer = createThirdBodyCentralGravityAccelerationModel(
-                        bodyUndergoingAcceleration,
-                        bodyExertingAcceleration,
-                        centralBody,
-                        nameOfBodyUndergoingAcceleration,
-                        nameOfBodyExertingAcceleration,
-                        nameOfCentralBody );
-        }
+        accelerationModelPointer = createGravitationalAccelerationModel(
+                    bodyUndergoingAcceleration, bodyExertingAcceleration, accelerationSettings,
+                    nameOfBodyUndergoingAcceleration, nameOfBodyExertingAcceleration,
+                    centralBody, nameOfCentralBody );
         break;
     case spherical_harmonic_gravity:
-        if( nameOfCentralBody == nameOfBodyExertingAcceleration ||
-                isFrameInertial( nameOfCentralBody ) )
-        {
-            // Check if gravitational parameter to use is sum of gravitational paramater of the
-            // two bodies.
-            bool useCentralBodyFixedFrame = 0;
-            if( nameOfCentralBody == nameOfBodyExertingAcceleration )
-            {
-                useCentralBodyFixedFrame = 1;
-            }
-
-            accelerationModelPointer = createSphericalHarmonicsGravityAcceleration(
-                        bodyUndergoingAcceleration,
-                        bodyExertingAcceleration,
-                        nameOfBodyUndergoingAcceleration,
-                        nameOfBodyExertingAcceleration,
-                        accelerationSettings, useCentralBodyFixedFrame );
-
-        }
-        else
-        {
-            throw std::runtime_error(
-                        "Error, cannot yet make third body spherical harmonic acceleration." );
-
-        }
+        accelerationModelPointer = createGravitationalAccelerationModel(
+                    bodyUndergoingAcceleration, bodyExertingAcceleration, accelerationSettings,
+                    nameOfBodyUndergoingAcceleration, nameOfBodyExertingAcceleration,
+                    centralBody, nameOfCentralBody );
+        break;
+    case mutual_spherical_harmonic_gravity:
+        accelerationModelPointer = createGravitationalAccelerationModel(
+                    bodyUndergoingAcceleration, bodyExertingAcceleration, accelerationSettings,
+                    nameOfBodyUndergoingAcceleration, nameOfBodyExertingAcceleration,
+                    centralBody, nameOfCentralBody );
         break;
     case aerodynamic:
         accelerationModelPointer = createAerodynamicAcceleratioModel(
@@ -574,6 +927,7 @@ basic_astrodynamics::AccelerationMap createAccelerationModelsMap(
     return createAccelerationModelsMap( bodyMap, selectedAccelerationPerBody, centralBodyMap );
 }
 
+
 } // namespace simulation_setup
 
 } // namespace tudat
diff --git a/Tudat/SimulationSetup/createAccelerationModels.h b/Tudat/SimulationSetup/createAccelerationModels.h
index 3063a0e..3f94014 100644
--- a/Tudat/SimulationSetup/createAccelerationModels.h
+++ b/Tudat/SimulationSetup/createAccelerationModels.h
@@ -28,6 +28,79 @@ namespace tudat
 namespace simulation_setup
 {
 
+//! Function to create a direct (i.e. not third-body) gravitational acceleration (of any type)
+/*!
+ * Function to create a direct (i.e. not third-body) gravitational acceleration of any type (i.e. point mass,
+ * spherical harmonic, mutual spherical harmonic).
+ *  \param bodyUndergoingAcceleration Pointer to object of body that is being accelerated.
+ *  \param bodyExertingAcceleration Pointer to object of body that is exerting the gravitational acceleration.
+ *  \param nameOfBodyUndergoingAcceleration Name of body that is being accelerated.
+ *  \param nameOfBodyExertingAcceleration Name of body that is exerting the gravitational acceleration.
+ *  \param accelerationSettings Settings object for the gravitational acceleration.
+ *  \param nameOfCentralBody Name of central body in frame centered at which acceleration is to
+ *  be calculated.
+ *  \param isCentralBody Boolean defining whether the body undergoing the acceleration is the central body for a
+ *  third-body acceleration, of which the return object of this funciton is one of the sub-parts. Boolean is
+ *  only used when creating mutual spherical harmonic acceleration, to ensure teh correct usage of the acceleration
+ *  settings.
+ *  \return Direct gravitational acceleration model of requested settings.
+ */
+boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > createDirectGravitationalAcceleration(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings,
+        const std::string& nameOfCentralBody = "",
+        const bool isCentralBody = 0 );
+
+//! Function to create a third-body gravitational acceleration (of any type)
+/*!
+ * Function to create a direct third-body gravitational acceleration of any type (i.e. point mass,
+ * spherical harmonic, mutual spherical harmonic).
+ *  \param bodyUndergoingAcceleration Pointer to object of body that is being accelerated.
+ *  \param bodyExertingAcceleration Pointer to object of body that is exerting the gravitational acceleration.
+ *  \param centralBody Pointer to central body in frame centered at which acceleration is to be calculated.
+ *  \param nameOfBodyUndergoingAcceleration Name of body that is being accelerated.
+ *  \param nameOfBodyExertingAcceleration Name of body that is exerting the gravitational acceleration.
+ *  \param nameOfCentralBody Name of central body in frame centered at which acceleration is to
+ *  be calculated.
+ *  \param accelerationSettings Settings object for the gravitational acceleration.
+ *  \return Third-body gravitational acceleration model of requested settings.
+ */
+boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > createThirdBodyGravitationalAcceleration(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const std::string& nameOfCentralBody,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings );
+
+//! Function to create gravitational acceleration (of any type)
+/*!
+ * Function to create a third-body or direct gravitational acceleration of any type (i.e. point mass,
+ * spherical harmonic, mutual spherical harmonic).
+ *  \param bodyUndergoingAcceleration Pointer to object of body that is being accelerated.
+ *  \param bodyExertingAcceleration Pointer to object of body that is exerting the gravitational acceleration.
+ *  \param accelerationSettings Settings object for the gravitational acceleration.
+ *  \param centralBody Pointer to central body in frame centered at which acceleration is to be calculated.
+ *  \param nameOfBodyUndergoingAcceleration Name of body that is being accelerated.
+ *  \param nameOfBodyExertingAcceleration Name of body that is exerting the gravitational acceleration.
+ *  \param nameOfCentralBody Name of central body in frame centered at which acceleration is to
+ *  be calculated.
+ *  \param accelerationSettings Settings object for the gravitational acceleration.
+ *  \return Gravitational acceleration model of requested settings.
+ */
+boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > createGravitationalAccelerationModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfCentralBody );
+
 //! Function to create central gravity acceleration model.
 /*!
  *  Function to create central gravity acceleration model from bodies exerting and undergoing
@@ -72,7 +145,7 @@ createCentralGravityAcceleratioModel(
  *  acceleration.
  *  \return Spherical harmonic gravity acceleration model pointer.
  */
-boost::shared_ptr< gravitation::SphericalHarmonicsGravitationalAccelerationModelXd >
+boost::shared_ptr< gravitation::SphericalHarmonicsGravitationalAccelerationModel >
 createSphericalHarmonicsGravityAcceleration(
         const boost::shared_ptr< Body > bodyUndergoingAcceleration,
         const boost::shared_ptr< Body > bodyExertingAcceleration,
@@ -81,6 +154,37 @@ createSphericalHarmonicsGravityAcceleration(
         const boost::shared_ptr< AccelerationSettings > accelerationSettings,
         const bool useCentralBodyFixedFrame );
 
+//! Function to create mutual spherical harmonic gravity acceleration model.
+/*!
+ *  Function to create mutual spherical harmonic gravity acceleration model from bodies exerting and
+ *  undergoing acceleration.
+ *  \param bodyUndergoingAcceleration Pointer to object of body that is being accelerated.
+ *  \param bodyExertingAcceleration Pointer to object of body that is exerting the mutual spherical
+ *  harmonic gravity acceleration.
+ *  \param nameOfBodyUndergoingAcceleration Name of body that is being accelerated.
+ *  \param nameOfBodyExertingAcceleration Name of body that is exerting the mutual spherical harmonic
+ *  gravity acceleration.
+ *  \param accelerationSettings Settings for acceleration model that is to be created (should
+ *  be of derived type associated with mutual spherical harmonic acceleration).
+ *  \param useCentralBodyFixedFrame Boolean setting whether the central attraction of body
+ *  undergoing acceleration on body exerting acceleration is to be included in acceleration model.
+ *  Should be set to true in case the body undergoing acceleration is a celestial body
+ *  (with gravity field) and integration is performed in the frame centered at the body exerting
+ *  acceleration.
+ *  \param acceleratedBodyIsCentralBody Boolean defining whether the body undergoing the acceleration is the central body
+ *  for a third-body acceleration, of which the return object of this funciton is one of the sub-parts.
+ *  \return Mutual spherical harmonic gravity acceleration model pointer.
+ */
+boost::shared_ptr< gravitation::MutualSphericalHarmonicsGravitationalAccelerationModel >
+createMutualSphericalHarmonicsGravityAcceleration(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings,
+        const bool useCentralBodyFixedFrame,
+        const bool acceleratedBodyIsCentralBody );
+
 //! Function to create a third body central gravity acceleration model.
 /*!
  *  Function to create a third body central gravity acceleration model from bodies exerting and
@@ -106,6 +210,62 @@ createThirdBodyCentralGravityAccelerationModel(
         const std::string& nameOfBodyExertingAcceleration,
         const std::string& nameOfCentralBody );
 
+//! Function to create a third body spheric harmonic gravity acceleration model.
+/*!
+ *  Function to create a third body spheric harmonic gravity acceleration model from bodies exerting and
+ *  undergoing acceleration, as well as the central body, w.r.t. which the integration is to be
+ *  performed.
+ *  \param bodyUndergoingAcceleration Pointer to object of body that is being accelerated.
+ *  \param bodyExertingAcceleration Pointer to object of body that is exerting the acceleration.
+ *  \param centralBody Pointer to central body in frame centered at which acceleration is to be
+ *  calculated.
+ *  \param nameOfBodyUndergoingAcceleration Name of object of body that is being accelerated.
+ *  \param nameOfBodyExertingAcceleration Name of object of body that is exerting the central
+ *  gravity acceleration.
+ *  \param nameOfCentralBody Name of central body in frame cenetered at which acceleration is to
+ *  be calculated.
+ *  \param accelerationSettings Settings for acceleration model that is to be created (should
+ *  be of derived type associated with spherical harmonic acceleration).
+ *  \return Pointer to object for calculating third-body spheric harmonic gravity acceleration between bodies.
+ */
+boost::shared_ptr< gravitation::ThirdBodySphericalHarmonicsGravitationalAccelerationModel >
+createThirdBodySphericalHarmonicGravityAccelerationModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const std::string& nameOfCentralBody,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings );
+
+//! Function to create a third body mutual spheric harmonic gravity acceleration model.
+/*!
+ *  Function to create a third body mutual spheric harmonic gravity acceleration model from bodies exerting and
+ *  undergoing acceleration, as well as the central body, w.r.t. which the integration is to be
+ *  performed.
+ *  \param bodyUndergoingAcceleration Pointer to object of body that is being accelerated.
+ *  \param bodyExertingAcceleration Pointer to object of body that is exerting the acceleration.
+ *  \param centralBody Pointer to central body in frame centered at which acceleration is to be
+ *  calculated.
+ *  \param nameOfBodyUndergoingAcceleration Name of object of body that is being accelerated.
+ *  \param nameOfBodyExertingAcceleration Name of object of body that is exerting the central
+ *  gravity acceleration.
+ *  \param nameOfCentralBody Name of central body in frame cenetered at which acceleration is to
+ *  be calculated.
+ *  \param accelerationSettings Settings for acceleration model that is to be created (should
+ *  be of derived type associated with mutual spherical harmonic acceleration).
+ *  \return Pointer to object for calculating third-body mutual spheric harmonic gravity acceleration between bodies.
+ */
+boost::shared_ptr< gravitation::ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel >
+createThirdBodyMutualSphericalHarmonicGravityAccelerationModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const std::string& nameOfCentralBody,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings );
+
 //! Function to create an aerodynamic acceleration model.
 /*!
  *  Function to create an aerodynamic acceleration model, automatically creates all required
@@ -201,7 +361,6 @@ basic_astrodynamics::AccelerationMap createAccelerationModelsMap(
         const std::vector< std::string >& propagatedBodies,
         const std::vector< std::string >& centralBodies );
 
-
 } // namespace simulation_setup
 
 } // namespace tudat
diff --git a/Tudat/SimulationSetup/createAccelerationPartials.cpp b/Tudat/SimulationSetup/createAccelerationPartials.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/Tudat/SimulationSetup/createAccelerationPartials.h b/Tudat/SimulationSetup/createAccelerationPartials.h
new file mode 100644
index 0000000..0daee9b
--- /dev/null
+++ b/Tudat/SimulationSetup/createAccelerationPartials.h
@@ -0,0 +1,237 @@
+#ifndef TUDAT_CREATEACCELERATIONPARTIALS_H
+#define TUDAT_CREATEACCELERATIONPARTIALS_H
+
+#include <boost/make_shared.hpp>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
+
+#include "Tudat/SimulationSetup/body.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/accelerationPartial.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/centralGravityAccelerationPartial.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/radiationPressureAccelerationPartial.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/thirdBodyGravityPartial.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.h"
+
+namespace tudat
+{
+
+namespace orbit_determination
+{
+
+namespace partial_derivatives
+{
+
+//! Function to create a single acceleration partial derivative object.
+/*!
+ *  Function to create a single acceleration partial derivative object.
+ *  \param accelerationModel Acceleration model for which a partial derivative is to be computed.
+ *  \param acceleratedBody Pair of name and object of body undergoing acceleration
+ *  \param acceleratingBody Pair of name and object of body exerting acceleration
+ *  \param bodyMap List of all body objects
+ *  \return Single acceleration partial derivative object.
+ */
+template< typename InitialStateParameterType = double >
+boost::shared_ptr< AccelerationPartial > createAnalyticalAccelerationPartial(
+        boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > accelerationModel,
+        const std::pair< std::string, boost::shared_ptr< simulation_setup::Body > > acceleratedBody,
+        const std::pair< std::string, boost::shared_ptr< simulation_setup::Body > > acceleratingBody,
+        const simulation_setup::NamedBodyMap bodyMap )
+{
+
+    using namespace basic_astrodynamics;
+    using namespace electro_magnetism;
+    using namespace aerodynamics;
+
+    boost::shared_ptr< AccelerationPartial > accelerationPartial;
+
+    // Identify current acceleration model type
+    AvailableAcceleration accelerationType = getAccelerationModelType( accelerationModel );
+    switch( accelerationType )
+    {
+    case central_gravity:
+
+        // Check if identifier is consistent with type.
+        if( boost::dynamic_pointer_cast< CentralGravitationalAccelerationModel3d >( accelerationModel ) == NULL )
+        {
+            throw std::runtime_error( "Acceleration class type does not match acceleration type (central_gravity) when making acceleration partial" );
+        }
+        else
+        {
+                // Create partial-calculating object.
+                accelerationPartial = boost::make_shared< CentralGravitationPartial >
+                        ( boost::dynamic_pointer_cast< CentralGravitationalAccelerationModel3d >( accelerationModel ),
+                          acceleratedBody.first, acceleratingBody.first );
+        }
+        break;
+
+    case third_body_central_gravity:
+        // Check if identifier is consistent with type.
+        if( boost::dynamic_pointer_cast< ThirdBodyCentralGravityAcceleration >( accelerationModel ) == NULL )
+        {
+            throw std::runtime_error( "Acceleration class type does not match acceleration type (third_body_central_gravity) when making acceleration partial" );
+        }
+        else
+        {
+            boost::shared_ptr< ThirdBodyCentralGravityAcceleration > thirdBodyAccelerationModel  =
+                    boost::dynamic_pointer_cast< ThirdBodyCentralGravityAcceleration >( accelerationModel );
+
+            // Create partials for constituent central gravity accelerations
+            boost::shared_ptr< CentralGravitationPartial > accelerationPartialForBodyUndergoingAcceleration =
+                    boost::dynamic_pointer_cast< CentralGravitationPartial >(
+                        createAnalyticalAccelerationPartial(
+                            thirdBodyAccelerationModel->getAccelerationModelForBodyUndergoingAcceleration( ),
+                            acceleratedBody, acceleratingBody, bodyMap ) );
+            boost::shared_ptr< CentralGravitationPartial > accelerationPartialForCentralBody =
+                    boost::dynamic_pointer_cast< CentralGravitationPartial >(
+                        createAnalyticalAccelerationPartial(
+                            thirdBodyAccelerationModel->getAccelerationModelForCentralBody( ),
+                            std::make_pair( thirdBodyAccelerationModel->getCentralBodyName( ),
+                                            bodyMap.at( thirdBodyAccelerationModel->getCentralBodyName( ) ) ),
+                            acceleratingBody, bodyMap  ) );
+
+            // Create partial-calculating object.
+            accelerationPartial = boost::make_shared< ThirdBodyGravityPartial< CentralGravitationPartial > >(
+                        accelerationPartialForBodyUndergoingAcceleration,
+                        accelerationPartialForCentralBody, acceleratedBody.first, acceleratingBody.first,
+                        thirdBodyAccelerationModel->getCentralBodyName( ) );
+
+        }
+        break;
+
+    case cannon_ball_radiation_pressure:
+    {
+        // Check if identifier is consistent with type.
+        boost::shared_ptr< CannonBallRadiationPressureAcceleration > radiationPressureAcceleration =
+                boost::dynamic_pointer_cast< CannonBallRadiationPressureAcceleration >( accelerationModel );
+        if( radiationPressureAcceleration == NULL )
+        {
+            throw std::runtime_error( "Acceleration class type does not match acceleration type (cannon_ball_radiation_pressure) when making acceleration partial" );
+        }
+        else
+        {
+            std::map< std::string, boost::shared_ptr< RadiationPressureInterface > > radiationPressureInterfaces =
+                    acceleratedBody.second->getRadiationPressureInterfaces( );
+
+            if( radiationPressureInterfaces.count( acceleratingBody.first ) == 0 )
+            {
+                throw std::runtime_error( "No radiation pressure coefficient interface found when making acceleration partial." );
+            }
+            else
+            {
+                boost::shared_ptr< RadiationPressureInterface > radiationPressureInterface =
+                        radiationPressureInterfaces.at( acceleratingBody.first );
+
+                // Create partial-calculating object.
+                accelerationPartial = boost::make_shared< CannonBallRadiationPressurePartial >
+                        ( radiationPressureInterface, radiationPressureAcceleration->getMassFunction( ),
+                          acceleratedBody.first, acceleratingBody.first );
+            }
+        }
+        break;
+    }
+    default:
+        std::string errorMessage = "Acceleration model " + boost::lexical_cast< std::string >( accelerationType ) +
+                " not found when making acceleration partial";
+        throw std::runtime_error( errorMessage );
+        break;
+    }
+
+    return accelerationPartial;
+}
+
+//! This function creates acceleration partial objects for translational dynamics
+/*!
+ *  This function creates acceleration partial objects for translational dynamics from acceleration models and
+ *  list of bodies' states of which derivatives are needed. The return type is an StateDerivativePartialsMap,
+ *  a standardized type for communicating such lists of these objects.
+ *  \param accelerationMap Map of maps containing list of acceleration models, identifying which acceleration acts on which
+ *   body.
+ *  \param bodyMap List of body objects constituting environment for calculations.
+ *  \param parametersToEstimate List of parameters which are to be estimated.
+ *  \return List of acceleration-partial-calculating objects in StateDerivativePartialsMap type.
+ */
+template< typename InitialStateParameterType >
+StateDerivativePartialsMap createAccelerationPartialsMap(
+        const basic_astrodynamics::AccelerationMap& accelerationMap,
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< InitialStateParameterType > >
+        parametersToEstimate )
+{
+    // Declare return map.
+    StateDerivativePartialsMap accelerationPartialsList;
+    std::map< std::string, std::map< std::string, std::vector< boost::shared_ptr< AccelerationPartial > > > >
+            accelerationPartialsMap;
+
+    std::vector< boost::shared_ptr< estimatable_parameters::EstimatableParameter<
+            Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > > > > initialDynamicalParameters =
+            parametersToEstimate->getEstimatedInitialStateParameters( );
+    accelerationPartialsList.resize( initialDynamicalParameters.size( ) );
+
+    // Iterate over list of bodies of which the partials of the accelerations acting on them are required.
+    for( basic_astrodynamics::AccelerationMap::const_iterator accelerationIterator = accelerationMap.begin( );
+         accelerationIterator != accelerationMap.end( ); accelerationIterator++ )
+    {
+        for( unsigned int i = 0; i < initialDynamicalParameters.size( ); i++ )
+        {
+            if( initialDynamicalParameters.at( i )->getParameterName( ).second.first == accelerationIterator->first )
+            {
+                if( ( initialDynamicalParameters.at( i )->getParameterName( ).first ==
+                      estimatable_parameters::initial_body_state ) )
+                {
+                    // Get object for body undergoing acceleration
+                    const std::string acceleratedBody = accelerationIterator->first;
+                    boost::shared_ptr< simulation_setup::Body > acceleratedBodyObject = bodyMap.at( acceleratedBody );
+
+                    // Retrieve list of accelerations acting on current body.
+                    basic_astrodynamics::SingleBodyAccelerationMap accelerationVector =
+                            accelerationMap.at( acceleratedBody );
+
+                    // Declare list of acceleration partials of current body.
+                    std::vector< boost::shared_ptr< StateDerivativePartial > > accelerationPartialVector;
+
+                    // Iterate over all acceleration models and generate their partial-calculating objects.
+                    for(  basic_astrodynamics::SingleBodyAccelerationMap::iterator
+                          innerAccelerationIterator = accelerationVector.begin( );
+                          innerAccelerationIterator != accelerationVector.end( ); innerAccelerationIterator++ )
+                    {
+                        // Get object for body exerting acceleration
+                        std::string acceleratingBody = innerAccelerationIterator->first;
+                        boost::shared_ptr< simulation_setup::Body > acceleratingBodyObject;
+                        if( acceleratingBody != "" )
+                        {
+                            acceleratingBodyObject = bodyMap.at( acceleratingBody );
+                        }
+
+                        for( unsigned int j = 0; j < innerAccelerationIterator->second.size( ); j++ )
+                        {
+                            // Create single partial object
+                            boost::shared_ptr< AccelerationPartial > currentAccelerationPartial =
+                                    createAnalyticalAccelerationPartial(
+                                        innerAccelerationIterator->second[ j ],
+                                        std::make_pair( acceleratedBody, acceleratedBodyObject ),
+                                        std::make_pair( acceleratingBody, acceleratingBodyObject ),
+                                        bodyMap );
+
+                            accelerationPartialVector.push_back( currentAccelerationPartial );
+                            accelerationPartialsMap[ acceleratedBody ][ acceleratingBody ].push_back(
+                                        currentAccelerationPartial );
+                        }
+                    }
+
+                    // Add partials of current body's accelerations to vector.
+                    accelerationPartialsList[ i ] = accelerationPartialVector;
+
+                }
+            }
+        }
+    }
+    return accelerationPartialsList;
+}
+
+}
+
+}
+
+}
+
+#endif // TUDAT_CREATEACCELERATIONPARTIALS_H
diff --git a/Tudat/SimulationSetup/createEphemeris.cpp b/Tudat/SimulationSetup/createEphemeris.cpp
index c842feb..c687be8 100644
--- a/Tudat/SimulationSetup/createEphemeris.cpp
+++ b/Tudat/SimulationSetup/createEphemeris.cpp
@@ -31,41 +31,6 @@ namespace simulation_setup
 
 using namespace ephemerides;
 
-#if USE_CSPICE
-//! Function to create a tabulated ephemeris using data from Spice.
-boost::shared_ptr< Ephemeris > createTabulatedEphemerisFromSpice(
-        const std::string& body,
-        const double initialTime,
-        const double endTime,
-        const double timeStep,
-        const std::string& observerName,
-        const std::string& referenceFrameName )
-{
-    using namespace interpolators;
-
-    std::map< double, basic_mathematics::Vector6d > timeHistoryOfState;
-
-    // Calculate state from spice at given time intervals and store in timeHistoryOfState.
-    double currentTime = initialTime;
-    while( currentTime < endTime )
-    {
-        timeHistoryOfState[ currentTime ] = spice_interface::getBodyCartesianStateAtEpoch(
-                    body, observerName, referenceFrameName, "none", currentTime );
-        currentTime += timeStep;
-    }
-
-    // Create interpolator.
-    boost::shared_ptr< LagrangeInterpolator< double, basic_mathematics::Vector6d > > interpolator =
-            boost::make_shared< LagrangeInterpolator< double, basic_mathematics::Vector6d > >(
-                timeHistoryOfState, 6, huntingAlgorithm,
-                lagrange_cubic_spline_boundary_interpolation );
-
-    // Create ephemeris and return.
-    return boost::make_shared< TabulatedCartesianEphemeris< > >(
-                interpolator, observerName, referenceFrameName );
-}
-#endif
-
 //! Function to create a ephemeris model.
 boost::shared_ptr< ephemerides::Ephemeris > createBodyEphemeris(
         const boost::shared_ptr< EphemerisSettings > ephemerisSettings,
@@ -77,7 +42,7 @@ boost::shared_ptr< ephemerides::Ephemeris > createBodyEphemeris(
     // Check which type of ephemeris model is to be created.
     switch( ephemerisSettings->getEphemerisType( ) )
     {
-    #if USE_CSPICE
+#if USE_CSPICE
     case direct_spice_ephemeris:
     {
         // Check consistency of type and class.
@@ -128,17 +93,32 @@ boost::shared_ptr< ephemerides::Ephemeris > createBodyEphemeris(
             }
 
             // Create corresponding ephemeris object.
-            ephemeris = createTabulatedEphemerisFromSpice(
+            if( !interpolatedEphemerisSettings->getUseLongDoubleStates( ) )
+            {
+                ephemeris = createTabulatedEphemerisFromSpice< double, double >(
                         inputName,
                         interpolatedEphemerisSettings->getInitialTime( ),
                         interpolatedEphemerisSettings->getFinalTime( ),
                         interpolatedEphemerisSettings->getTimeStep( ),
                         interpolatedEphemerisSettings->getFrameOrigin( ),
-                        interpolatedEphemerisSettings->getFrameOrientation( ) );
+                        interpolatedEphemerisSettings->getFrameOrientation( ),
+                        interpolatedEphemerisSettings->getInterpolatorSettings( ) );
+            }
+            else
+            {
+                ephemeris = createTabulatedEphemerisFromSpice< long double, double >(
+                        inputName,
+                        static_cast< long double >( interpolatedEphemerisSettings->getInitialTime( ) ),
+                        static_cast< long double >( interpolatedEphemerisSettings->getFinalTime( ) ),
+                        static_cast< long double >( interpolatedEphemerisSettings->getTimeStep( ) ),
+                        interpolatedEphemerisSettings->getFrameOrigin( ),
+                        interpolatedEphemerisSettings->getFrameOrientation( ),
+                        interpolatedEphemerisSettings->getInterpolatorSettings( ) );
+            }
         }
         break;
     }
-    #endif
+#endif
     case tabulated_ephemeris:
     {
         // Check consistency of type and class.
@@ -152,14 +132,39 @@ boost::shared_ptr< ephemerides::Ephemeris > createBodyEphemeris(
         else
         {
             // Create corresponding ephemeris object.
-            ephemeris = boost::make_shared< TabulatedCartesianEphemeris< > >(
-                        boost::make_shared<
-                        interpolators::LagrangeInterpolator< double, basic_mathematics::Vector6d > >
-                        ( tabulatedEphemerisSettings->getBodyStateHistory( ), 6,
-                          interpolators::huntingAlgorithm,
-                          interpolators::lagrange_cubic_spline_boundary_interpolation ),
-                        tabulatedEphemerisSettings->getFrameOrigin( ),
-                        tabulatedEphemerisSettings->getFrameOrientation( ) );
+            if( !tabulatedEphemerisSettings->getUseLongDoubleStates( ) )
+            {
+                ephemeris = boost::make_shared< TabulatedCartesianEphemeris< > >(
+                            boost::make_shared<
+                            interpolators::LagrangeInterpolator< double, basic_mathematics::Vector6d > >
+                            ( tabulatedEphemerisSettings->getBodyStateHistory( ), 6,
+                              interpolators::huntingAlgorithm,
+                              interpolators::lagrange_cubic_spline_boundary_interpolation ),
+                            tabulatedEphemerisSettings->getFrameOrigin( ),
+                            tabulatedEphemerisSettings->getFrameOrientation( ) );
+            }
+            else
+            {
+                // Cast input history to required type.
+                std::map< double, basic_mathematics::Vector6d > originalStateHistory =
+                        tabulatedEphemerisSettings->getBodyStateHistory( );
+                std::map< double, Eigen::Matrix< long double, 6, 1 > > longStateHistory;
+
+                for( std::map< double, basic_mathematics::Vector6d >::const_iterator stateIterator =
+                     originalStateHistory.begin( ); stateIterator != originalStateHistory.end( ); stateIterator++ )
+                {
+                    longStateHistory[ stateIterator->first ] = stateIterator->second.cast< long double >( );
+                    ephemeris =
+                            boost::make_shared< TabulatedCartesianEphemeris< long double, double > >(
+                                boost::make_shared< interpolators::LagrangeInterpolator<
+                                double, Eigen::Matrix< long double, 6, 1 > > >
+                                ( longStateHistory, 6,
+                                  interpolators::huntingAlgorithm,
+                                  interpolators::lagrange_cubic_spline_boundary_interpolation ),
+                                tabulatedEphemerisSettings->getFrameOrigin( ),
+                                tabulatedEphemerisSettings->getFrameOrientation( ) );
+                }
+            }
         }
         break;
     }
diff --git a/Tudat/SimulationSetup/createEphemeris.h b/Tudat/SimulationSetup/createEphemeris.h
index 43d76a9..c48e152 100644
--- a/Tudat/SimulationSetup/createEphemeris.h
+++ b/Tudat/SimulationSetup/createEphemeris.h
@@ -18,7 +18,10 @@
 
 #include "Tudat/InputOutput/matrixTextFileReader.h"
 #include "Tudat/Astrodynamics/Ephemerides/ephemeris.h"
+#include "Tudat/Astrodynamics/Ephemerides/tabulatedEphemeris.h"
 #include "Tudat/Astrodynamics/Ephemerides/approximatePlanetPositionsBase.h"
+#include "Tudat/Mathematics/Interpolators/createInterpolator.h"
+#include "Tudat/External/SpiceInterface/spiceInterface.h"
 
 namespace tudat
 {
@@ -217,37 +220,62 @@ public:
      *        (optional "SSB" by default).
      * \param frameOrientation Orientatioan of the reference frame in which the epehemeris is to be
      *          calculated (optional "ECLIPJ2000" by default).
+     * \param interpolatorSettings Settings to be used for the state interpolation.
      */
     InterpolatedSpiceEphemerisSettings( double initialTime,
                                         double finalTime,
                                         double timeStep,
                                         std::string frameOrigin = "SSB",
-                                        std::string frameOrientation = "ECLIPJ2000" ):
+                                        std::string frameOrientation = "ECLIPJ2000",
+                                        boost::shared_ptr< interpolators::InterpolatorSettings > interpolatorSettings =
+            boost::make_shared< interpolators::LagrangeInterpolatorSettings >( 6 ) ):
         DirectSpiceEphemerisSettings( frameOrigin, frameOrientation, 0, 0, 0,
                                       interpolated_spice ),
-        initialTime_( initialTime ), finalTime_( finalTime ), timeStep_( timeStep ){ }
+        initialTime_( initialTime ), finalTime_( finalTime ), timeStep_( timeStep ),
+        interpolatorSettings_( interpolatorSettings ), useLongDoubleStates_( 0 ){ }
 
-    //! Function to returns initial time from which interpolated data from Spice should be created.
+    //! Function to return initial time from which interpolated data from Spice should be created.
     /*!
-     *  Function to returns initial time from which interpolated data from Spice should be created.
+     *  Function to return initial time from which interpolated data from Spice should be created.
      *  \return Initial time from which interpolated data from Spice should be created.
      */
     double getInitialTime( ){ return initialTime_; }
 
-    //! Function to returns final time from which interpolated data from Spice should be created.
+    //! Function to return final time from which interpolated data from Spice should be created.
     /*!
-     *  Function to returns final time from which interpolated data from Spice should be created.
+     *  Function to return final time from which interpolated data from Spice should be created.
      *  \return Final time from which interpolated data from Spice should be created.
      */
     double getFinalTime( ){ return finalTime_; }
 
-    //! Function to returns time step with which interpolated data from Spice should be created.
+    //! Function to return time step with which interpolated data from Spice should be created.
     /*!
-     *  Function to returns time step with which interpolated data from Spice should be created.
+     *  Function to return time step with which interpolated data from Spice should be created.
      *  \return Time step with which interpolated data from Spice should be created.
      */
     double getTimeStep( ){ return timeStep_; }
 
+    //! Function to return settings to be used for the state interpolation.
+    /*!
+     *  Function to return settings to be used for the state interpolation.
+     *  \return Settings to be used for the state interpolation.
+     */
+
+    boost::shared_ptr< interpolators::InterpolatorSettings > getInterpolatorSettings( )
+    {
+        return interpolatorSettings_;
+    }
+
+    bool getUseLongDoubleStates( )
+    {
+        return useLongDoubleStates_;
+    }
+
+    void setUseLongDoubleStates( const bool useLongDoubleStates )
+    {
+        useLongDoubleStates_ = useLongDoubleStates;
+    }
+
 private:
 
     //! Initial time from which interpolated data from Spice should be created.
@@ -259,6 +287,10 @@ private:
     //! Time step with which interpolated data from Spice should be created.
     double timeStep_;
 
+    //! Settings to be used for the state interpolation.
+    boost::shared_ptr< interpolators::InterpolatorSettings > interpolatorSettings_;
+
+    bool useLongDoubleStates_;
 };
 
 //! EphemerisSettings derived class for defining settings of an approximate ephemeris for major
@@ -495,7 +527,7 @@ public:
             std::string frameOrigin = "SSB",
             std::string frameOrientation = "ECLIPJ2000" ):
         EphemerisSettings( tabulated_ephemeris, frameOrigin, frameOrientation ),
-        bodyStateHistory_( bodyStateHistory ){ }
+        bodyStateHistory_( bodyStateHistory ), useLongDoubleStates_( ){ }
 
     //! Function returning data map defining discrete data from which an ephemeris is to be created.
     /*!
@@ -505,6 +537,17 @@ public:
     std::map< double, basic_mathematics::Vector6d > getBodyStateHistory( )
     { return bodyStateHistory_; }
 
+
+    bool getUseLongDoubleStates( )
+    {
+        return useLongDoubleStates_;
+    }
+
+    void setUseLongDoubleStates( const bool useLongDoubleStates )
+    {
+        useLongDoubleStates_ = useLongDoubleStates;
+    }
+
 private:
 
     //! Data map defining discrete data from which an ephemeris is to be created.
@@ -513,8 +556,12 @@ private:
      *  ephemeris is to be created.
      */
     std::map< double, basic_mathematics::Vector6d > bodyStateHistory_;
+
+    bool useLongDoubleStates_;
 };
 
+#if USE_CSPICE
+
 //! Function to create a tabulated ephemeris using data from Spice.
 /*!
  *  Function to create a tabulated ephemeris using data from Spice.
@@ -532,13 +579,41 @@ private:
  *          calculated.
  * \return Tabulated ephemeris using data from Spice.
  */
+template< typename StateScalarType = double, typename TimeType = double >
 boost::shared_ptr< ephemerides::Ephemeris > createTabulatedEphemerisFromSpice(
         const std::string& body,
-        const double initialTime,
-        const double endTime,
-        const double timeStep,
+        const TimeType initialTime,
+        const TimeType endTime,
+        const TimeType timeStep,
         const std::string& observerName,
-        const std::string& referenceFrameName );
+        const std::string& referenceFrameName,
+        boost::shared_ptr< interpolators::InterpolatorSettings > interpolatorSettings =
+        boost::make_shared< interpolators::LagrangeInterpolatorSettings >( 8 ) )
+{
+    using namespace interpolators;
+
+    std::map< TimeType, Eigen::Matrix< StateScalarType, 6, 1 > > timeHistoryOfState;
+
+    // Calculate state from spice at given time intervals and store in timeHistoryOfState.
+    TimeType currentTime = initialTime;
+    while( currentTime < endTime )
+    {
+        timeHistoryOfState[ currentTime ] = spice_interface::getBodyCartesianStateAtEpoch(
+                    body, observerName, referenceFrameName, "none", static_cast< double >( currentTime ) ).
+                template cast< StateScalarType >( );
+        currentTime += timeStep;
+    }
+
+    // Create interpolator.
+    boost::shared_ptr< OneDimensionalInterpolator< TimeType, Eigen::Matrix< StateScalarType, 6, 1 > > > interpolator =
+            interpolators::createOneDimensionalInterpolator(
+                timeHistoryOfState, interpolatorSettings );
+
+    // Create ephemeris and return.
+    return boost::make_shared< ephemerides::TabulatedCartesianEphemeris< StateScalarType, TimeType > >(
+                interpolator, observerName, referenceFrameName );
+}
+#endif
 
 //! Function to create a ephemeris model.
 /*!
diff --git a/Tudat/SimulationSetup/createEstimatableParameters.cpp b/Tudat/SimulationSetup/createEstimatableParameters.cpp
new file mode 100644
index 0000000..09734b4
--- /dev/null
+++ b/Tudat/SimulationSetup/createEstimatableParameters.cpp
@@ -0,0 +1,127 @@
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/gravitationalParameter.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/radiationPressureCoefficient.h"
+#include "Tudat/SimulationSetup/createEstimatableParameters.h"
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+
+using namespace simulation_setup;
+using namespace ephemerides;
+using namespace gravitation;
+using namespace estimatable_parameters;
+
+boost::shared_ptr< EstimatableParameter< double > > createDoubleParameterToEstimate(
+        const boost::shared_ptr< EstimatableParameterSettings >& doubleParameterName,
+        const NamedBodyMap& bodyMap, const basic_astrodynamics::AccelerationMap& accelerationModelMap )
+{
+    boost::shared_ptr< EstimatableParameter< double > > doubleParameterToEstimate;
+
+    if( isDoubleParameter( doubleParameterName->parameterType_.first ) != true )
+    {
+        std::cerr<<"Error when requesting to make double parameter "<<doubleParameterName->parameterType_.first<<" of "<<
+                   doubleParameterName->parameterType_.second.first<<", parameter is not a double parameter "<<std::endl;
+    }
+    else
+    {
+        std::string currentBodyName = doubleParameterName->parameterType_.second.first;
+        boost::shared_ptr< Body > currentBody;
+
+        if( ( currentBodyName != "" ) && ( bodyMap.count( currentBodyName ) == 0 ) )
+        {
+            std::cerr<<"Warning when creating parameters to estimate, body "<<currentBodyName;
+            std::cerr<<" not in body map "<<doubleParameterName->parameterType_.first<<std::endl;
+            currentBody = boost::shared_ptr< Body >( );
+        }
+        else if( currentBodyName != "" )
+        {
+            currentBody = bodyMap.at( currentBodyName );
+        }
+
+        switch( doubleParameterName->parameterType_.first )
+        {
+        case gravitational_parameter:
+        {
+            if( currentBody->getGravityFieldModel( )== NULL )
+            {
+                std::cerr<<"Warning, body "<<currentBodyName<<" has no gravity field";
+                std::cerr<<", cannot estimate gravitational parameter."<<std::endl;
+            }
+            else
+            {
+                boost::shared_ptr< GravityFieldModel > gravityFieldModel = currentBody->getGravityFieldModel( );
+                doubleParameterToEstimate = boost::make_shared< GravitationalParameter >
+                        ( gravityFieldModel, currentBodyName );
+            }
+            break;
+        }
+        case radiation_pressure_coefficient:
+        {
+            if( currentBody->getRadiationPressureInterfaces( ).size( ) == 0 )
+            {
+                std::cerr<<"Error, no radiation pressure interfaces found in body "<<currentBodyName<<" when making Cr parameter"<<std::endl;
+            }
+            else if( currentBody->getRadiationPressureInterfaces( ).size( ) > 1 )
+            {
+                std::cerr<<"Error, multiple radiation pressure interfaces found in body "<<currentBodyName<<" when making Cr parameter"<<std::endl;
+            }
+            else
+            {
+                doubleParameterToEstimate = boost::make_shared< RadiationPressureCoefficient >(
+                            currentBody->getRadiationPressureInterfaces( ).begin( )->second,
+                            currentBodyName );
+            }
+            break;
+        }
+        default:
+            std::cerr<<"Warning, this double parameter has not yet been implemented when making parameters"<<std::endl;
+            break;
+        }
+    }
+
+    return doubleParameterToEstimate;
+}
+
+boost::shared_ptr< EstimatableParameter< Eigen::VectorXd > > createVectorParameterToEstimate(
+        const boost::shared_ptr< EstimatableParameterSettings >& vectorParameterName,
+        const NamedBodyMap& bodyMap, const basic_astrodynamics::AccelerationMap& accelerationModelMap )
+{
+    boost::shared_ptr< EstimatableParameter< Eigen::VectorXd > > vectorParameterToEstimate;
+
+    if( isDoubleParameter( vectorParameterName->parameterType_.first ) != false )
+    {
+        std::cerr<<"Error when requesting to make vector parameter "<<vectorParameterName->parameterType_.first<<" of "<<
+                   vectorParameterName->parameterType_.second.first<<", parameter is not a vector parameter "<<std::endl;
+    }
+    else
+    {
+        std::string currentBodyName = vectorParameterName->parameterType_.second.first;
+        boost::shared_ptr< Body > currentBody;
+
+        if( ( currentBodyName != "" ) && ( bodyMap.count( currentBodyName ) == 0 ) )
+        {
+            std::cerr<<"Warning when creating parameters to estimate, body "<<currentBodyName;
+            std::cerr<<" not in body map "<<vectorParameterName->parameterType_.first<<std::endl;
+        }
+        else if( ( currentBodyName != "" ) )
+        {
+            currentBody = bodyMap.at( currentBodyName );
+        }
+
+        switch( vectorParameterName->parameterType_.first )
+        {
+        default:
+            std::cerr<<"Warning, this vector parameter ("<<vectorParameterName->parameterType_.first<<") has not yet been implemented when making parameters"<<std::endl;
+            break;
+        }
+    }
+
+    return vectorParameterToEstimate;
+}
+
+}
+
+}
diff --git a/Tudat/SimulationSetup/createEstimatableParameters.h b/Tudat/SimulationSetup/createEstimatableParameters.h
new file mode 100644
index 0000000..1b4f7d8
--- /dev/null
+++ b/Tudat/SimulationSetup/createEstimatableParameters.h
@@ -0,0 +1,131 @@
+#ifndef CREATEESTIMATABLEPARAMETERS_H
+#define CREATEESTIMATABLEPARAMETERS_H
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
+
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/estimatableParameter.h"
+#include "Tudat/Astrodynamics/OrbitDetermination/EstimatableParameters/initialTranslationalState.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.h"
+#include "Tudat/Astrodynamics/Propagators/dynamicsSimulator.h"
+#include "Tudat/SimulationSetup/body.h"
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+template< typename InitialStateParameterType = double >
+boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > > >
+createInitialDynamicalStateParameterToEstimate(
+        const NamedBodyMap& bodyMap,
+        const boost::shared_ptr< estimatable_parameters::EstimatableParameterSettings >& parameterSettings )
+{
+    using namespace tudat::estimatable_parameters;
+
+    boost::shared_ptr< EstimatableParameter< Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > > > initialStateParameterToEstimate;
+
+    if( !isParameterDynamicalPropertyInitialState( parameterSettings->parameterType_.first ) )
+    {
+        std::cerr<<"Error when requesting to make initial state parameter "<<parameterSettings->parameterType_.first<<" of "<<
+                   parameterSettings->parameterType_.second.first<<", parameter is not an initial state parameter "<<std::endl;
+    }
+    else
+    {
+        switch( parameterSettings->parameterType_.first )
+        {
+        case initial_body_state:
+            if( boost::dynamic_pointer_cast< InitialTranslationalStateEstimatableParameterSettings< InitialStateParameterType > >(
+                        parameterSettings ) == NULL )
+            {
+                std::cerr<<"Error when making body initial state parameter, settings type is incompatible"<<std::endl;
+            }
+            else
+            {
+                boost::shared_ptr< InitialTranslationalStateEstimatableParameterSettings< InitialStateParameterType > > initialStateSettings =
+                        boost::dynamic_pointer_cast< InitialTranslationalStateEstimatableParameterSettings< InitialStateParameterType > >(
+                            parameterSettings );
+
+                if( ! ( initialStateSettings->initialTime_ == initialStateSettings->initialTime_  ) )
+                {
+                    initialStateParameterToEstimate = boost::make_shared< InitialTranslationalStateParameter< InitialStateParameterType > >(
+                                initialStateSettings->parameterType_.second.first, initialStateSettings->initialStateValue_,
+                                initialStateSettings->centralBody_,
+                                initialStateSettings->frameOrientation_ );
+                }
+                else
+                {
+                    initialStateParameterToEstimate = boost::make_shared< InitialTranslationalStateParameter< InitialStateParameterType > >(
+                                initialStateSettings->parameterType_.second.first, propagators::getInitialStateOfBody
+                                < double, InitialStateParameterType >(
+                                    initialStateSettings->parameterType_.second.first, initialStateSettings->centralBody_, bodyMap,
+                                    initialStateSettings->initialTime_ ), initialStateSettings->centralBody_,
+                                initialStateSettings->frameOrientation_ );
+                }
+            }
+            break;
+        default:
+            std::cerr<<"Error, could not create parameter for initial state of type "<<parameterSettings->parameterType_.first<<std::endl;
+
+        }
+    }
+
+    return initialStateParameterToEstimate;
+}
+
+
+boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > createDoubleParameterToEstimate(
+        const boost::shared_ptr< estimatable_parameters::EstimatableParameterSettings >& doubleParameterName,
+        const NamedBodyMap& bodyMap, const basic_astrodynamics::AccelerationMap& accelerationModelMap = basic_astrodynamics::AccelerationMap( ) );
+
+boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > createVectorParameterToEstimate(
+        const boost::shared_ptr< estimatable_parameters::EstimatableParameterSettings >& vectorParameterName,
+        const NamedBodyMap& bodyMap, const basic_astrodynamics::AccelerationMap& accelerationModelMap = basic_astrodynamics::AccelerationMap( ) );
+
+template< typename InitialStateParameterType = double >
+boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< InitialStateParameterType > > createParametersToEstimate(
+        const std::vector< boost::shared_ptr< estimatable_parameters::EstimatableParameterSettings > >& parameterNames,
+        const NamedBodyMap& bodyMap,
+        const basic_astrodynamics::AccelerationMap& accelerationModelMap = basic_astrodynamics::AccelerationMap( ) )
+
+{
+    using namespace tudat::estimatable_parameters;
+
+    std::vector< boost::shared_ptr< EstimatableParameter< Eigen::Matrix< InitialStateParameterType, Eigen::Dynamic, 1 > > > >
+            initialDynamicalParametersToEstimate;
+    std::vector< boost::shared_ptr< EstimatableParameter< double > > > doubleParametersToEstimate;
+    std::vector< boost::shared_ptr< EstimatableParameter< Eigen::VectorXd > > > vectorParametersToEstimate;
+
+    for( unsigned int i = 0; i < parameterNames.size( ); i++ )
+    {
+        if( isParameterDynamicalPropertyInitialState( parameterNames.at( i )->parameterType_.first ) )
+        {
+            initialDynamicalParametersToEstimate.push_back( createInitialDynamicalStateParameterToEstimate< InitialStateParameterType >(
+                                                                bodyMap, parameterNames.at( i ) ) );
+        }
+        else if( isDoubleParameter( parameterNames[ i ]->parameterType_.first ) == true )
+        {
+            doubleParametersToEstimate.push_back( createDoubleParameterToEstimate(
+                                                      parameterNames[ i ], bodyMap, accelerationModelMap ) );
+        }
+        else if( isDoubleParameter( parameterNames[ i ]->parameterType_.first ) == false )
+        {
+            vectorParametersToEstimate.push_back( createVectorParameterToEstimate(
+                                                      parameterNames[ i ], bodyMap, accelerationModelMap ) );
+        }
+        else
+        {
+            std::cerr<<"Error, parameter type of "<<parameterNames[ i ]->parameterType_.second.first<<" of "<<parameterNames[ i ]->parameterType_.first<<" not recognized when making estimatable parameter set."<<std::endl;
+        }
+    }
+
+    return boost::make_shared< EstimatableParameterSet< InitialStateParameterType > >(
+                doubleParametersToEstimate, vectorParametersToEstimate, initialDynamicalParametersToEstimate );
+}
+
+
+}
+
+}
+
+#endif // CREATEESTIMATABLEPARAMETERS_H
diff --git a/Tudat/SimulationSetup/createFlightConditions.h b/Tudat/SimulationSetup/createFlightConditions.h
index f6c7cc4..01d62a7 100644
--- a/Tudat/SimulationSetup/createFlightConditions.h
+++ b/Tudat/SimulationSetup/createFlightConditions.h
@@ -220,33 +220,6 @@ public:
 
     //! Constructor.
     /*!
-    *  Constructor, omitting all moment coefficient data.
-    *  \param constantForceCoefficient Constant force coefficients.
-    *  \param referenceArea Reference area with which aerodynamic forces and moments are
-    *  non-dimensionalized.
-    *  \param areCoefficientsInAerodynamicFrame Boolean to define whether the aerodynamic
-    *  coefficients are defined in the aerodynamic frame (lift, drag, side force) or in the body
-    *  frame (typically denoted as Cx, Cy, Cz).
-    *  \param areCoefficientsInNegativeAxisDirection Boolean to define whether the aerodynamic
-    *  coefficients are positiver along tyhe positive axes of the body or aerodynamic frame
-    *  (see areCoefficientsInAerodynamicFrame). Note that for (lift, drag, side force), the
-    *  coefficients are typically defined in negative direction.
-    */
-    ConstantAerodynamicCoefficientSettings(
-            const double referenceArea,
-            const Eigen::Vector3d& constantForceCoefficient,
-            const bool areCoefficientsInAerodynamicFrame = 0,
-            const bool areCoefficientsInNegativeAxisDirection = 1 ):
-        AerodynamicCoefficientSettings(
-            constant_aerodynamic_coefficients, TUDAT_NAN, referenceArea,
-            TUDAT_NAN, Eigen::Vector3d::Zero( ),
-            std::vector< aerodynamics::AerodynamicCoefficientsIndependentVariables >( ),
-            areCoefficientsInAerodynamicFrame, areCoefficientsInNegativeAxisDirection ),
-        constantForceCoefficient_( constantForceCoefficient ),
-        constantMomentCoefficient_( Eigen::Vector3d::Zero( ) ){ }
-
-    //! Constructor.
-    /*!
      *  Constructor.
      *  \param constantForceCoefficient Constant force coefficients.
      *  \param constantMomentCoefficient Constant moment coefficients.
@@ -283,6 +256,34 @@ public:
         constantMomentCoefficient_( constantMomentCoefficient )
     { }
 
+   //! Constructor.
+    /*!
+    *  Constructor, omitting all moment coefficient data.
+    *  \param constantForceCoefficient Constant force coefficients.
+    *  \param referenceArea Reference area with which aerodynamic forces and moments are
+    *  non-dimensionalized.
+    *  \param areCoefficientsInAerodynamicFrame Boolean to define whether the aerodynamic
+    *  coefficients are defined in the aerodynamic frame (lift, drag, side force) or in the body
+    *  frame (typically denoted as Cx, Cy, Cz).
+    *  \param areCoefficientsInNegativeAxisDirection Boolean to define whether the aerodynamic
+    *  coefficients are positiver along tyhe positive axes of the body or aerodynamic frame
+    *  (see areCoefficientsInAerodynamicFrame). Note that for (lift, drag, side force), the
+    *  coefficients are typically defined in negative direction.
+    */
+    ConstantAerodynamicCoefficientSettings(
+            const double referenceArea,
+            const Eigen::Vector3d& constantForceCoefficient,
+            const bool areCoefficientsInAerodynamicFrame = 0,
+            const bool areCoefficientsInNegativeAxisDirection = 1 ):
+        AerodynamicCoefficientSettings(
+            constant_aerodynamic_coefficients, TUDAT_NAN, referenceArea,
+            TUDAT_NAN, Eigen::Vector3d::Zero( ),
+            std::vector< aerodynamics::AerodynamicCoefficientsIndependentVariables >( ),
+            areCoefficientsInAerodynamicFrame, areCoefficientsInNegativeAxisDirection ),
+        constantForceCoefficient_( constantForceCoefficient ),
+        constantMomentCoefficient_( Eigen::Vector3d::Zero( ) ){ }
+
+
     //! Function to return constant force coefficients.
     /*!
      *  Function to return constant force coefficients.
@@ -616,4 +617,5 @@ boost::shared_ptr< aerodynamics::FlightConditions > createFlightConditions(
 } // namespace simulation_setup
 
 } // namespace tudat
+
 #endif // TUDAT_CREATEACCELERATIONMODELS_H
diff --git a/Tudat/SimulationSetup/createStateDerivativePartials.cpp b/Tudat/SimulationSetup/createStateDerivativePartials.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/Tudat/SimulationSetup/createStateDerivativePartials.h b/Tudat/SimulationSetup/createStateDerivativePartials.h
new file mode 100644
index 0000000..912fc47
--- /dev/null
+++ b/Tudat/SimulationSetup/createStateDerivativePartials.h
@@ -0,0 +1,83 @@
+#ifndef CREATESTATEDERIVATIVEPARTIALS_H
+#define CREATESTATEDERIVATIVEPARTIALS_H
+
+#include "Tudat/Astrodynamics/OrbitDetermination/stateDerivativePartial.h"
+#include "Tudat/Astrodynamics/Propagators/propagationSettings.h"
+#include "Tudat/Astrodynamics/Propagators/singleStateTypeDerivative.h"
+#include "Tudat/Astrodynamics/Propagators/nBodyStateDerivative.h"
+#include "Tudat/SimulationSetup/createAccelerationPartials.h"
+
+namespace tudat
+{
+
+namespace orbit_determination
+{
+
+namespace partial_derivatives
+{
+
+//! Function to create a set of state derivative partial objects.
+/*!
+ *  Function to create a set of state derivative partial objects for any propagated state types.
+ *  \param stateDerivativeModels List of state derivative models, ordered by state type (key)
+ *  \param bodyMap List of boy objects storing environment models of simulation
+ *  \param parametersToEstimate Object containing all parameters that are to be estimated and their current settings and
+ *  values.
+ *  return List partials of state derivative models from. The key is the type of dynamics for which partials are taken,
+ *  the values are StateDerivativePartialsMap (see StateDerivativePartialsMap definition for details).
+ */
+template< typename StateScalarType, typename TimeType, typename InitialStateParameterType >
+std::map< propagators::IntegratedStateType, StateDerivativePartialsMap > createStateDerivativePartials(
+        const std::unordered_map< propagators::IntegratedStateType,
+        std::vector< boost::shared_ptr< propagators::SingleStateTypeDerivative< StateScalarType, TimeType > > > >
+        stateDerivativeModels,
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< InitialStateParameterType > >
+        parametersToEstimate )
+{
+    std::map< propagators::IntegratedStateType, StateDerivativePartialsMap > stateDerivativePartials;
+
+    // Iterate over all state types
+    for( typename std::unordered_map< propagators::IntegratedStateType,
+         std::vector< boost::shared_ptr< propagators::SingleStateTypeDerivative< StateScalarType, TimeType > > > >::
+         const_iterator stateDerivativeIterator = stateDerivativeModels.begin( );
+         stateDerivativeIterator != stateDerivativeModels.end( );
+         stateDerivativeIterator++ )
+    {
+        // Identify state types
+        switch( stateDerivativeIterator->first )
+        {
+        case propagators::transational_state:
+        {
+            if( stateDerivativeIterator->second.size( ) > 1 )
+            {
+                throw std::runtime_error(
+                            "Error, cannot yet process multiple separate same type propagators when making partial derivatives of translational state." );
+            }
+            else
+            {
+                // Retrieve acceleration models and create partials
+                basic_astrodynamics::AccelerationMap accelerationModelList =
+                        boost::dynamic_pointer_cast< propagators::NBodyStateDerivative< StateScalarType, TimeType > >(
+                            stateDerivativeIterator->second.at( 0 ) )->getFullAccelerationsMap( );
+                stateDerivativePartials[ propagators::transational_state ] =
+                        createAccelerationPartialsMap< InitialStateParameterType >(
+                            accelerationModelList, bodyMap, parametersToEstimate );
+            }
+            break;
+        }
+        default:
+            std::string errorMessage = "Cannot yet create state derivative partial models for type " +
+                    boost::lexical_cast< std::string >( stateDerivativeIterator->first );
+            throw std::runtime_error( errorMessage );
+        }
+    }
+    return stateDerivativePartials;
+}
+
+}
+
+}
+
+}
+#endif // CREATESTATEDERIVATIVEPARTIALS_H
