diff --git a/Tudat/Astrodynamics/Aerodynamics/CMakeLists.txt b/Tudat/Astrodynamics/Aerodynamics/CMakeLists.txt
index 208fbd1..8cbb11c 100644
--- a/Tudat/Astrodynamics/Aerodynamics/CMakeLists.txt
+++ b/Tudat/Astrodynamics/Aerodynamics/CMakeLists.txt
@@ -80,7 +80,7 @@ setup_tudat_library_target(tudat_aerodynamics "${SRCROOT}{AERODYNAMICSDIR}")
 # Add unit tests.
 add_executable(test_AerodynamicMomentAndAerodynamicForce "${SRCROOT}${AERODYNAMICSDIR}/UnitTests/unitTestAerodynamicMomentAndAerodynamicForce.cpp")
 setup_custom_test_program(test_AerodynamicMomentAndAerodynamicForce "${SRCROOT}${AERODYNAMICSDIR}")
-target_link_libraries(test_AerodynamicMomentAndAerodynamicForce tudat_simulation_setup tudat_aerodynamics tudat_reference_frames tudat_ephemerides tudat_basic_mathematics ${Boost_LIBRARIES})
+target_link_libraries(test_AerodynamicMomentAndAerodynamicForce tudat_simulation_setup tudat_aerodynamics tudat_reference_frames tudat_ephemerides tudat_basic_astrodynamics tudat_basic_mathematics ${Boost_LIBRARIES})
 
 add_executable(test_AerodynamicsNamespace "${SRCROOT}${AERODYNAMICSDIR}/UnitTests/unitTestAerodynamicsNamespace.cpp")
 setup_custom_test_program(test_AerodynamicsNamespace "${SRCROOT}${AERODYNAMICSDIR}")
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/CMakeLists.txt b/Tudat/Astrodynamics/BasicAstrodynamics/CMakeLists.txt
index c4be163..a5dfdc7 100755
--- a/Tudat/Astrodynamics/BasicAstrodynamics/CMakeLists.txt
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/CMakeLists.txt
@@ -49,6 +49,8 @@ set(BASICASTRODYNAMICS_SOURCES
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/astrodynamicsFunctions.cpp"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/physicalConstants.cpp"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/bodyShapeModel.cpp"
+  "${SRCROOT}${BASICASTRODYNAMICSDIR}/sphericalStateConversions.cpp"
+
 )
 
 # Set the header files.
@@ -74,6 +76,7 @@ set(BASICASTRODYNAMICS_HEADERS
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/bodyShapeModel.h"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/oblateSpheroidBodyShapeModel.h"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/sphericalBodyShapeModel.h"
+  "${SRCROOT}${BASICASTRODYNAMICSDIR}/sphericalStateConversions.h"
 )
 
 # Add static libraries.
@@ -145,6 +148,10 @@ add_executable(test_GeodeticCoordinateConversions "${SRCROOT}${BASICASTRODYNAMIC
 setup_custom_test_program(test_GeodeticCoordinateConversions "${SRCROOT}${BASICASTRODYNAMICSDIR}")
 target_link_libraries(test_GeodeticCoordinateConversions tudat_basic_astrodynamics tudat_basic_mathematics ${Boost_LIBRARIES})
 
+add_executable(test_SphericalOrbitalStateConversions "${SRCROOT}${BASICASTRODYNAMICSDIR}/UnitTests/unitTestSphericalOrbitStateConversions.cpp")
+setup_custom_test_program(test_SphericalOrbitalStateConversions "${SRCROOT}${BASICASTRODYNAMICSDIR}")
+target_link_libraries(test_SphericalOrbitalStateConversions tudat_basic_astrodynamics tudat_reference_frames tudat_basic_mathematics ${Boost_LIBRARIES})
+
 add_executable(test_BodyShapeModels "${SRCROOT}${BASICASTRODYNAMICSDIR}/UnitTests/unitTestBodyShapeModels.cpp")
 setup_custom_test_program(test_BodyShapeModels "${SRCROOT}${BASICASTRODYNAMICSDIR}")
 target_link_libraries(test_BodyShapeModels tudat_basic_astrodynamics tudat_basic_mathematics ${Boost_LIBRARIES})
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestSphericalOrbitStateConversions.cpp b/Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestSphericalOrbitStateConversions.cpp
index 8b13789..5e17bfc 100644
--- a/Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestSphericalOrbitStateConversions.cpp
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestSphericalOrbitStateConversions.cpp
@@ -1 +1,107 @@
 
+#define BOOST_TEST_MAIN
+
+#include <iostream>
+
+#include <boost/test/unit_test.hpp>
+
+#include <Eigen/Core>
+
+#include "Tudat/Basics/testMacros.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/unitConversions.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/sphericalStateConversions.h"
+#include "Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h"
+
+namespace tudat
+{
+namespace unit_tests
+{
+
+using namespace orbital_element_conversions;
+using namespace unit_conversions;
+using namespace reference_frames;
+
+BOOST_AUTO_TEST_SUITE( test_spherical_state_conversions )
+
+//! Test inertial to rotating planetocentric frame transformations, using Matlab script of Erwin
+//! Mooij to generate reference data.
+BOOST_AUTO_TEST_CASE( testSphericalStateConversions )
+{
+    // Test case 1: arbitrary rotation
+    {
+        basic_mathematics::Vector6d cartesianState;
+        cartesianState<<-1656517.23153109, -5790058.28764025, -2440584.88186829,
+                6526.30784888051, -2661.34558272018, 2377.09572383163;
+
+        double testHeadingAngle = 1.229357188236127;
+        double testFlightPathAngle = -0.024894033070522;
+        double testLatitude = -0.385027359562548;
+        double testLongitude = -1.849449608688977;
+        double radius = cartesianState.segment( 0, 3 ).norm( );
+        double speed = cartesianState.segment( 3, 3 ).norm( );
+
+        basic_mathematics::Vector6d sphericalOrbitState  = convertCartesianToSphericalOrbitalState(
+                    cartesianState );
+        basic_mathematics::Vector6d reconvertedCartesianState  = convertSphericalOrbitalToCartesianState(
+                    sphericalOrbitState );
+        std::cout<<( sphericalOrbitState.transpose( ) )<<std::endl;
+
+        std::cout<<( reconvertedCartesianState.transpose( ) )<<std::endl<<
+                   ( cartesianState ).transpose( )<<std::endl;
+        std::cout<<( reconvertedCartesianState.segment( 3, 3 ).norm( ) )<<std::endl<<
+                   ( cartesianState ).segment( 3, 3 ).norm( )<<std::endl;
+        sleep( 10000.0 );
+
+    }
+
+    // Test case 2: rotation with zero and half pi angles.
+    {
+        basic_mathematics::Vector6d cartesianState;
+        cartesianState<<0.0, 6498098.09700000, 0.0, 0.0, 0.0, 7.438147520000000e+03;
+
+        double testHeadingAngle = 0.0;
+        double testFlightPathAngle = 0.0;
+        double testLatitude = 0.0;
+        double testLongitude = mathematical_constants::PI / 2.0;
+        double radius = cartesianState.segment( 0, 3 ).norm( );
+        double speed = cartesianState.segment( 3, 3 ).norm( );
+
+        basic_mathematics::Vector6d sphericalOrbitState  = convertCartesianToSphericalOrbitalState(
+                    cartesianState );
+        basic_mathematics::Vector6d reconvertedCartesianState  = convertSphericalOrbitalToCartesianState(
+                    sphericalOrbitState );
+        std::cout<<( reconvertedCartesianState - cartesianState ).transpose( )<<std::endl;
+
+
+    }
+
+    // Test case 3: rotation with zero and half pi angles.
+    {
+        basic_mathematics::Vector6d cartesianState;
+        cartesianState<<0.0, 0.0, 6.498098097000000e3, -7.438147520000000e3, 0.0, 0.0;
+
+        double testHeadingAngle = 0.0;
+        double testFlightPathAngle = 0.0;
+        double testLatitude = mathematical_constants::PI / 2.0;
+        double testLongitude = 0.0;
+        double radius = cartesianState.segment( 0, 3 ).norm( );
+        double speed = cartesianState.segment( 3, 3 ).norm( );
+
+        basic_mathematics::Vector6d sphericalOrbitState  = convertCartesianToSphericalOrbitalState(
+                    cartesianState );
+        basic_mathematics::Vector6d reconvertedCartesianState  = convertSphericalOrbitalToCartesianState(
+                    sphericalOrbitState );
+        std::cout<<( reconvertedCartesianState - cartesianState ).transpose( )<<std::endl;
+
+    }
+
+
+
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+} // namespace unit_tests
+} // namespace tudat
+
+
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/sphericalStateConversions.cpp b/Tudat/Astrodynamics/BasicAstrodynamics/sphericalStateConversions.cpp
index 8b13789..7de4302 100644
--- a/Tudat/Astrodynamics/BasicAstrodynamics/sphericalStateConversions.cpp
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/sphericalStateConversions.cpp
@@ -1 +1,80 @@
+#include <iostream>
 
+#include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
+#include "Tudat/Mathematics/BasicMathematics/coordinateConversions.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/stateVectorIndices.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/sphericalStateConversions.h"
+#include "Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h"
+
+namespace tudat
+{
+
+namespace orbital_element_conversions
+{
+
+//! Calculate current heading angle.
+double calculateHeadingAngle( const Eigen::Vector3d& velocityInVerticalFrame )
+{
+    return std::atan2( velocityInVerticalFrame( 1 ), velocityInVerticalFrame( 0 ) );
+}
+
+//! Calculatre current flight path angle.
+double calculateFlightPathAngle( const Eigen::Vector3d& velocityInVerticalFrame )
+{
+    return -std::asin( velocityInVerticalFrame( 2 ) / velocityInVerticalFrame.norm( ) );
+}
+
+basic_mathematics::Vector6d convertCartesianToSphericalOrbitalState(
+        const basic_mathematics::Vector6d& bodyFixedCartesianState )
+{
+    Eigen::Vector3d sphericalPosition = coordinate_conversions::convertCartesianToSpherical(
+                bodyFixedCartesianState.segment( 0, 3 ) );
+    basic_mathematics::Vector6d sphericalOrbitalState;
+    sphericalOrbitalState( radiusIndex ) = sphericalPosition( 0 );
+    sphericalOrbitalState( latitudeIndex ) = mathematical_constants::PI / 2.0 - sphericalPosition( 1 );
+    sphericalOrbitalState( longitudeIndex ) = sphericalPosition( 2 );
+
+    Eigen::Vector3d verticalFrameVelocity =
+            reference_frames::getRotatingPlanetocentricToLocalVerticalFrameTransformationQuaternion(
+                sphericalOrbitalState( longitudeIndex ), sphericalOrbitalState( latitudeIndex ) ) *
+            bodyFixedCartesianState.segment( 3, 3 );
+
+    std::cout<<"Vert. frame: "<<verticalFrameVelocity.transpose( )<<std::endl;
+    std::cout<<"Fixed. frame: "<<bodyFixedCartesianState.transpose( )<<std::endl;
+
+    sphericalOrbitalState( speedIndex ) = verticalFrameVelocity.norm( );
+    sphericalOrbitalState( flightPathIndex ) = calculateFlightPathAngle( verticalFrameVelocity );
+    sphericalOrbitalState( headingAngleIndex ) = calculateHeadingAngle( verticalFrameVelocity );
+
+    return sphericalOrbitalState;
+
+}
+
+basic_mathematics::Vector6d convertSphericalOrbitalToCartesianState(
+        const basic_mathematics::Vector6d& sphericalOrbitalState )
+{
+    basic_mathematics::Vector6d cartesianState;
+
+    Eigen::Vector3d sphericalPosition = sphericalOrbitalState.segment( 0, 3 );
+    sphericalPosition( 1 ) = mathematical_constants::PI / 2.0 - sphericalOrbitalState( 1 );
+    cartesianState.segment( 0, 3 ) = coordinate_conversions::convertSphericalToCartesian(
+                sphericalPosition );
+    Eigen::Vector3d velocityInVerticalFrame;
+    velocityInVerticalFrame( 0 ) = sphericalOrbitalState( speedIndex ) *
+            std::cos( sphericalOrbitalState( flightPathIndex ) ) *
+             std::cos( sphericalOrbitalState( headingAngleIndex ) );
+    velocityInVerticalFrame( 1 ) = sphericalOrbitalState( speedIndex ) *
+            std::cos( sphericalOrbitalState( flightPathIndex ) ) *
+             std::sin( sphericalOrbitalState( headingAngleIndex ) );
+    velocityInVerticalFrame( 2 ) = -sphericalOrbitalState( speedIndex ) *
+            std::sin( sphericalOrbitalState( flightPathIndex ) );
+
+    cartesianState.segment( 3, 3 ) = reference_frames::getLocalVerticalToRotatingPlanetocentricFrameTransformationQuaternion(
+                sphericalOrbitalState( longitudeIndex ), sphericalOrbitalState( latitudeIndex ) ) * velocityInVerticalFrame;
+
+    return cartesianState;
+}
+
+}
+
+}
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/sphericalStateConversions.h b/Tudat/Astrodynamics/BasicAstrodynamics/sphericalStateConversions.h
index 89f9580..9c33677 100644
--- a/Tudat/Astrodynamics/BasicAstrodynamics/sphericalStateConversions.h
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/sphericalStateConversions.h
@@ -1,4 +1,41 @@
-#ifndef SPHERICALSTATECONVERSIONS_H
-#define SPHERICALSTATECONVERSIONS_H
+#ifndef SPHERICALSTATECONVERSIONS_CPP
+#define SPHERICALSTATECONVERSIONS_CPP
 
-#endif // SPHERICALSTATECONVERSIONS_H
+#include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+#include "Tudat/Mathematics/BasicMathematics/coordinateConversions.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/stateVectorIndices.h"
+#include "Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h"
+
+namespace tudat
+{
+
+namespace orbital_element_conversions
+{
+
+//! Calculate current heading angle.
+/*!
+ * Calculate heading angle from velocity in vertical (LVLH) frame.
+ * \param velocityInVerticalFrame Current Cartesian velocity in vertical frame.
+ * \return Current heading angle.
+ */
+double calculateHeadingAngle( const Eigen::Vector3d& velocityInVerticalFrame );
+
+//! Calculate current flight path angle. Angle is defined positive upwards.
+/*!
+ *  Calculate flight path angle from velocity in vertical (LVLH) frame.
+ *  Angle is defined positive upwards.
+ *  \param velocityInVerticalFrame Current Cartesian velocity in vertical frame.
+ *  \return Current flight path angle.
+ */
+double calculateFlightPathAngle( const Eigen::Vector3d& velocityInVerticalFrame );
+
+basic_mathematics::Vector6d convertCartesianToSphericalOrbitalState(
+        const basic_mathematics::Vector6d& bodyFixedCartesianState );
+
+basic_mathematics::Vector6d convertSphericalOrbitalToCartesianState(
+        const basic_mathematics::Vector6d& sphericalOrbitalState );
+}
+
+}
+#endif // SPHERICALSTATECONVERSIONS_CPP
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/stateVectorIndices.h b/Tudat/Astrodynamics/BasicAstrodynamics/stateVectorIndices.h
index a5e273f..9df28fd 100644
--- a/Tudat/Astrodynamics/BasicAstrodynamics/stateVectorIndices.h
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/stateVectorIndices.h
@@ -75,6 +75,16 @@ enum ModifiedEquinoctialElementVectorIndices
     trueLongitudeIndex
 };
 
+enum SphericalStateElementIndices
+{
+    radiusIndex,
+    latitudeIndex,
+    longitudeIndex,
+    speedIndex,
+    flightPathIndex,
+    headingAngleIndex
+};
+
 //! Cartesian acceleration indices.
 enum CartesianAccelerationElementIndices
 {
diff --git a/Tudat/Astrodynamics/ReferenceFrames/CMakeLists.txt b/Tudat/Astrodynamics/ReferenceFrames/CMakeLists.txt
index 0b14c10..bc32dc1 100755
--- a/Tudat/Astrodynamics/ReferenceFrames/CMakeLists.txt
+++ b/Tudat/Astrodynamics/ReferenceFrames/CMakeLists.txt
@@ -62,4 +62,4 @@ target_link_libraries(test_ApparentAccelerationModel tudat_reference_frames ${Bo
 
 add_executable(test_AerodynamicAngleCalculator "${SRCROOT}${REFERENCEFRAMESDIR}/UnitTests/unitTestAerodynamicAngleCalculator.cpp")
 setup_custom_test_program(test_AerodynamicAngleCalculator "${SRCROOT}${REFERENCEFRAMESDIR}")
-target_link_libraries(test_AerodynamicAngleCalculator tudat_reference_frames tudat_basic_mathematics ${Boost_LIBRARIES})
+target_link_libraries(test_AerodynamicAngleCalculator tudat_reference_frames tudat_basic_astrodynamics tudat_basic_mathematics ${Boost_LIBRARIES})
diff --git a/Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.cpp b/Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.cpp
index 50fbc73..641f5b8 100644
--- a/Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.cpp
+++ b/Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.cpp
@@ -12,6 +12,7 @@
 #include <boost/shared_ptr.hpp>
 #include <boost/lexical_cast.hpp>
 
+#include "Tudat/Astrodynamics/BasicAstrodynamics/sphericalStateConversions.h"
 #include "Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.h"
 #include "Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h"
 #include "Tudat/Mathematics/BasicMathematics/coordinateConversions.h"
@@ -48,9 +49,10 @@ void AerodynamicAngleCalculator::update( )
                     currentAerodynamicAngles_.at( latitude_angle ) ) *
                 currentBodyFixedState_.segment( 3, 3 );
 
-        currentAerodynamicAngles_[ heading_angle ] = calculateHeadingAngle( verticalFrameVelocity );
+        currentAerodynamicAngles_[ heading_angle ] =
+                orbital_element_conversions::calculateHeadingAngle( verticalFrameVelocity );
         currentAerodynamicAngles_[ flight_path_angle ] =
-                calculateFlightPathAngle( verticalFrameVelocity );
+                orbital_element_conversions::calculateFlightPathAngle( verticalFrameVelocity );
 
         currentAerodynamicAngles_[ angle_of_attack ] = angleOfAttackFunction_( );
         currentAerodynamicAngles_[ angle_of_sideslip ] = angleOfSideslipFunction_( );
diff --git a/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.cpp b/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.cpp
index 35ffcfe..22dd5ae 100644
--- a/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.cpp
+++ b/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.cpp
@@ -358,18 +358,6 @@ Eigen::Quaterniond getAirspeedBasedAerodynamicToBodyFrameTransformationQuaternio
             angleOfAttack, angleOfSideslip ).inverse( );
 }
 
-//! Calculate current heading angle.
-double calculateHeadingAngle( const Eigen::Vector3d& velocityInVerticalFrame )
-{
-    return std::atan2( velocityInVerticalFrame( 1 ), velocityInVerticalFrame( 0 ) );
-}
-
-//! Calculatre current flight path angle.
-double calculateFlightPathAngle( const Eigen::Vector3d& velocityInVerticalFrame )
-{
-    return -std::asin( velocityInVerticalFrame( 2 ) / velocityInVerticalFrame.norm( ) );
-}
-
 
 } // namespace reference_frames
 } // namespace tudat
diff --git a/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h b/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h
index 4817599..0714369 100644
--- a/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h
+++ b/Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h
@@ -398,22 +398,6 @@ Eigen::Matrix3d getAirspeedBasedAerodynamicToBodyFrameTransformationMatrix(
 Eigen::Quaterniond getAirspeedBasedAerodynamicToBodyFrameTransformationQuaternion(
         const double angleOfAttack, const double angleOfSideslip );
 
-//! Calculate current heading angle.
-/*!
- * Calculate heading angle from velocity in vertical (LVLH) frame.
- * \param velocityInVerticalFrame Current Cartesian velocity in vertical frame.
- * \return Current heading angle.
- */
-double calculateHeadingAngle( const Eigen::Vector3d& velocityInVerticalFrame );
-
-//! Calculate current flight path angle. Angle is defined positive upwards.
-/*!
- *  Calculate flight path angle from velocity in vertical (LVLH) frame.
- *  Angle is defined positive upwards.
- *  \param velocityInVerticalFrame Current Cartesian velocity in vertical frame.
- *  \return Current flight path angle.
- */
-double calculateFlightPathAngle( const Eigen::Vector3d& velocityInVerticalFrame );
 
 } // namespace reference_frames
 } // namespace tudat
