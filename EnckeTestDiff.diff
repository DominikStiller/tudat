diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h b/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h
index 3a689da..d1b16e5 100644
--- a/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h
@@ -72,6 +72,10 @@ class AccelerationModel
 {
 public:
 
+    //! Constructor
+    AccelerationModel( ):
+        currentTime_( TUDAT_NAN ){ }
+
     //! Virtual destructor.
     /*!
      * Virtual destructor, necessary to ensure that derived class destructors get called correctly.
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h b/Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h
index a68f5ed..5240939 100644
--- a/Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h
@@ -147,7 +147,8 @@ Eigen::Matrix< ScalarType, 6, 1 > propagateKeplerOrbit(
         const ScalarType finalEccentricAnomaly =
                 convertMeanAnomalyToEccentricAnomaly< ScalarType >(
                     initialStateInKeplerianElements( eccentricityIndex ),
-                    initialMeanAnomaly + meanAnomalyChange );
+                    initialMeanAnomaly + meanAnomalyChange, false,
+                    TUDAT_NAN, aRootFinder );
 
         // Compute true anomaly for computed eccentric anomaly.
         finalStateInKeplerianElements( trueAnomalyIndex ) =
diff --git a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestEnckeStateDerivative.cpp b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestEnckeStateDerivative.cpp
index 6203f61..4379576 100644
--- a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestEnckeStateDerivative.cpp
+++ b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestEnckeStateDerivative.cpp
@@ -31,192 +31,192 @@ namespace unit_tests
 
 BOOST_AUTO_TEST_SUITE( test_encke_propagator )
 
-//BOOST_AUTO_TEST_CASE( testEnckePopagatorForPointMassCentralBodies )
-//{
-
-//    for( unsigned int simulationCase = 0; simulationCase < 2; simulationCase++ )
-//    {
-//        //Using declarations.
-//        using namespace tudat::interpolators;
-//        using namespace tudat::numerical_integrators;
-//        using namespace tudat::spice_interface;
-//        using namespace tudat::simulation_setup;
-//        using namespace tudat::basic_astrodynamics;
-//        using namespace tudat::orbital_element_conversions;
-//        using namespace tudat::propagators;
-
-
-//        //Load spice kernels.
-//        std::string kernelsPath = input_output::getSpiceKernelPath( );
-//        spice_interface::loadSpiceKernelInTudat( kernelsPath + "de-403-masses.tpc");
-//        spice_interface::loadSpiceKernelInTudat( kernelsPath + "naif0009.tls");
-//        spice_interface::loadSpiceKernelInTudat( kernelsPath + "pck00009.tpc");
-//        spice_interface::loadSpiceKernelInTudat( kernelsPath + "de421.bsp");
-
-//        unsigned int totalNumberOfBodies = 7;
-//        std::vector< std::string > bodyNames;
-//        bodyNames.resize( totalNumberOfBodies );
-//        bodyNames[ 0 ] = "Earth";
-//        bodyNames[ 1 ] = "Mars";
-//        bodyNames[ 2 ] = "Sun";
-//        bodyNames[ 3 ] = "Venus";
-//        bodyNames[ 4 ] = "Moon";
-//        bodyNames[ 5 ] = "Mercury";
-//        bodyNames[ 6 ] = "Jupiter";
-
-//        double initialEphemerisTime = 1.0E7;
-//        double finalEphemerisTime = 2.0E7;
-//        double maximumTimeStep = 3600.0;
-//        double buffer = 5.0 * maximumTimeStep;
-
-//        // Create bodies needed in simulation
-//        NamedBodyMap bodyMap = createBodies(
-//                    getDefaultBodySettings( bodyNames, initialEphemerisTime - buffer, finalEphemerisTime + buffer ) );
-//        setGlobalFrameBodyEphemerides( bodyMap, "SSB", "ECLIPJ2000" );
-
-//        // Set accelerations between bodies that are to be taken into account.
-//        SelectedAccelerationMap accelerationMap;
-//        std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfEarth;
-//        accelerationsOfEarth[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
-//        accelerationsOfEarth[ "Moon" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
-//        accelerationsOfEarth[ "Jupiter" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
-//        accelerationMap[ "Earth" ] = accelerationsOfEarth;
-
-//        std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfMars;
-//        accelerationsOfMars[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
-//        accelerationsOfMars[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
-//        accelerationsOfMars[ "Jupiter" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
-//        accelerationMap[ "Mars" ] = accelerationsOfMars;
-
-//        std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfMoon;
-//        accelerationsOfMoon[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
-//        accelerationsOfMoon[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
-//        accelerationsOfMoon[ "Jupiter" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
-//        accelerationMap[ "Moon" ] = accelerationsOfMoon;
-
-//        std::vector< std::string > bodiesToPropagate;
-//        bodiesToPropagate.push_back( "Earth" );
-//        bodiesToPropagate.push_back( "Mars" );
-//        bodiesToPropagate.push_back( "Moon" );
-
-//        unsigned int numberOfNumericalBodies = bodiesToPropagate.size( );
-
-//        std::vector< std::string > centralBodies;
-//        std::map< std::string, std::string > centralBodyMap;
-//        centralBodies.resize( numberOfNumericalBodies );
-
-//        for( int i = 0; i < 3; i++ )
-//        {
-//            if( i == 2 && simulationCase == 1 )
-//            {
-//                centralBodies[ i ] = "Earth";
-//            }
-//            else
-//            {
-//                centralBodies[ i ] = "Sun";
-//            }
-//            centralBodyMap[ bodiesToPropagate[ i ] ] = centralBodies[ i ];
-//        }
-
-
-
-//        Eigen::VectorXd systemInitialState = Eigen::VectorXd( bodiesToPropagate.size( ) * 6 );
-//        for( unsigned int i = 0; i < numberOfNumericalBodies ; i++ )
-//        {
-//            systemInitialState.segment( i * 6 , 6 ) =
-//                    bodyMap[ bodiesToPropagate[ i ] ]->getStateInBaseFrameFromEphemeris( initialEphemerisTime ) -
-//                    bodyMap[ centralBodies[ i ] ]->getStateInBaseFrameFromEphemeris( initialEphemerisTime );
-//        }
-
-//        AccelerationMap accelerationModelMap = createAccelerationModelsMap(
-//                    bodyMap, accelerationMap, centralBodyMap );
-
-//        boost::shared_ptr< IntegratorSettings< > > integratorSettings =
-//                boost::make_shared< IntegratorSettings< > >
-//                ( rungeKutta4,
-//                  initialEphemerisTime, finalEphemerisTime, 250.0 );
-
-//        boost::shared_ptr< TranslationalStatePropagatorSettings< double > > propagatorSettings =
-//                boost::make_shared< TranslationalStatePropagatorSettings< double > >
-//                ( centralBodies, accelerationModelMap, bodiesToPropagate, systemInitialState );
-
-//        SingleArcDynamicsSimulator< double > dynamicsSimulator2(
-//                    bodyMap, integratorSettings, propagatorSettings, true );
-
-//        double initialTestTime = initialEphemerisTime + 10.0 * maximumTimeStep;
-//        double finalTestTime = finalEphemerisTime - 10.0 * maximumTimeStep;
-//        double testTimeStep = 1.0E4;
-
-//        double currentTestTime = initialTestTime;
-//        std::map< double, Eigen::Matrix< double, 18, 1 > > cowellIntegrationResults;
-//        while( currentTestTime < finalTestTime )
-//        {
-//            cowellIntegrationResults[ currentTestTime ].segment( 0, 6 ) = bodyMap[ "Earth" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
-//            cowellIntegrationResults[ currentTestTime ].segment( 6, 6 ) = bodyMap[ "Mars" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
-//            cowellIntegrationResults[ currentTestTime ].segment( 12, 6 ) = bodyMap[ "Moon" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
-
-//            currentTestTime += testTimeStep;
-//        }
-
-
-//        propagatorSettings = boost::make_shared< TranslationalStatePropagatorSettings< double > >
-//                ( centralBodies, accelerationModelMap, bodiesToPropagate, systemInitialState, encke );
-
-//        SingleArcDynamicsSimulator< double > dynamicsSimulator(
-//                    bodyMap, integratorSettings, propagatorSettings, true );
-
-//        currentTestTime = initialTestTime;
-//        std::map< double, Eigen::Matrix< double, 18, 1 > > enckeIntegrationResults;
-//        while( currentTestTime < finalTestTime )
-//        {
-//            enckeIntegrationResults[ currentTestTime ].segment( 0, 6 ) = bodyMap[ "Earth" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
-//            enckeIntegrationResults[ currentTestTime ].segment( 6, 6 ) = bodyMap[ "Mars" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
-//            enckeIntegrationResults[ currentTestTime ].segment( 12, 6 ) = bodyMap[ "Moon" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
-//            currentTestTime += testTimeStep;
-//        }
-
-//        std::map< double, Eigen::Matrix< double, 18, 1 > >::iterator enckeIterator = enckeIntegrationResults.begin( );
-//        std::map< double, Eigen::Matrix< double, 18, 1 > >::iterator cowellIterator = cowellIntegrationResults.begin( );
-
-//        for( unsigned int i = 0; i < enckeIntegrationResults.size( ); i++ )
-//        {
-//            for( int j= 0; j< 3; j++ )
-//            {
-//                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 0.01 );
-//            }
-
-//            for( int j = 6; j < 9; j++ )
-//            {
-//                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 0.01 );
-//            }
-
-//            for( int j = 12; j < 15; j++ )
-//            {
-//                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 0.075 );
-//            }
-
-//            for( int j = 3; j < 6; j++ )
-//            {
-//                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 1.0E-8 );
-
-//            }
-
-//            for( int j = 9; j < 12; j++ )
-//            {
-//                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 1.0E-8 );
-
-//            }
-
-//            for( int j = 15; j < 18; j++ )
-//            {
-//                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 1.0E-6 );
-
-//            }
-//            enckeIterator++;
-//            cowellIterator++;
-//        }
-//    }
-//}
+BOOST_AUTO_TEST_CASE( testEnckePopagatorForPointMassCentralBodies )
+{
+
+    for( unsigned int simulationCase = 0; simulationCase < 2; simulationCase++ )
+    {
+        //Using declarations.
+        using namespace tudat::interpolators;
+        using namespace tudat::numerical_integrators;
+        using namespace tudat::spice_interface;
+        using namespace tudat::simulation_setup;
+        using namespace tudat::basic_astrodynamics;
+        using namespace tudat::orbital_element_conversions;
+        using namespace tudat::propagators;
+
+
+        //Load spice kernels.
+        std::string kernelsPath = input_output::getSpiceKernelPath( );
+        spice_interface::loadSpiceKernelInTudat( kernelsPath + "de-403-masses.tpc");
+        spice_interface::loadSpiceKernelInTudat( kernelsPath + "naif0009.tls");
+        spice_interface::loadSpiceKernelInTudat( kernelsPath + "pck00009.tpc");
+        spice_interface::loadSpiceKernelInTudat( kernelsPath + "de421.bsp");
+
+        unsigned int totalNumberOfBodies = 7;
+        std::vector< std::string > bodyNames;
+        bodyNames.resize( totalNumberOfBodies );
+        bodyNames[ 0 ] = "Earth";
+        bodyNames[ 1 ] = "Mars";
+        bodyNames[ 2 ] = "Sun";
+        bodyNames[ 3 ] = "Venus";
+        bodyNames[ 4 ] = "Moon";
+        bodyNames[ 5 ] = "Mercury";
+        bodyNames[ 6 ] = "Jupiter";
+
+        double initialEphemerisTime = 1.0E7;
+        double finalEphemerisTime = 2.0E7;
+        double maximumTimeStep = 3600.0;
+        double buffer = 5.0 * maximumTimeStep;
+
+        // Create bodies needed in simulation
+        NamedBodyMap bodyMap = createBodies(
+                    getDefaultBodySettings( bodyNames, initialEphemerisTime - buffer, finalEphemerisTime + buffer ) );
+        setGlobalFrameBodyEphemerides( bodyMap, "SSB", "ECLIPJ2000" );
+
+        // Set accelerations between bodies that are to be taken into account.
+        SelectedAccelerationMap accelerationMap;
+        std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfEarth;
+        accelerationsOfEarth[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationsOfEarth[ "Moon" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationsOfEarth[ "Jupiter" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationMap[ "Earth" ] = accelerationsOfEarth;
+
+        std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfMars;
+        accelerationsOfMars[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationsOfMars[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationsOfMars[ "Jupiter" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationMap[ "Mars" ] = accelerationsOfMars;
+
+        std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfMoon;
+        accelerationsOfMoon[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationsOfMoon[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationsOfMoon[ "Jupiter" ].push_back( boost::make_shared< AccelerationSettings >( central_gravity ) );
+        accelerationMap[ "Moon" ] = accelerationsOfMoon;
+
+        std::vector< std::string > bodiesToPropagate;
+        bodiesToPropagate.push_back( "Earth" );
+        bodiesToPropagate.push_back( "Mars" );
+        bodiesToPropagate.push_back( "Moon" );
+
+        unsigned int numberOfNumericalBodies = bodiesToPropagate.size( );
+
+        std::vector< std::string > centralBodies;
+        std::map< std::string, std::string > centralBodyMap;
+        centralBodies.resize( numberOfNumericalBodies );
+
+        for( int i = 0; i < 3; i++ )
+        {
+            if( i == 2 && simulationCase == 1 )
+            {
+                centralBodies[ i ] = "Earth";
+            }
+            else
+            {
+                centralBodies[ i ] = "Sun";
+            }
+            centralBodyMap[ bodiesToPropagate[ i ] ] = centralBodies[ i ];
+        }
+
+
+
+        Eigen::VectorXd systemInitialState = Eigen::VectorXd( bodiesToPropagate.size( ) * 6 );
+        for( unsigned int i = 0; i < numberOfNumericalBodies ; i++ )
+        {
+            systemInitialState.segment( i * 6 , 6 ) =
+                    bodyMap[ bodiesToPropagate[ i ] ]->getStateInBaseFrameFromEphemeris( initialEphemerisTime ) -
+                    bodyMap[ centralBodies[ i ] ]->getStateInBaseFrameFromEphemeris( initialEphemerisTime );
+        }
+
+        AccelerationMap accelerationModelMap = createAccelerationModelsMap(
+                    bodyMap, accelerationMap, centralBodyMap );
+
+        boost::shared_ptr< IntegratorSettings< > > integratorSettings =
+                boost::make_shared< IntegratorSettings< > >
+                ( rungeKutta4,
+                  initialEphemerisTime, finalEphemerisTime, 250.0 );
+
+        boost::shared_ptr< TranslationalStatePropagatorSettings< double > > propagatorSettings =
+                boost::make_shared< TranslationalStatePropagatorSettings< double > >
+                ( centralBodies, accelerationModelMap, bodiesToPropagate, systemInitialState );
+
+        SingleArcDynamicsSimulator< double > dynamicsSimulator2(
+                    bodyMap, integratorSettings, propagatorSettings, true );
+
+        double initialTestTime = initialEphemerisTime + 10.0 * maximumTimeStep;
+        double finalTestTime = finalEphemerisTime - 10.0 * maximumTimeStep;
+        double testTimeStep = 1.0E4;
+
+        double currentTestTime = initialTestTime;
+        std::map< double, Eigen::Matrix< double, 18, 1 > > cowellIntegrationResults;
+        while( currentTestTime < finalTestTime )
+        {
+            cowellIntegrationResults[ currentTestTime ].segment( 0, 6 ) = bodyMap[ "Earth" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
+            cowellIntegrationResults[ currentTestTime ].segment( 6, 6 ) = bodyMap[ "Mars" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
+            cowellIntegrationResults[ currentTestTime ].segment( 12, 6 ) = bodyMap[ "Moon" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
+
+            currentTestTime += testTimeStep;
+        }
+
+
+        propagatorSettings = boost::make_shared< TranslationalStatePropagatorSettings< double > >
+                ( centralBodies, accelerationModelMap, bodiesToPropagate, systemInitialState, encke );
+
+        SingleArcDynamicsSimulator< double > dynamicsSimulator(
+                    bodyMap, integratorSettings, propagatorSettings, true );
+
+        currentTestTime = initialTestTime;
+        std::map< double, Eigen::Matrix< double, 18, 1 > > enckeIntegrationResults;
+        while( currentTestTime < finalTestTime )
+        {
+            enckeIntegrationResults[ currentTestTime ].segment( 0, 6 ) = bodyMap[ "Earth" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
+            enckeIntegrationResults[ currentTestTime ].segment( 6, 6 ) = bodyMap[ "Mars" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
+            enckeIntegrationResults[ currentTestTime ].segment( 12, 6 ) = bodyMap[ "Moon" ]->getStateInBaseFrameFromEphemeris( currentTestTime );
+            currentTestTime += testTimeStep;
+        }
+
+        std::map< double, Eigen::Matrix< double, 18, 1 > >::iterator enckeIterator = enckeIntegrationResults.begin( );
+        std::map< double, Eigen::Matrix< double, 18, 1 > >::iterator cowellIterator = cowellIntegrationResults.begin( );
+
+        for( unsigned int i = 0; i < enckeIntegrationResults.size( ); i++ )
+        {
+            for( int j= 0; j< 3; j++ )
+            {
+                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 0.01 );
+            }
+
+            for( int j = 6; j < 9; j++ )
+            {
+                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 0.01 );
+            }
+
+            for( int j = 12; j < 15; j++ )
+            {
+                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 0.075 );
+            }
+
+            for( int j = 3; j < 6; j++ )
+            {
+                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 1.0E-8 );
+
+            }
+
+            for( int j = 9; j < 12; j++ )
+            {
+                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 1.0E-8 );
+
+            }
+
+            for( int j = 15; j < 18; j++ )
+            {
+                BOOST_CHECK_SMALL( ( enckeIterator->second - cowellIterator->second ).segment( j, 1 )( 0 ), 1.0E-6 );
+
+            }
+            enckeIterator++;
+            cowellIterator++;
+        }
+    }
+}
 
 BOOST_AUTO_TEST_CASE( testEnckePopagatorForSphericalHarmonicCentralBodies )
 {
diff --git a/Tudat/Astrodynamics/Propagators/createStateDerivativeModel.h b/Tudat/Astrodynamics/Propagators/createStateDerivativeModel.h
index 28d6a6a..3a2e4fa 100644
--- a/Tudat/Astrodynamics/Propagators/createStateDerivativeModel.h
+++ b/Tudat/Astrodynamics/Propagators/createStateDerivativeModel.h
@@ -99,6 +99,7 @@ boost::shared_ptr< CentralBodyData< StateScalarType, TimeType > > createCentralB
  *  propagation settings and environment.
  *  \param translationPropagatorSettings Settings for the translational dynamics model.
  *  \param bodyMap List of body objects in the environment
+ *  \param propagationStartTime Time from which numerical propagation starts.
  *  \return Translational state derivative model (instance of derived class of NBodyStateDerivative)
  */
 template< typename StateScalarType = double, typename TimeType = double >
@@ -181,6 +182,7 @@ boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > crea
  *  Function to create a state derivative model from propagation settings and the environment.
  *  \param propagatorSettings Settings for the dynamical model.
  *  \param bodyMap List of body objects in the environment
+ *  \param propagationStartTime Time from which numerical propagation starts.
  *  \return State derivative model (instance of required derived class of SingleStateTypeDerivative)
  */
 template< typename StateScalarType = double, typename TimeType = double >
@@ -246,7 +248,8 @@ createStateDerivativeModel(
  *  Function to create a list of state derivative models from
  *  propagation settings and the environment.
  *  \param propagatorSettings Settings for the dynamical model.
- *  \param bodyMap List of body objects in the environment
+ *  \param bodyMap List of body objects in the environment.
+ *  \param propagationStartTime Time from which numerical propagation starts.
  *  \return List of state derivative models (instances of required
  *  derived class of SingleStateTypeDerivative)
  */
diff --git a/Tudat/Astrodynamics/Propagators/nBodyEnckeStateDerivative.cpp b/Tudat/Astrodynamics/Propagators/nBodyEnckeStateDerivative.cpp
index 5b2c95d..8172b2a 100644
--- a/Tudat/Astrodynamics/Propagators/nBodyEnckeStateDerivative.cpp
+++ b/Tudat/Astrodynamics/Propagators/nBodyEnckeStateDerivative.cpp
@@ -25,8 +25,10 @@ std::vector< boost::function< double( ) > > removeCentralGravityAccelerations(
         // Check if current central body is exerting any accelerations on current body.
         if( accelerationModelsPerBody[ bodiesToBeIntegratedNumerically.at( i ) ].count( centralBodies.at( i ) ) == 0 )
         {
-            std::cerr<<"Warning cannot remove central point gravity of body "<<bodiesToBeIntegratedNumerically.at( i )
-                    <<" with central body "<<centralBodies.at( i )<<" no accelerations due to requested central body found. "<<std::endl;
+            std::string errorMessage =
+                    "Error, cannot remove central point gravity of body " + bodiesToBeIntegratedNumerically.at( i ) +
+                    " with central body " + centralBodies.at( i ) + " no accelerations due to requested central body found.";
+            throw std::runtime_error( errorMessage );
         }
         else
         {
@@ -35,7 +37,8 @@ std::vector< boost::function< double( ) > > removeCentralGravityAccelerations(
             int lastCandidate = -1;
             int numberOfCandidates = 0;
             bool isLastCandidateSphericalHarmonic = 0;
-            listOfAccelerations = accelerationModelsPerBody[ bodiesToBeIntegratedNumerically.at( i ) ][ centralBodies.at( i ) ];
+            listOfAccelerations =
+                    accelerationModelsPerBody[ bodiesToBeIntegratedNumerically.at( i ) ][ centralBodies.at( i ) ];
 
             for( unsigned int j = 0; j < listOfAccelerations.size( ); j++ )
             {
@@ -57,22 +60,31 @@ std::vector< boost::function< double( ) > > removeCentralGravityAccelerations(
                 else if( ( currentAccelerationType == third_body_central_gravity ) ||
                          ( currentAccelerationType == third_body_spherical_harmonic_gravity ) )
                 {
-                    std::cerr<<"Error when removing central body point gravity term, removal of 3rd body accelerations "
-                            <<" (of "<<centralBodies.at( i )<<" on "<<bodiesToBeIntegratedNumerically.at( i )<<") not yet supported"<<std::endl;
+                    std::string errorMessage =
+                            "Error when removing central body point gravity term, removal of 3rd body accelerations (of " +
+                            centralBodies.at( i ) +
+                            " on " + bodiesToBeIntegratedNumerically.at( i ) + ",) not yet supported";
+                    throw std::runtime_error( errorMessage );
                 }
             }
 
             // If no or multiple central acceleration candidates were found, give error.
             if( numberOfCandidates == 0 )
             {
-                std::cerr<<"Error when removing central body point gravity term on body "<<bodiesToBeIntegratedNumerically.at( i )
-                        <<" with central body "<<centralBodies.at( i )<<", no central gravity found."<<std::endl;
+                std::string errorMessage =
+                        "Error when removing central body point gravity term on body " +
+                        bodiesToBeIntegratedNumerically.at( i ) +
+                        " with central body " + centralBodies.at( i ) + ", no central gravity found.";
+                throw std::runtime_error( errorMessage );
+
             }
             else if( numberOfCandidates != 1 )
             {
-                std::cerr<<"Error when removing central body point gravity term on body "<<bodiesToBeIntegratedNumerically.at( i )
-                        <<" with central body "<<centralBodies.at( i )<<", "<<numberOfCandidates
-                       <<"central gravities found, not 1."<<std::endl;
+                std::string errorMessage =
+                        "Error when removing central body point gravity term on body " +
+                        bodiesToBeIntegratedNumerically.at( i ) +
+                        " with central body " + centralBodies.at( i ) + ", multiple central gravities found.";
+                throw std::runtime_error( errorMessage );
             }
             else
             {
diff --git a/Tudat/Astrodynamics/Propagators/nBodyEnckeStateDerivative.h b/Tudat/Astrodynamics/Propagators/nBodyEnckeStateDerivative.h
index 5fd9e81..93facca 100644
--- a/Tudat/Astrodynamics/Propagators/nBodyEnckeStateDerivative.h
+++ b/Tudat/Astrodynamics/Propagators/nBodyEnckeStateDerivative.h
@@ -20,10 +20,9 @@ namespace propagators
 template< typename StateScalarType = double >
 StateScalarType calculateEnckeQFunction( const StateScalarType qValue )
 {
-    return mathematical_constants::getFloatingInteger< StateScalarType >( 1 ) -
-            std::pow( mathematical_constants::getFloatingInteger< StateScalarType >( 1 )  +
-                     mathematical_constants::getFloatingInteger< StateScalarType >( 2 ) * qValue,
-                      mathematical_constants::getFloatingFraction< StateScalarType >( -3, 2 ) );
+    StateScalarType powerTerm =  mathematical_constants::getFloatingInteger< StateScalarType >( 1 )  +
+            mathematical_constants::getFloatingInteger< StateScalarType >( 2 ) * qValue;
+    return mathematical_constants::getFloatingInteger< StateScalarType >( 1 ) - 1.0 / ( powerTerm * std::sqrt( powerTerm ) );
 }
 
 
@@ -31,6 +30,7 @@ std::vector< boost::function< double( ) > > removeCentralGravityAccelerations(
         const std::vector< std::string >& centralBodies, const std::vector< std::string >& bodiesToBeIntegratedNumerically,
         basic_astrodynamics::AccelerationMap& accelerationModelsPerBody );
 
+
 template< typename StateScalarType = double, typename TimeType = double >
 class NBodyEnckeStateDerivative: public NBodyStateDerivative< StateScalarType, TimeType >
 {
@@ -40,7 +40,8 @@ public:
                                const std::vector< std::string >& bodiesToIntegrate,
                                const std::vector< Eigen::Matrix< StateScalarType, 6, 1 > >& initialKeplerElements,
                                const TimeType& initialTime ):
-        NBodyStateDerivative< StateScalarType, TimeType >( accelerationModelsPerBody, centralBodyData, encke, bodiesToIntegrate ),
+        NBodyStateDerivative< StateScalarType, TimeType >(
+            accelerationModelsPerBody, centralBodyData, encke, bodiesToIntegrate ),
         initialKeplerElements_( initialKeplerElements ),
         initialTime_( initialTime )
     {
@@ -92,15 +93,16 @@ public:
             keplerianRadius = keplerianOrbitCartesianState[ i ].segment( 0, 3 ).norm( );
 
             // Calculate Encke algorithm variables.
-            qValue = positionPerturbation.dot( keplerianOrbitCartesianState[ i ].segment( 0, 3 ) + 0.5 * positionPerturbation ) /
-                    ( keplerianRadius * keplerianRadius );
+            qValue = positionPerturbation.dot( keplerianOrbitCartesianState[ i ].segment( 0, 3 ) +
+                                               0.5 * positionPerturbation ) / ( keplerianRadius * keplerianRadius );
             qFunction = calculateEnckeQFunction( qValue );
 
             // Update state derivative with Encke term.
             stateDerivative.block( i * 6 + 3, 0, 3, 1 ) += static_cast< StateScalarType >(
                         centralBodyGravitationalParameters_[ i ]( ) ) /
                     ( keplerianRadius * keplerianRadius * keplerianRadius ) * (
-                        ( positionPerturbation + keplerianOrbitCartesianState[ i ].segment( 0, 3 ) ) * qFunction - positionPerturbation );
+                        ( positionPerturbation + keplerianOrbitCartesianState[ i ].segment( 0, 3 ) ) * qFunction -
+                        positionPerturbation );
         }
 
     }
@@ -126,8 +128,8 @@ public:
     }
 
     void convertToOutputSolution(
-                const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& internalSolution, const TimeType& time,
-                Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > currentCartesianLocalSoluton )
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& internalSolution, const TimeType& time,
+            Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > currentCartesianLocalSoluton )
     {
         // Calculate Keplerian orbit state around centeal bodies.
         std::vector< Eigen::Matrix< StateScalarType, 6, 1 > > keplerianOrbitCartesianState =
@@ -160,9 +162,10 @@ private:
         // Propagate Kepler orbit to current time and return.
         return orbital_element_conversions::convertKeplerianToCartesianElements< StateScalarType >(
                     orbital_element_conversions::propagateKeplerOrbit< StateScalarType >(
-                        initialKeplerElements_[ bodyIndex ], static_cast< StateScalarType >( time - initialTime_ ),
-                        static_cast< StateScalarType >( centralBodyGravitationalParameters_[ bodyIndex ]( ) ),
-                        rootFinder_ ), static_cast< StateScalarType >( centralBodyGravitationalParameters_[ bodyIndex ]( ) ) );
+                        initialKeplerElements_.at( bodyIndex ), static_cast< StateScalarType >( time - initialTime_ ),
+                        static_cast< StateScalarType >( centralBodyGravitationalParameters_.at( bodyIndex )( ) ),
+                        rootFinder_ ),
+                    static_cast< StateScalarType >( centralBodyGravitationalParameters_.at( bodyIndex )( ) ) );
     }
 
     std::vector< Eigen::Matrix< StateScalarType, 6, 1 > > calculateKeplerTrajectoryCartesianStates(
@@ -193,45 +196,6 @@ private:
     boost::shared_ptr< root_finders::RootFinderCore< StateScalarType > > rootFinder_;
 };
 
-template< typename StateScalarType = double, typename TimeType = double >
-void updateEnckePropagator(
-        const boost::shared_ptr< NBodyEnckeStateDerivative< StateScalarType, TimeType > > enckeStateDerivative,
-        const simulation_setup::NamedBodyMap& bodyMap,
-        const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > newInitialBodyStates )
-{
-    if( newInitialBodyStates.rows( )  != enckeStateDerivative->getStateSize( ) )
-    {
-        std::cerr<<"Error when updating Encke state derivative, state size is inconsistent"<<std::endl;
-    }
-
-    // Get central bodies of bodies that are integrated.
-    std::vector< std::string > centralBodies = enckeStateDerivative->getCentralBodyData( )->getCentralBodies( );
-
-    // Intialize vector of initial kepler elements
-    std::vector< Eigen::Matrix< StateScalarType, 6, 1 > > initialKeplerElements;
-    initialKeplerElements.resize( centralBodies.size( ) );
-
-    for( unsigned int i = 0; i < centralBodies.size( ); i++ )
-    {
-        // Get and verify central body.
-        boost::shared_ptr< simulation_setup::Body > currentCentralBody = bodyMap.at( centralBodies[ i ] );
-        if( currentCentralBody == NULL )
-        {
-            std::cerr<<"Error when updating encke propagator, central body "<<centralBodies[ i ]<<" is not a celestial body."<<std::endl;
-        }
-
-        // Recalculate initial Kepler elements of bodies w.r.t. their respective centraln bodies.
-        initialKeplerElements[ i ] = orbital_element_conversions::convertCartesianToKeplerianElements< StateScalarType >(
-                    newInitialBodyStates.segment( i * 6, 6 ), static_cast< StateScalarType >(
-                        bodyMap.at( centralBodies[ i ] )->getGravityFieldModel( )->
-                        getGravitationalParameter( ) ) );
-
-    }
-
-    // Reset initial kepler elements in propagator
-    enckeStateDerivative->updateInitialKeplerElements( initialKeplerElements );
-}
-
 
 }
 
diff --git a/Tudat/Astrodynamics/Propagators/propagationSettings.cpp b/Tudat/Astrodynamics/Propagators/propagationSettings.cpp
index 4757ebd..10cc969 100644
--- a/Tudat/Astrodynamics/Propagators/propagationSettings.cpp
+++ b/Tudat/Astrodynamics/Propagators/propagationSettings.cpp
@@ -39,7 +39,6 @@ int getSingleIntegrationDifferentialEquationOrder( const IntegratedStateType sta
         singleStateSize = 1;
         break;
     default:
-    default:
         std::string errorMessage =
                 "Did not recognize state type " + boost::lexical_cast< std::string >( stateType ) + "when getting order";
        throw std::runtime_error( errorMessage );
diff --git a/Tudat/SimulationSetup/body.h b/Tudat/SimulationSetup/body.h
index 4b64336..f34bba2 100644
--- a/Tudat/SimulationSetup/body.h
+++ b/Tudat/SimulationSetup/body.h
@@ -425,6 +425,7 @@ public:
         {
             std::cerr<<"Warning when settings gravity field model for body, mass function already found: resetting"<<std::endl;
         }
+
         currentMass_ = gravityFieldModel_->getGravitationalParameter( )
                        / physical_constants::GRAVITATIONAL_CONSTANT;
         bodyMassFunction_ = boost::lambda::constant( currentMass_ );
@@ -659,7 +660,6 @@ public:
         if( boost::dynamic_pointer_cast< gravitation::TimeDependentSphericalHarmonicsGravityField >(
                     gravityFieldModel_ ) != NULL )
         {
-            //std::cerr<<"Error, time. dep. update disabled due to circular dependency"<<std::endl;
             boost::dynamic_pointer_cast< gravitation::TimeDependentSphericalHarmonicsGravityField >(
                         gravityFieldModel_ )->updateCorrectionFunctions( );
         }
