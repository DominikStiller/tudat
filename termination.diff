diff --git a/Tudat/Astrodynamics/Propagators/CMakeLists.txt b/Tudat/Astrodynamics/Propagators/CMakeLists.txt
index 470b5a7..8b1bc69 100644
--- a/Tudat/Astrodynamics/Propagators/CMakeLists.txt
+++ b/Tudat/Astrodynamics/Propagators/CMakeLists.txt
@@ -133,6 +133,10 @@ add_executable(test_ForwardBackwardIntegration "${SRCROOT}${PROPAGATORSDIR}/Unit
 setup_custom_test_program(test_ForwardBackwardIntegration "${SRCROOT}${PROPAGATORSDIR}/")
 target_link_libraries(test_ForwardBackwardIntegration ${TUDAT_PROPAGATION_LIBRARIES} ${Boost_LIBRARIES})
 
+add_executable(test_ExactTermination "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestExactTermination.cpp")
+setup_custom_test_program(test_ExactTermination "${SRCROOT}${PROPAGATORSDIR}/")
+target_link_libraries(test_ExactTermination ${TUDAT_PROPAGATION_LIBRARIES} ${Boost_LIBRARIES})
+
 endif( )
 
 add_executable(test_StateDerivativeRestrictedThreeBodyProblem "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestStateDerivativeCircularRestrictedThreeBodyProblem.cpp")
diff --git a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestExactTermination.cpp b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestExactTermination.cpp
new file mode 100644
index 0000000..60e9f85
--- /dev/null
+++ b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestExactTermination.cpp
@@ -0,0 +1,329 @@
+/*    Copyright (c) 2010-2017, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ */
+
+#define BOOST_TEST_MAIN
+
+#include <limits>
+#include <string>
+#include <thread>
+
+#include <boost/make_shared.hpp>
+#include <boost/test/unit_test.hpp>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/unitConversions.h"
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebra.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h"
+
+#include "Tudat/External/SpiceInterface/spiceInterface.h"
+#include "Tudat/Mathematics/NumericalIntegrators/rungeKuttaCoefficients.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
+#include "Tudat/InputOutput/basicInputOutput.h"
+#include "Tudat/SimulationSetup/PropagationSetup/dynamicsSimulator.h"
+#include "Tudat/SimulationSetup/EnvironmentSetup/defaultBodies.h"
+#include "Tudat/SimulationSetup/EnvironmentSetup/createBodies.h"
+#include "Tudat/SimulationSetup/PropagationSetup/createNumericalSimulator.h"
+#include "Tudat/Mathematics/NumericalIntegrators/createNumericalIntegrator.h"
+
+namespace tudat
+{
+namespace unit_tests
+{
+
+BOOST_AUTO_TEST_SUITE( test_exact_termination )
+
+// Test Encke propagator for point mass, and spherical harmonics central body.
+BOOST_AUTO_TEST_CASE( testEnckePopagatorForSphericalHarmonicCentralBodies )
+{
+    for( unsigned int integratorCase = 0; integratorCase < 2; integratorCase++ )
+    {
+        for( unsigned int simulationCase = 0; simulationCase < 5; simulationCase++ )
+        {
+            for( unsigned int direction = 0; direction < 2; direction++ )
+            {
+                using namespace tudat;
+                using namespace simulation_setup;
+                using namespace propagators;
+                using namespace numerical_integrators;
+                using namespace orbital_element_conversions;
+                using namespace basic_mathematics;
+                using namespace gravitation;
+                using namespace numerical_integrators;
+
+                // Load Spice kernels.
+                spice_interface::loadStandardSpiceKernels( );
+
+                // Set simulation time settings.
+                double simulationStartEpoch;
+                double simulationEndEpoch;
+
+                double directionMultiplier = 1.0;
+                if( direction == 0 )
+                {
+                    simulationStartEpoch = 0.0;
+                    simulationEndEpoch = 0.2 * tudat::physical_constants::JULIAN_DAY;
+                }
+                else
+                {
+                    simulationStartEpoch = 0.2 * tudat::physical_constants::JULIAN_DAY;
+                    simulationEndEpoch = 0.0;
+                    directionMultiplier = -1.0;
+                }
+
+
+                // Define body settings for simulation.
+                std::vector< std::string > bodiesToCreate;
+                bodiesToCreate.push_back( "Sun" );
+                bodiesToCreate.push_back( "Earth" );
+                bodiesToCreate.push_back( "Moon" );
+
+                // Create body objects.
+                std::map< std::string, boost::shared_ptr< BodySettings > > bodySettings;
+                if( direction == 0 )
+                {
+                    bodySettings =
+                            getDefaultBodySettings( bodiesToCreate, simulationStartEpoch - 300.0, simulationEndEpoch + 300.0 );
+                }
+                else
+                {
+                    bodySettings =
+                            getDefaultBodySettings( bodiesToCreate, simulationEndEpoch - 300.0, simulationStartEpoch + 300.0 );
+                }
+                NamedBodyMap bodyMap = createBodies( bodySettings );
+
+                // Create spacecraft object.
+                bodyMap[ "Vehicle" ] = boost::make_shared< simulation_setup::Body >( );
+                bodyMap[ "Vehicle" ]->setConstantBodyMass( 400.0 );
+                bodyMap[ "Vehicle" ]->setEphemeris( boost::make_shared< ephemerides::TabulatedCartesianEphemeris< > >(
+                                                        boost::shared_ptr< interpolators::OneDimensionalInterpolator
+                                                        < double, Eigen::Vector6d  > >( ), "Earth", "ECLIPJ2000" ) );
+
+
+                // Finalize body creation.
+                setGlobalFrameBodyEphemerides( bodyMap, "Earth", "ECLIPJ2000" );
+
+                // Define propagator settings variables.
+                SelectedAccelerationMap accelerationMap;
+                std::vector< std::string > bodiesToPropagate;
+                std::vector< std::string > centralBodies;
+
+                // Define propagation settings.
+                std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > > accelerationsOfVehicle;
+
+                {
+                    accelerationsOfVehicle[ "Earth" ].push_back( boost::make_shared< AccelerationSettings >(
+                                                                     basic_astrodynamics::central_gravity ) );
+                    accelerationsOfVehicle[ "Sun" ].push_back( boost::make_shared< AccelerationSettings >(
+                                                                   basic_astrodynamics::central_gravity ) );
+                    accelerationsOfVehicle[ "Moon" ].push_back( boost::make_shared< AccelerationSettings >(
+                                                                    basic_astrodynamics::central_gravity ) );
+                }
+
+                accelerationMap[  "Vehicle" ] = accelerationsOfVehicle;
+                bodiesToPropagate.push_back( "Vehicle" );
+                centralBodies.push_back( "Earth" );
+                basic_astrodynamics::AccelerationMap accelerationModelMap = createAccelerationModelsMap(
+                            bodyMap, accelerationMap, bodiesToPropagate, centralBodies );
+
+                // Set Keplerian elements for Vehicle.
+                Eigen::Vector6d vehicleInitialStateInKeplerianElements;
+                vehicleInitialStateInKeplerianElements( semiMajorAxisIndex ) = 8000.0E3;
+                vehicleInitialStateInKeplerianElements( eccentricityIndex ) = 0.1;
+                vehicleInitialStateInKeplerianElements( inclinationIndex ) = unit_conversions::convertDegreesToRadians( 85.3 );
+                vehicleInitialStateInKeplerianElements( argumentOfPeriapsisIndex )
+                        = unit_conversions::convertDegreesToRadians( 235.7 );
+                vehicleInitialStateInKeplerianElements( longitudeOfAscendingNodeIndex )
+                        = unit_conversions::convertDegreesToRadians( 23.4 );
+                vehicleInitialStateInKeplerianElements( trueAnomalyIndex ) = unit_conversions::convertDegreesToRadians( 139.87 );
+
+                double earthGravitationalParameter = bodyMap.at( "Earth" )->getGravityFieldModel( )->getGravitationalParameter( );
+                const Eigen::Vector6d vehicleInitialState = convertKeplerianToCartesianElements(
+                            vehicleInitialStateInKeplerianElements, earthGravitationalParameter );
+
+                // Define propagator settings (Cowell)
+                boost::shared_ptr< PropagationTerminationSettings > terminationSettings;
+                std::vector< boost::shared_ptr< SingleDependentVariableSaveSettings > > dependentVariables;
+                dependentVariables.push_back(
+                            boost::make_shared< SingleDependentVariableSaveSettings >( relative_distance_dependent_variable,
+                                                                                       "Vehicle", "Earth" ) );
+                double finalTestTime;
+                double secondFinalTestTime;
+
+                if( direction == 0 )
+                {
+                    finalTestTime = 322.5;
+                    secondFinalTestTime = 501.0;
+                }
+                else
+                {
+                    finalTestTime = 11737.5;
+                    secondFinalTestTime = 11701.0;
+                }
+                if( simulationCase == 0 )
+                {
+                    terminationSettings = boost::make_shared< PropagationTimeTerminationSettings >(
+                                simulationEndEpoch - directionMultiplier * 4.5, true );
+                }
+                else if( simulationCase == 1 )
+                {
+                    terminationSettings = boost::make_shared< PropagationDependentVariableTerminationSettings >(
+                                dependentVariables.at( 0 ), 8.7E6, false, true,
+                                boost::make_shared< root_finders::RootFinderSettings >(
+                                    root_finders::bisection_root_finder, 1.0E-6, 100 ) );
+                }
+                else if( simulationCase == 2 )
+                {
+                    std::vector< boost::shared_ptr< PropagationTerminationSettings > > terminationSettingsList;
+                    terminationSettingsList.push_back(
+                                boost::make_shared< PropagationTimeTerminationSettings >( finalTestTime, true ) );
+                    terminationSettingsList.push_back(
+                                boost::make_shared< PropagationDependentVariableTerminationSettings >(
+                                    dependentVariables.at( 0 ), 8.7E6, false, true,
+                                    boost::make_shared< root_finders::RootFinderSettings >(
+                                        root_finders::bisection_root_finder, 1.0E-6, 100 ) ) );
+                    terminationSettings = boost::make_shared< PropagationHybridTerminationSettings >(
+                                terminationSettingsList, true );
+                }
+                else if( simulationCase == 3 )
+                {
+                    std::vector< boost::shared_ptr< PropagationTerminationSettings > > terminationSettingsList;
+                    terminationSettingsList.push_back(
+                                boost::make_shared< PropagationTimeTerminationSettings >( finalTestTime, true ) );
+                    terminationSettingsList.push_back(
+                                boost::make_shared< PropagationDependentVariableTerminationSettings >(
+                                    dependentVariables.at( 0 ), 8.7E6, false, true,
+                                    boost::make_shared< root_finders::RootFinderSettings >(
+                                        root_finders::bisection_root_finder, 1.0E-6, 100 ) ) );
+                    terminationSettings = boost::make_shared< PropagationHybridTerminationSettings >(
+                                terminationSettingsList, false );
+                }
+                else if( simulationCase == 4 )
+                {
+                    std::vector< boost::shared_ptr< PropagationTerminationSettings > > terminationSettingsList;
+                    terminationSettingsList.push_back(
+                                boost::make_shared< PropagationTimeTerminationSettings >( secondFinalTestTime, true ) );
+                    terminationSettingsList.push_back(
+                                boost::make_shared< PropagationDependentVariableTerminationSettings >(
+                                    dependentVariables.at( 0 ), 8.7E6, false, true,
+                                    boost::make_shared< root_finders::RootFinderSettings >(
+                                        root_finders::bisection_root_finder, 1.0E-6, 100 ) ) );
+                    terminationSettings = boost::make_shared< PropagationHybridTerminationSettings >(
+                                terminationSettingsList, true );
+                }
+
+
+                boost::shared_ptr< TranslationalStatePropagatorSettings< double > > propagatorSettings =
+                        boost::make_shared< TranslationalStatePropagatorSettings< double > >
+                        ( centralBodies, accelerationModelMap, bodiesToPropagate, vehicleInitialState, terminationSettings, cowell,
+                          boost::make_shared< DependentVariableSaveSettings >( dependentVariables ) );
+
+                // Define integrator settings.
+                const double fixedStepSize = 5.0;
+                boost::shared_ptr< IntegratorSettings< > > integratorSettings;
+                if( integratorCase == 0 )
+                {
+                    integratorSettings = boost::make_shared< IntegratorSettings< > >
+                            ( rungeKutta4, simulationStartEpoch, directionMultiplier * fixedStepSize );
+
+                }
+                else
+                {
+                    integratorSettings = boost::make_shared< RungeKuttaVariableStepSizeSettings< double > >
+                            ( rungeKuttaVariableStepSize, simulationStartEpoch, directionMultiplier * fixedStepSize,
+                              RungeKuttaCoefficients::CoefficientSets::rungeKuttaFehlberg45,
+                              1.0E-3, 1.0E3, 1.0E-12, 1.0E-12 );
+                }
+
+                // Propagate orbit with Cowell method
+                SingleArcDynamicsSimulator< double > dynamicsSimulator(
+                            bodyMap, integratorSettings, propagatorSettings, true, false, false );
+                std::map< double, Eigen::VectorXd > stateHistory = dynamicsSimulator.getEquationsOfMotionNumericalSolution( );
+                std::map< double, Eigen::VectorXd > dependentVariableHistory = dynamicsSimulator.getDependentVariableHistory( );
+
+                if( simulationCase == 0 )
+                {
+                    if( direction == 0 )
+                    {
+                        BOOST_CHECK_SMALL( std::fabs( stateHistory.rbegin( )->first -
+                                                      ( simulationEndEpoch - 4.5 ) ), 1.0E-10 );
+                    }
+                    else
+                    {
+                        BOOST_CHECK_SMALL( std::fabs( stateHistory.begin( )->first -
+                                                      ( simulationEndEpoch + 4.5 ) ), 1.0E-10 );
+                    }
+                }
+                else if( simulationCase == 1 )
+                {
+                    if( direction == 0 )
+                    {
+                        BOOST_CHECK_SMALL( std::fabs( dependentVariableHistory.rbegin( )->second( 0 ) - 8.7E6 ), 0.01 );
+                    }
+                    else
+                    {
+                        BOOST_CHECK_SMALL( std::fabs( dependentVariableHistory.begin( )->second( 0 ) - 8.7E6 ), 0.01 );
+                    }
+                }
+                else if( simulationCase == 2 )
+                {
+                    if( direction == 0 )
+                    {
+                        BOOST_CHECK_SMALL( std::fabs( stateHistory.rbegin( )->first - finalTestTime ), 0.01 );
+                    }
+                    else
+                    {
+                        BOOST_CHECK_SMALL( std::fabs( dependentVariableHistory.begin( )->second( 0 ) - 8.7E6 ), 0.01 );
+                    }
+                }
+                else if( simulationCase == 3 )
+                {
+                    if( direction == 0 )
+                    {
+                        BOOST_CHECK_SMALL( std::fabs( dependentVariableHistory.rbegin( )->second( 0 ) - 8.7E6 ), 0.01 );
+                    }
+                    else
+                    {
+                        BOOST_CHECK_SMALL( std::fabs( stateHistory.begin( )->first - finalTestTime ), 0.01 );
+                    }
+                }
+                else if( simulationCase == 4 )
+                {
+                    if( direction == 0 )
+                    {
+                        BOOST_CHECK_SMALL( std::fabs( stateHistory.rbegin( )->first - secondFinalTestTime ), 0.01 );
+                    }
+                    else
+                    {
+                        BOOST_CHECK_SMALL( std::fabs( stateHistory.begin( )->first - secondFinalTestTime ), 0.01 );
+                    }
+                }
+
+                //                std::cout<<"First time/altitude: "<<std::setprecision( 12 )<<dependentVariableHistory.begin( )->first<<" "<<
+                //                           dependentVariableHistory.begin( )->second<<std::endl;
+                //                std::cout<<"Final time/altitude: "<<std::setprecision( 12 )<<dependentVariableHistory.rbegin( )->first<<" "<<
+                //                           dependentVariableHistory.rbegin( )->second<<std::endl;
+
+                //                for( std::map< double, Eigen::VectorXd >::const_iterator it = dependentVariableHistory.begin( );
+                //                     it != dependentVariableHistory.end( ); it++ )
+                //                {
+                //                    std::cout<<"Time/altitude: "<<it->first<<" "<<it->second<<std::endl;
+                //                }
+            }
+        }
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+}
+
+}
+
+
diff --git a/Tudat/Astrodynamics/Propagators/integrateEquations.h b/Tudat/Astrodynamics/Propagators/integrateEquations.h
index e03973c..6138910 100644
--- a/Tudat/Astrodynamics/Propagators/integrateEquations.h
+++ b/Tudat/Astrodynamics/Propagators/integrateEquations.h
@@ -14,6 +14,7 @@
 #include <Eigen/Core>
 #include <boost/lambda/lambda.hpp>
 #include <chrono>
+#include <limits>
 
 #include <map>
 
@@ -24,6 +25,7 @@
 #include "Tudat/Astrodynamics/Propagators/singleStateTypeDerivative.h"
 #include "Tudat/Mathematics/NumericalIntegrators/createNumericalIntegrator.h"
 #include "Tudat/Mathematics/Interpolators/lagrangeInterpolator.h"
+#include "Tudat/Mathematics/RootFinders/createRootFinder.h"
 #include "Tudat/SimulationSetup/PropagationSetup/propagationTermination.h"
 
 namespace tudat
@@ -32,13 +34,191 @@ namespace tudat
 namespace propagators
 {
 
+template< typename StateType = Eigen::MatrixXd, typename TimeType = double, typename TimeStepType = TimeType  >
+TimeStepType getTerminationDependentVariableErrorForGivenTimeStep(
+        TimeStepType timeStep,
+        const boost::shared_ptr< numerical_integrators::NumericalIntegrator< TimeType, StateType, StateType, TimeStepType > > integrator,
+        boost::shared_ptr< SingleVariableLimitPropagationTerminationCondition > dependentVariableTerminationCondition )
+{
+
+    integrator->performIntegrationStep( timeStep );
+    integrator->getStateDerivativeFunction( )( integrator->getCurrentIndependentVariable( ),
+                                               integrator->getCurrentState( ) );
+
+    TimeStepType dependentVariableError =
+            static_cast< TimeStepType >( dependentVariableTerminationCondition->getStopConditionError( ) );
+
+    integrator->rollbackToPreviousState( );
+
+
+    return dependentVariableError;
+}
+
+
+template< typename StateType = Eigen::MatrixXd, typename TimeType = double, typename TimeStepType = TimeType  >
+void propagateToExactTerminationCondition(
+        const boost::shared_ptr< numerical_integrators::NumericalIntegrator< TimeType, StateType, StateType, TimeStepType > > integrator,
+        const boost::shared_ptr< PropagationTerminationCondition > terminationCondition,
+        const TimeType secondToLastTime,
+        const TimeType lastTime,
+        const StateType& secondToLastState,
+        const StateType& lastState,
+        TimeType& endTime,
+        StateType& endState )
+{
+    integrator->setStepSizeControl( false );
+
+    bool propagationIsForwards = ( ( lastTime - secondToLastTime ) > 0.0 ) ? true : false;
+
+    switch( terminationCondition->getTerminationType( ) )
+    {
+    case  time_stopping_condition:
+    {
+
+        boost::shared_ptr< FixedTimePropagationTerminationCondition > timeTerminationCondition =
+                boost::dynamic_pointer_cast< FixedTimePropagationTerminationCondition >( terminationCondition );
+
+        TimeStepType finalTimeStep = timeTerminationCondition->getStopTime( ) - secondToLastTime;
+
+        integrator->rollbackToPreviousState( );
+        endState = integrator->performIntegrationStep( finalTimeStep );
+        endTime = integrator->getCurrentIndependentVariable( );
+
+        break;
+    }
+    case  cpu_time_stopping_condition:
+        std::cerr<<"Error, cannot propagate to exact CPU time, returning state after condition violation:"<<std::endl;
+        endTime = lastTime;
+        endState = lastState;
+        break;
+
+    case dependent_variable_stopping_condition:
+    {
+        integrator->rollbackToPreviousState( );
+
+        boost::shared_ptr< SingleVariableLimitPropagationTerminationCondition > dependentVariableTerminationCondition =
+                boost::dynamic_pointer_cast< SingleVariableLimitPropagationTerminationCondition >( terminationCondition );
+
+        double timeStepSign = ( static_cast< double >( lastTime - secondToLastTime ) > 0.0 ) ? 1.0 : -1.0;
+
+        boost::function< TimeStepType( TimeStepType ) > dependentVariableErrorFunction =
+                boost::bind( &getTerminationDependentVariableErrorForGivenTimeStep< StateType, TimeType, TimeStepType >, _1,
+                             integrator, dependentVariableTerminationCondition );
+
+        TimeStepType finalTimeStep;
+        if( timeStepSign > 0 )
+        {
+            boost::shared_ptr< root_finders::RootFinderCore< TimeStepType > > finalConditionRootFinder =
+                    root_finders::createRootFinder< TimeStepType >(
+                        dependentVariableTerminationCondition->getTerminationRootFinderSettings( ),
+                        static_cast< TimeStepType >( std::numeric_limits< double >::min( ) ),
+                        static_cast< TimeStepType >( lastTime - secondToLastTime ),
+                        static_cast< TimeStepType >( std::numeric_limits< double >::min( ) ) );
+
+            finalTimeStep = finalConditionRootFinder->execute(
+                        boost::make_shared< basic_mathematics::FunctionProxy< TimeStepType, TimeStepType > >(
+                            dependentVariableErrorFunction ), ( lastTime - secondToLastTime ) / 2.0 );
+
+            endState = integrator->performIntegrationStep( finalTimeStep );
+        }
+        else
+        {
+            boost::shared_ptr< root_finders::RootFinderCore< TimeStepType > > finalConditionRootFinder =
+                    root_finders::createRootFinder< TimeStepType >(
+                        dependentVariableTerminationCondition->getTerminationRootFinderSettings( ),
+                        static_cast< TimeStepType >( lastTime - secondToLastTime ),
+                        static_cast< TimeStepType >( -std::numeric_limits< double >::min( ) ),
+                        static_cast< TimeStepType >( lastTime - secondToLastTime ) );
+
+            finalTimeStep = finalConditionRootFinder->execute(
+                        boost::make_shared< basic_mathematics::FunctionProxy< TimeStepType, TimeStepType > >(
+                            dependentVariableErrorFunction ), ( lastTime - secondToLastTime ) / 2.0 );
+
+            endState = integrator->performIntegrationStep( finalTimeStep );
+        }
+
+        endTime = integrator->getCurrentIndependentVariable( );
+
+        break;
+    }
+    case  hybrid_stopping_condition:
+    {
+        boost::shared_ptr< HybridPropagationTerminationCondition > hyrbidTerminationCondition =
+                boost::dynamic_pointer_cast< HybridPropagationTerminationCondition >( terminationCondition );
+        std::vector< boost::shared_ptr< PropagationTerminationCondition > > terminationConditionList =
+                hyrbidTerminationCondition->getPropagationTerminationConditions( );
+
+        std::vector< TimeType > endTimes;
+        endTimes.resize( terminationConditionList.size( ) );
+        std::vector< StateType > endStates;
+        endStates.resize( terminationConditionList.size( ) );
+
+        int minimumTimeIndex = 0;
+        int maximumTimeIndex = 0;
+
+        TimeStepType minimumTimeStep, maximumTimeStep;
+
+        for( unsigned int i = 0; i < terminationConditionList.size( ); i++ )
+        {
+            propagateToExactTerminationCondition(
+                        integrator, terminationConditionList.at( i ),secondToLastTime, lastTime, secondToLastState, lastState,
+                        endTimes[ i ], endStates[ i ] );
+
+            TimeStepType currentFinalTimeStep = endTimes[ i ] - secondToLastTime;
+
+            if( i == 0 )
+            {
+                minimumTimeStep = currentFinalTimeStep;
+                maximumTimeStep = currentFinalTimeStep;
+            }
+            else
+            {
+                if( currentFinalTimeStep < minimumTimeStep )
+                {
+                    minimumTimeStep = currentFinalTimeStep;
+                    minimumTimeIndex = i;
+                }
+
+                if( currentFinalTimeStep > maximumTimeStep )
+                {
+                    maximumTimeStep = currentFinalTimeStep;
+                    maximumTimeIndex = i;
+                }
+            }
+        }
+
+        if( ( propagationIsForwards && hyrbidTerminationCondition->getFulFillSingleCondition( ) ) ||
+                ( !propagationIsForwards && !hyrbidTerminationCondition->getFulFillSingleCondition( ) ) )
+        {
+            endState = endStates[ maximumTimeIndex ];
+            endTime = endTimes[ maximumTimeIndex ];
+        }
+        else if( ( propagationIsForwards && !hyrbidTerminationCondition->getFulFillSingleCondition( ) ) ||
+                 ( !propagationIsForwards && hyrbidTerminationCondition->getFulFillSingleCondition( ) ) )
+        {
+            endState = endStates[ minimumTimeIndex ];
+            endTime = endTimes[ minimumTimeIndex ];
+        }
+        else
+        {
+            throw std::runtime_error( "Error when propagating to exact final hybrid condition, case not recognized" );
+        }
+
+        break;
+    }
+    default:
+        throw std::runtime_error( "Error when propagating to exact final condition, did not recognize termination time" );
+    }
+}
+
+
 //! Function to numerically integrate a given first order differential equation
 /*!
  *  Function to numerically integrate a given first order differential equation, with the state derivative a function of
  *  a single independent variable and the current state
  *  \param integrator Numerical integrator used for propagation
  *  \param initialTimeStep Time step to use for first step of numerical integration
- *  \param stopPropagationFunction Function determining whether the propagation is to be stopped at the current time.
+ *  \param propagationTerminationCondition Object to determine when/how the propagation is to be stopped at the current time.
  *  \param solutionHistory History of dependent variables that are to be saved given as map
  *  (time as key; returned by reference)
  *  \param dependentVariableHistory History of dependent variables that are to be saved given as map
@@ -58,7 +238,7 @@ template< typename StateType = Eigen::MatrixXd, typename TimeType = double, type
 PropagationTerminationReason integrateEquationsFromIntegrator(
         const boost::shared_ptr< numerical_integrators::NumericalIntegrator< TimeType, StateType, StateType, TimeStepType > > integrator,
         const TimeStepType initialTimeStep,
-        const boost::function< bool( const double, const double ) > stopPropagationFunction,
+        const boost::shared_ptr< PropagationTerminationCondition > propagationTerminationCondition,
         std::map< TimeType, StateType >& solutionHistory,
         std::map< TimeType, Eigen::VectorXd >& dependentVariableHistory,
         std::map< TimeType, double >& cummulativeComputationTimeHistory,
@@ -146,7 +326,7 @@ PropagationTerminationReason integrateEquationsFromIntegrator(
             else
             {
                 std::cerr << "Error, propagation terminated at t=" + std::to_string( static_cast< double >( currentTime ) ) +
-                           ", found Nan/inf entry, returning propagation data up to current time" << std::endl;
+                             ", found Nan/inf entry, returning propagation data up to current time" << std::endl;
                 breakPropagation = 1;
                 propagationTerminationReason = runtime_error_caught_in_propagation;
             }
@@ -166,12 +346,62 @@ PropagationTerminationReason integrateEquationsFromIntegrator(
                           static_cast<int>( printInterval ) )  )
                 {
                     std::cout << "Current time and state in integration: " << std::setprecision( 10 ) <<
-                               timeStep << " " << currentTime << " " << newState.transpose( ) << std::endl;
+                                 timeStep << " " << currentTime << " " << newState.transpose( ) << std::endl;
                 }
             }
 
-            if( stopPropagationFunction( static_cast< double >( currentTime ), currentCPUTime ) )
+            if( propagationTerminationCondition->checkStopCondition( static_cast< double >( currentTime ), currentCPUTime ) )
             {
+                if( propagationTerminationCondition->getTerminateExactlyOnFinalCondition( ) )
+                {
+                    TimeType endTime;
+                    StateType endState;
+                    propagateToExactTerminationCondition(
+                                integrator, propagationTerminationCondition,
+                                integrator->getPreviousIndependentVariable( ),
+                                integrator->getCurrentIndependentVariable( ),
+                                integrator->getPreviousState( ),
+                                integrator->getCurrentState( ),
+                                endTime, endState );
+
+                    bool recomputeDependentVariables = false;
+                    if( dependentVariableHistory.size( ) > 0 )
+                    {
+                        if( dependentVariableHistory.rbegin( )->first == solutionHistory.rbegin( )->first )
+                        {
+                            if( timeStep > 0 )
+                            {
+                                dependentVariableHistory.erase( std::prev( dependentVariableHistory.end() ) );
+                            }
+                            else
+                            {
+                                dependentVariableHistory.erase(  dependentVariableHistory.begin( ) );
+                            }
+                            recomputeDependentVariables = true;
+                        }
+                    }
+
+                    if( timeStep > 0 )
+                    {
+                        solutionHistory.erase( std::prev( solutionHistory.end() ) );
+                        solutionHistory[ endTime ] = endState;
+                    }
+                    else
+                    {
+                        solutionHistory.erase( solutionHistory.begin( ) );
+                        solutionHistory[ endTime ] = endState;
+                    }
+
+                    if( recomputeDependentVariables )
+                    {
+                        integrator->getStateDerivativeFunction( )( endTime, endState );
+                        dependentVariableHistory[ endTime ] = dependentVariableFunction( );
+                    }
+
+                    integrator->setStepSizeControl( true );
+
+                }
+
                 propagationTerminationReason = termination_condition_reached;
                 breakPropagation = true;
             }
@@ -181,7 +411,7 @@ PropagationTerminationReason integrateEquationsFromIntegrator(
         {
             std::cerr << caughtException.what( ) << std::endl;
             std::cerr << "Error, propagation terminated at t=" + std::to_string( static_cast< double >( currentTime ) ) +
-                       ", returning propagation data up to current time" << std::endl;
+                         ", returning propagation data up to current time" << std::endl;
             breakPropagation = 1;
             propagationTerminationReason = runtime_error_caught_in_propagation;
         }
@@ -212,7 +442,7 @@ public:
      *  \param solutionHistory History of numerical states given as map (time as key; returned by reference)
      *  \param initialState Initial state
      *  \param integratorSettings Settings for numerical integrator.
-     *  \param stopPropagationFunction Function determining whether the propagation is to be stopped at the current time.
+     *  \param propagationTerminationCondition Object to determine when/how the propagation is to be stopped at the current time.
      *  \param dependentVariableHistory History of dependent variables that are to be saved given as map
      *  (time as key; returned by reference)
      *  \param cummulativeComputationTimeHistory History of cummulative computation times that are to be saved given
@@ -229,7 +459,7 @@ public:
             std::map< TimeType, StateType >& solutionHistory,
             const StateType initialState,
             const boost::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > > integratorSettings,
-            const boost::function< bool( const double, const double ) > stopPropagationFunction,
+            const boost::shared_ptr< PropagationTerminationCondition > propagationTerminationCondition,
             std::map< TimeType, Eigen::VectorXd >& dependentVariableHistory,
             std::map< TimeType, double >& cummulativeComputationTimeHistory,
             const boost::function< Eigen::VectorXd( ) > dependentVariableFunction =
@@ -252,7 +482,7 @@ public:
      *  \param solutionHistory History of numerical states given as map (time as key; returned by reference)
      *  \param initialState Initial state
      *  \param integratorSettings Settings for numerical integrator.
-     *  \param stopPropagationFunction Function determining whether the propagation is to be stopped at the current time.
+     *  \param propagationTerminationCondition Object to determine when/how the propagation is to be stopped at the current time.
      *  \param dependentVariableHistory History of dependent variables that are to be saved given as map
      *  (time as key; returned by reference)
      *  \param cummulativeComputationTimeHistory History of cummulative computation times that are to be saved given
@@ -269,7 +499,7 @@ public:
             std::map< double, StateType >& solutionHistory,
             const StateType initialState,
             const boost::shared_ptr< numerical_integrators::IntegratorSettings< double > > integratorSettings,
-            const boost::function< bool( const double, const double ) > stopPropagationFunction,
+            const boost::shared_ptr< PropagationTerminationCondition > propagationTerminationCondition,
             std::map< double, Eigen::VectorXd >& dependentVariableHistory,
             std::map< double, double >& cummulativeComputationTimeHistory,
             const boost::function< Eigen::VectorXd( ) > dependentVariableFunction =
@@ -277,6 +507,9 @@ public:
             const double printInterval = TUDAT_NAN,
             const std::chrono::steady_clock::time_point initialClockTime = std::chrono::steady_clock::now( ) )
     {
+        boost::function< bool( const double, const double ) > stopPropagationFunction =
+                boost::bind( &PropagationTerminationCondition::checkStopCondition, propagationTerminationCondition, _1, _2 );
+
         // Create numerical integrator.
         boost::shared_ptr< numerical_integrators::NumericalIntegrator< double, StateType, StateType > > integrator =
                 numerical_integrators::createIntegrator< double, StateType >(
@@ -288,7 +521,7 @@ public:
         }
 
         return integrateEquationsFromIntegrator< StateType, double >(
-                    integrator, integratorSettings->initialTimeStep_, stopPropagationFunction, solutionHistory,
+                    integrator, integratorSettings->initialTimeStep_, propagationTerminationCondition, solutionHistory,
                     dependentVariableHistory,
                     cummulativeComputationTimeHistory,
                     dependentVariableFunction,
@@ -312,7 +545,7 @@ public:
      *  \param solutionHistory History of numerical states given as map (time as key; returned by reference)
      *  \param initialState Initial state
      *  \param integratorSettings Settings for numerical integrator.
-     *  \param stopPropagationFunction Function determining whether the propagation is to be stopped at the current time.
+     *  \param propagationTerminationCondition Object to determine when/how the propagation is to be stopped at the current time.
      *  \param dependentVariableHistory History of dependent variables that are to be saved given as map
      *  (time as key; returned by reference)
      *  \param cummulativeComputationTimeHistory History of cummulative computation times that are to be saved given
@@ -329,7 +562,7 @@ public:
             std::map< Time, StateType >& solutionHistory,
             const StateType initialState,
             const boost::shared_ptr< numerical_integrators::IntegratorSettings< Time > > integratorSettings,
-            const boost::function< bool( const double, const double ) > stopPropagationFunction,
+            const boost::shared_ptr< PropagationTerminationCondition > propagationTerminationCondition,
             std::map< Time, Eigen::VectorXd >& dependentVariableHistory,
             std::map< Time, double >& cummulativeComputationTimeHistory,
             const boost::function< Eigen::VectorXd( ) > dependentVariableFunction =
@@ -337,6 +570,9 @@ public:
             const Time printInterval = TUDAT_NAN,
             const std::chrono::steady_clock::time_point initialClockTime = std::chrono::steady_clock::now( ) )
     {
+        boost::function< bool( const double, const double ) > stopPropagationFunction =
+                boost::bind( &PropagationTerminationCondition::checkStopCondition, propagationTerminationCondition, _1, _2 );
+
         // Create numerical integrator.
         boost::shared_ptr< numerical_integrators::NumericalIntegrator< Time, StateType, StateType, long double > > integrator =
                 numerical_integrators::createIntegrator< Time, StateType, long double  >(
@@ -348,7 +584,7 @@ public:
         }
 
         return integrateEquationsFromIntegrator< StateType, Time, long double >(
-                    integrator, integratorSettings->initialTimeStep_, stopPropagationFunction, solutionHistory,
+                    integrator, integratorSettings->initialTimeStep_, propagationTerminationCondition, solutionHistory,
                     dependentVariableHistory,
                     cummulativeComputationTimeHistory,
                     dependentVariableFunction,
diff --git a/Tudat/CMakeLists.txt b/Tudat/CMakeLists.txt
index 15a2655..7956e17 100755
--- a/Tudat/CMakeLists.txt
+++ b/Tudat/CMakeLists.txt
@@ -297,14 +297,14 @@ endif()
 list(APPEND TUDAT_PROPAGATION_LIBRARIES tudat_simulation_setup tudat_ground_stations tudat_propagators
     tudat_aerodynamics tudat_system_models tudat_geometric_shapes tudat_relativity tudat_gravitation tudat_mission_segments
     tudat_electro_magnetism tudat_propulsion tudat_ephemerides ${TUDAT_ITRS_LIBRARIES} tudat_numerical_integrators tudat_reference_frames
-     tudat_statistics tudat_propagators ${TUDAT_EXTERNAL_INTERFACE_LIBRARIES} tudat_basic_astrodynamics tudat_basic_mathematics
+     tudat_statistics tudat_propagators ${TUDAT_EXTERNAL_INTERFACE_LIBRARIES} tudat_basic_astrodynamics tudat_root_finders tudat_basic_mathematics
      tudat_input_output tudat_basics ${TUDAT_EXTERNAL_LIBRARIES})
 
 list(APPEND TUDAT_ESTIMATION_LIBRARIES tudat_simulation_setup tudat_observation_models tudat_ground_stations tudat_acceleration_partials
     tudat_observation_partials tudat_estimatable_parameters tudat_orbit_determination  tudat_propagators
     tudat_aerodynamics tudat_system_models tudat_geometric_shapes tudat_relativity tudat_gravitation tudat_mission_segments
     tudat_electro_magnetism tudat_propulsion tudat_ephemerides ${TUDAT_ITRS_LIBRARIES} tudat_numerical_integrators tudat_reference_frames
-    tudat_statistics tudat_propagators ${TUDAT_EXTERNAL_INTERFACE_LIBRARIES} tudat_basic_astrodynamics tudat_basic_mathematics
+    tudat_statistics tudat_propagators ${TUDAT_EXTERNAL_INTERFACE_LIBRARIES} tudat_basic_astrodynamics tudat_root_finders tudat_basic_mathematics
     tudat_input_output tudat_basics ${TUDAT_EXTERNAL_LIBRARIES})
 
 
diff --git a/Tudat/JsonInterface/UnitTests/inputs/unitTestSimulationSinglePerturbedSatellite/main.json b/Tudat/JsonInterface/UnitTests/inputs/unitTestSimulationSinglePerturbedSatellite/main.json
index e86f599..3ca1cd0 100644
--- a/Tudat/JsonInterface/UnitTests/inputs/unitTestSimulationSinglePerturbedSatellite/main.json
+++ b/Tudat/JsonInterface/UnitTests/inputs/unitTestSimulationSinglePerturbedSatellite/main.json
@@ -102,5 +102,26 @@
   "integrator": {
     "type": "rungeKutta4",
     "stepSize": 10
-  }
-}
\ No newline at end of file
+  },
+    "export": [
+        {
+            "file": "kepler_output.dat",
+            "variables": [
+                {
+                    "body": "asterix",
+                    "dependentVariableType": "keplerElements",
+                    "relativeToBody": "Earth"
+                }
+            ]
+        },
+        {
+            "file": "cartesian_output.dat",
+            "variables": [
+                {
+                    "type": "state"
+                }
+            ]
+        }
+    ]
+}
+
diff --git a/Tudat/Mathematics/NumericalIntegrators/euler.h b/Tudat/Mathematics/NumericalIntegrators/euler.h
index 37424c4..551dd05 100644
--- a/Tudat/Mathematics/NumericalIntegrators/euler.h
+++ b/Tudat/Mathematics/NumericalIntegrators/euler.h
@@ -142,6 +142,16 @@ public:
         return true;
     }
 
+    IndependentVariableType getPreviousIndependentVariable( )
+    {
+        return this->lastIndependentVariable_;
+    }
+
+    StateType getPreviousState( )
+    {
+        return this->lastState_;
+    }
+
     //! Modify the state at the current value of the independent variable.
     /*!
      * Modify the state at the current value of the independent variable.
diff --git a/Tudat/Mathematics/NumericalIntegrators/numericalIntegrator.h b/Tudat/Mathematics/NumericalIntegrators/numericalIntegrator.h
index 354c0d3..8fb2b8e 100644
--- a/Tudat/Mathematics/NumericalIntegrators/numericalIntegrator.h
+++ b/Tudat/Mathematics/NumericalIntegrators/numericalIntegrator.h
@@ -99,6 +99,16 @@ public:
      */
     virtual bool rollbackToPreviousState( ) = 0;
 
+    virtual IndependentVariableType getPreviousIndependentVariable( )
+    {
+        throw std::runtime_error( "Function getPreviousIndependentVariable not implemented in this integrator" );
+    }
+
+    virtual StateType getPreviousState( )
+    {
+        throw std::runtime_error( "Function getPreviousState not implemented in this integrator" );
+    }
+
     //! Perform an integration to a specified independent variable value.
     /*!
      * Performs an integration to independentVariableEnd with initial state and initial independent
@@ -160,6 +170,9 @@ public:
         propagationTerminationFunction_ = terminationFunction;
     }
 
+    virtual void setStepSizeControl( const bool useStepSizeControl )
+    { }
+
 protected:
 
     //! Function that returns the state derivative.
diff --git a/Tudat/Mathematics/NumericalIntegrators/rungeKutta4Integrator.h b/Tudat/Mathematics/NumericalIntegrators/rungeKutta4Integrator.h
index 4c621ce..bf93247 100644
--- a/Tudat/Mathematics/NumericalIntegrators/rungeKutta4Integrator.h
+++ b/Tudat/Mathematics/NumericalIntegrators/rungeKutta4Integrator.h
@@ -175,6 +175,16 @@ public:
         return true;
     }
 
+    IndependentVariableType getPreviousIndependentVariable( )
+    {
+        return lastIndependentVariable_;
+    }
+
+    StateType getPreviousState( )
+    {
+        return lastState_;
+    }
+
     //! Modify the state at the current value of the independent variable.
     /*!
      * Modify the state at the current value of the independent variable.
diff --git a/Tudat/Mathematics/NumericalIntegrators/rungeKuttaVariableStepSizeIntegrator.h b/Tudat/Mathematics/NumericalIntegrators/rungeKuttaVariableStepSizeIntegrator.h
index c336a77..dfb73b3 100644
--- a/Tudat/Mathematics/NumericalIntegrators/rungeKuttaVariableStepSizeIntegrator.h
+++ b/Tudat/Mathematics/NumericalIntegrators/rungeKuttaVariableStepSizeIntegrator.h
@@ -135,7 +135,7 @@ public:
         safetyFactorForNextStepSize_( std::fabs( static_cast< double >( safetyFactorForNextStepSize ) ) ),
         maximumFactorIncreaseForNextStepSize_( std::fabs( static_cast< double >( maximumFactorIncreaseForNextStepSize ) ) ),
         minimumFactorDecreaseForNextStepSize_( std::fabs( static_cast< double >( minimumFactorDecreaseForNextStepSize ) ) ),
-        newStepSizeFunction_( newStepSizeFunction )
+        newStepSizeFunction_( newStepSizeFunction ), useStepSizeControl_( true )
     {
         // Set default newStepSizeFunction_ to the class method.
         if ( this->newStepSizeFunction_ == 0 )
@@ -197,7 +197,7 @@ public:
         safetyFactorForNextStepSize_( std::fabs( static_cast< double >( safetyFactorForNextStepSize ) ) ),
         maximumFactorIncreaseForNextStepSize_( std::fabs( static_cast< double >( maximumFactorIncreaseForNextStepSize ) ) ),
         minimumFactorDecreaseForNextStepSize_( std::fabs( static_cast< double >( minimumFactorDecreaseForNextStepSize ) ) ),
-        newStepSizeFunction_( newStepSizeFunction )
+        newStepSizeFunction_( newStepSizeFunction ), useStepSizeControl_( true )
     {
         // Set default newStepSizeFunction_ to the class method.
         if ( newStepSizeFunction_ == 0 )
@@ -238,8 +238,8 @@ public:
      * Runge-Kutta scheme.
      * \return Current state derivatives evaluated according to stages of Runge-Kutta scheme.
      */
-    std::vector< StateDerivativeType > getCurrentStateDerivatives( ) 
-    { 
+    std::vector< StateDerivativeType > getCurrentStateDerivatives( )
+    {
         return currentStateDerivatives_;
     }
 
@@ -272,6 +272,16 @@ public:
         return true;
     }
 
+    IndependentVariableType getPreviousIndependentVariable( )
+    {
+        return this->lastIndependentVariable_;
+    }
+
+    StateType getPreviousState( )
+    {
+        return this->lastState_;
+    }
+
     //! Modify the state at the current interval.
     /*!
      * Modify the state at the current interval. This allows for discrete jumps in the state, often
@@ -288,6 +298,11 @@ public:
         this->lastIndependentVariable_ = currentIndependentVariable_;
     }
 
+    void setStepSizeControl( const bool useStepSizeControl )
+    {
+        useStepSizeControl_ = useStepSizeControl;
+    }
+
 protected:
 
     //! Computes the next step size and validates the result.
@@ -424,6 +439,8 @@ protected:
      * Vector of state derivatives, i.e. values of k_{i} in Runge-Kutta scheme.
      */
     std::vector< StateDerivativeType > currentStateDerivatives_;
+
+    bool useStepSizeControl_;
 };
 
 //! Perform a single integration step.
@@ -438,7 +455,7 @@ RungeKuttaVariableStepSizeIntegrator< IndependentVariableType, StateType, StateD
 
     // Define lower and higher order estimates.
     StateType lowerOrderEstimate( this->currentState_ ),
-              higherOrderEstimate( this->currentState_ );
+            higherOrderEstimate( this->currentState_ );
 
     // Compute the k_i state derivatives per stage.
     for ( int stage = 0; stage < this->coefficients_.cCoefficients.rows( ); stage++ )
@@ -512,54 +529,62 @@ RungeKuttaVariableStepSizeIntegrator< IndependentVariableType, StateType, StateD
         const StateType& lowerOrderEstimate, const StateType& higherOrderEstimate,
         const TimeStepType stepSize )
 {
-    // Compute new step size using new step size function, which also returns whether the
-    // relative error is within bounds or not.
-    std::pair< TimeStepType, bool > newStepSizePair = this->newStepSizeFunction_(
-                stepSize, this->coefficients_.lowerOrder, this->coefficients_.higherOrder,
-                this->safetyFactorForNextStepSize_, this->relativeErrorTolerance_,
-                this->absoluteErrorTolerance_, lowerOrderEstimate,
-                higherOrderEstimate );
-
-    // Check whether change in stepsize does not exceed bounds.
-    // If the stepsize is reduced to less than the prescibed minimum factor, set to minimum factor.
-    // If the stepsize is increased to more than the prescribed maximum factor, set to maximum
-    // factor. These bounds are necessary to prevent the stepsize changes from aliasing
-    // with the dynamics of the system of ODEs.
-    // Also check if maximum step size is exceeded and step next step size to maximum if necessary.
-    // Typically used bounds can be found in (Burden and Faires, 2001).
-    if ( newStepSizePair.first / stepSize <= this->minimumFactorDecreaseForNextStepSize_ )
+    if( useStepSizeControl_ )
     {
-        this->stepSize_ = stepSize * this->minimumFactorDecreaseForNextStepSize_;
-    }
+        // Compute new step size using new step size function, which also returns whether the
+        // relative error is within bounds or not.
+        std::pair< TimeStepType, bool > newStepSizePair = this->newStepSizeFunction_(
+                    stepSize, this->coefficients_.lowerOrder, this->coefficients_.higherOrder,
+                    this->safetyFactorForNextStepSize_, this->relativeErrorTolerance_,
+                    this->absoluteErrorTolerance_, lowerOrderEstimate,
+                    higherOrderEstimate );
+
+        // Check whether change in stepsize does not exceed bounds.
+        // If the stepsize is reduced to less than the prescibed minimum factor, set to minimum factor.
+        // If the stepsize is increased to more than the prescribed maximum factor, set to maximum
+        // factor. These bounds are necessary to prevent the stepsize changes from aliasing
+        // with the dynamics of the system of ODEs.
+        // Also check if maximum step size is exceeded and step next step size to maximum if necessary.
+        // Typically used bounds can be found in (Burden and Faires, 2001).
+        if ( newStepSizePair.first / stepSize <= this->minimumFactorDecreaseForNextStepSize_ )
+        {
+            this->stepSize_ = stepSize * this->minimumFactorDecreaseForNextStepSize_;
+        }
 
-    else if ( newStepSizePair.first / stepSize >= maximumFactorIncreaseForNextStepSize_ )
-    {
-        this->stepSize_ = stepSize * this->maximumFactorIncreaseForNextStepSize_;
-    }
+        else if ( newStepSizePair.first / stepSize >= maximumFactorIncreaseForNextStepSize_ )
+        {
+            this->stepSize_ = stepSize * this->maximumFactorIncreaseForNextStepSize_;
+        }
 
-    else
-    {
-       this->stepSize_ = newStepSizePair.first;
-    }
+        else
+        {
+            this->stepSize_ = newStepSizePair.first;
+        }
 
-    // Check if minimum step size is violated and throw exception if necessary.
-    if ( std::fabs( this->stepSize_ ) < std::fabs( this->minimumStepSize_ ) )
-    {
-        throw MinimumStepSizeExceededError( std::fabs( this->minimumStepSize_ ),
-                                                      std::fabs( this->stepSize_ ) );
-    }
-    else if( std::fabs( this->stepSize_ ) > std::fabs( this->maximumStepSize_ ) )
-    {
-        this->stepSize_ = stepSize / std::fabs( stepSize ) * std::fabs( this->maximumStepSize_ );
-    }
+        // Check if minimum step size is violated and throw exception if necessary.
+        if ( std::fabs( this->stepSize_ ) < std::fabs( this->minimumStepSize_ ) )
+        {
+            throw MinimumStepSizeExceededError( std::fabs( this->minimumStepSize_ ),
+                                                std::fabs( this->stepSize_ ) );
+        }
+        else if( std::fabs( this->stepSize_ ) > std::fabs( this->maximumStepSize_ ) )
+        {
+            this->stepSize_ = stepSize / std::fabs( stepSize ) * std::fabs( this->maximumStepSize_ );
+        }
+
+        if( stepSize * this->stepSize_ < 0 )
+        {
+            throw std::runtime_error( "Error during step size control, step size flipped sign" );
+        }
 
-    if( stepSize * this->stepSize_ < 0 )
+        // Check if computed error in state is too large and reject step if true.
+        return newStepSizePair.second;
+    }
+    else
     {
-        throw std::runtime_error( "Error during step size control, step size flipped sign" );
+        this->stepSize_ = stepSize;
+        return true;
     }
-
-    // Check if computed error in state is too large and reject step if true.
-    return newStepSizePair.second;
 }
 
 //! Compute new step size.
diff --git a/Tudat/Mathematics/RootFinders/CMakeLists.txt b/Tudat/Mathematics/RootFinders/CMakeLists.txt
index c294008..b6231b5 100755
--- a/Tudat/Mathematics/RootFinders/CMakeLists.txt
+++ b/Tudat/Mathematics/RootFinders/CMakeLists.txt
@@ -16,6 +16,7 @@ set(ROOTFINDERS_HEADERS
   "${SRCROOT}${MATHEMATICSDIR}/RootFinders/secantRootFinder.h"
   "${SRCROOT}${MATHEMATICSDIR}/RootFinders/bisection.h"
   "${SRCROOT}${MATHEMATICSDIR}/RootFinders/terminationConditions.h"
+  "${SRCROOT}${MATHEMATICSDIR}/RootFinders/createRootFinder.h"
   "${SRCROOT}${MATHEMATICSDIR}/RootFinders/UnitTests/testFunction.h"
   "${SRCROOT}${MATHEMATICSDIR}/RootFinders/UnitTests/testFunction1.h"
   "${SRCROOT}${MATHEMATICSDIR}/RootFinders/UnitTests/testFunction2.h"
@@ -25,7 +26,7 @@ set(ROOTFINDERS_HEADERS
 )
 
 set(ROOTFINDERS_SOURCES
-  "${SRCROOT}${MATHEMATICSDIR}/RootFinders/dummyRootFinder.cpp"
+  "${SRCROOT}${MATHEMATICSDIR}/RootFinders/createRootFinder.cpp"
 )
 
 
diff --git a/Tudat/Mathematics/RootFinders/bisection.h b/Tudat/Mathematics/RootFinders/bisection.h
index f1ed409..ef7c4ad 100644
--- a/Tudat/Mathematics/RootFinders/bisection.h
+++ b/Tudat/Mathematics/RootFinders/bisection.h
@@ -20,6 +20,8 @@
 #ifndef TUDAT_BISECTION_H
 #define TUDAT_BISECTION_H
 
+#include <iostream>
+
 #include <boost/bind.hpp>
 #include <boost/make_shared.hpp>
 #include <boost/shared_ptr.hpp>
diff --git a/Tudat/Mathematics/RootFinders/createRootFinder.h b/Tudat/Mathematics/RootFinders/createRootFinder.h
new file mode 100644
index 0000000..27c1746
--- /dev/null
+++ b/Tudat/Mathematics/RootFinders/createRootFinder.h
@@ -0,0 +1,102 @@
+/*    Copyright (c) 2010-2017, Delft University of Technology
+ *    All rigths reserved
+ *
+ *    This file is part of the Tudat. Redistribution and use in source and
+ *    binary forms, with or without modification, are permitted exclusively
+ *    under the terms of the Modified BSD license. You should have received
+ *    a copy of the license with this file. If not, please or visit:
+ *    http://tudat.tudelft.nl/LICENSE.
+ *
+ */
+
+#ifndef TUDAT_CREATE_ROOT_FINDERS_H
+#define TUDAT_CREATE_ROOT_FINDERS_H
+
+#include <Tudat/Mathematics/RootFinders/rootFinder.h>
+#include <Tudat/Mathematics/RootFinders/bisection.h>
+#include <Tudat/Mathematics/RootFinders/halleyRootFinder.h>
+#include <Tudat/Mathematics/RootFinders/newtonRaphson.h>
+#include <Tudat/Mathematics/RootFinders/secantRootFinder.h>
+
+namespace tudat
+{
+
+namespace root_finders
+{
+
+enum RootFinderType
+{
+    bisection_root_finder,
+    halley_root_finder,
+    newton_raphson_root_finder,
+    secant_root_finder
+};
+
+class RootFinderSettings
+{
+public:
+    RootFinderSettings( const RootFinderType rootFinderType,
+                        const double terminationTolerance, const unsigned int maximumNumberOfIterations  ):
+        rootFinderType_( rootFinderType ), terminationTolerance_( terminationTolerance ),
+        maximumNumberOfIterations_( maximumNumberOfIterations ){ }
+
+    ~RootFinderSettings( ){ }
+
+    RootFinderType rootFinderType_;
+
+    double terminationTolerance_;
+
+    unsigned int maximumNumberOfIterations_;
+
+};
+
+bool doesRootFinderRequireDerivatives( const boost::shared_ptr< RootFinderSettings > rootFinderSettings );
+
+
+template< typename DataType = double >
+boost::shared_ptr< RootFinderCore< DataType > > createRootFinder(
+        const boost::shared_ptr< RootFinderSettings > rootFinderSettings,
+        const DataType lowerBound = TUDAT_NAN, const DataType upperBound = TUDAT_NAN,
+        const DataType previousGuess = TUDAT_NAN )
+{
+    boost::shared_ptr< RootFinderCore< DataType > > rootFinder;
+    switch( rootFinderSettings->rootFinderType_ )
+    {
+    case bisection_root_finder:
+        if( !( lowerBound == lowerBound ) || !( upperBound == upperBound ) )
+        {
+            throw std::runtime_error( "Error when making bisection root finder, lower/upped bound not provided" );
+        }
+        rootFinder = boost::make_shared< BisectionCore< DataType > >(
+                    rootFinderSettings->terminationTolerance_, rootFinderSettings->maximumNumberOfIterations_,
+                    lowerBound, upperBound );
+        break;
+    case halley_root_finder:
+        rootFinder = boost::make_shared< HalleyRootFinderCore< DataType > >(
+                    rootFinderSettings->terminationTolerance_, rootFinderSettings->maximumNumberOfIterations_ );
+        break;
+    case newton_raphson_root_finder:
+
+        rootFinder = boost::make_shared< NewtonRaphsonCore< DataType > >(
+                    rootFinderSettings->terminationTolerance_, rootFinderSettings->maximumNumberOfIterations_ );
+        break;
+    case secant_root_finder:
+        if( !( previousGuess == previousGuess ) )
+        {
+            throw std::runtime_error( "Error when making secant root finder, initial guess not provided" );
+        }
+        rootFinder = boost::make_shared< SecantRootFinderCore< DataType > >(
+                    rootFinderSettings->terminationTolerance_, rootFinderSettings->maximumNumberOfIterations_,
+                    previousGuess );
+        break;
+    default:
+        throw std::runtime_error( "Error when creating root finder, did not recognize root finder type" );
+    }
+    return rootFinder;
+}
+
+} // namespace root_finders
+
+} // namespace tudat
+
+#endif // TUDAT_CREATE_ROOT_FINDERS_H
diff --git a/Tudat/Mathematics/RootFinders/dummyRootFinder.cpp b/Tudat/Mathematics/RootFinders/dummyRootFinder.cpp
deleted file mode 100644
index c37b7cc..0000000
--- a/Tudat/Mathematics/RootFinders/dummyRootFinder.cpp
+++ /dev/null
@@ -1,3 +0,0 @@
-#include "Tudat/Mathematics/RootFinders/rootFinder.h"
-
-// FILE INCLUDED FOR COMPATIBILITY (MUST HAVE .CPP FILE ON SOME SYSTEMS)
diff --git a/Tudat/SimulationSetup/PropagationSetup/dynamicsSimulator.h b/Tudat/SimulationSetup/PropagationSetup/dynamicsSimulator.h
index 5bc1c6b..199cc89 100644
--- a/Tudat/SimulationSetup/PropagationSetup/dynamicsSimulator.h
+++ b/Tudat/SimulationSetup/PropagationSetup/dynamicsSimulator.h
@@ -430,8 +430,7 @@ public:
                     stateDerivativeFunction_, equationsOfMotionNumericalSolutionRaw_,
                     dynamicsStateDerivative_->convertFromOutputSolution(
                         initialStates, this->initialPropagationTime_ ), integratorSettings_,
-                    boost::bind( &PropagationTerminationCondition::checkStopCondition,
-                                 propagationTerminationCondition_, _1, _2 ),
+                    propagationTerminationCondition_,
                     dependentVariableHistory_,
                     cummulativeComputationTimeHistory_,
                     dependentVariablesFunctions_,
diff --git a/Tudat/SimulationSetup/PropagationSetup/propagationTermination.cpp b/Tudat/SimulationSetup/PropagationSetup/propagationTermination.cpp
index c4a20bd..7153be7 100644
--- a/Tudat/SimulationSetup/PropagationSetup/propagationTermination.cpp
+++ b/Tudat/SimulationSetup/PropagationSetup/propagationTermination.cpp
@@ -106,7 +106,8 @@ boost::shared_ptr< PropagationTerminationCondition > createPropagationTerminatio
         boost::shared_ptr< PropagationTimeTerminationSettings > timeTerminationSettings =
                 boost::dynamic_pointer_cast< PropagationTimeTerminationSettings >( terminationSettings );
         propagationTerminationCondition = boost::make_shared< FixedTimePropagationTerminationCondition >(
-                    timeTerminationSettings->terminationTime_, ( initialTimeStep > 0 ) );
+                    timeTerminationSettings->terminationTime_, ( initialTimeStep > 0 ),
+                    timeTerminationSettings->terminateExactlyOnFinalCondition_ );
         break;
     }
     case cpu_time_stopping_condition:
@@ -140,7 +141,9 @@ boost::shared_ptr< PropagationTerminationCondition > createPropagationTerminatio
         propagationTerminationCondition = boost::make_shared< SingleVariableLimitPropagationTerminationCondition >(
                     dependentVariableTerminationSettings->dependentVariableSettings_,
                     dependentVariableFunction, dependentVariableTerminationSettings->limitValue_,
-                    dependentVariableTerminationSettings->useAsLowerLimit_ );
+                    dependentVariableTerminationSettings->useAsLowerLimit_,
+                    dependentVariableTerminationSettings->terminateExactlyOnFinalCondition_,
+                    dependentVariableTerminationSettings->terminationRootFinderSettings_ );
         break;
     }
     case hybrid_stopping_condition:
@@ -158,7 +161,8 @@ boost::shared_ptr< PropagationTerminationCondition > createPropagationTerminatio
                             bodyMap, initialTimeStep ) );
         }
         propagationTerminationCondition = boost::make_shared< HybridPropagationTerminationCondition >(
-                    propagationTerminationConditionList, hybridTerminationSettings->fulFillSingleCondition_ );
+                    propagationTerminationConditionList, hybridTerminationSettings->fulFillSingleCondition_,
+                    hybridTerminationSettings->terminateExactlyOnFinalCondition_ );
         break;
     }
     default:
diff --git a/Tudat/SimulationSetup/PropagationSetup/propagationTermination.h b/Tudat/SimulationSetup/PropagationSetup/propagationTermination.h
index b2e4611..01ee3bc 100644
--- a/Tudat/SimulationSetup/PropagationSetup/propagationTermination.h
+++ b/Tudat/SimulationSetup/PropagationSetup/propagationTermination.h
@@ -42,7 +42,16 @@ class PropagationTerminationCondition
 public:
 
     //! Constructor
-    PropagationTerminationCondition( ){ }
+    /*!
+     * Constructor
+     * \param terminationType Type of termination conditions
+     * \param terminateExactlyOnFinalCondition Boolean to denote whether the propagation is to terminate exactly on the final
+     * condition, or whether it is to terminate on the first step where it is violated.
+     */
+    PropagationTerminationCondition(
+            const PropagationTerminationTypes terminationType,
+            const bool terminateExactlyOnFinalCondition = false ):
+        terminationType_( terminationType ), terminateExactlyOnFinalCondition_( terminateExactlyOnFinalCondition ){ }
 
     //! Destructor
     virtual ~PropagationTerminationCondition( ){ }
@@ -56,6 +65,23 @@ public:
      * \return True if propagation is to be stopped, false otherwise.
      */
     virtual bool checkStopCondition( const double time, const double cpuTime ) = 0;
+
+    virtual PropagationTerminationTypes getTerminationType( )
+    {
+        return terminationType_;
+    }
+
+    bool getTerminateExactlyOnFinalCondition( )
+    {
+        return terminateExactlyOnFinalCondition_;
+    }
+
+protected:
+
+    PropagationTerminationTypes terminationType_;
+
+    bool terminateExactlyOnFinalCondition_;
+
 };
 
 //! Class for stopping the propagation after a fixed amount of time (i.e. for certain independent variable value)
@@ -69,10 +95,14 @@ public:
      * \param stopTime Time at which the propagation is to stop.
      * \param propagationDirectionIsPositive Boolean denoting whether propagation is forward (if true) or backwards
      * (if false) in time.
+     * \param terminateExactlyOnFinalCondition Boolean to denote whether the propagation is to terminate exactly on the final
+     * condition, or whether it is to terminate on the first step where it is violated.
      */
     FixedTimePropagationTerminationCondition(
             const double stopTime,
-            const bool propagationDirectionIsPositive ):
+            const bool propagationDirectionIsPositive,
+            const bool terminateExactlyOnFinalCondition = false ):
+        PropagationTerminationCondition( time_stopping_condition, terminateExactlyOnFinalCondition ),
         stopTime_( stopTime ),
         propagationDirectionIsPositive_( propagationDirectionIsPositive ){ }
 
@@ -86,6 +116,11 @@ public:
      */
     bool checkStopCondition( const double time, const double cpuTime );
 
+    double getStopTime( )
+    {
+        return stopTime_;
+    }
+
 private:
 
     //! Time at which the propagation is to stop.
@@ -106,6 +141,7 @@ public:
      * \param cpuStopTime CPU time at which the propagation is to stop.
      */
     FixedCPUTimePropagationTerminationCondition( const double cpuStopTime ) :
+        PropagationTerminationCondition( cpu_time_stopping_condition, false ),
         cpuStopTime_( cpuStopTime ) { }
 
 
@@ -138,14 +174,32 @@ public:
      * \param limitingValue Value at which the propagation is to be stopped
      * \param useAsLowerBound Boolean denoting whether the propagation should stop if the dependent variable goes below
      * (if true) or above (if false) limitingValue
+     * \param terminateExactlyOnFinalCondition Boolean to denote whether the propagation is to terminate exactly on the final
+     * condition, or whether it is to terminate on the first step where it is violated.
+     * \param terminationRootFinderSettings Settings to create root finder used to converge on exact final condition.
      */
     SingleVariableLimitPropagationTerminationCondition(
             const boost::shared_ptr< SingleDependentVariableSaveSettings > dependentVariableSettings,
             const boost::function< double( ) > variableRetrievalFuntion,
             const double limitingValue,
-            const bool useAsLowerBound ):
+            const bool useAsLowerBound,
+            const bool terminateExactlyOnFinalCondition = false,
+            const boost::shared_ptr< root_finders::RootFinderSettings > terminationRootFinderSettings = NULL ):
+        PropagationTerminationCondition(
+            dependent_variable_stopping_condition, terminateExactlyOnFinalCondition ),
         dependentVariableSettings_( dependentVariableSettings ), variableRetrievalFuntion_( variableRetrievalFuntion ),
-        limitingValue_( limitingValue ), useAsLowerBound_( useAsLowerBound ){ }
+        limitingValue_( limitingValue ), useAsLowerBound_( useAsLowerBound ),
+    terminationRootFinderSettings_( terminationRootFinderSettings )
+    {
+        if( ( terminateExactlyOnFinalCondition == false ) && ( terminationRootFinderSettings != NULL ) )
+        {
+            std::cerr<<"Warning, root finder provided to SingleVariableLimitPropagationTerminationCondition, but termination on final conditions set to false"<<std::endl;
+        }
+        if( ( terminateExactlyOnFinalCondition == true ) && doesRootFinderRequireDerivatives( terminationRootFinderSettings ) )
+        {
+            throw std::runtime_error( "Error when setting exact dependent variable termination, requested root finder requires derivatives; not available in state derivative model" );
+        }
+    }
 
     //! Destructor.
     ~SingleVariableLimitPropagationTerminationCondition( ){ }
@@ -160,6 +214,16 @@ public:
      */
     bool checkStopCondition( const double time, const double cpuTime );
 
+    double getStopConditionError( )
+    {
+         return variableRetrievalFuntion_( ) - limitingValue_;
+    }
+
+    boost::shared_ptr< root_finders::RootFinderSettings > getTerminationRootFinderSettings( )
+    {
+        return terminationRootFinderSettings_;
+    }
+
 private:
 
     //! Settings for dependent variable that is to be checked
@@ -174,6 +238,8 @@ private:
     //! Boolean denoting whether the propagation should stop if the dependent variable goes below
     //! (if true) or above (if false) limitingValue
     bool useAsLowerBound_;
+
+    boost::shared_ptr< root_finders::RootFinderSettings > terminationRootFinderSettings_;
 };
 
 //! Class for stopping the propagation when one or all of a given set of stopping conditions is reached.
@@ -187,11 +253,15 @@ public:
      * \param propagationTerminationCondition List of termination conditions that are checked when calling
      * checkStopCondition is called.
      * \param fulFillSingleCondition Boolean denoting whether a single (if true) or all (if false) of the entries in the
-     * propagationTerminationCondition_ should return true from the checkStopCondition function to stop the propagation.
+     * propagationTerminationCondition_ should return true from the checkStopCondition function to stop the propagation
+     * \param terminateExactlyOnFinalCondition Boolean to denote whether the propagation is to terminate exactly on the final
+     * condition, or whether it is to terminate on the first step where it is violated.
      */
     HybridPropagationTerminationCondition(
             const std::vector< boost::shared_ptr< PropagationTerminationCondition > > propagationTerminationCondition,
-            const bool fulFillSingleCondition = 0 ):
+            const bool fulFillSingleCondition = 0,
+            const bool terminateExactlyOnFinalCondition = 0 ):
+        PropagationTerminationCondition( hybrid_stopping_condition, terminateExactlyOnFinalCondition ),
         propagationTerminationCondition_( propagationTerminationCondition ),
         fulFillSingleCondition_( fulFillSingleCondition ){ }
 
@@ -205,6 +275,16 @@ public:
      */
     bool checkStopCondition( const double time, const double cpuTime );
 
+    std::vector< boost::shared_ptr< PropagationTerminationCondition > > getPropagationTerminationConditions( )
+    {
+        return propagationTerminationCondition_;
+    }
+
+    bool getFulFillSingleCondition( )
+    {
+        return fulFillSingleCondition_;
+    }
+
 private:
 
     //! List of termination conditions that are checked when calling checkStopCondition is called.
diff --git a/Tudat/SimulationSetup/PropagationSetup/propagationTerminationSettings.h b/Tudat/SimulationSetup/PropagationSetup/propagationTerminationSettings.h
index 02b3258..8a9ca04 100644
--- a/Tudat/SimulationSetup/PropagationSetup/propagationTerminationSettings.h
+++ b/Tudat/SimulationSetup/PropagationSetup/propagationTerminationSettings.h
@@ -15,6 +15,8 @@
 
 #include <boost/shared_ptr.hpp>
 
+#include "Tudat/Mathematics/RootFinders/createRootFinder.h"
+
 namespace tudat
 {
 
@@ -46,15 +48,20 @@ public:
     /*!
      * Constructor
      * \param terminationType Type of stopping condition that is to be used.
+     * \param terminateExactlyOnFinalCondition Boolean to denote whether the propagation is to terminate exactly on the final
+     * condition, or whether it is to terminate on the first step where it is violated.
      */
-    PropagationTerminationSettings( const PropagationTerminationTypes terminationType ):
-        terminationType_( terminationType ){ }
+    PropagationTerminationSettings( const PropagationTerminationTypes terminationType,
+                                    const bool terminateExactlyOnFinalCondition = false ):
+        terminationType_( terminationType ), terminateExactlyOnFinalCondition_( terminateExactlyOnFinalCondition ){ }
 
     //! Destructor
     virtual ~PropagationTerminationSettings( ){ }
 
     //! Type of stopping condition that is to be used.
     PropagationTerminationTypes terminationType_;
+
+    bool terminateExactlyOnFinalCondition_;
 };
 
 //! Class for propagation stopping conditions settings: stopping the propagation after a fixed amount of time
@@ -70,9 +77,12 @@ public:
     /*!
      * Constructor
      * \param terminationTime Maximum time for the propagation, upon which the propagation is to be stopped
+     * \param terminateExactlyOnFinalCondition Boolean to denote whether the propagation is to terminate exactly on the final
+     * condition, or whether it is to terminate on the first step where it is violated.
      */
-    PropagationTimeTerminationSettings( const double terminationTime ):
-        PropagationTerminationSettings( time_stopping_condition ),
+    PropagationTimeTerminationSettings( const double terminationTime,
+                                        const bool terminateExactlyOnFinalCondition = false ):
+        PropagationTerminationSettings( time_stopping_condition, terminateExactlyOnFinalCondition ),
         terminationTime_( terminationTime ){ }
 
     //! Destructor
@@ -126,14 +136,27 @@ public:
      * \param limitValue Value at which the propagation is to be stopped
      * \param useAsLowerLimit Boolean denoting whether the propagation should stop if the dependent variable goes below
      * (if true) or above (if false) limitingValue
+     * \param terminateExactlyOnFinalCondition Boolean to denote whether the propagation is to terminate exactly on the final
+     * condition, or whether it is to terminate on the first step where it is violated.
+     * \param terminationRootFinderSettings Settings to create root finder used to converge on exact final condition.
      */
     PropagationDependentVariableTerminationSettings(
             const boost::shared_ptr< SingleDependentVariableSaveSettings > dependentVariableSettings,
             const double limitValue,
-            const bool useAsLowerLimit ):
-        PropagationTerminationSettings( dependent_variable_stopping_condition ),
+            const bool useAsLowerLimit,
+            const bool terminateExactlyOnFinalCondition = false,
+            const boost::shared_ptr< root_finders::RootFinderSettings > terminationRootFinderSettings = NULL ):
+        PropagationTerminationSettings(
+            dependent_variable_stopping_condition, terminateExactlyOnFinalCondition ),
         dependentVariableSettings_( dependentVariableSettings ),
-        limitValue_( limitValue ), useAsLowerLimit_( useAsLowerLimit ){ }
+        limitValue_( limitValue ), useAsLowerLimit_( useAsLowerLimit ),
+        terminationRootFinderSettings_( terminationRootFinderSettings )
+    {
+        if( terminateExactlyOnFinalCondition_ && ( terminationRootFinderSettings_ == NULL ) )
+        {
+            throw std::runtime_error( "Error when defining exavct dependent variable propagation termination settings. Root finder not defined" );
+        }
+    }
 
     //! Destructor
     ~PropagationDependentVariableTerminationSettings( ){ }
@@ -147,6 +170,8 @@ public:
     //! Boolean denoting whether the propagation should stop if the dependent variable goes below (if true) or above
     //! (if false) limitingValue
     bool useAsLowerLimit_;
+
+    boost::shared_ptr< root_finders::RootFinderSettings > terminationRootFinderSettings_;
 };
 
 //! Class for propagation stopping conditions settings: combination of other stopping conditions.
@@ -171,7 +196,20 @@ public:
             const bool fulFillSingleCondition = 0 ):
         PropagationTerminationSettings( hybrid_stopping_condition ),
         terminationSettings_( terminationSettings ),
-        fulFillSingleCondition_( fulFillSingleCondition ){ }
+        fulFillSingleCondition_( fulFillSingleCondition )
+    {
+        for( unsigned int i = 0; i < terminationSettings_.size( ); i++ )
+        {
+            if( i == 0 )
+            {
+                terminateExactlyOnFinalCondition_ = terminationSettings_.at( 0 )->terminateExactlyOnFinalCondition_;
+            }
+            else if( terminationSettings_.at( i )->terminateExactlyOnFinalCondition_ != terminateExactlyOnFinalCondition_ )
+            {
+                throw std::runtime_error( "Error in hybrid termination settings, terminateExactlyOnFinalCondition_ is inconsistent" );
+            }
+        }
+    }
 
     //! Destructor
     ~PropagationHybridTerminationSettings( ){ }
diff --git a/Tudat/SimulationSetup/PropagationSetup/variationalEquationsSolver.h b/Tudat/SimulationSetup/PropagationSetup/variationalEquationsSolver.h
index 36f9350..28b0c55 100644
--- a/Tudat/SimulationSetup/PropagationSetup/variationalEquationsSolver.h
+++ b/Tudat/SimulationSetup/PropagationSetup/variationalEquationsSolver.h
@@ -632,8 +632,7 @@ public:
             EquationIntegrationInterface< MatrixType, TimeType >::integrateEquations(
                         dynamicsSimulator_->getStateDerivativeFunction( ), rawNumericalSolution,
                         initialVariationalState, integratorSettings_,
-                        boost::bind( &PropagationTerminationCondition::checkStopCondition,
-                                     dynamicsSimulator_->getPropagationTerminationCondition( ), _1, _2 ),
+                        dynamicsSimulator_->getPropagationTerminationCondition( ),
                         dependentVariableHistory,
                         cummulativeComputationTimeHistory,
                         dynamicsSimulator_->getDependentVariablesFunctions( ),
@@ -673,8 +672,7 @@ public:
             EquationIntegrationInterface< Eigen::MatrixXd, double >::integrateEquations(
                         dynamicsSimulator_->getDoubleStateDerivativeFunction( ), rawNumericalSolution, initialVariationalState,
                         variationalOnlyIntegratorSettings_,
-                        boost::bind( &PropagationTerminationCondition::checkStopCondition,
-                                     dynamicsSimulator_->getPropagationTerminationCondition( ), _1, _2 ),
+                        dynamicsSimulator_->getPropagationTerminationCondition( ),
                         dependentVariableHistory, cummulativeComputationTimeHistory );
 
             setVariationalEquationsSolution< double, double >(
@@ -1156,9 +1154,7 @@ public:
                             singleArcDynamicsSimulators.at( i )->getStateDerivativeFunction( ),
                             rawNumericalSolution,
                             initialVariationalState, integratorSettings,
-                            boost::bind( &PropagationTerminationCondition::checkStopCondition,
-                                         singleArcDynamicsSimulators.at( i )->getPropagationTerminationCondition( ),
-                                         _1, _2 ),
+                            singleArcDynamicsSimulators.at( i )->getPropagationTerminationCondition( ),
                             dependentVariableHistorySolutions.at( i ),
                             cummulativeComputationTimeHistorySolutions.at( i ),
                             singleArcDynamicsSimulators.at( i )->getDependentVariablesFunctions( ) );
@@ -1242,9 +1238,7 @@ public:
                             singleArcDynamicsSimulators.at( i )->getStateDerivativeFunction( ),
                             rawNumericalSolutions, initialVariationalState,
                             singleArcDynamicsSimulators.at( i )->getIntegratorSettings( ),
-                            boost::bind( &PropagationTerminationCondition::checkStopCondition,
-                                         singleArcDynamicsSimulators.at( i )->getPropagationTerminationCondition( ),
-                                         _1, _2 ),
+                            singleArcDynamicsSimulators.at( i )->getPropagationTerminationCondition( ),
                             dummyDependentVariableHistorySolution, dummyCummulativeComputationTimeHistorySolution );
 
                 // Save state transition and sensitivity matrix solutions for current arc.
