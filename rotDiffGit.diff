diff --git a/Tudat/Astrodynamics/Ephemerides/CMakeLists.txt b/Tudat/Astrodynamics/Ephemerides/CMakeLists.txt
index c6f7518..4205b4c 100644
--- a/Tudat/Astrodynamics/Ephemerides/CMakeLists.txt
+++ b/Tudat/Astrodynamics/Ephemerides/CMakeLists.txt
@@ -37,6 +37,7 @@ set(EPHEMERIDES_SOURCES
   "${SRCROOT}${EPHEMERIDESDIR}/approximatePlanetPositionsBase.cpp"
   "${SRCROOT}${EPHEMERIDESDIR}/approximatePlanetPositions.cpp"
   "${SRCROOT}${EPHEMERIDESDIR}/approximatePlanetPositionsCircularCoplanar.cpp"
+  "${SRCROOT}${EPHEMERIDESDIR}/rotationalEphemeris.cpp"
   "${SRCROOT}${EPHEMERIDESDIR}/cartesianStateExtractor.cpp"
   "${SRCROOT}${EPHEMERIDESDIR}/keplerStateExtractor.cpp"
   "${SRCROOT}${EPHEMERIDESDIR}/simpleRotationalEphemeris.cpp"
@@ -77,6 +78,10 @@ add_executable(test_KeplerStateExtractor "${SRCROOT}${EPHEMERIDESDIR}/UnitTests/
 setup_custom_test_program(test_KeplerStateExtractor "${SRCROOT}${EPHEMERIDESDIR}")
 target_link_libraries(test_KeplerStateExtractor tudat_ephemerides tudat_input_output tudat_basic_astrodynamics tudat_basic_mathematics tudat_root_finders ${Boost_LIBRARIES})
 
+add_executable(test_RotationalEphemeris "${SRCROOT}${EPHEMERIDESDIR}/UnitTests/unitTestRotationalEphemeris.cpp")
+setup_custom_test_program(test_RotationalEphemeris "${SRCROOT}${EPHEMERIDESDIR}")
+target_link_libraries(test_RotationalEphemeris tudat_ephemerides tudat_reference_frames tudat_input_output tudat_basic_astrodynamics tudat_basic_mathematics ${Boost_LIBRARIES})
+
 add_executable(test_SimpleRotationalEphemeris "${SRCROOT}${EPHEMERIDESDIR}/UnitTests/unitTestSimpleRotationalEphemeris.cpp")
 setup_custom_test_program(test_SimpleRotationalEphemeris "${SRCROOT}${EPHEMERIDESDIR}")
 target_link_libraries(test_SimpleRotationalEphemeris tudat_ephemerides tudat_reference_frames tudat_input_output tudat_basic_astrodynamics tudat_basic_mathematics ${Boost_LIBRARIES})
diff --git a/Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestRotationalEphemeris.cpp b/Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestRotationalEphemeris.cpp
new file mode 100644
index 0000000..feaef61
--- /dev/null
+++ b/Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestRotationalEphemeris.cpp
@@ -0,0 +1,154 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+   *    All rights reserved.
+   *
+   *    Redistribution and use in source and binary forms, with or without modification, are
+   *    permitted provided that the following conditions are met:
+   *      - Redistributions of source code must retain the above copyright notice, this list of
+   *        conditions and the following disclaimer.
+   *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+   *        conditions and the following disclaimer in the documentation and/or other materials
+   *        provided with the distribution.
+   *      - Neither the name of the Delft University of Technology nor the names of its contributors
+   *        may be used to endorse or promote products derived from this software without specific
+   *        prior written permission.
+   *
+   *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+   *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+   *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+   *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+   *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+   *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+   *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+   *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+   *    OF THE POSSIBILITY OF SUCH DAMAGE.
+   *
+   *    Changelog
+   *      YYMMDD    Author              Comment
+   *      130219    D. Dirkx            File created.
+   *      130227    R.C.A. Boon         Removed using directives (using namespace), added necessary
+   *                                    using declarations (using ...::member), removed obsolete
+   *                                    include statements
+   *      130302    D. Dirkx            Updated file by putting tests in local scope;
+   *                                    expanded tests.
+   *
+   *    References
+   *
+   *    Notes
+   *      The unit tests use rotation matrices generated by spice, the code for the spice interface
+   *      used to generate these testing values are included in this file, but commented.
+   */
+
+#define BOOST_TEST_MAIN
+
+#include <limits>
+#include <iostream>
+
+#include <boost/test/floating_point_comparison.hpp>
+#include <boost/test/unit_test.hpp>
+
+#include <Eigen/Core>
+
+#include "Tudat/Basics/testMacros.h"
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebra.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/timeConversions.h"
+#include "Tudat/Astrodynamics/Ephemerides/simpleRotationalEphemeris.h"
+//#include "Tudat/External/SpiceInterface/spiceInterface.h"
+//#include "Tudat/InputOutput/basicInputOutput.h"
+
+namespace tudat
+{
+namespace unit_tests
+{
+
+using namespace ephemerides;
+
+BOOST_AUTO_TEST_SUITE( test_rotational_ephemeris )
+
+// Test functions to calculate rotation matrix derivative from angular velocity vector and vice
+// versa.
+BOOST_AUTO_TEST_CASE( testRotationalEphemeris )
+{    
+    // Define names of frames.
+    const std::string baseFrame = "J2000";
+    const std::string targetFrame = "IAU_VENUS";
+
+    // Set time at which rotational ephemeris it to be called for subsequent tests.
+
+    // Test rotation to target frame at specified time.
+    {
+
+        // The following code block can be used to retrieve the benchmark data from Spice.
+        //        spice_interface::loadSpiceKernelInTudat( input_output::getSpiceKernelPath( ) +
+        // "pck00010.tpc" );
+        //        const double secondsSinceJ2000 = 1.0E6;
+        //        Eigen::Quaterniond spiceRotationMatrix =
+        //                spice_interface::computeRotationQuaternionBetweenFrames(
+        // baseFrame, targetFrame, secondsSinceJ2000 );
+        //        Eigen::Matrix3d spiceRotationMatrixDerivative =
+        //                spice_interface::computeRotationMatrixDerivativeBetweenFrames(
+        // baseFrame, targetFrame, secondsSinceJ2000 );
+        //        Eigen::Vector3d spiceRotationalVelocityVector =
+        //                spice_interface::getAngularVelocityVectorOfFrameInOriginalFrame(
+        // baseFrame, targetFrame, secondsSinceJ2000 );
+
+        // Set rotational characteristics at given time, as calculated with Spice
+        // (see above commented lines).
+        Eigen::Matrix3d spiceRotationMatrixDerivative;
+        spiceRotationMatrixDerivative <<
+                1.690407961416589e-07, 2.288121921543265e-07, 9.283170431475241e-08,
+                -2.468632444964533e-07, 1.540516111965609e-07, 6.981529179974795e-08,
+                0.0,           0.0,          0.0;
+
+        Eigen::Matrix3d spiceRotationMatrix;
+        spiceRotationMatrix << -0.8249537745726603, 0.5148010526833556, 0.2333048348715243,
+                -0.5648910720519699, -0.7646317780963481, -0.3102197940834743,
+                0.01869081416890206, -0.3877088083617987, 0.9215923900425707;
+
+        Eigen::Vector3d spiceRotationalVelocityVector;
+        spiceRotationalVelocityVector << -5.593131603532092e-09,
+                1.160198999048488e-07,
+                -2.75781861386115e-07;
+
+        // Calculate rotational velocity from SPICE rotation matrix derivative.
+        Eigen::Vector3d rotationalVelocityVector =
+                getRotationalVelocityVectorInBaseFrameFromMatrices(
+                    spiceRotationMatrix, spiceRotationMatrixDerivative.transpose( ) );
+
+        // Calculate rotation matrix derivative from SPICE rotational velocity vector.
+        Eigen::Matrix3d rotationMatrixDerivative = getDerivativeOfRotationMatrixToFrame(
+                    spiceRotationMatrix, spiceRotationalVelocityVector );
+
+        // Calculate rotational velocity from previously calculated rotation matrix derivative.
+        Eigen::Matrix3d backCalculatedRotationMatrixDerivative =
+                getDerivativeOfRotationMatrixToFrame(
+                    spiceRotationMatrix, rotationalVelocityVector );
+
+        // Calculate rotation matrix derivative from previously calculated rotational velocity
+        // vector.
+        Eigen::Vector3d backCalculatedRotationalVelocityVector =
+                getRotationalVelocityVectorInBaseFrameFromMatrices(
+                    spiceRotationMatrix, rotationMatrixDerivative.transpose( ) );
+
+        // Check equivalence of results.
+        for( int i = 0; i < 3; i++ )
+        {
+            BOOST_CHECK_SMALL( rotationalVelocityVector( i ) -
+                               backCalculatedRotationalVelocityVector( i ), 2.0E-22 );
+            BOOST_CHECK_SMALL( rotationalVelocityVector( i ) -
+                               spiceRotationalVelocityVector( i ), 2.0E-22 );
+
+            for( int j = 0; j < 3; j++ )
+            {
+                BOOST_CHECK_SMALL( rotationMatrixDerivative( i, j ) -
+                                   backCalculatedRotationMatrixDerivative( i, j ), 2.0E-22 );
+                BOOST_CHECK_SMALL( rotationMatrixDerivative( i, j ) -
+                                   spiceRotationMatrixDerivative( i, j ), 2.0E-22 );
+            }
+        }
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+} // namespace unit_tests
+} // namespace tudat
diff --git a/Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestSimpleRotationalEphemeris.cpp b/Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestSimpleRotationalEphemeris.cpp
index 9b14333..89e1a02 100644
--- a/Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestSimpleRotationalEphemeris.cpp
+++ b/Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestSimpleRotationalEphemeris.cpp
@@ -52,6 +52,8 @@
 
 #include "Tudat/Astrodynamics/BasicAstrodynamics/timeConversions.h"
 #include "Tudat/Astrodynamics/Ephemerides/simpleRotationalEphemeris.h"
+//#include "Tudat/External/SpiceInterface/spiceInterface.h"
+//#include "Tudat/InputOutput/basicInputOutput.h"
 #include "Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h"
 
 namespace tudat
@@ -140,11 +142,20 @@ BOOST_AUTO_TEST_CASE( testSimpleRotationalEphemeris )
 
     // Test rotation to target frame at specified time.
     {
-        // The following code block can be used to retrieve the benchmark data from Spice.
         /*
-        Eigen::Quaterniond spiceInitialRotationToTargetFrame =
-               computeRotationQuaternionBetweenFrames( baseFrame, targetFrame, secondsSinceJ2000 );
+        spice_interface::loadSpiceKernelInTudat( input_output::getSpiceKernelPath( ) + "pck00010.tpc" );
+        // The following code block can be used to retrieve the benchmark data from Spice.
+
+        Eigen::Quaterniond spiceRotationMatrix =
+               computeRotationQuaternionBetweenFrames( baseFrame, targetFrame, secondsSinceJ2000 );\
+        spice_interface::computeRotationMatrixDerivativeBetweenFrames( baseFrame, targetFrame, secondsSinceJ2000 );
+
         */
+        Eigen::Matrix3d spiceRotationMatrixDerivative;
+        spiceRotationMatrixDerivative << 1.690407961416589e-07, 2.288121921543265e-07, 9.283170431475241e-08,
+                -2.468632444964533e-07, 1.540516111965609e-07, 6.981529179974795e-08,
+                0.0,           0.0,          0.0;
+
 
         // Set rotation at given time, as calculated with Spice (see above commented lines)
         Eigen::Matrix3d spiceRotationMatrix;
@@ -152,21 +163,115 @@ BOOST_AUTO_TEST_CASE( testSimpleRotationalEphemeris )
                 -0.5648910720519699, -0.7646317780963481, -0.3102197940834743,
                 0.01869081416890206, -0.3877088083617987, 0.9215923900425707;
 
-        // Calculate rotations to frame at certain time;
-        // Check Spice result with ephemerides results.
+        // Calculate rotation to frame, and its time derivative, at certain time;
         Eigen::Quaterniond ephemerisRotation =
                 venusRotationalEphemerisFromAngles.getRotationToTargetFrame(
                     secondsSinceJ2000, JULIAN_DAY_ON_J2000 );
+        Eigen::Matrix3d ephemerisRotationDerivative =
+                venusRotationalEphemerisFromAngles.getDerivativeOfRotationToTargetFrame(
+                    secondsSinceJ2000, JULIAN_DAY_ON_J2000 );;
 
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( Eigen::Matrix3d( ephemerisRotation  ),
-                                           spiceRotationMatrix, 5.0E-15 );
+        // Check Spice result with ephemerides results.
+        for( unsigned int i = 0; i < 3; i++ )
+        {
+            for( unsigned int j = 0; j < 3; j++ )
+            {
+                BOOST_CHECK_SMALL(
+                            Eigen::Matrix3d( ephemerisRotation )( i, j ) -
+                            spiceRotationMatrix( i, j ), 2.0E-15 );
+                BOOST_CHECK_SMALL(
+                            spiceRotationMatrixDerivative( i, j ) -
+                            ephemerisRotationDerivative( i, j ), 2.0E-22 );
+            }
+
+        }
 
-        ephemerisRotation =
-                venusRotationalEphemerisFromInitialState.getRotationToTargetFrame(
+        // Compare inverse rotation and its time derivative.
+        Eigen::Quaterniond inverseEphemerisRotation =
+                venusRotationalEphemerisFromInitialState.getRotationToBaseFrame(
+                    secondsSinceJ2000, JULIAN_DAY_ON_J2000 );
+        Eigen::Matrix3d inverseEphemerisRotationDerivative =
+                venusRotationalEphemerisFromAngles.getDerivativeOfRotationToBaseFrame(
                     secondsSinceJ2000, JULIAN_DAY_ON_J2000 );
 
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( Eigen::Matrix3d( ephemerisRotation ),
-                                           spiceRotationMatrix, 5.0E-15 );
+        Eigen::Matrix3d inverseSpiceRotationMatrix = spiceRotationMatrix.inverse( );
+        Eigen::Matrix3d inverseSpiceRotationMatrixDerivative = spiceRotationMatrixDerivative.transpose( );
+
+        // Check Spice result with ephemerides results.
+        for( unsigned int i = 0; i < 3; i++ )
+        {
+            for( unsigned int j = 0; j < 3; j++ )
+            {
+                BOOST_CHECK_SMALL(
+                            Eigen::Matrix3d( inverseEphemerisRotation )( i, j ) -
+                            inverseSpiceRotationMatrix( i, j ), 2.0E-15 );
+                BOOST_CHECK_SMALL(
+                            inverseEphemerisRotationDerivative( i, j ) -
+                            inverseSpiceRotationMatrixDerivative( i, j ), 2.0E-22 );
+            }
+
+        }
+    }
+
+    // Test rotation matrix derivative by means of finite differences
+    {
+        double timeStep = 10.0;
+
+        // Calculate rotations to frame at two times.
+        Eigen::Quaterniond ephemerisRotation1 =
+                venusRotationalEphemerisFromAngles.getRotationToTargetFrame(
+                    secondsSinceJ2000, JULIAN_DAY_ON_J2000 );
+        Eigen::Quaterniond ephemerisRotation2 =
+                venusRotationalEphemerisFromAngles.getRotationToTargetFrame(
+                    secondsSinceJ2000 + timeStep, JULIAN_DAY_ON_J2000 );
+
+        // Numerically calculate matrix derivative.
+        Eigen::Matrix3d numericalEphemerisRotationDerivative =
+                ( Eigen::Matrix3d( ephemerisRotation2 ) - Eigen::Matrix3d( ephemerisRotation1 ) ) /
+                timeStep;
+
+        // Calculate matrix derivative directly and compare.
+        Eigen::Matrix3d ephemerisRotationDerivative =
+                venusRotationalEphemerisFromAngles.getDerivativeOfRotationToTargetFrame(
+                    secondsSinceJ2000 + timeStep / 2.0, JULIAN_DAY_ON_J2000 );
+        for( unsigned int i = 0; i < 3; i++ )
+        {
+            for( unsigned int j = 0; j < 3; j++ )
+            {
+                BOOST_CHECK_SMALL(
+                            numericalEphemerisRotationDerivative( i, j ) -
+                            ephemerisRotationDerivative( i, j ), 2.0E-16 );
+            }
+
+        }
+
+        // Calculate rotations from frame at two times;
+        ephemerisRotation1 =
+                venusRotationalEphemerisFromAngles.getRotationToBaseFrame(
+                    secondsSinceJ2000, JULIAN_DAY_ON_J2000 );
+        ephemerisRotation2 =
+                venusRotationalEphemerisFromAngles.getRotationToBaseFrame(
+                    secondsSinceJ2000 + timeStep, JULIAN_DAY_ON_J2000 );
+
+        // Numerically calculate matrix derivative.
+        ephemerisRotationDerivative =
+                venusRotationalEphemerisFromAngles.getDerivativeOfRotationToBaseFrame(
+                    secondsSinceJ2000 + timeStep / 2.0, JULIAN_DAY_ON_J2000 );
+
+        // Calculate matrix derivative directly and compare.
+        numericalEphemerisRotationDerivative =
+                ( Eigen::Matrix3d( ephemerisRotation2 ) - Eigen::Matrix3d( ephemerisRotation1 ) ) /
+                timeStep;
+        for( unsigned int i = 0; i < 3; i++ )
+        {
+            for( unsigned int j = 0; j < 3; j++ )
+            {
+                BOOST_CHECK_SMALL(
+                            numericalEphemerisRotationDerivative( i, j ) -
+                            ephemerisRotationDerivative( i, j ), 2.0E-16 );
+            }
+
+        }
     }
 
     // Test rotation from target frame at specified time (is checked by checking if it is inverse
diff --git a/Tudat/Astrodynamics/Ephemerides/rotationalEphemeris.cpp b/Tudat/Astrodynamics/Ephemerides/rotationalEphemeris.cpp
new file mode 100644
index 0000000..f77bd27
--- /dev/null
+++ b/Tudat/Astrodynamics/Ephemerides/rotationalEphemeris.cpp
@@ -0,0 +1,98 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+   *   All rights reserved.
+   *
+   *   Redistribution and use in source and binary forms, with or without modification, are
+   *   permitted provided that the following conditions are met:
+   *     - Redistributions of source code must retain the above copyright notice, this list of
+   *       conditions and the following disclaimer.
+   *     - Redistributions in binary form must reproduce the above copyright notice, this list of
+   *       conditions and the following disclaimer in the documentation and/or other materials
+   *       provided with the distribution.
+   *     - Neither the name of the Delft University of Technology nor the names of its contributors
+   *       may be used to endorse or promote products derived from this software without specific
+   *       prior written permission.
+   *
+   *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+   *   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+   *   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+   *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+   *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+   *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+   *   AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+   *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+   *   OF THE POSSIBILITY OF SUCH DAMAGE.
+   *
+   *   Changelog
+   *     YYMMDD    Author            Comment
+   *     130219    D. Dirkx          Migrated from personal code.
+   *     130227    R.C.A. Boon       Changed include guard, improved commenting.
+   *
+   *   References
+   *
+   *   Notes
+   *
+   */
+
+#include <iostream>
+
+#include "Tudat/Astrodynamics/Ephemerides/rotationalEphemeris.h"
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebra.h"
+
+namespace tudat
+{
+namespace ephemerides
+{
+
+//! Function to calculate the rotational velocity vector of frame B w.r.t frame A.
+Eigen::Vector3d getRotationalVelocityVectorInBaseFrameFromMatrices(
+        const Eigen::Matrix3d& rotationToTargetFrame,
+        const Eigen::Matrix3d& rotationMatrixToGlobalFrameDerivative )
+{
+    Eigen::Matrix3d crossProductMatrix =
+            rotationMatrixToGlobalFrameDerivative * rotationToTargetFrame;
+    return ( Eigen::Vector3d( ) << crossProductMatrix( 2, 1 ),
+             crossProductMatrix( 0, 2 ), crossProductMatrix( 1, 0 ) ).finished( );
+
+}
+
+//! Function to calculate the time derivative of rotation matrix from frame A to frame B.
+Eigen::Matrix3d getDerivativeOfRotationMatrixToFrame(
+        const Eigen::Matrix3d& rotationToTargetFrame,
+        const Eigen::Vector3d& rotationalVelocityVectorOfTargetFrameInBaseFrame )
+{
+    return linear_algebra::getCrossProductMatrix(
+                -rotationToTargetFrame * rotationalVelocityVectorOfTargetFrameInBaseFrame ) *
+            rotationToTargetFrame;
+}
+
+//! Transform a state (Cartesian position and velocity) from one frame to another.
+basic_mathematics::Vector6d transformStateToFrame(
+        const basic_mathematics::Vector6d& stateInBaseFrame,
+        const Eigen::Quaterniond& rotationToFrame,
+        const Eigen::Matrix3d& rotationMatrixToFrameDerivative )
+{
+    basic_mathematics::Vector6d stateInTargetFrame;
+    stateInTargetFrame.segment( 0, 3 ) =
+            rotationToFrame * stateInBaseFrame.segment( 0, 3 );
+    stateInTargetFrame.segment( 3, 3 ) =
+            rotationMatrixToFrameDerivative * stateInBaseFrame.segment( 0, 3 ) +
+            rotationToFrame * stateInBaseFrame.segment( 3, 3 );
+    return stateInTargetFrame;
+
+}
+
+//! Transform a state (Cartesian position and velocity) from one frame to another.
+basic_mathematics::Vector6d transformStateToFrame(
+        const basic_mathematics::Vector6d& stateInTargetFrame,
+        const boost::function< Eigen::Quaterniond( ) > rotationToFrameFunction,
+        const boost::function< Eigen::Matrix3d( ) > rotationMatrixToFrameDerivativeFunction )
+{
+    return transformStateToFrame(
+                stateInTargetFrame, rotationToFrameFunction( ),
+                rotationMatrixToFrameDerivativeFunction( ) );
+}
+
+} // namespace tudat
+
+} // namespace ephemerides
+
diff --git a/Tudat/Astrodynamics/Ephemerides/rotationalEphemeris.h b/Tudat/Astrodynamics/Ephemerides/rotationalEphemeris.h
index 977eb48..ea14c34 100644
--- a/Tudat/Astrodynamics/Ephemerides/rotationalEphemeris.h
+++ b/Tudat/Astrodynamics/Ephemerides/rotationalEphemeris.h
@@ -38,9 +38,15 @@
 
 #include <string>
 
+#include <boost/function.hpp>
+
 #include <Eigen/Core>
 #include <Eigen/Geometry>
 
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/timeConversions.h"
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+
 namespace tudat
 {
 namespace ephemerides
@@ -84,7 +90,8 @@ public:
      * \return Rotation quaternion computed.
      */
     virtual Eigen::Quaterniond getRotationToBaseFrame(
-            const double secondsSinceEpoch, const double julianDayAtEpoch ) = 0;
+            const double secondsSinceEpoch, const double julianDayAtEpoch =
+            basic_astrodynamics::JULIAN_DAY_ON_J2000 ) = 0;
 
     //! Get rotation quaternion to target frame from base frame.
     /*!
@@ -96,7 +103,38 @@ public:
      * \return Rotation quaternion computed.
      */
     virtual Eigen::Quaterniond getRotationToTargetFrame(
-            const double secondsSinceEpoch, const double julianDayAtEpoch ) = 0;
+            const double secondsSinceEpoch, const double julianDayAtEpoch =
+            basic_astrodynamics::JULIAN_DAY_ON_J2000 ) = 0;
+
+    //! Function to calculate the derivative of the rotation matrix from target frame to original
+    //! frame.
+    /*!
+     *  Function to calculate the derivative of the rotation matrix from target frame to original
+     *  frame at specified time, to be implemented by derived class.
+     *  \param secondsSinceEpoch Seconds since Julian day epoch specified by 2nd argument
+     *  \param julianDayAtEpoch Reference epoch in Julian days from which number of seconds are
+     *          counted.
+     *  \return Derivative of rotation from target (typically local) to original (typically global)
+     *          frame at specified time.
+     */
+    virtual Eigen::Matrix3d getDerivativeOfRotationToBaseFrame(
+            const double secondsSinceEpoch, const double julianDayAtEpoch =
+            basic_astrodynamics::JULIAN_DAY_ON_J2000 ) = 0;
+
+    //! Function to calculate the derivative of the rotation matrix from original frame to target
+    //! frame.
+    /*!
+     *  Function to calculate the derivative of the rotation matrix from original frame to target
+     *  frame at specified time, to be implemented by derived class.
+     * \param secondsSinceEpoch Seconds since Julian day epoch specified by 2nd argument
+     * \param julianDayAtEpoch Reference epoch in Julian days from which number of seconds are
+     *          counted.
+     *  \return Derivative of rotation from original (typically global) to target (typically local)
+     *          frame at specified time.
+     */
+    virtual Eigen::Matrix3d getDerivativeOfRotationToTargetFrame(
+            const double secondsSinceEpoch, const double julianDayAtEpoch =
+            basic_astrodynamics::JULIAN_DAY_ON_J2000 ) = 0;
 
     //! Get base reference frame orientation.
     /*!
@@ -128,6 +166,65 @@ protected:
 
 };
 
+//! Function to calculate the rotational velocity vector of frame B w.r.t frame A.
+/*!
+ *  Function to calculate the rotational velocity vector of frame B (local) w.r.t frame A (global)
+ *  from the rotation matrix between the frames, as well as its time derivative.
+ *  \param rotationToTargetFrame Rotation matrix from frame A to frame B.
+ *  \param rotationMatrixToGlobalFrameDerivative Time derivative if rotation matrix from
+ *  frame B to frame A.
+ *  \return Angular velocity vector of frame B, expressed in frame A.
+ */
+Eigen::Vector3d getRotationalVelocityVectorInBaseFrameFromMatrices(
+        const Eigen::Matrix3d& rotationToTargetFrame,
+        const Eigen::Matrix3d& rotationMatrixToGlobalFrameDerivative );
+
+//! Function to calculate the time derivative of rotation matrix from frame A to frame B.
+/*!
+ *  Function to calculate the time derivative of rotation matrix from frame A (global) to frame B
+ *  (local) from the rotation matrix between the frames, as well as the angular velocity
+ *  vector of frame B w.r.t. frame A.
+ *  \param rotationToTargetFrame Rotation matrix from frame A to frame B.
+ *  \param rotationalVelocityVectorInTargetFrame Angular velocity vector of frame B,
+ *  expressed in frame A.
+ *  \return Time derivative if rotation matrix from frame A to frame B.
+ */
+Eigen::Matrix3d getDerivativeOfRotationMatrixToFrame(
+        const Eigen::Matrix3d& rotationToTargetFrame,
+        const Eigen::Vector3d& rotationalVelocityVectorInTargetFrame );
+
+//! Transform a state (Cartesian position and velocity) from one frame to another.
+/*!
+ *  Transform a state (Cartesian position and velocity) from one frame to another, taking into
+ *  account both the instantaneous rotational state of the two frames, and the rotational
+ *  rate of one frame w.r.t. the other.
+ *  \param stateInBaseFrame State that is to be transformed from base to target frame.
+ *  \param rotationToFrame Rotation from base to target frame.
+ *  \param rotationMatrixToFrameDerivative Time derivative of rotation matrix from base to target
+ *  frame.
+ *  \return State (Cartesian position and velocity) in target frame.
+ */
+basic_mathematics::Vector6d transformStateToFrame(
+        const basic_mathematics::Vector6d& stateInBaseFrame,
+        const Eigen::Quaterniond& rotationToFrame,
+        const Eigen::Matrix3d& rotationMatrixToFrameDerivative );
+
+//! Transform a state (Cartesian position and velocity) from one frame to another.
+/*!
+ *  Transform a state (Cartesian position and velocity) from one frame to another, taking into
+ *  account both the instantaneous rotational state of the two frames, and the rotational
+ *  rate of one frame w.r.t. the other.
+ *  \param stateInBaseFrame State that is to be transformed from base to target frame.
+ *  \param rotationToFrameFunction Function returning rotation from base to target frame.
+ *  \param rotationMatrixToFrameDerivativeFunction Function returning time derivative of rotation
+ *   matrix from base to target frame.
+ *  \return State (Cartesian position and velocity) in target frame.
+ */
+basic_mathematics::Vector6d transformStateToFrame(
+        const basic_mathematics::Vector6d& stateInBaseFrame,
+        const boost::function< Eigen::Quaterniond( ) > rotationToFrameFunction,
+        const boost::function< Eigen::Matrix3d( ) > rotationMatrixToFrameDerivativeFunction );
+
 } // namespace tudat
 } // namespace ephemerides
 
diff --git a/Tudat/Astrodynamics/Ephemerides/simpleRotationalEphemeris.cpp b/Tudat/Astrodynamics/Ephemerides/simpleRotationalEphemeris.cpp
index 7c55435..f7293b0 100644
--- a/Tudat/Astrodynamics/Ephemerides/simpleRotationalEphemeris.cpp
+++ b/Tudat/Astrodynamics/Ephemerides/simpleRotationalEphemeris.cpp
@@ -67,5 +67,28 @@ Eigen::Quaterniond SimpleRotationalEphemeris::getRotationToTargetFrame(
                 rotationAngle ) * initialRotationToTargetFrame_;
 }
 
+//! Function to calculate the derivative of the rotation matrix from target frame to original frame.
+Eigen::Matrix3d SimpleRotationalEphemeris::getDerivativeOfRotationToTargetFrame(
+        const double secondsSinceEpoch, const double julianDayAtEpoch )
+{
+    // Determine number of seconds since initial rotational state, as set by constructor.
+    double inputSecondsSinceEpoch = secondsSinceEpoch;
+    if ( julianDayAtEpoch != inputReferenceJulianDay_ )
+    {
+        inputSecondsSinceEpoch -= ( inputReferenceJulianDay_ - julianDayAtEpoch )
+                * physical_constants::JULIAN_DAY;
+    }
+
+    // Determine rotation angle compared to initial rotational state.
+    double rotationAngle = basic_mathematics::computeModulo(
+                ( inputSecondsSinceEpoch - initialSecondsSinceEpoch_ ) * rotationRate_,
+                2.0 * mathematical_constants::PI );
+
+    // Calculate derivative of rotation matrix.
+    return rotationRate_ * auxiliaryMatrix_ * tudat::reference_frames::
+            getInertialToPlanetocentricFrameTransformationQuaternion( rotationAngle )
+            * Eigen::Matrix3d( initialRotationToTargetFrame_ );
+}
+
 } // namespace tudat
 } // namespace ephemerides
diff --git a/Tudat/Astrodynamics/Ephemerides/simpleRotationalEphemeris.h b/Tudat/Astrodynamics/Ephemerides/simpleRotationalEphemeris.h
index c685de1..99ed1a0 100644
--- a/Tudat/Astrodynamics/Ephemerides/simpleRotationalEphemeris.h
+++ b/Tudat/Astrodynamics/Ephemerides/simpleRotationalEphemeris.h
@@ -79,7 +79,9 @@ public:
           initialRotationToTargetFrame_( initialRotationToTargetFrame ),
           initialSecondsSinceEpoch_( initialSecondsSinceEpoch ),
           inputReferenceJulianDay_( inputReferenceJulianDay )
-    { }
+    {
+        auxiliaryMatrix_<< 0.0, 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0;
+    }
 
     //! Constructor from rotation state angles.
     /*!
@@ -113,7 +115,9 @@ public:
                   poleDeclination, poleRightAscension, primeMeridianOfDate ) ),
           initialSecondsSinceEpoch_( initialSecondsSinceEpoch ),
           inputReferenceJulianDay_( inputReferenceJulianDay )
-    { }
+    {
+        auxiliaryMatrix_<< 0.0, 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0;
+    }
 
     //! Calculate rotation quaternion from target frame to base frame.
     /*!
@@ -138,9 +142,43 @@ public:
      *          counted.
      * \return Rotation quaternion computed.
      */
-    virtual Eigen::Quaterniond getRotationToTargetFrame(
+    Eigen::Quaterniond getRotationToTargetFrame(
             const double secondsSinceEpoch, const double julianDayAtEpoch );
 
+    //! Function to calculate the derivative of the rotation matrix from target frame to original
+    //! frame.
+    /*!
+     *  Function to calculate the derivative of the rotation matrix from target frame to original
+     *  frame at specified time.
+     *  \param secondsSinceEpoch Seconds since Julian day epoch specified by 2nd argument
+     *  \param julianDayAtEpoch Reference epoch in Julian days from which number of seconds are
+     *          counted.
+     *  \return Derivative of rotation from target (typically local) to original (typically global)
+     *          frame at specified time.
+     */
+    Eigen::Matrix3d getDerivativeOfRotationToBaseFrame(
+            const double secondsSinceEpoch, const double julianDayAtEpoch =
+            basic_astrodynamics::JULIAN_DAY_ON_J2000 )
+    {
+        return getDerivativeOfRotationToTargetFrame( secondsSinceEpoch, julianDayAtEpoch ).
+                transpose( );
+    }
+
+    //! Function to calculate the derivative of the rotation matrix from original frame to target
+    //! frame.
+    /*!
+     *  Function to calculate the derivative of the rotation matrix from original frame to target
+     *  frame at specified time.
+     * \param secondsSinceEpoch Seconds since Julian day epoch specified by 2nd argument
+     * \param julianDayAtEpoch Reference epoch in Julian days from which number of seconds are
+     *          counted.
+     *  \return Derivative of rotation from original (typically global) to target (typically local)
+     *          frame at specified time.
+     */
+    Eigen::Matrix3d getDerivativeOfRotationToTargetFrame(
+            const double secondsSinceEpoch, const double julianDayAtEpoch =
+            basic_astrodynamics::JULIAN_DAY_ON_J2000 );
+
     //! Get rotation from target to base frame at initial time.
     /*!
      * Returns rotation from target to base frame at initial time.
@@ -194,6 +232,9 @@ private:
      * Julian day of reference epoch.
      */
    const  double inputReferenceJulianDay_;
+
+   //! Auxiliary matrix used to calculate the time derivative of a rotation matrix.
+   Eigen::Matrix3d auxiliaryMatrix_;
 };
 
 } // namespace tudat
diff --git a/Tudat/External/SpiceInterface/UnitTests/unitTestSpiceInterface.cpp b/Tudat/External/SpiceInterface/UnitTests/unitTestSpiceInterface.cpp
index fda3f8a..ff3c376 100644
--- a/Tudat/External/SpiceInterface/UnitTests/unitTestSpiceInterface.cpp
+++ b/Tudat/External/SpiceInterface/UnitTests/unitTestSpiceInterface.cpp
@@ -211,6 +211,8 @@ BOOST_AUTO_TEST_CASE( testSpiceWrappers_3 )
     // Retrieve rotation from wrapper.
     rotationQuaternion = computeRotationQuaternionBetweenFrames(
                 observer, target, ephemerisTime );
+    Eigen::Matrix3d rotationMatrixDerivative = computeRotationMatrixDerivativeBetweenFrames(
+                observer, target, ephemerisTime );
 
     // Create rotational ephemeris with Spice
     boost::shared_ptr< ephemerides::SpiceRotationalEphemeris > spiceRotationalEphemeris =
@@ -221,24 +223,49 @@ BOOST_AUTO_TEST_CASE( testSpiceWrappers_3 )
     Eigen::Quaterniond inverseRotationQuaternionFromObject = spiceRotationalEphemeris->
             getRotationToBaseFrame( ephemerisTime );
 
+    Eigen::Matrix3d rotationMatrixDerivativeFromObject = spiceRotationalEphemeris->
+            getDerivativeOfRotationToTargetFrame( ephemerisTime );
+    Eigen::Matrix3d inverseRotationMatrixDerivativeFromObject = spiceRotationalEphemeris->
+            getDerivativeOfRotationToBaseFrame( ephemerisTime );
+
     // Convert result to Matrix3d for comparison.
     const Eigen::Matrix3d rotationMatrix = Eigen::Matrix3d( rotationQuaternion );
     const Eigen::Matrix3d rotationMatrixFromObject =
             Eigen::Matrix3d( rotationQuaternionFromObject );
+    const Eigen::Matrix3d inverseRotationMatrixFromObject =
+            Eigen::Matrix3d( inverseRotationQuaternionFromObject );
+
 
     // Retrieve rotation directly from spice.
-    double rotationMatrixSpice[ 3 ][ 3 ];
-    pxform_c( observer.c_str( ), target.c_str( ), ephemerisTime, rotationMatrixSpice );
+    double stateTransitionMatrix[ 6 ][ 6 ];
+    sxform_c( observer.c_str( ), target.c_str( ), ephemerisTime, stateTransitionMatrix );
+
+    double inverseStateTransitionMatrix[ 6 ][ 6 ];
+    sxform_c( target.c_str( ), observer.c_str( ), ephemerisTime, inverseStateTransitionMatrix );
 
     // Check equality of results.
     for ( unsigned int i = 0; i < 3; i++ )
     {
         for ( unsigned int j = 0; j < 3; j++ )
         {
-            BOOST_CHECK_SMALL( rotationMatrixSpice[ i ][ j ] - rotationMatrix( i, j ),
+            BOOST_CHECK_SMALL( stateTransitionMatrix[ i ][ j ] - rotationMatrix( i, j ),
+                               2.0 * std::numeric_limits< double >::epsilon( ) );
+            BOOST_CHECK_SMALL( stateTransitionMatrix[ i ][ j ] -
+                               rotationMatrixFromObject( i, j ),
                                2.0 * std::numeric_limits< double >::epsilon( ) );
-            BOOST_CHECK_SMALL( rotationMatrixSpice[ i ][ j ] - rotationMatrixFromObject( i, j ),
+            BOOST_CHECK_SMALL( stateTransitionMatrix[ i + 3 ][ j ] -
+                               rotationMatrixDerivative( i, j ),
+                               2.0E-4 * std::numeric_limits< double >::epsilon( ) );
+            BOOST_CHECK_SMALL( stateTransitionMatrix[ i + 3 ][ j ] -
+                               rotationMatrixDerivativeFromObject( i, j ),
+                               2.0E-4 * std::numeric_limits< double >::epsilon( ) );
+
+            BOOST_CHECK_SMALL( inverseStateTransitionMatrix[ i ][ j ] -
+                               inverseRotationMatrixFromObject( i, j ),
                                2.0 * std::numeric_limits< double >::epsilon( ) );
+            BOOST_CHECK_SMALL( inverseStateTransitionMatrix[ i + 3 ][ j ] -
+                               inverseRotationMatrixDerivativeFromObject( i, j ),
+                               2.0E-4 * std::numeric_limits< double >::epsilon( ) );
         }
     }
 
diff --git a/Tudat/External/SpiceInterface/spiceInterface.cpp b/Tudat/External/SpiceInterface/spiceInterface.cpp
index 524406f..292b52c 100644
--- a/Tudat/External/SpiceInterface/spiceInterface.cpp
+++ b/Tudat/External/SpiceInterface/spiceInterface.cpp
@@ -34,6 +34,8 @@
  *
  */
 
+#include <iostream>
+
 #include <boost/lexical_cast.hpp>
 
 #include "Tudat/Astrodynamics/BasicAstrodynamics/unitConversions.h"
@@ -148,6 +150,49 @@ Eigen::Quaterniond computeRotationQuaternionBetweenFrames( const std::string& or
     return Eigen::Quaterniond( rotationMatrix );
 }
 
+//! Computes time derivative of rotation matrix between two frames.
+Eigen::Matrix3d computeRotationMatrixDerivativeBetweenFrames( const std::string& originalFrame,
+                                                              const std::string& newFrame,
+                                                              const double ephemerisTime )
+{
+    double stateTransition[ 6 ][ 6 ];
+
+    // Calculate state transition matrix.
+    sxform_c( originalFrame.c_str( ), newFrame.c_str( ), ephemerisTime, stateTransition );
+
+    // Put rotation matrix derivative in Eigen Matrix3d
+    Eigen::Matrix3d matrixDerivative = Eigen::Matrix3d::Zero( );
+    for( unsigned int i = 0; i < 3; i++ )
+    {
+        for( unsigned int j = 0; j < 3; j++ )
+        {
+            matrixDerivative( i, j ) = stateTransition[ i + 3 ][ j ];
+        }
+    }
+
+    return matrixDerivative;
+}
+
+//! Computes the angular velocity of one frame w.r.t. to another frame.
+Eigen::Vector3d getAngularVelocityVectorOfFrameInOriginalFrame( const std::string& originalFrame,
+                                                                const std::string& newFrame,
+                                                                const double ephemerisTime )
+{
+    double stateTransition[ 6 ][ 6 ];
+
+    // Calculate state transition matrix.
+    sxform_c( originalFrame.c_str( ), newFrame.c_str( ), ephemerisTime, stateTransition );
+
+    double rotation[ 3 ][ 3 ];
+    double angularVelocity[ 3 ];
+
+    // Calculate angular velocity vector.
+    xf2rav_c( stateTransition, rotation, angularVelocity );
+
+    return ( Eigen::Vector3d( )<<angularVelocity[ 0 ], angularVelocity[ 1 ], angularVelocity[ 2 ] ).
+            finished( );
+}
+
 //! Get property of a body from Spice.
 std::vector< double > getBodyProperties( const std::string& body, const std::string& property,
                                          const int maximumNumberOfValues )
@@ -182,8 +227,8 @@ double getBodyGravitationalParameter( const std::string& body )
 
     // Convert from km^3/s^2 to m^3/s^2
     return unit_conversions::convertKilometersToMeters< double >(
-               unit_conversions::convertKilometersToMeters< double >(
-                   unit_conversions::convertKilometersToMeters< double >(
+                unit_conversions::convertKilometersToMeters< double >(
+                    unit_conversions::convertKilometersToMeters< double >(
                         gravitationalParameter[ 0 ] ) ) );
 }
 
diff --git a/Tudat/External/SpiceInterface/spiceInterface.h b/Tudat/External/SpiceInterface/spiceInterface.h
index 762521b..157b436 100644
--- a/Tudat/External/SpiceInterface/spiceInterface.h
+++ b/Tudat/External/SpiceInterface/spiceInterface.h
@@ -58,7 +58,7 @@
 
 extern "C"
 {
-    #include "cspice/include/SpiceUsr.h"
+#include "cspice/include/SpiceUsr.h"
 }
 
 namespace tudat
@@ -159,16 +159,46 @@ Eigen::Vector3d getBodyCartesianPositionAtEpoch( const std::string& targetBodyNa
 //! Compute quaternion of rotation between two frames.
 /*!
  * This function computes the quaternion of rotation between two frames at a given time instant.
- * Kernels defining the two frames, as well as any required intermeidate frames, at the requested
+ * Kernels defining the two frames, as well as any required intermediate frames, at the requested
  * time must have been loaded. Wrapper for pxform_c spice function.
  * \param originalFrame Reference frame from which the rotation is made.
  * \param newFrame Reference frame to which the rotation is made.
  * \param ephemerisTime Value of ephemeris time at which rotation is to be determined.
+ * \return Rotation quaternion from original to new frame at given time.
  */
 Eigen::Quaterniond computeRotationQuaternionBetweenFrames( const std::string& originalFrame,
                                                            const std::string& newFrame,
                                                            const double ephemerisTime );
 
+//! Computes time derivative of rotation matrix between two frames.
+/*!
+ * This function computes the derivative of the rotation matrix between two frames at a given
+ * time instant. Kernels defining the two frames, as well as any required intermediate frames, at
+ * the requested time must have been loaded. Wrapper for (part of) sxform_c spice function.
+ * \param originalFrame Reference frame from which the rotation is made.
+ * \param newFrame Reference frame to which the rotation is made.
+ * \param ephemerisTime Value of ephemeris time at which rotation is to be determined.
+ * \return Time derivative of rotation matrix from original to new frame at given time.
+ */
+Eigen::Matrix3d computeRotationMatrixDerivativeBetweenFrames( const std::string& originalFrame,
+                                                              const std::string& newFrame,
+                                                              const double ephemerisTime );
+
+//! Computes the angular velocity of one frame w.r.t. to another frame.
+/*!
+ * Computes the angular velocity of one frame w.r.t. to another frame. at a given
+ * time instant. Kernels defining the two frames, as well as any required intermediate frames, at
+ * the requested time must have been loaded. Wrapper for xf2rav_c spice function (utilizing
+ *  sxform_c).
+ * \param originalFrame Reference frame from which the rotation is made.
+ * \param newFrame Reference frame to which the rotation is made.
+ * \param ephemerisTime Value of ephemeris time at which rotation is to be determined.
+ * \return Angular velocity of newFrame w.r.t. originalFrame, expressed in originalFrame.
+ */
+Eigen::Vector3d getAngularVelocityVectorOfFrameInOriginalFrame( const std::string& originalFrame,
+                                                                const std::string& newFrame,
+                                                                const double ephemerisTime );
+
 //! Get property of a body from Spice.
 /*!
  * Function to retrieve a property of a body from Spice, wraps the bodvrd_c Spice function.
diff --git a/Tudat/External/SpiceInterface/spiceRotationalEphemeris.cpp b/Tudat/External/SpiceInterface/spiceRotationalEphemeris.cpp
index 1f0946f..8a9a2b6 100644
--- a/Tudat/External/SpiceInterface/spiceRotationalEphemeris.cpp
+++ b/Tudat/External/SpiceInterface/spiceRotationalEphemeris.cpp
@@ -16,22 +16,37 @@ namespace ephemerides
 
 //! Function to calculate the rotation quaternion from target frame to original frame.
 Eigen::Quaterniond SpiceRotationalEphemeris::getRotationToBaseFrame(
-        const double ephemerisTime, const double julianDayAtEpoch )
+        const double secondsSinceEpoch, const double julianDayAtEpoch )
 {
-    if( julianDayAtEpoch != basic_astrodynamics::JULIAN_DAY_ON_J2000 )
+    // Set number of seconds since J2000.
+    double ephemerisTime = secondsSinceEpoch;
+    if ( julianDayAtEpoch != basic_astrodynamics::JULIAN_DAY_ON_J2000 )
     {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error(
-                            "Spice rotational ephemeris must take J2000 as"
-                            " reference input time.") ) );
+        ephemerisTime -= ( basic_astrodynamics::JULIAN_DAY_ON_J2000 - julianDayAtEpoch )
+                * physical_constants::JULIAN_DAY;
     }
 
     // Get rotational quaternion from spice wrapper function
-    Eigen::Quaterniond rotationalState = spice_interface::computeRotationQuaternionBetweenFrames(
+    return spice_interface::computeRotationQuaternionBetweenFrames(
                 targetFrameOrientation_, baseFrameOrientation_, ephemerisTime );
+}
+
+//! Function to calculate the derivative of the rotation matrix from target frame to original
+//! frame.
+Eigen::Matrix3d SpiceRotationalEphemeris::getDerivativeOfRotationToBaseFrame(
+        const double secondsSinceEpoch, const double julianDayAtEpoch )
+{
+    // Set number of seconds since J2000.
+    double ephemerisTime = secondsSinceEpoch;
+    if ( julianDayAtEpoch != basic_astrodynamics::JULIAN_DAY_ON_J2000 )
+    {
+        ephemerisTime -= ( basic_astrodynamics::JULIAN_DAY_ON_J2000 - julianDayAtEpoch )
+                * physical_constants::JULIAN_DAY;
+    }
 
-    return rotationalState;
+    // Get rotation matrix derivative from spice wrapper function
+    return spice_interface::computeRotationMatrixDerivativeBetweenFrames(
+                targetFrameOrientation_, baseFrameOrientation_, ephemerisTime );
 }
 
 
diff --git a/Tudat/External/SpiceInterface/spiceRotationalEphemeris.h b/Tudat/External/SpiceInterface/spiceRotationalEphemeris.h
index 484080a..1135653 100644
--- a/Tudat/External/SpiceInterface/spiceRotationalEphemeris.h
+++ b/Tudat/External/SpiceInterface/spiceRotationalEphemeris.h
@@ -76,6 +76,41 @@ public:
         return getRotationToBaseFrame( secondsSinceEpoch, julianDayAtEpoch ).inverse( );
     }
 
+    //! Function to calculate the derivative of the rotation matrix from target frame to original
+    //! frame.
+    /*!
+     *  Function to calculate the derivative of the rotation matrix from target frame to original
+     *  frame at specified time, calculated by SPICE sx_form function.
+     *  \param secondsSinceEpoch Seconds since Julian day epoch specified by 2nd argument
+     *  \param julianDayAtEpoch Reference epoch in Julian days from which number of seconds are
+     *          counted.
+     *  \return Derivative of rotation from target (typically local) to original (typically global)
+     *          frame at specified time.
+     */
+    Eigen::Matrix3d getDerivativeOfRotationToBaseFrame(
+            const double secondsSinceEpoch, const double julianDayAtEpoch =
+            basic_astrodynamics::JULIAN_DAY_ON_J2000 );
+
+
+    //! Function to calculate the derivative of the rotation matrix from original frame to target
+    //! frame.
+    /*!
+     *  Function to calculate the derivative of the rotation matrix from target frame to original
+     *  frame at specified time, calculated by SPICE sx_form function.
+     *  \param secondsSinceEpoch Seconds since Julian day epoch specified by 2nd argument
+     *  \param julianDayAtEpoch Reference epoch in Julian days from which number of seconds are
+     *          counted.
+     *  \return Derivative of rotation from original (typically global) to target (typically local)
+     *          frame at specified time.
+     */
+    Eigen::Matrix3d getDerivativeOfRotationToTargetFrame(
+            const double secondsSinceEpoch, const double julianDayAtEpoch =
+            basic_astrodynamics::JULIAN_DAY_ON_J2000 )
+    {
+        return getDerivativeOfRotationToBaseFrame( secondsSinceEpoch, julianDayAtEpoch ).
+                transpose( );
+    }
+
 };
 
 }
diff --git a/Tudat/Mathematics/BasicMathematics/linearAlgebra.cpp b/Tudat/Mathematics/BasicMathematics/linearAlgebra.cpp
index c378916..e15eaed 100644
--- a/Tudat/Mathematics/BasicMathematics/linearAlgebra.cpp
+++ b/Tudat/Mathematics/BasicMathematics/linearAlgebra.cpp
@@ -54,6 +54,19 @@ namespace tudat
 namespace linear_algebra
 {
 
+//! Function that returns that 'cross-product matrix'
+Eigen::Matrix3d getCrossProductMatrix( const Eigen::Vector3d& vector )
+{
+    Eigen::Matrix3d crossProductMatrix = Eigen::Matrix3d::Zero( );
+    crossProductMatrix( 1, 0 ) = vector.z( );
+    crossProductMatrix( 0, 1 ) = -vector.z( );
+    crossProductMatrix( 2, 0 ) = -vector.y( );
+    crossProductMatrix( 0, 2 ) = vector.y( );
+    crossProductMatrix( 2, 1 ) = vector.x( );
+    crossProductMatrix( 1, 2 ) = -vector.x( );
+    return crossProductMatrix;
+}
+
 //! Compute cosine of the angle between two vectors.
 double computeCosineOfAngleBetweenVectors( const Eigen::VectorXd& vector0,
                                            const Eigen::VectorXd& vector1 )
diff --git a/Tudat/Mathematics/BasicMathematics/linearAlgebra.h b/Tudat/Mathematics/BasicMathematics/linearAlgebra.h
index 2c368b5..c7b5e76 100644
--- a/Tudat/Mathematics/BasicMathematics/linearAlgebra.h
+++ b/Tudat/Mathematics/BasicMathematics/linearAlgebra.h
@@ -43,6 +43,15 @@ namespace tudat
 namespace linear_algebra
 {
 
+//! Function that returns that 'cross-product matrix'
+/*!
+ *  Function that returns that 'cross-product matrix', i.e. for vectors a,b and c, with c = a x b, the matrix A such that
+ *  c = Ab.
+ *  \param leftHandVector The left-multiplying vector (a in above example)
+ *  \return The matrix by which to premultiply the right-multiplying vector to obtain the cross product of the two matrices.
+ */
+Eigen::Matrix3d getCrossProductMatrix( const Eigen::Vector3d& leftHandVector );
+
 //! Compute cosine of the angle between two vectors.
 /*!
  * Computes the cosine of the angle between two vectors; both vectors must have non-zero norm.
