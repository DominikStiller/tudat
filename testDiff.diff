diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamics.cpp b/Tudat/Astrodynamics/Aerodynamics/aerodynamics.cpp
index 4ef6ed7..8f3ecf6 100644
--- a/Tudat/Astrodynamics/Aerodynamics/aerodynamics.cpp
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamics.cpp
@@ -506,5 +506,10 @@ double computeSpeedOfSound( const double temperature, const double ratioOfSpecif
     return std::sqrt( temperature * ratioOfSpecificHeats * specificGasConstant );
 }
 
+double computeMachNumber( const double speed, const double speedOfSound )
+{
+    return speed / speedOfSound;
+}
+
 } // namespace aerodynamics
 } // namespace tudat
diff --git a/Tudat/Astrodynamics/Aerodynamics/aerodynamics.h b/Tudat/Astrodynamics/Aerodynamics/aerodynamics.h
index 066f44e..382bcff 100644
--- a/Tudat/Astrodynamics/Aerodynamics/aerodynamics.h
+++ b/Tudat/Astrodynamics/Aerodynamics/aerodynamics.h
@@ -345,6 +345,8 @@ double computeShockDeflectionAngle( double shockAngle, double machNumber,
 double computeSpeedOfSound( const double temperature, const double ratioOfSpecificHeats,
                             const double specificGasConstant );
 
+double computeMachNumber( const double speed, const double speedOfSound );
+
 } // namespace aerodynamics
 } // namespace tudat
 
diff --git a/Tudat/Astrodynamics/Aerodynamics/flightConditions.cpp b/Tudat/Astrodynamics/Aerodynamics/flightConditions.cpp
index 339e98f..e714b1f 100644
--- a/Tudat/Astrodynamics/Aerodynamics/flightConditions.cpp
+++ b/Tudat/Astrodynamics/Aerodynamics/flightConditions.cpp
@@ -2,6 +2,7 @@
 
 #include <boost/shared_ptr.hpp>
 
+#include "Tudat/Astrodynamics/Aerodynamics/aerodynamics.h"
 #include "Tudat/Astrodynamics/Aerodynamics/flightConditions.h"
 #include "Tudat/Astrodynamics/Aerodynamics/standardAtmosphere.h"
 #include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
@@ -91,8 +92,9 @@ void FlightConditions::updateConditions( const double currentTime )
         //Calculate Mach number if needed.
         case mach_number_dependent:
             aerodynamicCoefficientIndependentVariables.push_back(
-                        currentAirspeed_ / atmosphereModel_->getSpeedOfSound(
-                            currentAltitude_, currentLongitude_, currentLatitude_, currentTime_ ) );
+                        aerodynamics::computeMachNumber(
+                        currentAirspeed_, atmosphereModel_->getSpeedOfSound(
+                            currentAltitude_, currentLongitude_, currentLatitude_, currentTime_ ) ) );
             break;
         //Get angle of attack if needed.
         case angle_of_attack_dependent:
diff --git a/Tudat/Astrodynamics/Aerodynamics/flightConditions.h b/Tudat/Astrodynamics/Aerodynamics/flightConditions.h
index 2e70385..4c34a05 100644
--- a/Tudat/Astrodynamics/Aerodynamics/flightConditions.h
+++ b/Tudat/Astrodynamics/Aerodynamics/flightConditions.h
@@ -102,6 +102,12 @@ public:
         return currentAirspeed_;
     }
 
+    double getCurrentSpeedOfSound( )
+    {
+        return atmosphereModel_->getSpeedOfSound(
+                    currentAltitude_, currentLongitude_, currentLatitude_, currentTime_ );
+    }
+
     //! Function to return the current time of the FlightConditions
     /*!
      *  Function to return the current time of the FlightConditions.
diff --git a/Tudat/Astrodynamics/Propagators/CMakeLists.txt b/Tudat/Astrodynamics/Propagators/CMakeLists.txt
index c9d0fc7..bf45beb 100644
--- a/Tudat/Astrodynamics/Propagators/CMakeLists.txt
+++ b/Tudat/Astrodynamics/Propagators/CMakeLists.txt
@@ -38,6 +38,7 @@ set(PROPAGATORS_SOURCES
   "${SRCROOT}${PROPAGATORSDIR}/createEnvironmentUpdater.cpp"
   "${SRCROOT}${PROPAGATORSDIR}/setNumericallyIntegratedStates.cpp"
   "${SRCROOT}${PROPAGATORSDIR}/propagationSettings.cpp"
+  "${SRCROOT}${PROPAGATORSDIR}/integrateEquations.cpp"
 )
 
 # Add header files.
diff --git a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestCowellStateDerivative.cpp b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestCowellStateDerivative.cpp
index b5d49bc..683fc2c 100644
--- a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestCowellStateDerivative.cpp
+++ b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestCowellStateDerivative.cpp
@@ -130,7 +130,7 @@ BOOST_AUTO_TEST_CASE( testCowellPopagatorCentralBodies )
     // Define numerical integrator settings.
     boost::shared_ptr< IntegratorSettings< > > integratorSettings =
             boost::make_shared< IntegratorSettings< > >
-            ( rungeKutta4, initialEphemerisTime, finalEphemerisTime, 240.0 );
+            ( rungeKutta4, initialEphemerisTime, 240.0 );
 
     // Define central bodies to use in propagation (all w.r.t SSB).
     std::vector< std::string > centralBodies;
@@ -151,7 +151,7 @@ BOOST_AUTO_TEST_CASE( testCowellPopagatorCentralBodies )
                 bodyMap, accelerationMap, centralBodyMap );
     boost::shared_ptr< TranslationalStatePropagatorSettings< double > > propagatorSettings =
             boost::make_shared< TranslationalStatePropagatorSettings< double > >
-            ( centralBodies, accelerationModelMap, bodiesToIntegrate, systemInitialState );
+            ( centralBodies, accelerationModelMap, bodiesToIntegrate, systemInitialState, finalEphemerisTime );
 
     // Create simulation object and propagate dynamics.
     SingleArcDynamicsSimulator< > dynamicsSimulator(
@@ -175,7 +175,7 @@ BOOST_AUTO_TEST_CASE( testCowellPopagatorCentralBodies )
                 bodyMap, accelerationMap, centralBodyMap );
     boost::shared_ptr< TranslationalStatePropagatorSettings< double > > propagatorSettings2 =
             boost::make_shared< TranslationalStatePropagatorSettings< double > >
-            ( centralBodies, accelerationModelMap2, bodiesToIntegrate, systemInitialState );
+            ( centralBodies, accelerationModelMap2, bodiesToIntegrate, systemInitialState, finalEphemerisTime );
 
     // Create new simulation object and propagate dynamics.
     SingleArcDynamicsSimulator< > dynamicsSimulator2(
@@ -347,7 +347,7 @@ BOOST_AUTO_TEST_CASE( testCowellPopagatorKeplerCompare )
     // Define settings for numerical integrator.
     boost::shared_ptr< IntegratorSettings< > > integratorSettings =
             boost::make_shared< IntegratorSettings< > >
-            ( rungeKutta4, initialEphemerisTime, finalEphemerisTime, 120.0 );
+            ( rungeKutta4, initialEphemerisTime, 120.0 );
 
     // Run test where Moon gravity is/is not taken into account.
     for( unsigned testCase = 0; testCase < 2; testCase++ )
@@ -401,7 +401,7 @@ BOOST_AUTO_TEST_CASE( testCowellPopagatorKeplerCompare )
                     bodyMap, accelerationMap, centralBodyMap );
         boost::shared_ptr< TranslationalStatePropagatorSettings< double > > propagatorSettings =
                 boost::make_shared< TranslationalStatePropagatorSettings< double > >
-                ( centralBodies, accelerationModelMap, bodiesToIntegrate, systemInitialState );
+                ( centralBodies, accelerationModelMap, bodiesToIntegrate, systemInitialState, finalEphemerisTime );
 
         // Create dynamics simulation object.
         SingleArcDynamicsSimulator< > dynamicsSimulator(
diff --git a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestEnvironmentUpdater.cpp b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestEnvironmentUpdater.cpp
index ec51c5e..4036b84 100644
--- a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestEnvironmentUpdater.cpp
+++ b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestEnvironmentUpdater.cpp
@@ -52,6 +52,7 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
 {
 
     double initialTime = 86400.0;
+    double finalTime = 2.0 * 86400.0;
 
     // Load Spice kernels
     const std::string kernelsPath = input_output::getSpiceKernelPath( );
@@ -135,7 +136,7 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
             boost::shared_ptr< PropagatorSettings< double > > propagatorSettings =
                     boost::make_shared< TranslationalStatePropagatorSettings< double > >(
                         centralBodyList, accelerationsMap, propagatedBodyList, getInitialStateOfBody(
-                            "Moon", centralBodies[ "Moon" ], bodyMap, initialTime ) );
+                            "Moon", centralBodies[ "Moon" ], bodyMap, initialTime ), finalTime );
             std::map< propagators::EnvironmentModelsToUpdate, std::vector< std::string > > environmentModelsToUpdate =
                     createEnvironmentUpdaterSettings< double >( bodyMap, propagatorSettings );
 
@@ -215,7 +216,7 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
             boost::shared_ptr< PropagatorSettings< double > > propagatorSettings =
                     boost::make_shared< TranslationalStatePropagatorSettings< double > >(
                         centralBodyList, accelerationsMap, propagatedBodyList, getInitialStateOfBody(
-                            "Moon", centralBodies[ "Moon" ], bodyMap, initialTime ) );
+                            "Moon", centralBodies[ "Moon" ], bodyMap, initialTime ), finalTime );
             std::map< propagators::EnvironmentModelsToUpdate, std::vector< std::string > > environmentModelsToUpdate =
                     createEnvironmentUpdaterSettings< double >( bodyMap, propagatorSettings );
 
@@ -287,7 +288,7 @@ BOOST_AUTO_TEST_CASE( test_centralGravityEnvironmentUpdate )
             boost::shared_ptr< PropagatorSettings< double > > propagatorSettings =
                     boost::make_shared< TranslationalStatePropagatorSettings< double > >(
                         centralBodyList, accelerationsMap, propagatedBodyList, getInitialStateOfBody(
-                            "Moon", centralBodies[ "Moon" ], bodyMap, initialTime ) );
+                            "Moon", centralBodies[ "Moon" ], bodyMap, initialTime ), finalTime );
             std::map< propagators::EnvironmentModelsToUpdate, std::vector< std::string > > environmentModelsToUpdate =
                     createEnvironmentUpdaterSettings< double >( bodyMap, propagatorSettings );
 
@@ -378,6 +379,7 @@ double getBodyMass( const double time )
 BOOST_AUTO_TEST_CASE( test_NonConservativeForceEnvironmentUpdate )
 {
     double initialTime = 86400.0;
+    double finalTime = 2.0 * 86400.0;
 
     using namespace tudat::simulation_setup;
     using namespace tudat;
@@ -441,7 +443,7 @@ BOOST_AUTO_TEST_CASE( test_NonConservativeForceEnvironmentUpdate )
         boost::shared_ptr< PropagatorSettings< double > > propagatorSettings =
                 boost::make_shared< TranslationalStatePropagatorSettings< double > >(
                     centralBodyList, accelerationsMap, propagatedBodyList, getInitialStateOfBody(
-                        "Vehicle", centralBodies[ "Vehicle" ], bodyMap, initialTime ) );
+                        "Vehicle", centralBodies[ "Vehicle" ], bodyMap, initialTime ), finalTime );
         std::map< propagators::EnvironmentModelsToUpdate, std::vector< std::string > > environmentModelsToUpdate =
                 createEnvironmentUpdaterSettings< double >( bodyMap, propagatorSettings );
 
@@ -513,7 +515,7 @@ BOOST_AUTO_TEST_CASE( test_NonConservativeForceEnvironmentUpdate )
         boost::shared_ptr< PropagatorSettings< double > > propagatorSettings =
                 boost::make_shared< TranslationalStatePropagatorSettings< double > >(
                     centralBodyList, accelerationsMap, propagatedBodyList, getInitialStateOfBody(
-                        "Vehicle", centralBodies[ "Vehicle" ], bodyMap, initialTime ) );
+                        "Vehicle", centralBodies[ "Vehicle" ], bodyMap, initialTime ), finalTime );
         std::map< propagators::EnvironmentModelsToUpdate, std::vector< std::string > > environmentModelsToUpdate =
                 createEnvironmentUpdaterSettings< double >( bodyMap, propagatorSettings );
 
diff --git a/Tudat/Astrodynamics/Propagators/dynamicsSimulator.h b/Tudat/Astrodynamics/Propagators/dynamicsSimulator.h
index 2254313..6be0249 100644
--- a/Tudat/Astrodynamics/Propagators/dynamicsSimulator.h
+++ b/Tudat/Astrodynamics/Propagators/dynamicsSimulator.h
@@ -173,6 +173,8 @@ public:
         dynamicsStateDerivative_ = boost::make_shared< DynamicsStateDerivativeModel< TimeType, StateScalarType > >(
                     createStateDerivativeModels< StateScalarType, TimeType >(
                         propagatorSettings_, bodyMap_ ), environmentUpdater_ );
+        propagationStoppingCondition_ = createPropagationStoppingConditions(
+                    propagatorSettings->getTerminationSettings( ), bodyMap_, integratorSettings->initialTimeStep_ );
         stateDerivativeFunction_ =
                 boost::bind( &DynamicsStateDerivativeModel< TimeType, StateScalarType >::computeStateDerivative,
                              dynamicsStateDerivative_, _1, _2 );
@@ -321,6 +323,8 @@ protected:
     //! Settings for propagator.
     boost::shared_ptr< PropagatorSettings< StateScalarType > > propagatorSettings_;
 
+    boost::shared_ptr< PropagationStoppingCondition > propagationStoppingCondition_;
+
     //! Object for retrieving ephemerides for transformation of reference frame (origins)
     boost::shared_ptr< ephemerides::ReferenceFrameManager > frameManager_;
 
@@ -355,7 +359,7 @@ public:
     using DynamicsSimulator< StateScalarType, TimeType >::integratorSettings_;
     using DynamicsSimulator< StateScalarType, TimeType >::propagatorSettings_;
     using DynamicsSimulator< StateScalarType, TimeType >::integratedStateProcessors_;
-
+    using DynamicsSimulator< StateScalarType, TimeType >::propagationStoppingCondition_;
 
     //! Constructor of simulator.
     /*!
@@ -412,7 +416,8 @@ public:
         equationsOfMotionNumericalSolution_ =
                 integrateEquations< Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >, TimeType >(
                     stateDerivativeFunction_, dynamicsStateDerivative_->convertFromOutputSolution(
-                        initialStates, integratorSettings_->initialTime_ ), integratorSettings_ );
+                        initialStates, integratorSettings_->initialTime_ ), integratorSettings_,
+                    boost::bind( &PropagationStoppingCondition::checkStopCondition, propagationStoppingCondition_, _1 ) );
         equationsOfMotionNumericalSolution_ = dynamicsStateDerivative_->
                 convertNumericalStateSolutionsToOutputSolutions( equationsOfMotionNumericalSolution_ );
 
diff --git a/Tudat/Astrodynamics/Propagators/integrateEquations.cpp b/Tudat/Astrodynamics/Propagators/integrateEquations.cpp
index 8b13789..1e2a251 100644
--- a/Tudat/Astrodynamics/Propagators/integrateEquations.cpp
+++ b/Tudat/Astrodynamics/Propagators/integrateEquations.cpp
@@ -1 +1,233 @@
+#include "Tudat/Astrodynamics/Aerodynamics/aerodynamics.h"
+#include "Tudat/Astrodynamics/Propagators/integrateEquations.h"
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebra.h"
+
+namespace tudat
+{
+
+namespace propagators
+{
+
+boost::function< double( ) > getDependentVariableFunction(
+        const PropagationDependentVariables dependentVariable,
+        const std::string& bodyWithProperty,
+        const std::string& secondaryBody,
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const basic_astrodynamics::AccelerationMap& accelerationModelList )
+{
+    boost::function< double( ) > variableFunction;
+    switch( dependentVariable )
+    {
+    case mach_number_dependent_variable:
+    {
+        if( bodyMap.at( bodyWithProperty )->getFlightConditions( ) == NULL )
+        {
+
+        }
+
+        boost::function< double( const double, const double ) > functionToEvaluate =
+                boost::bind( &aerodynamics::computeMachNumber, _1, _2 );
+        boost::function< double( ) > firstInput =
+                boost::bind( &aerodynamics::FlightConditions::getCurrentAirspeed,
+                             bodyMap.at( bodyWithProperty )->getFlightConditions( ) );
+        boost::function< double( ) > secondInput =
+                boost::bind( &aerodynamics::FlightConditions::getCurrentSpeedOfSound,
+                             bodyMap.at( bodyWithProperty )->getFlightConditions( ) );
+
+
+        variableFunction = boost::bind( &evaluateFunction< double, double >,
+                                        functionToEvaluate, firstInput, secondInput );
+        break;
+    }
+    case altitude_dependent_variable:
+        if( bodyMap.at( bodyWithProperty )->getFlightConditions( ) == NULL )
+        {
+
+        }
+        variableFunction = boost::bind( &aerodynamics::FlightConditions::getCurrentAltitude,
+                                        bodyMap.at( bodyWithProperty )->getFlightConditions( ) );
+        break;
+    case airspeed_dependent_variable:
+        if( bodyMap.at( bodyWithProperty )->getFlightConditions( ) == NULL )
+        {
+
+        }
+        variableFunction = boost::bind( &aerodynamics::FlightConditions::getCurrentAirspeed,
+                                        bodyMap.at( bodyWithProperty )->getFlightConditions( ) );
+        break;
+    case local_density_dependent_variable:
+        if( bodyMap.at( bodyWithProperty )->getFlightConditions( ) == NULL )
+        {
+
+        }
+        variableFunction = boost::bind( &aerodynamics::FlightConditions::getCurrentDensity,
+                                        bodyMap.at( bodyWithProperty )->getFlightConditions( ) );
+        break;
+    case radiation_pressure_dependent_variable:
+        if( bodyMap.at( bodyWithProperty )->getRadiationPressureInterfaces( ).count( secondaryBody ) == 0 )
+        {
+
+        }
+        variableFunction = boost::bind( &electro_magnetism::RadiationPressureInterface::getCurrentRadiationPressure,
+                                        bodyMap.at( bodyWithProperty )->getRadiationPressureInterfaces( ).at( secondaryBody ) );
+        break;
+    case relative_distance_dependent_variable:
+    {
+
+        boost::function< double( const Eigen::Vector3d&, const Eigen::Vector3d& ) > functionToEvaluate =
+                boost::bind( &linear_algebra::computeNormOfVectorDifference, _1, _2 );
+        boost::function< Eigen::Vector3d( ) > firstInput =
+                boost::bind( &simulation_setup::Body::getPosition, bodyMap.at( bodyWithProperty ) );
+        boost::function< Eigen::Vector3d( ) > secondInput =
+                boost::bind( &simulation_setup::Body::getPosition, bodyMap.at( secondaryBody ) );
+
+        variableFunction = boost::bind(
+                    &evaluateReferenceFunction< double, Eigen::Vector3d >, functionToEvaluate, firstInput, secondInput );
+        break;
+    }
+    case relative_speed_dependent_variable:
+    {
+        boost::function< double( const Eigen::Vector3d&, const Eigen::Vector3d& ) > functionToEvaluate =
+                boost::bind( &linear_algebra::computeNormOfVectorDifference, _1, _2 );
+        boost::function< Eigen::Vector3d( ) > firstInput =
+                boost::bind( &simulation_setup::Body::getVelocity, bodyMap.at( bodyWithProperty ) );
+        boost::function< Eigen::Vector3d( ) > secondInput =
+                boost::bind( &simulation_setup::Body::getVelocity, bodyMap.at( secondaryBody ) );
+
+        variableFunction = boost::bind(
+                    &evaluateReferenceFunction< double, Eigen::Vector3d >, functionToEvaluate, firstInput, secondInput );
+
+        break;
+    }
+    case total_acceleration_norm_dependent_variable:
+
+        break;
+    }
+    return variableFunction;
+}
+
+
+bool FixedTimeStoppingCondition::checkStopCondition( const double time  )
+{
+    bool stopPropagation = 0;
+
+    if( propagationDirectionIsPositive_ && ( time >= stopTime_ ) )
+    {
+        stopPropagation = 1;
+    }
+    else if( !propagationDirectionIsPositive_ && ( time <= stopTime_ ) )
+    {
+        stopPropagation = 1;
+    }
+    return stopPropagation;
+}
+
+
+bool SingleVariableLimitStoppingCondition::checkStopCondition( const double time  )
+{
+    bool stopPropagation = 0;
+    double currentVariable = variableRetrievalFuntion_( );
+    if( useAsLowerBound_ && ( currentVariable < limitingValue_ ) )
+    {
+        stopPropagation = 1;
+    }
+    else if( !useAsLowerBound_ && ( currentVariable > limitingValue_ ) )
+    {
+        stopPropagation = 1;
+    }
+    return stopPropagation;
+}
+
+
+bool HybridStoppingCondition::checkStopCondition( const double time )
+{
+    if( fulFillSingleCondition_ )
+    {
+        bool stopPropagation = 0;
+        for( unsigned int i = 0; i < stoppingCondition_.size( ); i++ )
+        {
+            if( stoppingCondition_.at( i )->checkStopCondition( time ) )
+            {
+                stopPropagation = 1;
+                break;
+            }
+        }
+        return stopPropagation;
+    }
+    else
+    {
+        bool stopPropagation = 1;
+        for( unsigned int i = 0; i < stoppingCondition_.size( ); i++ )
+        {
+            if( !stoppingCondition_.at( i )->checkStopCondition( time ) )
+            {
+                stopPropagation = 0;
+                break;
+            }
+        }
+        return stopPropagation;
+    }
+}
+
+
+
+boost::shared_ptr< PropagationStoppingCondition > createPropagationStoppingConditions(
+        const boost::shared_ptr< PropagationTerminationSettings > terminationSettings,
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const double initialTimeStep )
+{
+    boost::shared_ptr< PropagationStoppingCondition > stoppingCondition;
+    switch( terminationSettings->terminationType_ )
+    {
+    case time_stopping_condition:
+    {
+        boost::shared_ptr< PropagationTimeTerminationSettings > timeTerminationSettings =
+                boost::dynamic_pointer_cast< PropagationTimeTerminationSettings >( terminationSettings );
+        stoppingCondition = boost::make_shared< FixedTimeStoppingCondition >(
+                    timeTerminationSettings->terminationTime_, ( initialTimeStep > 0 ) ? true : false );
+        break;
+    }
+    case dependent_variable_stopping_condition:
+    {
+        boost::shared_ptr< PropagationDependentVariableTerminationSettings > dependentVariableTerminationSettings =
+                boost::dynamic_pointer_cast< PropagationDependentVariableTerminationSettings >( terminationSettings );
+        boost::function< double( ) > dependentVariableFunction =
+                getDependentVariableFunction( dependentVariableTerminationSettings->variableType_,
+                                              dependentVariableTerminationSettings->associatedBody_,
+                                              dependentVariableTerminationSettings->secondaryBody_,
+                                              bodyMap );
+        stoppingCondition = boost::make_shared< SingleVariableLimitStoppingCondition >(
+                    std::make_pair( dependentVariableTerminationSettings->variableType_,
+                                    dependentVariableTerminationSettings->associatedBody_ ),
+                    dependentVariableFunction, dependentVariableTerminationSettings->limitValue_,
+                    dependentVariableTerminationSettings->useAsLowerLimit_ );
+        break;
+    }
+    case hybrid_stopping_condition:
+    {
+        boost::shared_ptr< PropagationHybridTerminationSettings > hybridTerminationSettings =
+                boost::dynamic_pointer_cast< PropagationHybridTerminationSettings >( terminationSettings );
+
+        std::vector< boost::shared_ptr< PropagationStoppingCondition > > stoppingConditionList;
+        for( unsigned int i = 0; i < hybridTerminationSettings->terminationSettings_.size( ); i++ )
+        {
+            stoppingConditionList.push_back(
+                        createPropagationStoppingConditions(
+                            hybridTerminationSettings->terminationSettings_.at( i ),
+                            bodyMap, initialTimeStep ) );
+        }
+        stoppingCondition = boost::make_shared< HybridStoppingCondition >(
+                    stoppingConditionList, hybridTerminationSettings->fulFillSingleCondition_ );
+        break;
+    }
+    default:
+
+        break;
+    }
+    return stoppingCondition;
+}
+
+}
+
+}
 
diff --git a/Tudat/Astrodynamics/Propagators/integrateEquations.h b/Tudat/Astrodynamics/Propagators/integrateEquations.h
index 7a0efbc..5010652 100644
--- a/Tudat/Astrodynamics/Propagators/integrateEquations.h
+++ b/Tudat/Astrodynamics/Propagators/integrateEquations.h
@@ -29,6 +29,107 @@ namespace tudat
 namespace propagators
 {
 
+template< typename OutputType, typename InputType >
+OutputType evaluateReferenceFunction(
+        const boost::function< OutputType( const InputType&, const InputType& ) > functionToEvaluate,
+        const boost::function< InputType( ) > firstInput,
+        const boost::function< InputType( ) > secondInput )
+{
+    return functionToEvaluate( firstInput( ), secondInput( ) );
+}
+
+template< typename OutputType, typename InputType >
+OutputType evaluateFunction(
+        const boost::function< OutputType( const InputType, const InputType ) > functionToEvaluate,
+        const boost::function< InputType( ) > firstInput,
+        const boost::function< InputType( ) > secondInput )
+{
+    return functionToEvaluate( firstInput( ), secondInput( ) );
+}
+
+boost::function< double( ) > getDependentVariableFunction(
+        const PropagationDependentVariables dependentVariable,
+        const std::string& bodyWithProperty,
+        const std::string& secondaryBody,
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const basic_astrodynamics::AccelerationMap& accelerationModelList = basic_astrodynamics::AccelerationMap( ) );
+
+class PropagationStoppingCondition
+{
+public:
+    PropagationStoppingCondition( ){ }
+
+    virtual ~PropagationStoppingCondition( ){ }
+
+    virtual bool checkStopCondition( const double time ) = 0;
+};
+
+class FixedTimeStoppingCondition: public PropagationStoppingCondition
+{
+public:
+    FixedTimeStoppingCondition(
+            const double stopTime,
+            const bool propagationDirectionIsPositive ):
+        stopTime_( stopTime ),
+        propagationDirectionIsPositive_( propagationDirectionIsPositive ){ }
+
+
+    bool checkStopCondition( const double time );
+
+private:
+    double stopTime_;
+
+    bool propagationDirectionIsPositive_;
+};
+
+class SingleVariableLimitStoppingCondition: public PropagationStoppingCondition
+{
+public:
+    SingleVariableLimitStoppingCondition(
+            const std::pair< PropagationDependentVariables, std::string > variableType,
+            const boost::function< double( ) > variableRetrievalFuntion,
+            const double limitingValue,
+            const bool useAsLowerBound ):
+    variableType_( variableType ), variableRetrievalFuntion_( variableRetrievalFuntion ),
+    limitingValue_( limitingValue ), useAsLowerBound_( useAsLowerBound ){ }
+
+    virtual ~SingleVariableLimitStoppingCondition( ){ }
+
+    bool checkStopCondition( const double time );
+
+private:
+    std::pair< PropagationDependentVariables, std::string > variableType_;
+
+    boost::function< double( ) > variableRetrievalFuntion_;
+
+    double limitingValue_;
+
+    bool useAsLowerBound_;
+};
+
+class HybridStoppingCondition: public PropagationStoppingCondition
+{
+public:
+    HybridStoppingCondition(
+            const std::vector< boost::shared_ptr< PropagationStoppingCondition > > stoppingCondition,
+            const bool fulFillSingleCondition = 0 ):
+        stoppingCondition_( stoppingCondition ), fulFillSingleCondition_( fulFillSingleCondition ){ }
+
+    bool checkStopCondition( const double time );
+
+private:
+
+    std::vector< boost::shared_ptr< PropagationStoppingCondition > > stoppingCondition_;
+
+    bool fulFillSingleCondition_;
+};
+
+
+boost::shared_ptr< PropagationStoppingCondition > createPropagationStoppingConditions(
+        const boost::shared_ptr< PropagationTerminationSettings > terminationSettings,
+        const simulation_setup::NamedBodyMap& bodyMap,
+        const double initialTimeStep );
+
 //! Function to numerically integrate a given first order differential equation
 /*!
  *  Function to numerically integrate a given first order differential equation, with the state derivative a function of
@@ -44,7 +145,8 @@ template< typename StateType = Eigen::MatrixXd, typename TimeType = double >
 std::map< TimeType, StateType > integrateEquations(
         boost::function< StateType( const TimeType, const StateType&) > stateDerivativeFunction,
         const StateType initialState,
-        boost::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > > integratorSettings,
+        const boost::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > > integratorSettings,
+        const boost::function< bool( const double ) > stopPropagationFunction,
         const TimeType printInterval = TUDAT_NAN )
 {
     using namespace tudat::numerical_integrators;
@@ -71,7 +173,6 @@ std::map< TimeType, StateType > integrateEquations(
 
     // Set initial time step and total integration time.
     TimeType timeStep = integratorSettings->initialTimeStep_;
-    TimeType endTime = integratorSettings->endTime_;
     TimeType previousTime = currentTime;
 
     // Perform first integration step.
@@ -85,7 +186,7 @@ std::map< TimeType, StateType > integrateEquations(
     int printIndex = 0;
     int printFrequency = integratorSettings->printFrequency_;
     // Perform numerical integration steps until end time reached.
-    while( timeStepSign * static_cast< TimeType >( currentTime ) < timeStepSign * static_cast< TimeType >( endTime ) )
+    do
     {
         previousTime = currentTime;
 
@@ -115,6 +216,7 @@ std::map< TimeType, StateType > integrateEquations(
             }
         }
     }
+    while( !stopPropagationFunction( static_cast< double >( currentTime ) ) );
 
     return solutionHistory;
 }
diff --git a/Tudat/Astrodynamics/Propagators/propagationSettings.h b/Tudat/Astrodynamics/Propagators/propagationSettings.h
index 8ed8fe1..acfce6b 100644
--- a/Tudat/Astrodynamics/Propagators/propagationSettings.h
+++ b/Tudat/Astrodynamics/Propagators/propagationSettings.h
@@ -17,6 +17,7 @@
 #include <iostream>
 #include <unordered_map>
 
+#include <boost/make_shared.hpp>
 #include <boost/lexical_cast.hpp>
 
 #include <Eigen/Core>
@@ -44,6 +45,90 @@ enum TranslationalPropagatorType
     cowell = 0
 };
 
+enum PropagationDependentVariables
+{
+    mach_number_dependent_variable,
+    altitude_dependent_variable,
+    airspeed_dependent_variable,
+    local_density_dependent_variable,
+    relative_speed_dependent_variable,
+    relative_distance_dependent_variable,
+    radiation_pressure_dependent_variable,    
+    total_acceleration_norm_dependent_variable
+};
+
+enum PropagationTerminationTypes
+{
+    time_stopping_condition,
+    dependent_variable_stopping_condition,
+    hybrid_stopping_condition
+};
+
+
+class PropagationTerminationSettings
+{
+public:
+    PropagationTerminationSettings( const PropagationTerminationTypes terminationType ):
+        terminationType_( terminationType ){ }
+
+    virtual ~PropagationTerminationSettings( ){ }
+
+    PropagationTerminationTypes terminationType_;
+};
+
+class PropagationTimeTerminationSettings: public PropagationTerminationSettings
+{
+public:
+    PropagationTimeTerminationSettings( const double terminationTime ):
+        PropagationTerminationSettings( time_stopping_condition ),
+        terminationTime_( terminationTime ){ }
+
+    ~PropagationTimeTerminationSettings( ){ }
+
+    double terminationTime_;
+};
+
+class PropagationDependentVariableTerminationSettings: public PropagationTerminationSettings
+{
+public:
+    PropagationDependentVariableTerminationSettings( const PropagationDependentVariables variableType,
+                                                     const std::string associatedBody,
+                                                     const double limitValue,
+                                                     const bool useAsLowerLimit,
+                                                     const std::string secondaryBody = "" ):
+        PropagationTerminationSettings( dependent_variable_stopping_condition ),
+        variableType_( variableType ), associatedBody_( associatedBody ),
+        limitValue_( limitValue ), useAsLowerLimit_( useAsLowerLimit ), secondaryBody_( secondaryBody ){ }
+
+    ~PropagationDependentVariableTerminationSettings( ){ }
+
+    PropagationDependentVariables variableType_;
+
+    std::string associatedBody_;
+
+    double limitValue_;
+
+    bool useAsLowerLimit_;
+
+    std::string secondaryBody_;
+};
+
+class PropagationHybridTerminationSettings: public PropagationTerminationSettings
+{
+public:
+    PropagationHybridTerminationSettings(
+            const std::vector< boost::shared_ptr< PropagationTerminationSettings > > terminationSettings,
+            const bool fulFillSingleCondition = 0 ):
+        PropagationTerminationSettings( hybrid_stopping_condition ),
+        terminationSettings_( terminationSettings ),
+        fulFillSingleCondition_( fulFillSingleCondition ){ }
+
+    std::vector< boost::shared_ptr< PropagationTerminationSettings > > terminationSettings_;
+
+    bool fulFillSingleCondition_;
+
+};
+
 //! Get size of state for single propagated state of given type.
 /*!
  * Get size of state for single propagated state of given type (i.e. 6 for translational state).
@@ -77,8 +162,10 @@ public:
      * \param initialBodyStates Initial state used as input for numerical integration
      */
     PropagatorSettings( const IntegratedStateType stateType,
-                        const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > initialBodyStates ):
-        stateType_( stateType ), initialStates_( initialBodyStates ), stateSize_( initialBodyStates.rows( ) ){ }
+                        const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > initialBodyStates,
+                        const boost::shared_ptr< PropagationTerminationSettings > terminationSettings ):
+        stateType_( stateType ), initialStates_( initialBodyStates ), stateSize_( initialBodyStates.rows( ) ),
+    terminationSettings_( terminationSettings ){ }
 
     //! Virtual destructor.
     virtual ~PropagatorSettings( ){ }
@@ -117,6 +204,11 @@ public:
         return stateSize_;
     }
 
+    boost::shared_ptr< PropagationTerminationSettings > getTerminationSettings( )
+    {
+        return terminationSettings_;
+    }
+
 protected:
 
     //!  Initial state used as input for numerical integration
@@ -125,6 +217,8 @@ protected:
     //! Total size of the propagated state.
     int stateSize_;
 
+    boost::shared_ptr< PropagationTerminationSettings > terminationSettings_;
+
 };
 
 //! Class for defining settings for propagating translational dynamics.
@@ -155,11 +249,39 @@ public:
                                           const basic_astrodynamics::AccelerationMap& accelerationsMap,
                                           const std::vector< std::string >& bodiesToIntegrate,
                                           const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& initialBodyStates,
+                                          const boost::shared_ptr< PropagationTerminationSettings > terminationSettings,
                                           const TranslationalPropagatorType propagator = cowell):
-        PropagatorSettings< StateScalarType >( transational_state, initialBodyStates ), centralBodies_( centralBodies ),
+        PropagatorSettings< StateScalarType >( transational_state, initialBodyStates, terminationSettings ),
+        centralBodies_( centralBodies ),
         accelerationsMap_( accelerationsMap ), bodiesToIntegrate_( bodiesToIntegrate ),
         propagator_( propagator ){ }
 
+    //! Constructor
+    /*!
+     * Constructor
+     * \param centralBodies List of bodies w.r.t. which the bodies in bodiesToIntegrate_ are propagated.
+     * \param accelerationsMap A map containing the list of accelerations acting on each body, identifying
+     *  the body being acted on and the body acted on by an acceleration. The map has as key a string denoting
+     *  the name of the body the list of accelerations, provided as the value corresponding to a key, is acting on.
+     *  This map-value is again a map with string as key, denoting the body exerting the acceleration, and as value
+     *  a pointer to an acceleration model.
+     * \param bodiesToIntegrate List of bodies for which the translational state is to be propagated.
+     * \param initialBodyStates Initial state used as input for numerical integration
+     * \param propagator Type of translational state propagator to be used
+     */
+    TranslationalStatePropagatorSettings( const std::vector< std::string >& centralBodies,
+                                          const basic_astrodynamics::AccelerationMap& accelerationsMap,
+                                          const std::vector< std::string >& bodiesToIntegrate,
+                                          const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 >& initialBodyStates,
+                                          const double endTime,
+                                          const TranslationalPropagatorType propagator = cowell):
+        PropagatorSettings< StateScalarType >(
+            transational_state, initialBodyStates,  boost::make_shared< PropagationTimeTerminationSettings >( endTime ) ),
+        centralBodies_( centralBodies ),
+        accelerationsMap_( accelerationsMap ), bodiesToIntegrate_( bodiesToIntegrate ),
+        propagator_( propagator ){ }
+
+
     //! Virtual destructor
     /*!
      *  Virtual destructor
diff --git a/Tudat/Mathematics/BasicMathematics/linearAlgebra.cpp b/Tudat/Mathematics/BasicMathematics/linearAlgebra.cpp
index e15eaed..fd1c12d 100644
--- a/Tudat/Mathematics/BasicMathematics/linearAlgebra.cpp
+++ b/Tudat/Mathematics/BasicMathematics/linearAlgebra.cpp
@@ -103,6 +103,12 @@ double computeAngleBetweenVectors( const Eigen::VectorXd& vector0, const Eigen::
     return std::acos( dotProductOfNormalizedVectors );
 }
 
+double computeNormOfVectorDifference( const Eigen::Vector3d& vector0,
+                                      const Eigen::Vector3d& vector1 )
+{
+    return ( vector0 - vector1 ).norm( );
+}
+
 } // namespace linear_algebra
 
 } // namespace tudat
diff --git a/Tudat/Mathematics/BasicMathematics/linearAlgebra.h b/Tudat/Mathematics/BasicMathematics/linearAlgebra.h
index c7b5e76..12330ab 100644
--- a/Tudat/Mathematics/BasicMathematics/linearAlgebra.h
+++ b/Tudat/Mathematics/BasicMathematics/linearAlgebra.h
@@ -72,6 +72,8 @@ double computeCosineOfAngleBetweenVectors( const Eigen::VectorXd& vector0,
 double computeAngleBetweenVectors( const Eigen::VectorXd& vector0,
                                    const Eigen::VectorXd& vector1 );
 
+double computeNormOfVectorDifference( const Eigen::Vector3d& vector0,
+                                   const Eigen::Vector3d& vector1 );
 //! Flip matrix rows.
 /*!
  * Flips all rows of an Eigen-matrix, i.e., order of rows is reversed.
@@ -94,6 +96,8 @@ static inline void flipMatrixRows( Eigen::MatrixXd& matrixToFlip )
     }
 }
 
+double computeNormOfVectorDifference( const Eigen::Vector3d& vector0,
+                                      const Eigen::Vector3d& vector1 );
 } // namespace linear_algebra
 
 } // namespace tudat
diff --git a/Tudat/Mathematics/NumericalIntegrators/createNumericalIntegrator.h b/Tudat/Mathematics/NumericalIntegrators/createNumericalIntegrator.h
index 12d6c3b..35feba1 100644
--- a/Tudat/Mathematics/NumericalIntegrators/createNumericalIntegrator.h
+++ b/Tudat/Mathematics/NumericalIntegrators/createNumericalIntegrator.h
@@ -45,16 +45,15 @@ public:
      *  Constructor for integrator settings.
      *  \param integratorType Type of numerical integrator
      *  \param initialTime Start time (independent variable) of numerical integration.
-     *  \param endTime Stop time (independent variable) of numerical integration.
      *  \param initialTimeStep Initial time (independent variable) step used in numerical integration. Adapted during integration
      *  for variable step size integrators.
      *  \param printFrequency Frequency at which to save the numerical integrated states (in units of i.e. per n integration
      *  time steps, with n = printFrequency).
      */
     IntegratorSettings( const AvailableIntegrators integratorType, const TimeType initialTime,
-                        const TimeType endTime, const TimeType initialTimeStep,
+                        const TimeType initialTimeStep,
                         const int printFrequency = 1 ): integratorType_( integratorType ),
-        initialTime_( initialTime ), endTime_( endTime ), initialTimeStep_( initialTimeStep ),
+        initialTime_( initialTime ), initialTimeStep_( initialTimeStep ),
         printFrequency_( printFrequency ){ }
 
     //! Virtual destructor.
@@ -75,12 +74,6 @@ public:
      */
     TimeType initialTime_;
 
-    //! Stop time of numerical integration.
-    /*!
-     *  Stop time (independent variable) of numerical integration.
-     */
-    TimeType endTime_;
-
     //! Initial time step used in numerical integration
     /*!
      *  Initial time (independent variable) step used in numerical integration. Adapted during integration
@@ -111,7 +104,6 @@ public:
      *  Constructor for variable step RK integrator settings.
      *  \param integratorType Type of numerical integrator (must be an RK variable step type)
      *  \param initialTime Start time (independent variable) of numerical integration.
-     *  \param endTime Stop time (independent variable) of numerical integration.
      *  \param initialTimeStep Initial time (independent variable) step used in numerical integration.
      *  Adapted during integration
      *  \param coefficientSet Coefficient set (butcher tableau) to use in integration.
@@ -130,7 +122,6 @@ public:
     RungeKuttaVariableStepSizeSettings(
             const AvailableIntegrators integratorType,
             const TimeType initialTime,
-            const TimeType endTime,
             const TimeType initialTimeStep,
             const numerical_integrators::RungeKuttaCoefficients::CoefficientSets coefficientSet,
             const TimeType minimumStepSize, const TimeType maximumStepSize,
@@ -140,7 +131,7 @@ public:
             const TimeType safetyFactorForNextStepSize = 0.8,
             const TimeType maximumFactorIncreaseForNextStepSize = 4.0,
             const TimeType minimumFactorDecreaseForNextStepSize = 0.1 ):
-        IntegratorSettings< TimeType >( integratorType, initialTime, endTime, initialTimeStep, printFrequency ),
+        IntegratorSettings< TimeType >( integratorType, initialTime, initialTimeStep, printFrequency ),
         coefficientSet_( coefficientSet ), minimumStepSize_( minimumStepSize ), maximumStepSize_( maximumStepSize ),
         relativeErrorTolerance_( relativeErrorTolerance ), absoluteErrorTolerance_( absoluteErrorTolerance ),
         safetyFactorForNextStepSize_( safetyFactorForNextStepSize ),
diff --git a/Tudat/SimulationSetup/createAccelerationModels.cpp b/Tudat/SimulationSetup/createAccelerationModels.cpp
index d1a3d78..b706db8 100644
--- a/Tudat/SimulationSetup/createAccelerationModels.cpp
+++ b/Tudat/SimulationSetup/createAccelerationModels.cpp
@@ -554,6 +554,28 @@ AccelerationMap createAccelerationModelsMap(
     return accelerationModelMap;
 }
 
+//! Function to create acceleration models from a map of bodies and acceleration model types.
+basic_astrodynamics::AccelerationMap createAccelerationModelsMap(
+        const NamedBodyMap& bodyMap,
+        const SelectedAccelerationMap& selectedAccelerationPerBody,
+        const std::vector< std::string >& propagatedBodies,
+        const std::vector< std::string >& centralBodies )
+{
+    if( centralBodies.size( ) != propagatedBodies.size( ) )
+    {
+        throw std::runtime_error( "Error, number of propagated bodies must equal number of central bodies" );
+    }
+
+    std::map< std::string, std::string > centralBodyMap;
+    for( unsigned int i = 0; i < propagatedBodies.size( ); i++ )
+    {
+        centralBodyMap[ propagatedBodies.at( i ) ] = centralBodies.at( i );
+    }
+
+    return createAccelerationModelsMap( bodyMap, selectedAccelerationPerBody, centralBodyMap );
+}
+
+
 } // namespace simulation_setup
 
 } // namespace tudat
diff --git a/Tudat/SimulationSetup/createAccelerationModels.h b/Tudat/SimulationSetup/createAccelerationModels.h
index 44dc4f9..6555e5a 100644
--- a/Tudat/SimulationSetup/createAccelerationModels.h
+++ b/Tudat/SimulationSetup/createAccelerationModels.h
@@ -183,6 +183,12 @@ basic_astrodynamics::AccelerationMap createAccelerationModelsMap(
         const SelectedAccelerationMap& selectedAccelerationPerBody,
         const std::map< std::string, std::string >& centralBodies );
 
+basic_astrodynamics::AccelerationMap createAccelerationModelsMap(
+        const NamedBodyMap& bodyMap,
+        const SelectedAccelerationMap& selectedAccelerationPerBody,
+        const std::vector< std::string >& propagatedBodies,
+        const std::vector< std::string >& centralBodies );
+
 } // namespace simulation_setup
 
 } // namespace tudat
diff --git a/Tudat/SimulationSetup/createFlightConditions.h b/Tudat/SimulationSetup/createFlightConditions.h
index 0e10ce9..563643d 100644
--- a/Tudat/SimulationSetup/createFlightConditions.h
+++ b/Tudat/SimulationSetup/createFlightConditions.h
@@ -245,6 +245,34 @@ public:
         constantMomentCoefficient_( constantMomentCoefficient )
     { }
 
+   //! Constructor.
+    /*!
+    *  Constructor, omitting all moment coefficient data.
+    *  \param constantForceCoefficient Constant force coefficients.
+    *  \param referenceArea Reference area with which aerodynamic forces and moments are
+    *  non-dimensionalized.
+    *  \param areCoefficientsInAerodynamicFrame Boolean to define whether the aerodynamic
+    *  coefficients are defined in the aerodynamic frame (lift, drag, side force) or in the body
+    *  frame (typically denoted as Cx, Cy, Cz).
+    *  \param areCoefficientsInNegativeAxisDirection Boolean to define whether the aerodynamic
+    *  coefficients are positiver along tyhe positive axes of the body or aerodynamic frame
+    *  (see areCoefficientsInAerodynamicFrame). Note that for (lift, drag, side force), the
+    *  coefficients are typically defined in negative direction.
+    */
+    ConstantAerodynamicCoefficientSettings(
+            const double referenceArea,
+            const Eigen::Vector3d& constantForceCoefficient,
+            const bool areCoefficientsInAerodynamicFrame = 0,
+            const bool areCoefficientsInNegativeAxisDirection = 1 ):
+        AerodynamicCoefficientSettings(
+            constant_aerodynamic_coefficients, TUDAT_NAN, referenceArea,
+            TUDAT_NAN, Eigen::Vector3d::Zero( ),
+            std::vector< aerodynamics::AerodynamicCoefficientsIndependentVariables >( ),
+            areCoefficientsInAerodynamicFrame, areCoefficientsInNegativeAxisDirection ),
+        constantForceCoefficient_( constantForceCoefficient ),
+        constantMomentCoefficient_( Eigen::Vector3d::Zero( ) ){ }
+
+
     //! Function to return constant force coefficients.
     /*!
      *  Function to return constant force coefficients.
