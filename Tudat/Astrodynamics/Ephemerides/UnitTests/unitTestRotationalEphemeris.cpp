/*    Copyright (c) 2010-2015, Delft University of Technology
   *    All rights reserved.
   *
   *    Redistribution and use in source and binary forms, with or without modification, are
   *    permitted provided that the following conditions are met:
   *      - Redistributions of source code must retain the above copyright notice, this list of
   *        conditions and the following disclaimer.
   *      - Redistributions in binary form must reproduce the above copyright notice, this list of
   *        conditions and the following disclaimer in the documentation and/or other materials
   *        provided with the distribution.
   *      - Neither the name of the Delft University of Technology nor the names of its contributors
   *        may be used to endorse or promote products derived from this software without specific
   *        prior written permission.
   *
   *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
   *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
   *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
   *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
   *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
   *    OF THE POSSIBILITY OF SUCH DAMAGE.
   *
   *    Changelog
   *      YYMMDD    Author              Comment
   *      130219    D. Dirkx            File created.
   *      130227    R.C.A. Boon         Removed using directives (using namespace), added necessary
   *                                    using declarations (using ...::member), removed obsolete
   *                                    include statements
   *      130302    D. Dirkx            Updated file by putting tests in local scope;
   *                                    expanded tests.
   *
   *    References
   *
   *    Notes
   *      The unit tests use rotation matrices generated by spice, the code for the spice interface
   *      used to generate these testing values are included in this file, but commented.
   */

#define BOOST_TEST_MAIN

#include <limits>
#include <iostream>

#include <boost/test/floating_point_comparison.hpp>
#include <boost/test/unit_test.hpp>

#include <Eigen/Core>

#include "Tudat/Basics/testMacros.h"
#include "Tudat/Mathematics/BasicMathematics/linearAlgebra.h"
#include "Tudat/Astrodynamics/BasicAstrodynamics/timeConversions.h"
#include "Tudat/Astrodynamics/Ephemerides/simpleRotationalEphemeris.h"
//#include "Tudat/External/SpiceInterface/spiceInterface.h"
//#include "Tudat/InputOutput/basicInputOutput.h"

namespace tudat
{
namespace unit_tests
{

using namespace ephemerides;

BOOST_AUTO_TEST_SUITE( test_rotational_ephemeris )

// Test functions to calculate rotation matrix derivative from angular velocity vector and vice
// versa.
BOOST_AUTO_TEST_CASE( testRotationalEphemeris )
{
    // Define names of frames.
    const std::string baseFrame = "J2000";
    const std::string targetFrame = "IAU_VENUS";

    // Set time at which rotational ephemeris it to be called for subsequent tests.

    // Test rotation to target frame at specified time.
    {

        // The following code block can be used to retrieve the benchmark data from Spice.
        //        spice_interface::loadSpiceKernelInTudat( input_output::getSpiceKernelPath( ) +
        // "pck00010.tpc" );
        //        const double secondsSinceJ2000 = 1.0E6;
        //        Eigen::Quaterniond spiceRotationMatrix =
        //                spice_interface::computeRotationQuaternionBetweenFrames(
        // baseFrame, targetFrame, secondsSinceJ2000 );
        //        Eigen::Matrix3d spiceRotationMatrixDerivative =
        //                spice_interface::computeRotationMatrixDerivativeBetweenFrames(
        // baseFrame, targetFrame, secondsSinceJ2000 );
        //        Eigen::Vector3d spiceRotationalVelocityVector =
        //                spice_interface::getAngularVelocityVectorOfFrameInOriginalFrame(
        // baseFrame, targetFrame, secondsSinceJ2000 );

        // Set rotational characteristics at given time, as calculated with Spice
        // (see above commented lines).
        Eigen::Matrix3d spiceRotationMatrixDerivative;
        spiceRotationMatrixDerivative <<
                1.690407961416589e-07, 2.288121921543265e-07, 9.283170431475241e-08,
                -2.468632444964533e-07, 1.540516111965609e-07, 6.981529179974795e-08,
                0.0,           0.0,          0.0;

        Eigen::Matrix3d spiceRotationMatrix;
        spiceRotationMatrix << -0.8249537745726603, 0.5148010526833556, 0.2333048348715243,
                -0.5648910720519699, -0.7646317780963481, -0.3102197940834743,
                0.01869081416890206, -0.3877088083617987, 0.9215923900425707;

        Eigen::Vector3d spiceRotationalVelocityVector;
        spiceRotationalVelocityVector << -5.593131603532092e-09,
                1.160198999048488e-07,
                -2.75781861386115e-07;

        // Calculate rotational velocity from SPICE rotation matrix derivative.
        Eigen::Vector3d rotationalVelocityVector =
                getRotationalVelocityVectorInBaseFrameFromMatrices(
                    spiceRotationMatrix, spiceRotationMatrixDerivative.transpose( ) );

        // Calculate rotation matrix derivative from SPICE rotational velocity vector.
        Eigen::Matrix3d rotationMatrixDerivative = getDerivativeOfRotationMatrixToFrame(
                    spiceRotationMatrix, spiceRotationalVelocityVector );

        // Calculate rotational velocity from previously calculated rotation matrix derivative.
        Eigen::Matrix3d backCalculatedRotationMatrixDerivative =
                getDerivativeOfRotationMatrixToFrame(
                    spiceRotationMatrix, rotationalVelocityVector );

        // Calculate rotation matrix derivative from previously calculated rotational velocity
        // vector.
        Eigen::Vector3d backCalculatedRotationalVelocityVector =
                getRotationalVelocityVectorInBaseFrameFromMatrices(
                    spiceRotationMatrix, rotationMatrixDerivative.transpose( ) );

        // Check equivalence of results.
        for( int i = 0; i < 3; i++ )
        {
            BOOST_CHECK_SMALL( rotationalVelocityVector( i ) -
                               backCalculatedRotationalVelocityVector( i ), 2.0E-22 );
            BOOST_CHECK_SMALL( rotationalVelocityVector( i ) -
                               spiceRotationalVelocityVector( i ), 2.0E-22 );

            for( int j = 0; j < 3; j++ )
            {
                BOOST_CHECK_SMALL( rotationMatrixDerivative( i, j ) -
                                   backCalculatedRotationMatrixDerivative( i, j ), 2.0E-22 );
                BOOST_CHECK_SMALL( rotationMatrixDerivative( i, j ) -
                                   spiceRotationMatrixDerivative( i, j ), 2.0E-22 );
            }
        }
    }
}

BOOST_AUTO_TEST_SUITE_END( )

} // namespace unit_tests
} // namespace tudat
