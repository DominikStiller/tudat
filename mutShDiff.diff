diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.cpp b/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.cpp
index 1dccec9..e0fb0d2 100644
--- a/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.cpp
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.cpp
@@ -75,6 +75,10 @@ AvailableAcceleration getAccelerationModelType(
     {
         accelerationType = spherical_harmonic_gravity;
     }
+    else if( boost::dynamic_pointer_cast< MutualSphericalHarmonicsGravitationalAccelerationModelXd >( accelerationModel ) != NULL )
+    {
+        accelerationType = mutual_spherical_harmonic_gravity;
+    }
     else if( boost::dynamic_pointer_cast< AerodynamicAcceleration >(
                  accelerationModel ) != NULL )
     {
diff --git a/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.h b/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.h
index 2d4a08f..a909fc7 100644
--- a/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.h
+++ b/Tudat/Astrodynamics/BasicAstrodynamics/accelerationModelTypes.h
@@ -38,6 +38,7 @@
 #include "Tudat/Astrodynamics/ElectroMagnetism/cannonBallRadiationPressureAcceleration.h"
 #include "Tudat/Astrodynamics/Gravitation/centralGravityModel.h"
 #include "Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h"
+#include "Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.h"
 #include "Tudat/Astrodynamics/Gravitation/thirdBodyPerturbation.h"
 #include "Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.h"
 
@@ -62,7 +63,8 @@ enum AvailableAcceleration
     cannon_ball_radiation_pressure,
     spherical_harmonic_gravity,
     third_body_central_gravity,
-    third_body_spherical_harmonic_gravity
+    third_body_spherical_harmonic_gravity,
+    mutual_spherical_harmonic_gravity
 };
 
 //! Function to identify the derived class type of an acceleration model.
diff --git a/Tudat/Astrodynamics/Gravitation/CMakeLists.txt b/Tudat/Astrodynamics/Gravitation/CMakeLists.txt
index e8d426c..db0684e 100644
--- a/Tudat/Astrodynamics/Gravitation/CMakeLists.txt
+++ b/Tudat/Astrodynamics/Gravitation/CMakeLists.txt
@@ -57,6 +57,7 @@ set(GRAVITATION_SOURCES
   "${SRCROOT}${GRAVITATIONDIR}/UnitTests/planetTestData.cpp"
   "${SRCROOT}${GRAVITATIONDIR}/unitConversionsCircularRestrictedThreeBodyProblem.cpp"
   "${SRCROOT}${GRAVITATIONDIR}/tabulatedGravityFieldVariations.cpp"
+  "${SRCROOT}${GRAVITATIONDIR}/mutualSphericalHarmonicGravityModel.cpp"
 )
 
 # Set the header files.
@@ -79,6 +80,7 @@ set(GRAVITATION_HEADERS
   "${SRCROOT}${GRAVITATIONDIR}/unitConversionsCircularRestrictedThreeBodyProblem.h"
   "${SRCROOT}${GRAVITATIONDIR}/UnitTests/planetTestData.h"
   "${SRCROOT}${GRAVITATIONDIR}/tabulatedGravityFieldVariations.h"
+  "${SRCROOT}${GRAVITATIONDIR}/mutualSphericalHarmonicGravityModel.h"
 )
 
 # Add static libraries.
@@ -125,3 +127,8 @@ target_link_libraries(test_ThirdBodyPerturbation tudat_gravitation tudat_basic_m
 add_executable(test_GravityFieldVariations "${SRCROOT}${GRAVITATIONDIR}/UnitTests/unitTestGravityFieldVariations.cpp")
 setup_custom_test_program(test_GravityFieldVariations "${SRCROOT}${GRAVITATIONDIR}")
 target_link_libraries(test_GravityFieldVariations tudat_gravitation tudat_basic_mathematics tudat_spice_interface ${SPICE_LIBRARIES} ${Boost_LIBRARIES} )
+
+add_executable(test_MutualSphericalHarmonicsGravityModel "${SRCROOT}${GRAVITATIONDIR}/UnitTests/unitTestMutualSphericalHarmonicAcceleration.cpp")
+setup_custom_test_program(test_MutualSphericalHarmonicsGravityModel "${SRCROOT}${GRAVITATIONDIR}")
+target_link_libraries(test_MutualSphericalHarmonicsGravityModel tudat_simulation_setup tudat_electro_magnetism tudat_aerodynamics tudat_ephemerides tudat_reference_frames tudat_basic_astrodynamics tudat_gravitation tudat_spice_interface tudat_spice_interface tudat_input_output tudat_basic_mathematics ${SPICE_LIBRARIES} ${Boost_LIBRARIES} )
+
diff --git a/Tudat/Astrodynamics/Gravitation/UnitTests/unitTestMutualSphericalHarmonicAcceleration.cpp b/Tudat/Astrodynamics/Gravitation/UnitTests/unitTestMutualSphericalHarmonicAcceleration.cpp
new file mode 100644
index 0000000..8161c8c
--- /dev/null
+++ b/Tudat/Astrodynamics/Gravitation/UnitTests/unitTestMutualSphericalHarmonicAcceleration.cpp
@@ -0,0 +1,300 @@
+#define BOOST_TEST_MAIN
+
+#include <string>
+#include <thread>
+
+#include <boost/test/unit_test.hpp>
+#include <boost/random/uniform_01.hpp>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+#include "Tudat/Basics/testMacros.h"
+
+#include "Tudat/Astrodynamics/Gravitation/thirdBodyPerturbation.h"
+#include "Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.h"
+#include "Tudat/External/SpiceInterface/spiceInterface.h"
+#include "Tudat/InputOutput/basicInputOutput.h"
+#include "Tudat/SimulationSetup/createAccelerationModels.h"
+#include "Tudat/SimulationSetup/createBodies.h"
+#include "Tudat/SimulationSetup/createGravityField.h"
+#include "Tudat/SimulationSetup/defaultBodies.h"
+
+
+namespace tudat
+{
+
+namespace unit_tests
+{
+
+using namespace tudat::spice_interface;
+using namespace tudat::simulation_setup;
+using namespace tudat::gravitation;
+using namespace tudat::basic_astrodynamics;
+using namespace tudat::simulation_setup;
+
+std::pair< Eigen::MatrixXd, Eigen::MatrixXd > generateCosineSineCoefficients(
+        const int maximumDegree, const int maximumOrder, const int bodyIndex )
+{
+    Eigen::MatrixXd cosineCoefficients = Eigen::MatrixXd::Zero( maximumDegree + 1, maximumOrder + 1 );
+    Eigen::MatrixXd sineCoefficients = Eigen::MatrixXd::Zero( maximumDegree + 1, maximumOrder + 1 );
+
+    cosineCoefficients( 0, 0 ) = 1.0;
+
+    basic_mathematics::GlobalRandomNumberGeneratorType randomNumberGenerator(
+                static_cast< unsigned int >( bodyIndex ) );
+    boost::uniform_01< boost::mt19937> distribution( randomNumberGenerator );
+
+    for( int i = 1; i < maximumDegree + 1; i++ )
+    {
+        for( int j = 0; ( j < maximumOrder + 1 ) && ( j <= i ); j++ )
+        {
+            cosineCoefficients( i, j ) = ( ( distribution( ) > 0.5 ) ? ( 1.0 ): ( -1.0 ) ) * distribution( ) * 1.0E-6;
+            if( j > 0 )
+            {
+                sineCoefficients( i, j ) =  ( ( distribution( ) > 0.5 ) ? ( 1.0 ): ( -1.0 ) ) * distribution( ) * 1.0E-6;
+            }
+
+        }
+    }
+
+    return std::make_pair( cosineCoefficients, sineCoefficients );
+}
+
+boost::shared_ptr< tudat::simulation_setup::GravityFieldSettings > getDummyJovianSystemGravityField(
+        const std::string& bodyName )
+{
+    boost::shared_ptr< GravityFieldSettings > gravityFieldSettings;
+
+    std::vector< double > randomNumberSettings;
+    randomNumberSettings.push_back( 0.0 );
+    randomNumberSettings.push_back( 1.0E-4 );
+
+    std::pair< Eigen::MatrixXd, Eigen::MatrixXd > coefficients;
+
+    if( bodyName == "Jupiter" )
+    {
+        //boost::shared_ptr< RandomVariableGenerator< double > > randomCoefficientGenerator = createBoostContinuousRandomVariableGenerator(
+        //            normal, randomNumberSettings , 0.0 );
+        coefficients = generateCosineSineCoefficients( 10, 10, 0 );
+
+        gravityFieldSettings = boost::make_shared< SphericalHarmonicsGravityFieldSettings >
+                ( getBodyGravitationalParameter( "Jupiter" ), getAverageRadius( "Jupiter" ),
+                  coefficients.first, coefficients.second, "IAU_Jupiter" );
+    }
+    else if( bodyName == "Io" )
+    {
+        coefficients = generateCosineSineCoefficients( 10, 10, 1 );
+
+        gravityFieldSettings = boost::make_shared< SphericalHarmonicsGravityFieldSettings >
+                ( 5.959916033410404E012, getAverageRadius( "Io" ),
+                  coefficients.first, coefficients.second, "IAU_Io" );
+    }
+    else if( bodyName == "Europa" )
+    {
+        coefficients = generateCosineSineCoefficients( 10, 10, 2 );
+
+        gravityFieldSettings = boost::make_shared< SphericalHarmonicsGravityFieldSettings >
+                ( 3.202738774922892E12, getAverageRadius( "Europa" ),
+                  coefficients.first, coefficients.second, "IAU_Europa" );
+    }
+
+    return gravityFieldSettings;
+
+}
+
+
+BOOST_AUTO_TEST_SUITE( test_mutual_spherical_harmonic_gravity )
+
+BOOST_AUTO_TEST_CASE( testMutualSphericalHarmonicGravity )
+{
+    // Load spice kernels.
+    std::string kernelsPath = input_output::getSpiceKernelPath( );
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de-403-masses.tpc");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "naif0009.tls");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "pck00009.tpc");
+    //spice_interface::loadSpiceKernelInTudat( kernelsPath + "jup230l.bsp");
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de421.bsp");
+
+    // Create list of bodies to create.
+    std::vector< std::string > bodyNames;
+    bodyNames.push_back( "Jupiter" );
+    bodyNames.push_back( "Io" );
+    bodyNames.push_back( "Europa" );
+    bodyNames.push_back( "Sun" );
+
+    // Specify initial time
+    double initialTime = 1.0E7;
+    double finalTime = 1.2E7;
+
+    // Get body settings.
+    std::map< std::string, boost::shared_ptr< BodySettings > > bodySettings =
+            getDefaultBodySettings( bodyNames, initialTime, finalTime );
+    bodySettings[ "Jupiter" ]->gravityFieldSettings = getDummyJovianSystemGravityField( "Jupiter" );
+    bodySettings[ "Io" ]->gravityFieldSettings = getDummyJovianSystemGravityField( "Io" );
+    bodySettings[ "Europa" ]->gravityFieldSettings = getDummyJovianSystemGravityField( "Europa" );
+
+    bodySettings[ "Jupiter" ]->ephemerisSettings = boost::make_shared< KeplerEphemerisSettings >(
+                ( basic_mathematics::Vector6d( )<< 778.57E9, 0.0489, 1.3 / 60.0, 0.0, 0.0, 0.0 ).finished( ), 0.0,
+                  getBodyGravitationalParameter( "Sun" ), "Sun", "ECLIPJ2000" );
+    bodySettings[ "Io" ]->ephemerisSettings = boost::make_shared< KeplerEphemerisSettings >(
+                ( basic_mathematics::Vector6d( )<< 421.8E6, 0.004, 0.04 / 60.0, 0.0, 0.0, 0.0 ).finished( ), 0.0,
+                  getBodyGravitationalParameter( "Jupiter" ), "Sun", "ECLIPJ2000" );
+    bodySettings[ "Europa" ]->ephemerisSettings = boost::make_shared< KeplerEphemerisSettings >(
+                ( basic_mathematics::Vector6d( )<< 671.1E6, 0.009, 0.47 / 60.0, 0.0, 0.0, 0.0 ).finished( ), 0.0,
+                  getBodyGravitationalParameter( "Jupiter" ), "Sun", "ECLIPJ2000" );
+
+
+    // Create bodies needed in simulation
+    NamedBodyMap bodyMap = createBodies( bodySettings );
+    setGlobalFrameBodyEphemerides( bodyMap, "SSB", "ECLIPJ2000" );
+
+    // Set current state and rotation of bodies.
+    double currentTime = 1.1E7;
+    bodyMap[ "Jupiter" ]->setCurrentRotationToLocalFrameFromEphemeris( currentTime );
+    bodyMap[ "Jupiter" ]->setStateFromEphemeris( currentTime );
+    bodyMap[ "Io" ]->setCurrentRotationToLocalFrameFromEphemeris( currentTime );
+    bodyMap[ "Io" ]->setStateFromEphemeris( currentTime );
+    bodyMap[ "Europa" ]->setCurrentRotationToLocalFrameFromEphemeris( currentTime );
+    bodyMap[ "Europa" ]->setStateFromEphemeris( currentTime );
+
+    // Retrieve gravity fields.
+    boost::shared_ptr< SphericalHarmonicsGravityField > jupiterGravityField = boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >(
+                ( bodyMap.at( "Jupiter" ) )->getGravityFieldModel( ) );
+    boost::shared_ptr< SphericalHarmonicsGravityField > ioGravityField = boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >(
+                ( bodyMap.at( "Io" ) )->getGravityFieldModel( ) );
+    boost::shared_ptr< SphericalHarmonicsGravityField > europaGravityField = boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >(
+                ( bodyMap.at( "Europa" ) )->getGravityFieldModel( ) );
+
+    // Create central gravity acceleration (mu = Io + Jupiter)
+    boost::shared_ptr< AccelerationSettings > centralGravitySettings = boost::make_shared< AccelerationSettings >( central_gravity );
+    boost::shared_ptr< CentralGravitationalAccelerationModel3d > centralGravity =
+            boost::dynamic_pointer_cast< CentralGravitationalAccelerationModel3d >(
+                createAccelerationModel( bodyMap.at( "Io" ), bodyMap.at( "Jupiter" ), centralGravitySettings, "Io", "Jupiter",
+                                         bodyMap.at( "Jupiter" ), "Jupiter" ) );
+
+    // Calculate central gravity acceleration.
+    centralGravity->updateMembers( );
+    Eigen::Vector3d centralGravityAcceleration = centralGravity->getAcceleration( );
+
+    // Create spherical harmonic gravity of Jupiter on Io, Jupiter-fixed (mu = Io + Jupiter)
+    boost::shared_ptr< AccelerationSettings > sphericalHarmonicGravityOnIoFromJupiterSettings =
+            boost::make_shared< SphericalHarmonicAccelerationSettings >( 5, 5 );
+    boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModelXd > sphericalHarmonicGravityOnIoFromJupiter =
+            boost::dynamic_pointer_cast< SphericalHarmonicsGravitationalAccelerationModelXd >(
+                createAccelerationModel(  bodyMap.at( "Io" ), bodyMap.at( "Jupiter" ), sphericalHarmonicGravityOnIoFromJupiterSettings,
+                                          "Io", "Jupiter", bodyMap.at( "Jupiter" ), "Jupiter" ) );
+
+    // Calculate spherical harmonic gravity of Jupiter on Io.
+    sphericalHarmonicGravityOnIoFromJupiter->updateMembers( );
+    Eigen::Vector3d sphericalHarmonicGravityOnIoFromJupiterAcceleration = sphericalHarmonicGravityOnIoFromJupiter->getAcceleration( );
+
+    // Create spherical harmonic gravity of Io on Jupiter, Io-fixed (mu = Io + Jupiter)
+    boost::shared_ptr< AccelerationSettings > sphericalHarmonicGravityOnJupiterFromIoSettings =
+            boost::make_shared< SphericalHarmonicAccelerationSettings >( 5, 5 );
+    boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModelXd > sphericalHarmonicGravityOnJupiterFromIo =
+            boost::dynamic_pointer_cast< SphericalHarmonicsGravitationalAccelerationModelXd >(
+                createAccelerationModel( bodyMap.at( "Jupiter" ), bodyMap.at( "Io" ), sphericalHarmonicGravityOnJupiterFromIoSettings,
+                                         "Jupiter", "Io", bodyMap.at( "Io" ), "Io" ) );
+
+    // Calculate spherical harmonic gravity of Io on Jupiter.
+    sphericalHarmonicGravityOnJupiterFromIo->updateMembers( );
+    Eigen::Vector3d sphericalHarmonicGravityOnJupiterFromIoAcceleration = sphericalHarmonicGravityOnJupiterFromIo->getAcceleration( );
+
+    // Create mutual spherical harmonic gravity between Io and Jupiter on Io, Jupiter fixed (mu = Io + Jupiter)
+    boost::shared_ptr< AccelerationSettings > mutualDirectJupiterIoShGravitySettings =
+            boost::make_shared< MutualSphericalHarmonicAccelerationSettings >( 5, 5, 5, 5 );
+    boost::shared_ptr< MutualSphericalHarmonicsGravitationalAccelerationModelXd > mutualDirectJupiterIoShGravity =
+            boost::dynamic_pointer_cast< MutualSphericalHarmonicsGravitationalAccelerationModelXd >(
+                createAccelerationModel( bodyMap.at( "Io" ), bodyMap.at( "Jupiter" ), mutualDirectJupiterIoShGravitySettings,
+                                         "Io", "Jupiter", bodyMap.at( "Jupiter" ), "Jupiter" ) );
+
+    // Calculate mutual spherical harmonic gravity between Io and Jupiter on Io.
+    mutualDirectJupiterIoShGravity->updateMembers( );
+    Eigen::Vector3d mutualDirectJupiterIoShGravityAcceleration = mutualDirectJupiterIoShGravity->getAcceleration( );
+
+    // Calculate expected mutual spherical harmonic gravity from sub-accelerations.
+    Eigen::Vector3d expectedAcceleration = -centralGravityAcceleration + sphericalHarmonicGravityOnIoFromJupiterAcceleration -
+            sphericalHarmonicGravityOnJupiterFromIoAcceleration;
+
+    // Test against directly calculated mutual spherical harmonic gravity.
+    for( unsigned int i = 0; i < 3; i++ )
+    {
+        BOOST_CHECK_SMALL( std::fabs( expectedAcceleration( i ) - mutualDirectJupiterIoShGravityAcceleration( i ) ),
+                           8.0 * std::numeric_limits< double >::epsilon( ) );
+    }
+
+    // Create mutual spherical harmonic gravity between Io and Jupiter on Jupiter, Io fixed (mu = Io + Jupiter)
+    boost::shared_ptr< AccelerationSettings > mutualDirectJupiterIoShGravitySettings2 =
+            boost::make_shared< MutualSphericalHarmonicAccelerationSettings >( 5, 5, 5, 5 );
+    boost::shared_ptr< MutualSphericalHarmonicsGravitationalAccelerationModelXd > mutualDirectJupiterIoShGravity2 =
+            boost::dynamic_pointer_cast< MutualSphericalHarmonicsGravitationalAccelerationModelXd >(
+                createAccelerationModel( bodyMap.at( "Jupiter" ), bodyMap.at( "Io" ), mutualDirectJupiterIoShGravitySettings2,
+                                         "Jupiter", "Io", bodyMap.at( "Io" ), "Io" ) );
+
+    // Calculate mutual spherical harmonic gravity between Io and Jupiter on Jupiter.
+    mutualDirectJupiterIoShGravity2->updateMembers( );
+    Eigen::Vector3d mutualDirectJupiterIoShGravityAcceleration2 = mutualDirectJupiterIoShGravity2->getAcceleration( );
+
+    expectedAcceleration = centralGravityAcceleration - sphericalHarmonicGravityOnIoFromJupiterAcceleration + sphericalHarmonicGravityOnJupiterFromIoAcceleration;
+
+
+    // Test against directly calculated mutual spherical harmonic gravity.
+    for( unsigned int i = 0; i < 3; i++ )
+    {
+        BOOST_CHECK_SMALL( std::fabs( expectedAcceleration( i ) - mutualDirectJupiterIoShGravityAcceleration2( i ) ),
+                           8.0 * std::numeric_limits< double >::epsilon( ) );
+    }
+
+    // Test against directly calculated mutual spherical harmonic gravity.
+    for( unsigned int i = 0; i < 3; i++ )
+    {
+        BOOST_CHECK_SMALL( std::fabs( mutualDirectJupiterIoShGravityAcceleration( i ) + mutualDirectJupiterIoShGravityAcceleration2( i ) ),
+                           10.0 * std::numeric_limits< double >::epsilon( ) );
+    }
+
+    // Create 3rd body mutual spherical harmonics between Io and Europa on Europa, Jupiter fixed (mu = Io)
+    boost::shared_ptr< AccelerationSettings > mutualThirdBodyIoOnEuropaShGravitySettings =
+            boost::make_shared< MutualSphericalHarmonicAccelerationSettings >( 5, 5, 5, 5, 5, 5 );
+    boost::shared_ptr< ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel > mutualThirdBodyIoOnEuropaShGravity =
+            boost::dynamic_pointer_cast< ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel >(
+                createAccelerationModel( bodyMap.at( "Europa" ), bodyMap.at( "Io" ), mutualThirdBodyIoOnEuropaShGravitySettings,
+                                         "Europa", "Io", bodyMap.at( "Jupiter" ), "Jupiter" ) );
+
+    // Calculate 3rd body mutual spherical harmonics between Io and Europa on Europa.
+    mutualThirdBodyIoOnEuropaShGravity->updateMembers( );
+    Eigen::Vector3d mutualThirdBodyIoOnEuropaShGravityAcceleration = mutualThirdBodyIoOnEuropaShGravity->getAcceleration( );
+
+
+    // Create mutual spherical harmonics between Io and Europa on Europa, Io fixed (mu = Io + Europa)
+    boost::shared_ptr< MutualSphericalHarmonicsGravitationalAccelerationModelXd > mutualDirectIoOnEuropaShGravity =
+            boost::dynamic_pointer_cast< MutualSphericalHarmonicsGravitationalAccelerationModelXd >(
+                createAccelerationModel( bodyMap.at( "Europa" ), bodyMap.at( "Io" ), mutualThirdBodyIoOnEuropaShGravitySettings,
+                                         "Europa", "Io", bodyMap.at( "Io" ), "Io" ) );
+    mutualDirectIoOnEuropaShGravity->updateMembers( );
+    Eigen::Vector3d mutualDirectIoOnEuropaShGravityAcceleration = mutualDirectIoOnEuropaShGravity->getAcceleration( );
+
+    // Get sub accelerations from 3rd body acceleration.
+    Eigen::Vector3d directAccelerationFromThirdBodyModel = mutualThirdBodyIoOnEuropaShGravity->getAccelerationModelForBodyUndergoingAcceleration( )->getAcceleration( );
+    Eigen::Vector3d centralBodyAccelerationFromThirdBodyModel = mutualThirdBodyIoOnEuropaShGravity->getAccelerationModelForCentralBody( )->
+            getAcceleration( );
+
+
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( directAccelerationFromThirdBodyModel,
+                                       ( ioGravityField->getGravitationalParameter( ) / ( ioGravityField->getGravitationalParameter( ) +
+                                                                                        europaGravityField->getGravitationalParameter( ) ) *
+                                       mutualDirectIoOnEuropaShGravityAcceleration ), ( 8.0 * std::numeric_limits< double >::epsilon( ) ) );
+
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( centralBodyAccelerationFromThirdBodyModel,
+                                       ( ioGravityField->getGravitationalParameter( ) / ( ioGravityField->getGravitationalParameter( ) +
+                                                                                        jupiterGravityField->getGravitationalParameter( ) ) *
+                                       mutualDirectJupiterIoShGravityAcceleration2 ), ( 8.0 * std::numeric_limits< double >::epsilon( ) ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( mutualThirdBodyIoOnEuropaShGravityAcceleration,
+                                       ( directAccelerationFromThirdBodyModel - centralBodyAccelerationFromThirdBodyModel ),
+                                       ( std::numeric_limits< double >::epsilon( ) ) );
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+}
+
+}
diff --git a/Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.cpp b/Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.cpp
new file mode 100644
index 0000000..8787085
--- /dev/null
+++ b/Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.cpp
@@ -0,0 +1,18 @@
+#include "Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.h"
+
+namespace tudat
+{
+
+namespace gravitation
+{
+
+Eigen::MatrixXd setDegreeAndOrderCoefficientToZero( const boost::function< Eigen::MatrixXd( ) > originalCosineCoefficientFunction )
+{
+    Eigen::MatrixXd newCoefficients = originalCosineCoefficientFunction( );
+    newCoefficients( 0, 0 ) = 0.0;
+    return newCoefficients;
+}
+
+}
+
+}
diff --git a/Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.h b/Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.h
new file mode 100644
index 0000000..055b3e2
--- /dev/null
+++ b/Tudat/Astrodynamics/Gravitation/mutualSphericalHarmonicGravityModel.h
@@ -0,0 +1,244 @@
+#ifndef MUTUALSPHERICALHARMONICGRAVITYMODEL_H
+#define MUTUALSPHERICALHARMONICGRAVITYMODEL_H
+
+
+#include <boost/function.hpp>
+#include <boost/lambda/lambda.hpp>
+#include <boost/shared_ptr.hpp>
+#include <boost/bind.hpp>
+#include <boost/make_shared.hpp>
+
+#include <Eigen/Core>
+#include <Eigen/Geometry>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
+#include "Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModelBase.h"
+#include "Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h"
+#include "Tudat/Astrodynamics/Gravitation/thirdBodyPerturbation.h"
+#include "Tudat/Mathematics/BasicMathematics/legendrePolynomials.h"
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+
+namespace tudat
+{
+
+namespace gravitation
+{
+
+//! Function to manually remove the C(0,0) term from cosine coefficients,
+/*!
+ *  Function to manually remove the C(0,0) term from cosine coefficients, used by MutualSphericalHarmonicsGravitationalAccelerationModel.
+ *  By using this function, the original function returning the sh coefficients is left untouched, not compromising the environment
+ *  model, while the C(0,0) term is not calculated doubly by the MutualSphericalHarmonicsGravitationalAccelerationModel class.
+ */
+Eigen::MatrixXd setDegreeAndOrderCoefficientToZero( const boost::function< Eigen::MatrixXd( ) > originalCosineCoefficientFunction );
+
+//! Class to calculate the mutual spherical harmonic gravitational acceleration between two bodies.
+/*!
+ *  Class to calculate the mutual spherical harmonic gravitational acceleration between two extended bodies A and B. The calculations include
+ *  the interaction of the point masses A and B, extended body A and point mass B, as well as extended bodyB and point mass A.
+ *  As an example, the model can be used for precise calculations of the dynamics of planetary system (Earth-Moon, Mars-Phoboss-Deimos,
+ *  Jupiter-Galilean satellites). Model is taken from Lainey et al. (2001)
+ *  \tparam CoefficientMatrixType Type of spherical harmonic coeficient container.
+ */
+template< typename CoefficientMatrixType = Eigen::MatrixXd >
+class MutualSphericalHarmonicsGravitationalAccelerationModel
+        : public basic_astrodynamics::AccelerationModel< Eigen::Vector3d >
+{
+private:
+
+    //! Typedef for coefficient-matrix-returning function.
+    typedef boost::function< CoefficientMatrixType( ) > CoefficientMatrixReturningFunction;
+
+    //! Typedef for function returning body position.
+    typedef boost::function< Eigen::Vector3d( ) > StateFunction;
+
+    //! Typedef for function returning gravitational parameter.
+    typedef boost::function< double( ) > DataReturningFunction;
+
+public:
+
+    //! Constructor.
+    /*!
+     *  Constructor, provides the position functions of the involved bodies, and the required data on their gravitational fields.
+     *  \param positionOfBodySubjectToAccelerationFunction Function returning the current position of the body undergoing the acceleration.
+     *  \param positionOfBodyExertingAccelerationFunction Function returning the current position of the body exerting the acceleration.
+     *  \param gravitationalParameterFunction Function returning the current gravitational parameter, either of the body exerting the
+     *  acceleration or the sum of that of both bodies, depending on value of useCentralBodyFixedFrame, (false for former, true for latter).
+     *  \param equatorialRadiusOfBodyExertingAcceleration Equatorial radius used in representation of spherical harmonic coefficients of
+     *  body exerting acceleration.
+     *  \param equatorialRadiusOfBodyUndergoingAcceleration Equatorial radius used in representation of spherical harmonic coefficients of
+     *  body undergoing acceleration.
+     *  \param cosineHarmonicCoefficientsFunctionOfBodyExertingAcceleration Function returning the spherical harmonic cosine coefficients of
+     *  the body exerting the acceleration.
+     *  \param sineHarmonicCoefficientsFunctionOfBodyExertingAcceleration Function returning the spherical harmonic sine coefficients of
+     *  the body exerting the acceleration.
+     *  \param cosineHarmonicCoefficientsFunctionOfBodyUndergoingAcceleration Function returning the spherical harmonic cosine coefficients of
+     *  the body undergoing the acceleration.
+     *  \param toLocalFrameOfBodyExertingAccelerationTransformation Function returning the quaternion to rotate from the body-fixed frame of
+     *  the body exerting the acceleration, in  which the spherical harmonic coefficients are defined, to the inertially oriented frame, in which the
+     *  acceleration is expressed.
+     *  \param toLocalFrameOfBodyUndergoingAccelerationTransformation Function returning the quaternion to rotate from the body-fixed frame of
+     *  the body undergoing the acceleration, in  which the spherical harmonic coefficients are defined, to the inertially oriented frame, in which the
+     *  acceleration is expressed.
+     *  \param useCentralBodyFixedFrame Boolean denoting whether the acceleration is expressed in a frame centered on the body exerting the
+     *  acceleration, in which case the gravitational parameter that is used is the some of the gravitational parameters of both bodies, to take into
+     *  account the inertial acceleration of the reference frame in which the acceleration is performed.
+     */
+    MutualSphericalHarmonicsGravitationalAccelerationModel(
+            const StateFunction& positionOfBodySubjectToAccelerationFunction,
+            const StateFunction& positionOfBodyExertingAccelerationFunction,
+            const DataReturningFunction& gravitationalParameterFunction,
+            const double equatorialRadiusOfBodyExertingAcceleration,
+            const double equatorialRadiusOfBodyUndergoingAcceleration,
+            const CoefficientMatrixReturningFunction& cosineHarmonicCoefficientsFunctionOfBodyExertingAcceleration,
+            const CoefficientMatrixReturningFunction& sineHarmonicCoefficientsFunctionOfBodyExertingAcceleration,
+            const CoefficientMatrixReturningFunction& cosineHarmonicCoefficientsFunctionOfBodyUndergoingAcceleration,
+            const CoefficientMatrixReturningFunction& sineHarmonicCoefficientsFunctionOfBodyUndergoingAcceleration,
+            const boost::function< Eigen::Quaterniond( ) >& toLocalFrameOfBodyExertingAccelerationTransformation,
+            const boost::function< Eigen::Quaterniond( ) >& toLocalFrameOfBodyUndergoingAccelerationTransformation,
+            const bool useCentralBodyFixedFrame,
+            boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache > sphericalHarmonicsCacheOfBodyExertingAcceleration =
+            boost::make_shared< basic_mathematics::SphericalHarmonicsCache >( ),
+            boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache > sphericalHarmonicsCacheOfBodyUndergoingAcceleration =
+            boost::make_shared< basic_mathematics::SphericalHarmonicsCache >( ) ):
+        useCentralBodyFixedFrame_( useCentralBodyFixedFrame ),
+        gravitationalParameterFunction_( gravitationalParameterFunction )
+    {
+
+        // Create spherical harmonic acceleration due to expansion of body exerting acceleration
+        accelerationModelFromShExpansionOfBodyExertingAcceleration_ = boost::make_shared<
+                SphericalHarmonicsGravitationalAccelerationModel< CoefficientMatrixType > >(
+                    positionOfBodySubjectToAccelerationFunction, gravitationalParameterFunction, equatorialRadiusOfBodyExertingAcceleration,
+                    cosineHarmonicCoefficientsFunctionOfBodyExertingAcceleration, sineHarmonicCoefficientsFunctionOfBodyExertingAcceleration,
+                    positionOfBodyExertingAccelerationFunction, toLocalFrameOfBodyExertingAccelerationTransformation,
+                    useCentralBodyFixedFrame, sphericalHarmonicsCacheOfBodyExertingAcceleration );
+
+        // Create spherical harmonic acceleration due to expansion of body undergoing acceleration, with the C(0,0) term set to zero to
+        // prevent the double computation of the central term. Note that the order of the position functions is switched wrt the regular input,
+        // to ensure that the acceleration vector points in the right direction (i.e. from body undergoing to body exerting acceleration).
+        accelerationModelFromShExpansionOfBodyundergoingAcceleration_ = boost::make_shared<
+                SphericalHarmonicsGravitationalAccelerationModel< CoefficientMatrixType > >(
+                    positionOfBodyExertingAccelerationFunction, gravitationalParameterFunction, equatorialRadiusOfBodyUndergoingAcceleration,
+                    boost::bind( &setDegreeAndOrderCoefficientToZero, cosineHarmonicCoefficientsFunctionOfBodyUndergoingAcceleration ),
+                    sineHarmonicCoefficientsFunctionOfBodyUndergoingAcceleration,
+                    positionOfBodySubjectToAccelerationFunction, toLocalFrameOfBodyUndergoingAccelerationTransformation,
+                    useCentralBodyFixedFrame, sphericalHarmonicsCacheOfBodyUndergoingAcceleration );
+    }
+
+    MutualSphericalHarmonicsGravitationalAccelerationModel(
+            const boost::shared_ptr< MutualSphericalHarmonicsGravitationalAccelerationModel > originalAccelerationModel ):
+        accelerationModelFromShExpansionOfBodyExertingAcceleration_(
+            originalAccelerationModel->getAccelerationModelFromShExpansionOfBodyExertingAcceleration( ) ),
+        accelerationModelFromShExpansionOfBodyundergoingAcceleration_(
+            originalAccelerationModel->getAccelerationModelFromShExpansionOfBodyUndergoingAcceleration( ) ),
+        useCentralBodyFixedFrame_( originalAccelerationModel->getUseCentralBodyFixedFrame( ) ),
+        gravitationalParameterFunction_( originalAccelerationModel->getGravitationalParameterFunction( ) )
+    {
+
+    }
+
+    //! Update member variables used by the acceleration model.
+    /*!
+     *  Update member variables used by the two constituent sh acceleration models.
+     */
+    virtual void updateMembers( const double currentTime = TUDAT_NAN )
+    {
+        accelerationModelFromShExpansionOfBodyExertingAcceleration_->updateMembers( currentTime );
+        accelerationModelFromShExpansionOfBodyundergoingAcceleration_->updateMembers( currentTime );
+        this->currentTime_ = currentTime;
+    }
+
+    virtual void resetTime( const double currentTime = TUDAT_NAN )
+    {
+        currentTime_ = currentTime;
+
+        accelerationModelFromShExpansionOfBodyExertingAcceleration_->resetTime( currentTime );
+        accelerationModelFromShExpansionOfBodyundergoingAcceleration_->resetTime( currentTime );
+    }
+
+    //! Function to get the mutual sh acceleration value.
+    /*!
+     *  Function to get the mutual sh acceleration value, determined from the sum of the two constituent sh acceleration models.
+     */
+    Eigen::Vector3d getAcceleration( )
+    {
+        return accelerationModelFromShExpansionOfBodyExertingAcceleration_->getAcceleration( ) -
+                accelerationModelFromShExpansionOfBodyundergoingAcceleration_->getAcceleration( );
+    }
+
+    //! Function returning whether the acceleration is expressed in a frame centered on the body exerting the acceleration.
+    /*!
+     *  Function returning whether the acceleration is expressed in a frame centered on the body exerting the acceleration.
+     */
+    bool getUseCentralBodyFixedFrame( )
+    {
+        return useCentralBodyFixedFrame_;
+    }
+
+    DataReturningFunction getGravitationalParameterFunction( )
+    {
+        return gravitationalParameterFunction_;
+    }
+
+    //! Function returning the object calculating spherical harmonic acceleration due to the body exerting acceleration
+    /*!
+     *  Function returning the object calculating spherical harmonic acceleration due to the body exerting acceleration
+     */
+    boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModel< CoefficientMatrixType > >
+    getAccelerationModelFromShExpansionOfBodyExertingAcceleration( )
+    {
+        return accelerationModelFromShExpansionOfBodyExertingAcceleration_;
+    }
+
+    //! Function returning the object calculating spherical harmonic acceleration due to the body undergoing acceleration
+    /*!
+     *  Function returning the object calculating spherical harmonic acceleration due to the body undergoing acceleration
+     */
+    boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModel< CoefficientMatrixType > >
+    getAccelerationModelFromShExpansionOfBodyUndergoingAcceleration( )
+    {
+        return accelerationModelFromShExpansionOfBodyundergoingAcceleration_;
+    }
+
+protected:
+
+    //! Boolean denoting whether the acceleration is expressed in a frame centered on the body exerting the acceleration
+    /*!
+     *  Boolean denoting whether the acceleration is expressed in a frame centered on the body exerting the acceleration, in which case the
+     *  gravitational parameter that is used is the some of the gravitational parameters of both bodies, to take into
+     *  account the inertial acceleration of the reference frame in which the acceleration is performed.
+     */
+    bool useCentralBodyFixedFrame_;
+
+    DataReturningFunction gravitationalParameterFunction_;
+
+    //! Object calculating spherical harmonic acceleration due to the body exerting acceleration
+    /*!
+     *  Object calculating spherical harmonic acceleration due to the body exerting acceleration
+     */
+    boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModel< CoefficientMatrixType > >
+    accelerationModelFromShExpansionOfBodyExertingAcceleration_;
+
+    //! Object calculating spherical harmonic acceleration due to the body undergoing acceleration
+    /*!
+     *  Object calculating spherical harmonic acceleration due to the body undergoing acceleration, as felt by the body undergoing the acceleration
+     *  due to the figure-point mass coupling between the body undergoing and the body exerting the acceleration. Note that this
+     *  acceleration has no central-central term (i.e. C(0,0) is set to zero), as this term is only calculated by
+     *  accelerationModelFromShExpansionOfBodyExertingAcceleration_.
+     */
+    boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModel< CoefficientMatrixType > >
+    accelerationModelFromShExpansionOfBodyundergoingAcceleration_;
+
+
+};
+
+typedef MutualSphericalHarmonicsGravitationalAccelerationModel< Eigen::MatrixXd > MutualSphericalHarmonicsGravitationalAccelerationModelXd;
+
+//! Typedef for third body mutual spherical harmonic gravity acceleration.
+typedef ThirdBodyAcceleration< MutualSphericalHarmonicsGravitationalAccelerationModelXd >
+ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel;
+}
+
+}
+
+#endif // MUTUALSPHERICALHARMONICGRAVITYMODEL_H
diff --git a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h
index 93c0eb0..266ed8c 100644
--- a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h
+++ b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h
@@ -292,7 +292,8 @@ public:
             rotationFromBodyFixedToIntegrationFrameFunction =
             boost::lambda::constant( Eigen::Quaterniond( Eigen::Matrix3d::Identity( ) ) ),
             const bool isMutualAttractionUsed = 0,
-            boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache > sphericalHarmonicsCache = boost::make_shared< basic_mathematics::SphericalHarmonicsCache >( ) )
+            boost::shared_ptr< basic_mathematics::SphericalHarmonicsCache > sphericalHarmonicsCache
+            = boost::make_shared< basic_mathematics::SphericalHarmonicsCache >( ) )
         : Base( positionOfBodySubjectToAccelerationFunction,
                 aGravitationalParameterFunction,
                 positionOfBodyExertingAccelerationFunction,
@@ -411,7 +412,6 @@ template< typename CoefficientMatrixType >
 Eigen::Vector3d SphericalHarmonicsGravitationalAccelerationModel< CoefficientMatrixType >
 ::getAcceleration( )
 {
-
     return rotationToIntegrationFrame_ *
             computeGeodesyNormalizedGravitationalAccelerationSum(
                 rotationToIntegrationFrame_.inverse( ) * (
diff --git a/Tudat/Basics/CMakeLists.txt b/Tudat/Basics/CMakeLists.txt
index 3f401b2..50c41a9 100644
--- a/Tudat/Basics/CMakeLists.txt
+++ b/Tudat/Basics/CMakeLists.txt
@@ -40,6 +40,7 @@ set(BASICSDIR_SOURCES
 
 # Add header files.
 set(BASICSDIR_HEADERS 
+  "${SRCROOT}${BASICSDIR}/utilities.h"
   "${SRCROOT}${BASICSDIR}/testMacros.h"
   "${SRCROOT}${BASICSDIR}/utilityMacros.h"
 )
diff --git a/Tudat/Basics/utilities.h b/Tudat/Basics/utilities.h
index ce41b79..52c1067 100644
--- a/Tudat/Basics/utilities.h
+++ b/Tudat/Basics/utilities.h
@@ -64,6 +64,12 @@ std::vector< KeyType > createVectorFromMapKeys( const std::map< KeyType, VectorA
     return outputVector;
 }
 
+template< typename S >
+S sumFunctionReturn( const boost::function< S( ) > function1, const boost::function< S( ) > function2 )
+{
+    return function1( ) + function2( );
+}
+
 template< typename S, typename T >
 void createVectorBlockMatrixHistory(
         const std::map< S, Eigen::Matrix< T, Eigen::Dynamic, Eigen::Dynamic > >& matrixHistory,
diff --git a/Tudat/SimulationSetup/accelerationSettings.h b/Tudat/SimulationSetup/accelerationSettings.h
index 731e360..1dbbdb6 100644
--- a/Tudat/SimulationSetup/accelerationSettings.h
+++ b/Tudat/SimulationSetup/accelerationSettings.h
@@ -83,6 +83,38 @@ public:
     int maximumOrder_;
 };
 
+//! Class for providing acceleration settings for mutual spherical harmonics acceleration model.
+/*!
+ *  Class for providing accelerationsettings for mutual spherical harmonics acceleration model, specifically the maximum degree and order up to which
+ *  the fields of the two bodies are be expanded. Please not that the minimum degrees and orders are currently always set to zero.
+ */
+class MutualSphericalHarmonicAccelerationSettings: public AccelerationSettings
+{
+public:
+
+    MutualSphericalHarmonicAccelerationSettings( const int maximumDegreeOfBodyExertingAcceleration,
+                                                 const int maximumOrderOfBodyExertingAcceleration,
+                                                 const int maximumDegreeOfBodyUndergoingAcceleration,
+                                                 const int maximumOrderOfBodyUndergoingAcceleration,
+                                                 const int maximumDegreeOfCentralBody = 0,
+                                                 const int maximumOrderOfCentralBody = 0 ):
+        AccelerationSettings( basic_astrodynamics::mutual_spherical_harmonic_gravity ),
+        maximumDegreeOfBodyExertingAcceleration_( maximumDegreeOfBodyExertingAcceleration ),
+        maximumOrderOfBodyExertingAcceleration_( maximumOrderOfBodyExertingAcceleration ),
+        maximumDegreeOfBodyUndergoingAcceleration_( maximumDegreeOfBodyUndergoingAcceleration ),
+        maximumOrderOfBodyUndergoingAcceleration_( maximumOrderOfBodyUndergoingAcceleration ),
+        maximumDegreeOfCentralBody_( maximumDegreeOfCentralBody ), maximumOrderOfCentralBody_( maximumOrderOfCentralBody ){ }
+
+    int maximumDegreeOfBodyExertingAcceleration_;
+    int maximumOrderOfBodyExertingAcceleration_;
+    int maximumDegreeOfBodyUndergoingAcceleration_;
+    int maximumOrderOfBodyUndergoingAcceleration_;
+
+    int maximumDegreeOfCentralBody_;
+    int maximumOrderOfCentralBody_;
+};
+
+
 //! Typedef defining a list of acceleration settings, set up in the same manner as the
 //! AccelerationMap typedef.
 typedef std::map< std::string, std::map< std::string, std::vector< boost::shared_ptr<
diff --git a/Tudat/SimulationSetup/createAccelerationModels.cpp b/Tudat/SimulationSetup/createAccelerationModels.cpp
index d1a3d78..5f8d9c2 100644
--- a/Tudat/SimulationSetup/createAccelerationModels.cpp
+++ b/Tudat/SimulationSetup/createAccelerationModels.cpp
@@ -18,6 +18,7 @@
 #include "Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.h"
 #include "Tudat/Astrodynamics/ReferenceFrames/aerodynamicAngleCalculator.h"
 #include "Tudat/Astrodynamics/ReferenceFrames/referenceFrameTransformations.h"
+#include "Tudat/Basics/utilities.h"
 #include "Tudat/SimulationSetup/accelerationSettings.h"
 #include "Tudat/SimulationSetup/createAccelerationModels.h"
 #include "Tudat/SimulationSetup/createFlightConditions.h"
@@ -34,12 +35,150 @@ using namespace basic_astrodynamics;
 using namespace electro_magnetism;
 using namespace ephemerides;
 
-//! Function to add to double-returning functions.
-double evaluateDoubleFunctions(
-        const boost::function< double( ) >& function1,
-        const boost::function< double( ) >& function2 )
+
+boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > createDirectGravitationalAcceleration(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings,
+        const std::string& nameOfCentralBody,
+        const bool isCentralBody )
+{
+    bool sumGravitationalParameters = 0;
+    if( ( nameOfCentralBody == nameOfBodyExertingAcceleration ) && bodyUndergoingAcceleration != NULL )
+    {
+        sumGravitationalParameters = 1;
+    }
+
+
+    boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > accelerationModel;
+       switch( accelerationSettings->accelerationType_ )
+        {
+        case central_gravity:
+            accelerationModel = createCentralGravityAcceleratioModel(
+                        bodyUndergoingAcceleration,
+                        bodyExertingAcceleration,
+                        nameOfBodyUndergoingAcceleration,
+                        nameOfBodyExertingAcceleration,
+                        sumGravitationalParameters );
+            break;
+        case spherical_harmonic_gravity:
+            accelerationModel = createSphericalHarmonicsGravityAcceleration(
+                        bodyUndergoingAcceleration,
+                        bodyExertingAcceleration,
+                        nameOfBodyUndergoingAcceleration,
+                        nameOfBodyExertingAcceleration,
+                        accelerationSettings,
+                        sumGravitationalParameters );
+            break;
+        case mutual_spherical_harmonic_gravity:
+            accelerationModel = createMutualSphericalHarmonicsGravityAcceleration(
+                        bodyUndergoingAcceleration,
+                        bodyExertingAcceleration,
+                        nameOfBodyUndergoingAcceleration,
+                        nameOfBodyExertingAcceleration,
+                        accelerationSettings,
+                        sumGravitationalParameters,
+                        isCentralBody );
+            break;
+        default:
+            std::cerr<<"Error when making gravitional acceleration model, cannot parse type "<<accelerationSettings->accelerationType_<<std::endl;
+        }
+    return accelerationModel;
+}
+
+boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > createThirdBodyGravitationalAcceleration(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const std::string& nameOfCentralBody,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings )
 {
-    return function1( ) + function2( );
+    boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > accelerationModel;
+    switch( accelerationSettings->accelerationType_ )
+    {
+    case central_gravity:
+        accelerationModel = boost::make_shared< ThirdBodyAcceleration< CentralGravitationalAccelerationModel3d > >(
+                    boost::dynamic_pointer_cast< CentralGravitationalAccelerationModel3d >(
+                        createDirectGravitationalAcceleration(
+                            bodyUndergoingAcceleration, bodyExertingAcceleration, nameOfBodyUndergoingAcceleration, nameOfBodyExertingAcceleration,
+                            accelerationSettings, "", 0 ) ),
+                    boost::dynamic_pointer_cast< CentralGravitationalAccelerationModel3d >(
+                        createDirectGravitationalAcceleration(
+                            centralBody, bodyExertingAcceleration, nameOfCentralBody, nameOfBodyExertingAcceleration,
+                            accelerationSettings, "", 1 ) ), nameOfCentralBody );
+        break;
+    case spherical_harmonic_gravity:
+        accelerationModel = boost::make_shared< ThirdBodyAcceleration< SphericalHarmonicsGravitationalAccelerationModelXd > >(
+                    boost::dynamic_pointer_cast< SphericalHarmonicsGravitationalAccelerationModelXd >(
+                        createDirectGravitationalAcceleration(
+                            bodyUndergoingAcceleration, bodyExertingAcceleration, nameOfBodyUndergoingAcceleration, nameOfBodyExertingAcceleration,
+                            accelerationSettings, "", 0 ) ),
+                    boost::dynamic_pointer_cast< SphericalHarmonicsGravitationalAccelerationModelXd >(
+                        createDirectGravitationalAcceleration(
+                            centralBody, bodyExertingAcceleration, nameOfCentralBody, nameOfBodyExertingAcceleration,
+                            accelerationSettings, "", 1 ) ), nameOfCentralBody );
+        break;
+    case mutual_spherical_harmonic_gravity:
+        accelerationModel = boost::make_shared< ThirdBodyAcceleration< MutualSphericalHarmonicsGravitationalAccelerationModelXd > >(
+                    boost::dynamic_pointer_cast< MutualSphericalHarmonicsGravitationalAccelerationModelXd >(
+                        createDirectGravitationalAcceleration(
+                            bodyUndergoingAcceleration, bodyExertingAcceleration, nameOfBodyUndergoingAcceleration, nameOfBodyExertingAcceleration,
+                            accelerationSettings, "", 0 ) ),
+                    boost::dynamic_pointer_cast< MutualSphericalHarmonicsGravitationalAccelerationModelXd >(
+                        createDirectGravitationalAcceleration(
+                            centralBody, bodyExertingAcceleration, nameOfCentralBody, nameOfBodyExertingAcceleration,
+                            accelerationSettings, "", 1 ) ), nameOfCentralBody );
+        break;
+    default:
+        std::cerr<<"Error when making third body gravitional acceleration model, cannot parse type "<<accelerationSettings->accelerationType_<<std::endl;
+    }
+    return accelerationModel;
+}
+
+
+boost::shared_ptr< AccelerationModel< Eigen::Vector3d > > createGravitationalAccelerationModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfCentralBody )
+{
+    //std::cout<<std::endl<<"Creating acceleration "<<nameOfBodyUndergoingAcceleration<<" "<<nameOfBodyExertingAcceleration<<" "<<nameOfCentralBody<<"========================================="<<std::endl;
+
+    boost::shared_ptr< AccelerationModel< Eigen::Vector3d > > accelerationModelPointer;
+    if( accelerationSettings->accelerationType_ != central_gravity &&
+            accelerationSettings->accelerationType_ != spherical_harmonic_gravity &&
+            accelerationSettings->accelerationType_ != mutual_spherical_harmonic_gravity )
+    {
+        std::cerr<<"Error when making gravitational acceleration, type is inconsistent"<<std::endl;
+    }
+
+    if( nameOfCentralBody == nameOfBodyExertingAcceleration || ephemerides::isFrameInertial( nameOfCentralBody ) )
+    {
+        accelerationModelPointer = createDirectGravitationalAcceleration( bodyUndergoingAcceleration,
+                                                                          bodyExertingAcceleration,
+                                                                          nameOfBodyUndergoingAcceleration,
+                                                                          nameOfBodyExertingAcceleration,
+                                                                          accelerationSettings,
+                                                                          nameOfCentralBody, false );
+    }
+    else
+    {
+        accelerationModelPointer = createThirdBodyGravitationalAcceleration( bodyUndergoingAcceleration,
+                                                                             bodyExertingAcceleration,
+                                                                             centralBody,
+                                                                             nameOfBodyUndergoingAcceleration,
+                                                                             nameOfBodyExertingAcceleration,
+                                                                             nameOfCentralBody, accelerationSettings );
+    }
+
+    return accelerationModelPointer;
 }
 
 
@@ -84,7 +223,7 @@ boost::shared_ptr< CentralGravitationalAccelerationModel3d > createCentralGravit
                     boost::bind( &gravitation::GravityFieldModel::getGravitationalParameter,
                                  bodyUndergoingAcceleration->getGravityFieldModel( ) );
             gravitationalParameterFunction =
-                    boost::bind( &evaluateDoubleFunctions,
+                    boost::bind( &utilities::sumFunctionReturn< double >,
                                  gravitationalParameterOfBodyExertingAcceleration,
                                  gravitationalParameterOfBodyUndergoingAcceleration );
         }
@@ -182,7 +321,7 @@ createSphericalHarmonicsGravityAcceleration(
                         boost::bind( &gravitation::GravityFieldModel::getGravitationalParameter,
                                      bodyUndergoingAcceleration->getGravityFieldModel( ) );
                 gravitationalParameterFunction =
-                        boost::bind( &evaluateDoubleFunctions,
+                        boost::bind( &utilities::sumFunctionReturn< double >,
                                      gravitationalParameterOfBodyExertingAcceleration,
                                      gravitationalParameterOfBodyUndergoingAcceleration );
             }
@@ -209,6 +348,116 @@ createSphericalHarmonicsGravityAcceleration(
     return accelerationModel;
 }
 
+boost::shared_ptr< gravitation::MutualSphericalHarmonicsGravitationalAccelerationModelXd > createMutualSphericalHarmonicsGravityAcceleration(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings,
+        const bool useCentralBodyFixedFrame,
+        const bool acceleratedBodyIsCentralBody )
+{
+    using namespace basic_astrodynamics;
+
+    // Declare pointer to return object
+    boost::shared_ptr< MutualSphericalHarmonicsGravitationalAccelerationModelXd > accelerationModel;
+
+    // Dynamic cast acceleration settings to required type and check consistency.
+    boost::shared_ptr< MutualSphericalHarmonicAccelerationSettings > mutualSphericalHarmonicsSettings =
+            boost::dynamic_pointer_cast< MutualSphericalHarmonicAccelerationSettings >( accelerationSettings );
+    if( mutualSphericalHarmonicsSettings == NULL )
+    {
+        std::cerr<<"Error, expected mutual spherical harmonics acceleration settings when making acceleration model on "<<
+                   nameOfBodyUndergoingAcceleration<<" due to "<<nameOfBodyExertingAcceleration<<std::endl;
+    }
+    else
+    {
+        // Get pointer to gravity field of central body and cast to required type.
+        boost::shared_ptr< SphericalHarmonicsGravityField > sphericalHarmonicsGravityFieldOfBodyExertingAcceleration =
+                boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >( bodyExertingAcceleration->getGravityFieldModel( ) );
+        boost::shared_ptr< SphericalHarmonicsGravityField > sphericalHarmonicsGravityFieldOfBodyUndergoingAcceleration =
+                boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >( bodyUndergoingAcceleration->getGravityFieldModel( ) );
+
+        if( sphericalHarmonicsGravityFieldOfBodyExertingAcceleration == NULL )
+        {
+            std::cerr<<"Error "<<nameOfBodyExertingAcceleration<<" does not have a spherical harmonics gravity field "<<
+                       "when making mutual spherical harmonics gravity acceleration on"<<nameOfBodyUndergoingAcceleration<<std::endl;
+        }
+        else if( sphericalHarmonicsGravityFieldOfBodyUndergoingAcceleration == NULL )
+        {
+            std::cerr<<"Error "<<nameOfBodyUndergoingAcceleration<<" does not have a spherical harmonics gravity field "<<
+                       "when making mutual spherical harmonics gravity acceleration on"<<nameOfBodyUndergoingAcceleration<<std::endl;
+        }
+        else
+        {
+            boost::function< double( ) > gravitationalParameterFunction;
+
+            // Create function returning summed gravitational parameter of the two bodies.
+            if( useCentralBodyFixedFrame == false )
+            {
+                gravitationalParameterFunction =
+                        boost::bind( &SphericalHarmonicsGravityField::getGravitationalParameter, sphericalHarmonicsGravityFieldOfBodyExertingAcceleration );
+            }
+            else
+            {
+                // Create function returning summed gravitational parameter of the two bodies.
+                boost::function< double( ) > gravitationalParameterOfBodyExertingAcceleration =
+                        boost::bind( &gravitation::GravityFieldModel::getGravitationalParameter,
+                                     sphericalHarmonicsGravityFieldOfBodyExertingAcceleration );
+                boost::function< double( ) > gravitationalParameterOfBodyUndergoingAcceleration =
+                        boost::bind( &gravitation::GravityFieldModel::getGravitationalParameter,
+                                     sphericalHarmonicsGravityFieldOfBodyUndergoingAcceleration );
+                gravitationalParameterFunction =
+                        boost::bind( &utilities::sumFunctionReturn< double >,
+                                     gravitationalParameterOfBodyExertingAcceleration, gravitationalParameterOfBodyUndergoingAcceleration );
+            }
+
+            // Create acceleration object.
+
+            int maximumDegreeOfUndergoingBody, maximumOrderOfUndergoingBody;
+            if( !acceleratedBodyIsCentralBody )
+            {
+                maximumDegreeOfUndergoingBody = mutualSphericalHarmonicsSettings->maximumDegreeOfBodyUndergoingAcceleration_;
+                maximumOrderOfUndergoingBody = mutualSphericalHarmonicsSettings->maximumOrderOfBodyUndergoingAcceleration_;
+            }
+            else
+            {
+                maximumDegreeOfUndergoingBody = mutualSphericalHarmonicsSettings->maximumDegreeOfCentralBody_;
+                maximumOrderOfUndergoingBody = mutualSphericalHarmonicsSettings->maximumOrderOfCentralBody_;
+            }
+
+            accelerationModel = boost::make_shared< MutualSphericalHarmonicsGravitationalAccelerationModelXd >(
+                        boost::bind( &Body::getPosition, bodyUndergoingAcceleration ),
+                        boost::bind( &Body::getPosition, bodyExertingAcceleration ),
+                        gravitationalParameterFunction,
+                        sphericalHarmonicsGravityFieldOfBodyExertingAcceleration->getReferenceRadius( ),
+                        sphericalHarmonicsGravityFieldOfBodyUndergoingAcceleration->getReferenceRadius( ),
+                        boost::bind( &SphericalHarmonicsGravityField::getCosineCoefficients,
+                                     sphericalHarmonicsGravityFieldOfBodyExertingAcceleration,
+                                     mutualSphericalHarmonicsSettings->maximumDegreeOfBodyExertingAcceleration_,
+                                     mutualSphericalHarmonicsSettings->maximumOrderOfBodyExertingAcceleration_ ),
+                        boost::bind( &SphericalHarmonicsGravityField::getSineCoefficients,
+                                     sphericalHarmonicsGravityFieldOfBodyExertingAcceleration,
+                                     mutualSphericalHarmonicsSettings->maximumDegreeOfBodyExertingAcceleration_,
+                                     mutualSphericalHarmonicsSettings->maximumOrderOfBodyExertingAcceleration_ ),
+                        boost::bind( &SphericalHarmonicsGravityField::getCosineCoefficients,
+                                     sphericalHarmonicsGravityFieldOfBodyUndergoingAcceleration,
+                                     maximumDegreeOfUndergoingBody,
+                                     maximumOrderOfUndergoingBody ),
+                        boost::bind( &SphericalHarmonicsGravityField::getSineCoefficients,
+                                     sphericalHarmonicsGravityFieldOfBodyUndergoingAcceleration,
+                                     maximumDegreeOfUndergoingBody,
+                                     maximumOrderOfUndergoingBody ),
+                        boost::bind( &Body::getCurrentRotationToGlobalFrame,
+                                     bodyExertingAcceleration ),
+                        boost::bind( &Body::getCurrentRotationToGlobalFrame,
+                                     bodyUndergoingAcceleration ),
+                        useCentralBodyFixedFrame );
+        }
+    }
+    return accelerationModel;
+}
+
 
 //! Function to create a third body central gravity acceleration model.
 boost::shared_ptr< gravitation::ThirdBodyCentralGravityAcceleration >
@@ -239,6 +488,123 @@ createThirdBodyCentralGravityAccelerationModel(
 }
 
 
+boost::shared_ptr< gravitation::ThirdBodySphericalHarmonicsGravitationalAccelerationModel > createThirdBodySphericalHarmonicGravityAccelerationModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const std::string& nameOfCentralBody,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings )
+{
+    using namespace basic_astrodynamics;
+
+    // Declare pointer to return object
+    boost::shared_ptr< ThirdBodySphericalHarmonicsGravitationalAccelerationModel > accelerationModel;
+
+    // Dynamic cast acceleration settings to required type and check consistency.
+    boost::shared_ptr< SphericalHarmonicAccelerationSettings > sphericalHarmonicsSettings =
+            boost::dynamic_pointer_cast< SphericalHarmonicAccelerationSettings >( accelerationSettings );
+    if( sphericalHarmonicsSettings == NULL )
+    {
+        std::cerr<<"Error, expected spherical harmonics acceleration settings when making acceleration model on "<<
+                   nameOfBodyUndergoingAcceleration<<" due to "<<nameOfBodyExertingAcceleration<<std::endl;
+    }
+    else
+    {
+        // Get pointer to gravity field of central body and cast to required type.
+        boost::shared_ptr< SphericalHarmonicsGravityField > sphericalHarmonicsGravityField =
+                boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >( bodyExertingAcceleration->getGravityFieldModel( ) );
+        if( sphericalHarmonicsGravityField == NULL )
+        {
+            std::cerr<<"Error "<<nameOfBodyExertingAcceleration<<" does not have a spherical harmonics gravity field "<<
+                       "when making third body spherical harmonics gravity acceleration on"<<nameOfBodyUndergoingAcceleration<<std::endl;
+        }
+        else
+        {
+
+            accelerationModel =  boost::make_shared< ThirdBodySphericalHarmonicsGravitationalAccelerationModel >(
+                        boost::dynamic_pointer_cast< SphericalHarmonicsGravitationalAccelerationModelXd >(
+                            createSphericalHarmonicsGravityAcceleration(
+                                bodyUndergoingAcceleration, bodyExertingAcceleration, nameOfBodyUndergoingAcceleration,
+                                nameOfBodyExertingAcceleration, sphericalHarmonicsSettings, 0 ) ),
+                        boost::dynamic_pointer_cast< SphericalHarmonicsGravitationalAccelerationModelXd >(
+                            createSphericalHarmonicsGravityAcceleration(
+                                centralBody, bodyExertingAcceleration, nameOfCentralBody,
+                                nameOfBodyExertingAcceleration, sphericalHarmonicsSettings, 0 ) ), nameOfCentralBody );
+        }
+    }
+    return accelerationModel;
+}
+
+boost::shared_ptr< gravitation::ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel > createThirdBodyMutualSphericalHarmonicGravityAccelerationModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const std::string& nameOfCentralBody,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings )
+{
+    // Declare pointer to return object
+    boost::shared_ptr< ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel > accelerationModel;
+
+    // Dynamic cast acceleration settings to required type and check consistency.
+    boost::shared_ptr< MutualSphericalHarmonicAccelerationSettings > mutualSphericalHarmonicsSettings =
+            boost::dynamic_pointer_cast< MutualSphericalHarmonicAccelerationSettings >( accelerationSettings );
+    if( mutualSphericalHarmonicsSettings == NULL )
+    {
+        std::cerr<<"Error, expected mutual spherical harmonics acceleration settings when making acceleration model on "<<
+                   nameOfBodyUndergoingAcceleration<<" due to "<<nameOfBodyExertingAcceleration<<std::endl;
+    }
+    else
+    {
+        // Get pointer to gravity field of central body and cast to required type.
+        boost::shared_ptr< SphericalHarmonicsGravityField > sphericalHarmonicsGravityFieldOfBodyExertingAcceleration =
+                boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >( bodyExertingAcceleration->getGravityFieldModel( ) );
+        boost::shared_ptr< SphericalHarmonicsGravityField > sphericalHarmonicsGravityFieldOfBodyUndergoingAcceleration =
+                boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >( bodyUndergoingAcceleration->getGravityFieldModel( ) );
+        boost::shared_ptr< SphericalHarmonicsGravityField > sphericalHarmonicsGravityFieldOfCentralBody =
+                boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >( centralBody->getGravityFieldModel( ) );
+
+        if( sphericalHarmonicsGravityFieldOfBodyExertingAcceleration == NULL )
+        {
+            std::cerr<<"Error "<<nameOfBodyExertingAcceleration<<" does not have a spherical harmonics gravity field "<<
+                       "when making mutual spherical harmonics gravity acceleration on"<<nameOfBodyUndergoingAcceleration<<std::endl;
+        }
+        else if( sphericalHarmonicsGravityFieldOfBodyUndergoingAcceleration == NULL )
+        {
+            std::cerr<<"Error "<<nameOfBodyUndergoingAcceleration<<" does not have a spherical harmonics gravity field "<<
+                       "when making mutual spherical harmonics gravity acceleration on"<<nameOfBodyUndergoingAcceleration<<std::endl;
+        }
+        else if( sphericalHarmonicsGravityFieldOfCentralBody == NULL )
+        {
+            std::cerr<<"Error "<<nameOfCentralBody<<" does not have a spherical harmonics gravity field "<<
+                       "when making mutual spherical harmonics gravity acceleration on"<<nameOfBodyUndergoingAcceleration<<std::endl;
+        }
+        else
+        {
+            boost::shared_ptr< MutualSphericalHarmonicAccelerationSettings > accelerationSettingsForCentralBodyAcceleration =
+                    boost::make_shared< MutualSphericalHarmonicAccelerationSettings >(
+                        mutualSphericalHarmonicsSettings->maximumDegreeOfBodyExertingAcceleration_,
+                        mutualSphericalHarmonicsSettings->maximumOrderOfBodyExertingAcceleration_,
+                        mutualSphericalHarmonicsSettings->maximumDegreeOfCentralBody_,
+                        mutualSphericalHarmonicsSettings->maximumOrderOfCentralBody_ );
+            accelerationModel =  boost::make_shared< ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel >(
+                        boost::dynamic_pointer_cast< MutualSphericalHarmonicsGravitationalAccelerationModelXd >(
+                            createMutualSphericalHarmonicsGravityAcceleration(
+                                bodyUndergoingAcceleration, bodyExertingAcceleration, nameOfBodyUndergoingAcceleration,
+                                nameOfBodyExertingAcceleration, mutualSphericalHarmonicsSettings, 0, 0 ) ),
+                        boost::dynamic_pointer_cast< MutualSphericalHarmonicsGravitationalAccelerationModelXd >(
+                            createMutualSphericalHarmonicsGravityAcceleration(
+                                centralBody, bodyExertingAcceleration, nameOfCentralBody,
+                                nameOfBodyExertingAcceleration, accelerationSettingsForCentralBodyAcceleration, 0, 1 ) ),
+                        nameOfCentralBody );
+        }
+    }
+    return accelerationModel;
+}
+
 //! Function to create an aerodynamic acceleration model.
 boost::shared_ptr< aerodynamics::AerodynamicAcceleration > createAerodynamicAcceleratioModel(
         const boost::shared_ptr< Body > bodyUndergoingAcceleration,
@@ -372,63 +738,22 @@ boost::shared_ptr< AccelerationModel< Eigen::Vector3d > > createAccelerationMode
     switch( accelerationSettings->accelerationType_ )
     {
     case central_gravity:
-        // Check if body is a single-body central gravity acceleration (use third-body if not)
-        if( nameOfCentralBody == nameOfBodyExertingAcceleration ||
-                isFrameInertial( nameOfCentralBody ) )
-        {
-            // Check if gravitational parameter to use is sum of gravitational paramater of the
-            // two bodies.
-            bool useCentralBodyFixedFrame = 0;
-            if( nameOfCentralBody == nameOfBodyExertingAcceleration )
-            {
-                useCentralBodyFixedFrame = 1;
-            }
-
-            accelerationModelPointer = createCentralGravityAcceleratioModel(
-                        bodyUndergoingAcceleration,
-                        bodyExertingAcceleration,
-                        nameOfBodyUndergoingAcceleration,
-                        nameOfBodyExertingAcceleration, useCentralBodyFixedFrame );
-        }
-        // Create third body central gravity acceleration
-        else
-        {
-
-            accelerationModelPointer = createThirdBodyCentralGravityAccelerationModel(
-                        bodyUndergoingAcceleration,
-                        bodyExertingAcceleration,
-                        centralBody,
-                        nameOfBodyUndergoingAcceleration,
-                        nameOfBodyExertingAcceleration,
-                        nameOfCentralBody );
-        }
+        accelerationModelPointer = createGravitationalAccelerationModel(
+                    bodyUndergoingAcceleration, bodyExertingAcceleration, accelerationSettings,
+                    nameOfBodyUndergoingAcceleration, nameOfBodyExertingAcceleration,
+                    centralBody, nameOfCentralBody );
         break;
     case spherical_harmonic_gravity:
-        if( nameOfCentralBody == nameOfBodyExertingAcceleration ||
-                isFrameInertial( nameOfCentralBody ) )
-        {
-            // Check if gravitational parameter to use is sum of gravitational paramater of the
-            // two bodies.
-            bool useCentralBodyFixedFrame = 0;
-            if( nameOfCentralBody == nameOfBodyExertingAcceleration )
-            {
-                useCentralBodyFixedFrame = 1;
-            }
-
-            accelerationModelPointer = createSphericalHarmonicsGravityAcceleration(
-                        bodyUndergoingAcceleration,
-                        bodyExertingAcceleration,
-                        nameOfBodyUndergoingAcceleration,
-                        nameOfBodyExertingAcceleration,
-                        accelerationSettings, useCentralBodyFixedFrame );
-
-        }
-        else
-        {
-            throw std::runtime_error(
-                        "Error, cannot yet make third body spherical harmonic acceleration." );
-
-        }
+        accelerationModelPointer = createGravitationalAccelerationModel(
+                    bodyUndergoingAcceleration, bodyExertingAcceleration, accelerationSettings,
+                    nameOfBodyUndergoingAcceleration, nameOfBodyExertingAcceleration,
+                    centralBody, nameOfCentralBody );
+        break;
+    case mutual_spherical_harmonic_gravity:
+        accelerationModelPointer = createGravitationalAccelerationModel(
+                    bodyUndergoingAcceleration, bodyExertingAcceleration, accelerationSettings,
+                    nameOfBodyUndergoingAcceleration, nameOfBodyExertingAcceleration,
+                    centralBody, nameOfCentralBody );
         break;
     case aerodynamic:
         accelerationModelPointer = createAerodynamicAcceleratioModel(
diff --git a/Tudat/SimulationSetup/createAccelerationModels.h b/Tudat/SimulationSetup/createAccelerationModels.h
index 44dc4f9..cc71e83 100644
--- a/Tudat/SimulationSetup/createAccelerationModels.h
+++ b/Tudat/SimulationSetup/createAccelerationModels.h
@@ -28,6 +28,34 @@ namespace tudat
 namespace simulation_setup
 {
 
+boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > createDirectGravitationalAcceleration(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings,
+        const std::string& nameOfCentralBody = "",
+        const bool isCentralBody = 0 );
+
+
+boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > createThirdBodyGravitationalAcceleration(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const std::string& nameOfCentralBody,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings );
+
+boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > createGravitationalAccelerationModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfCentralBody );
+
 //! Function to create central gravity acceleration model.
 /*!
  *  Function to create central gravity acceleration model from bodies exerting and undergoing
@@ -81,6 +109,15 @@ createSphericalHarmonicsGravityAcceleration(
         const boost::shared_ptr< AccelerationSettings > accelerationSettings,
         const bool useCentralBodyFixedFrame );
 
+boost::shared_ptr< gravitation::MutualSphericalHarmonicsGravitationalAccelerationModelXd > createMutualSphericalHarmonicsGravityAcceleration(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings,
+        const bool useCentralBodyFixedFrame,
+        const bool acceleratedBodyIsCentralBody );
+
 //! Function to create a third body central gravity acceleration model.
 /*!
  *  Function to create a third body central gravity acceleration model from bodies exerting and
@@ -106,6 +143,24 @@ createThirdBodyCentralGravityAccelerationModel(
         const std::string& nameOfBodyExertingAcceleration,
         const std::string& nameOfCentralBody );
 
+boost::shared_ptr< gravitation::ThirdBodySphericalHarmonicsGravitationalAccelerationModel > createThirdBodySphericalHarmonicGravityAccelerationModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const std::string& nameOfCentralBody,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings );
+
+boost::shared_ptr< gravitation::ThirdBodyMutualSphericalHarmonicsGravitationalAccelerationModel > createThirdBodyMutualSphericalHarmonicGravityAccelerationModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const std::string& nameOfCentralBody,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings );
+
 //! Function to create an aerodynamic acceleration model.
 /*!
  *  Function to create an aerodynamic acceleration model, automatically creates all required
