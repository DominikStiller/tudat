Index: Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.h
===================================================================
--- Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.h	(revision 586)
+++ Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.h	(revision 588)
@@ -96,7 +96,11 @@
  * \param divisor Number that is divided by.
  * \return Remainder of division of dividend by divisor.
  */
-double computeModulo( const double dividend, const double divisor );
+template< typename ScalarType = double >
+ScalarType computeModulo( const ScalarType dividend, const ScalarType divisor )
+{
+    return dividend - divisor * std::floor( dividend / divisor );
+}
 
 } // namespace basic_mathematics
 } // namespace tudat
Index: Tudat/Mathematics/BasicMathematics/UnitTests/unitTestMathematicalConstants.cpp
===================================================================
--- Tudat/Mathematics/BasicMathematics/UnitTests/unitTestMathematicalConstants.cpp	(revision 586)
+++ Tudat/Mathematics/BasicMathematics/UnitTests/unitTestMathematicalConstants.cpp	(revision 588)
@@ -34,6 +34,7 @@
  *      120128    K. Kumar          Changed BOOST_CHECK to BOOST_CHECK_CLOSE_FRACTION for unit test
  *                                  comparisons.
  *      121205    K. Kumar          Updated license in file header.
+ *      150417    D. Dirkx          Added tests for floating ints.
  *
  *    References
  *
@@ -43,6 +44,8 @@
 
 #define BOOST_TEST_MAIN
 
+#include <iostream>
+#include <iomanip>
 #include <limits>
 
 #include <boost/math/special_functions/fpclassify.hpp>
@@ -101,6 +104,46 @@
     BOOST_CHECK( boost::math::isnan( TUDAT_NAN ) );
 }
 
+BOOST_AUTO_TEST_CASE( test_TemplatedValues )
+{
+    double one = 1.0;
+    long double longOne = 1.00000000000000000000L;
+
+    BOOST_CHECK_CLOSE(  mathematical_constants::getFloatingInteger< double >( 1 ),
+                        one, std::numeric_limits< double >::epsilon( ) );
+    BOOST_CHECK_CLOSE(  mathematical_constants::getFloatingInteger< long double >( 1 ),
+                        longOne, std::numeric_limits< long  double >::epsilon( ) );
+
+    BOOST_CHECK_SMALL(  mathematical_constants::getFloatingInteger< double >( 0 ),
+                        std::numeric_limits< double >::epsilon( ) );
+    BOOST_CHECK_SMALL(  mathematical_constants::getFloatingInteger< long double >( 0 ),
+                        std::numeric_limits< long  double >::epsilon( ) );
+
+    double two = 2.0;
+    long double longTwo = 2.00000000000000000000L;
+
+    BOOST_CHECK_CLOSE(  mathematical_constants::getFloatingInteger< double >( 2 ),
+                        two, std::numeric_limits< double >::epsilon( ) );
+    BOOST_CHECK_CLOSE(  mathematical_constants::getFloatingInteger< long double >( 2 ),
+                        longTwo, std::numeric_limits< long  double >::epsilon( ) );
+
+    BOOST_CHECK_CLOSE(  mathematical_constants::getFloatingFraction< double >( 1, 2 ),
+                        mathematical_constants::getFloatingInteger< double >( 1 ) /
+                        mathematical_constants::getFloatingInteger< double >( 2 ),
+                        std::numeric_limits< double >::epsilon( ) );
+    BOOST_CHECK_CLOSE(  mathematical_constants::getFloatingFraction< long double >( 1, 2 ),
+                        mathematical_constants::getFloatingInteger< long double >( 1 ) /
+                        mathematical_constants::getFloatingInteger< long double >( 2 )
+                        , std::numeric_limits< long double >::epsilon( ) );
+
+
+    BOOST_CHECK_CLOSE(  mathematical_constants::getPi< double >( ),
+                        mathematical_constants::PI, std::numeric_limits< double >::epsilon( ) );
+    BOOST_CHECK_CLOSE(  mathematical_constants::getPi< long double >( ),
+                        mathematical_constants::LONG_PI, std::numeric_limits< long  double >::epsilon( ) );
+
+}
+
 // Close Boost test suite.
 BOOST_AUTO_TEST_SUITE_END( ) // End test_mathematical_constants
 
Index: Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.cpp
===================================================================
--- Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.cpp	(revision 586)
+++ Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.cpp	(revision 588)
@@ -71,11 +71,5 @@
   return globalRandomNumberGenerator;
 }
 
-//! Compute modulo of double.
-double computeModulo( const double dividend, const double divisor )
-{
-    return dividend - divisor * std::floor( dividend / divisor );
-}
-
 } // namespace basic_mathematics
 } // namespace tudat
Index: Tudat/Mathematics/BasicMathematics/mathematicalConstants.h
===================================================================
--- Tudat/Mathematics/BasicMathematics/mathematicalConstants.h	(revision 586)
+++ Tudat/Mathematics/BasicMathematics/mathematicalConstants.h	(revision 588)
@@ -59,8 +59,8 @@
 
 //! The Golden ratio \f$\approx\f$ 1.6180.
 /*!
- * The golden ratio, also known as the divine proportion, golden mean, or golden section, is a 
- * number often encountered when taking the ratios of distances in simple geometric figures such as 
+ * The golden ratio, also known as the divine proportion, golden mean, or golden section, is a
+ * number often encountered when taking the ratios of distances in simple geometric figures such as
  * the pentagon, pentagram, decagon and dodecahedron.
  * \sa Wolfram MathWorld, Constant: http://mathworld.wolfram.com/GoldenRatio.html.
  */
@@ -68,19 +68,21 @@
 
 //! The constant PI \f$\approx\f$ 3.14159.
 /*!
- * The constant PI, denoted \f$\pi\f$, is a real number defined as the ratio of a circle's circumference
- * C to its diameter, d = 2r.
+ * The constant PI, denoted \f$\pi\f$, is a real number defined as the ratio of a circle's
+ * circumference C to its diameter, d = 2r.
  * \sa Wolfram MathWorld, Constant: http://mathworld.wolfram.com/Pi.html.
  */
 #ifdef M_PI
-    const static double PI = M_PI;
+const static double PI = M_PI;
 #else
-    const static double PI = 3.141592653589793238; // 18 digits.
+const static double PI = 3.141592653589793238; // 18 digits.
 #endif
 
+const static long double LONG_PI = 3.14159265358979323846264338328L;
+
 //! Not-a-number (NaN).
 /*!
- * NaN (Not a Number) is a value of the numeric data type representing an undefined or 
+ * NaN (Not a Number) is a value of the numeric data type representing an undefined or
  * unrepresentable value.
  *
  * This is a shorthand notation for std::numeric_limits<double>::signaling_NaN();
@@ -87,6 +89,52 @@
  */
 #define TUDAT_NAN std::numeric_limits< double >::signaling_NaN( )
 
+//! Function to return an integer in a floating point representation, for arbitrary
+//! floating point type
+/*!
+ * Function to return an integer in a floating point representation, for arbitrary
+ * floating point type. The function is defined as constexpr so that all operations occur
+ * at compile time.
+ * \param integer Integer to be represented as floating point value.
+ * \return Integer in floating point representation.
+ */
+template< typename ScalarType  >
+constexpr ScalarType getFloatingInteger( const int integer )
+{
+    return static_cast< ScalarType >( integer );
+}
+
+//! Function to return a rational number in a floating point representation, for arbitrary
+//! floating point type
+/*!
+ * Function to return a rational number in a floating point representation, for arbitrary
+ * floating point type. The function is defined as constexpr so that all operations occur
+ * at compile time.
+ * \param numerator Numerator of rational number to be represented as floating point value.
+ * \param denominator Denominator of rational number to be represented as floating point value.
+ * \return Integer in floating point representation.
+ */
+template< typename ScalarType  >
+constexpr ScalarType getFloatingFraction( const int numerator, const int denominator )
+{
+    return static_cast< ScalarType >( numerator ) / static_cast< ScalarType >( denominator );
+}
+
+//! Function to return an the value of pi in a floating point representation, for arbitrary
+//! floating point type
+/*!
+ * Function to return an the value of pi in a floating point representation, for arbitrary
+ * floating point type. The function is defined as constexpr so that all operations occur
+ * at compile time.
+ * \return Pi in requested floating point representation.
+ */
+template< typename ScalarType  >
+ScalarType getPi( )
+{
+    return static_cast< ScalarType >( LONG_PI );
+}
+
+
 } // namespace mathematical_constants
 
 } // namespace tudat
Index: Tudat/Mathematics/BasicMathematics/CMakeLists.txt
===================================================================
--- Tudat/Mathematics/BasicMathematics/CMakeLists.txt	(revision 586)
+++ Tudat/Mathematics/BasicMathematics/CMakeLists.txt	(revision 588)
@@ -49,7 +49,7 @@
 )
 
 # Add header files.
-set(BASICMATHEMATICS_HEADERS 
+set(BASICMATHEMATICS_HEADERS
   "${SRCROOT}${MATHEMATICSDIR}/BasicMathematics/basicFunction.h"
   "${SRCROOT}${MATHEMATICSDIR}/BasicMathematics/convergenceException.h"
   "${SRCROOT}${MATHEMATICSDIR}/BasicMathematics/coordinateConversions.h"
Index: Tudat/Mathematics/Interpolators/lagrangeInterpolator.h
===================================================================
--- Tudat/Mathematics/Interpolators/lagrangeInterpolator.h	(revision 586)
+++ Tudat/Mathematics/Interpolators/lagrangeInterpolator.h	(revision 588)
@@ -277,7 +277,8 @@
         else
         {
             // Initialize repeated numerator to 1
-            ScalarType repeatedNumerator = 1.0;//mathematics::getOne< ScalarType >( );
+            ScalarType repeatedNumerator =
+                    mathematical_constants::getFloatingInteger< ScalarType >( 1 );
 
             // Check if requested independent variable is equal to data point
             if( independentValues_[ lowerEntry ] == targetIndependentVariableValue )
@@ -297,7 +298,7 @@
                 // Set up repeated numerator and cache of independent variable values from which
                 // interpolant is created.
                 int j = 0;
-                for( int i = 0; i <= 2*offsetEntries_ + 1; i++ )
+                for( int i = 0; i <= 2 * offsetEntries_ + 1; i++ )
                 {
                     j = i + lowerEntry - offsetEntries_;
                     independentVariableDifferenceCache[ i ] =
@@ -309,8 +310,7 @@
                 }
 
                 // Evaluate interpolating polynomial at requested data point.
-                for( int i = 0; i <= 2*offsetEntries_ + 1;
-                     i++ )
+                for( int i = 0; i <=  2 *offsetEntries_ + 1; i++ )
                 {
                     j = i + lowerEntry - offsetEntries_;
                     interpolatedValue += dependentValues_[ j ]  *
@@ -365,7 +365,8 @@
             // Calculate all denominators for single interval.
             for( int j = 0; j <= 2 * offsetEntries_ + 1; j++ )
             {
-                denominators[ i ][ j ] = 1.0;//mathematics::getOne< ScalarType >( );
+                denominators[ i ][ j ] =
+                        mathematical_constants::getFloatingInteger< ScalarType >( 1 );
 
                 for( int k = 0; k <= 2 * offsetEntries_ + 1; k++ )
                 {
Index: Tudat/Mathematics/RootFinders/secantRootFinder.h
===================================================================
--- Tudat/Mathematics/RootFinders/secantRootFinder.h	(revision 586)
+++ Tudat/Mathematics/RootFinders/secantRootFinder.h	(revision 588)
@@ -26,6 +26,7 @@
  *      YYMMDD    Author            Comment
  *      120208    S. Billemont      Creation of code.
  *      140219    E. Brandon        Adapted to current Tudat root-finder structure.
+ *      150417    D. Dirkx          Made modifications for templated root finding.
  *
  *    References
  *      Press W.H., et al. Numerical Recipes in C++: The Art of Scientific Computing. Cambridge
@@ -124,7 +125,15 @@
      *          (Default is 0.5)
      */
     SecantRootFinderCore( const double relativeXTolerance, const unsigned int maxIterations,
-                          const DataType initialGuessOfRootOne = 0.5 );
+                          const DataType initialGuessOfRootOne = 0.5 )
+        : RootFinderCore< DataType >(
+              boost::bind(
+                  &termination_conditions::RootRelativeToleranceTerminationCondition< DataType >::
+                  checkTerminationCondition, boost::make_shared<
+                  termination_conditions::RootRelativeToleranceTerminationCondition< DataType > >(
+                      relativeXTolerance, maxIterations ), _1, _2, _3, _4, _5 ) ),
+          initialGuessOfRootOne_( initialGuessOfRootOne )
+    { }
 
     //! Default destructor.
     ~SecantRootFinderCore( ) { }
@@ -185,8 +194,8 @@
 
             // Compute next value of root using the following algorithm (see class documentation):
             nextRootValue           = currentRootValue - currentFunctionValue
-                                      * ( currentRootValue - lastRootValue )
-                                      / ( currentFunctionValue - lastFunctionValue );
+                    * ( currentRootValue - lastRootValue )
+                    / ( currentFunctionValue - lastFunctionValue );
             nextFunctionValue       = this->rootFunction->evaluate( nextRootValue );
 
             // Update the counter.
@@ -223,19 +232,6 @@
 
 };
 
-//! Constructor taking typical convergence criteria and the least accurate initial guess.
-template< typename DataType >
-SecantRootFinderCore< DataType >::SecantRootFinderCore( const double relativeXTolerance,
-                                                        const unsigned int maxIterations,
-                                                        const DataType initialGuessOfRootOne )
-    : RootFinderCore< DataType >(
-          boost::bind( &termination_conditions::RootRelativeToleranceTerminationCondition::
-                       checkTerminationCondition, boost::make_shared<
-                       termination_conditions::RootRelativeToleranceTerminationCondition >(
-                           relativeXTolerance, maxIterations ), _1, _2, _3, _4, _5 ) ),
-      initialGuessOfRootOne_( initialGuessOfRootOne )
-{ }
-
 // Some handy typedefs.
 typedef SecantRootFinderCore< double > SecantRootFinder;
 typedef boost::shared_ptr< SecantRootFinder > SecantRootFinderPointer;
Index: Tudat/Mathematics/RootFinders/halleyRootFinder.h
===================================================================
--- Tudat/Mathematics/RootFinders/halleyRootFinder.h	(revision 586)
+++ Tudat/Mathematics/RootFinders/halleyRootFinder.h	(revision 588)
@@ -26,6 +26,7 @@
  *      YYMMDD    Author            Comment
  *      120208    S. Billemont      Creation of code.
  *      140219    E. Brandon        Adapted to current Tudat root-finder structure.
+ *      150417    D. Dirkx          Made modifications for templated root finding.
  *
  *    References
  *      Press W.H., et al. Numerical Recipes in C++: The Art of Scientific Computing. Cambridge
@@ -113,9 +114,19 @@
      *  \param maxIterations Maximum number of iterations after which the root finder is
      *          terminated, i.e. convergence is assumed.
      */
-    HalleyRootFinderCore( const double relativeXTolerance, const unsigned int maxIterations );
+    HalleyRootFinderCore( const DataType relativeXTolerance, const unsigned int maxIterations )
+        : RootFinderCore< DataType >(
+              boost::bind(
+                  &termination_conditions::RootRelativeToleranceTerminationCondition< DataType >::
+                  checkTerminationCondition, boost::make_shared<
+                  termination_conditions::RootRelativeToleranceTerminationCondition< DataType > >(
+                      relativeXTolerance, maxIterations ), _1, _2, _3, _4, _5 ) )
+    { }
 
     //! Default destructor.
+    /*!
+     * Default destructor.
+     */
     ~HalleyRootFinderCore( ){ }
 
     //! Find a root of the function provided as input.
@@ -141,10 +152,10 @@
         DataType nextFunctionValue            = this->rootFunction->evaluate( nextRootValue );
         DataType currentFirstDerivativeValue  = TUDAT_NAN;
         DataType nextFirstDerivativeValue     = this->rootFunction->
-                                                computeDerivative( 1, nextRootValue );
+                computeDerivative( 1, nextRootValue );
         DataType currentSecondDerivativeValue = TUDAT_NAN;
         DataType nextSecondDerivativeValue    = this->rootFunction->
-                                                computeDerivative( 2, nextRootValue );
+                computeDerivative( 2, nextRootValue );
 
         // Loop counter.
         unsigned int counter = 1;
@@ -161,8 +172,8 @@
             // Compute next value of root using the following algorithm (see class documentation):
             nextRootValue               = currentRootValue
                     - ( ( 2.0 * currentFunctionValue * currentFirstDerivativeValue )
-                    / ( 2.0 * currentFirstDerivativeValue * currentFirstDerivativeValue
-                        - currentFunctionValue * currentSecondDerivativeValue ) );
+                        / ( 2.0 * currentFirstDerivativeValue * currentFirstDerivativeValue
+                            - currentFunctionValue * currentSecondDerivativeValue ) );
             nextFunctionValue           = this->rootFunction->evaluate( nextRootValue );
             nextFirstDerivativeValue    = this->rootFunction->computeDerivative( 1, nextRootValue );
             nextSecondDerivativeValue   = this->rootFunction->computeDerivative( 2, nextRootValue );
@@ -182,17 +193,6 @@
 
 };
 
-//! Constructor taking typical convergence criteria.
-template< typename DataType >
-HalleyRootFinderCore< DataType >::HalleyRootFinderCore( const double relativeXTolerance,
-                                                        const unsigned int maxIterations )
-    : RootFinderCore< DataType >(
-          boost::bind( &termination_conditions::RootRelativeToleranceTerminationCondition::
-                       checkTerminationCondition, boost::make_shared<
-                       termination_conditions::RootRelativeToleranceTerminationCondition >(
-                           relativeXTolerance, maxIterations ), _1, _2, _3, _4, _5 ) )
-{ }
-
 // Some handy typedefs.
 typedef HalleyRootFinderCore< double > HalleyRootFinder;
 typedef boost::shared_ptr< HalleyRootFinder > HalleyRootFinderPointer;
Index: Tudat/Mathematics/RootFinders/UnitTests/unitTestBisection.cpp
===================================================================
--- Tudat/Mathematics/RootFinders/UnitTests/unitTestBisection.cpp	(revision 586)
+++ Tudat/Mathematics/RootFinders/UnitTests/unitTestBisection.cpp	(revision 588)
@@ -25,6 +25,7 @@
  *    Changelog
  *      YYMMDD    Author            Comment
  *      140219    E. Brandon        File copied from Newton-Raphson unit test.
+ *      150417    D. Dirkx          Made modifications for templated root finding.
  *
  *    References
  *
@@ -68,8 +69,8 @@
 
     // The termination condition.
     Bisection::TerminationFunction terminationConditionFunction =
-            boost::bind( &RootAbsoluteToleranceTerminationCondition::checkTerminationCondition,
-                         boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
+            boost::bind( &RootAbsoluteToleranceTerminationCondition< double >::checkTerminationCondition,
+                         boost::make_shared< RootAbsoluteToleranceTerminationCondition< double > >(
                              testFunction->getTrueRootAccuracy( ) ), _1, _2, _3, _4, _5 );
 
     // Test Bisection object.
@@ -92,8 +93,8 @@
 
     // The termination condition.
     Bisection::TerminationFunction terminationConditionFunction =
-            boost::bind( &RootAbsoluteToleranceTerminationCondition::checkTerminationCondition,
-                         boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
+            boost::bind( &RootAbsoluteToleranceTerminationCondition< double >::checkTerminationCondition,
+                         boost::make_shared< RootAbsoluteToleranceTerminationCondition< double > >(
                              testFunction->getTrueRootAccuracy( ) ), _1, _2, _3, _4, _5 );
 
     // Test Bisection object.
@@ -116,8 +117,8 @@
 
     // The termination condition.
     Bisection::TerminationFunction terminationConditionFunction =
-            boost::bind( &RootAbsoluteToleranceTerminationCondition::checkTerminationCondition,
-                         boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
+            boost::bind( &RootAbsoluteToleranceTerminationCondition< double >::checkTerminationCondition,
+                         boost::make_shared< RootAbsoluteToleranceTerminationCondition< double > >(
                              testFunction->getTrueRootAccuracy( ) ), _1, _2, _3, _4, _5 );
 
     // Test Bisection object.
@@ -159,8 +160,8 @@
 
     // The termination condition.
     Bisection::TerminationFunction terminationConditionFunction
-            = boost::bind( &RootRelativeToleranceTerminationCondition::checkTerminationCondition,
-                           boost::make_shared< RootRelativeToleranceTerminationCondition >(
+            = boost::bind( &RootRelativeToleranceTerminationCondition< >::checkTerminationCondition,
+                           boost::make_shared< RootRelativeToleranceTerminationCondition< > >(
                                1.0e-10 ), _1, _2, _3, _4, _5 );
 
     // Test Bisection object, per case.
@@ -184,8 +185,8 @@
 
     // The termination condition.
     Bisection::TerminationFunction terminationConditionFunction =
-            boost::bind( &RootAbsoluteToleranceTerminationCondition::checkTerminationCondition,
-                         boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
+            boost::bind( &RootAbsoluteToleranceTerminationCondition< double >::checkTerminationCondition,
+                         boost::make_shared< RootAbsoluteToleranceTerminationCondition< double > >(
                              testFunction->getTrueRootAccuracy( ) ), _1, _2, _3, _4, _5 );
 
     // Test Bisection object. The input interval does not bracket the solution.
Index: Tudat/Mathematics/RootFinders/UnitTests/unitTestNewtonRaphson.cpp
===================================================================
--- Tudat/Mathematics/RootFinders/UnitTests/unitTestNewtonRaphson.cpp	(revision 586)
+++ Tudat/Mathematics/RootFinders/UnitTests/unitTestNewtonRaphson.cpp	(revision 588)
@@ -42,6 +42,7 @@
  *      120318    S. Billemont      Move to new root_finders codebase.
  *      120402    T. Secretin       Code-check.
  *      120810    P. Musegaas       Code-check. Merged two branches. Various edits.
+ *      150417    D. Dirkx          Made modifications for templated root finding.
  *
  *    References
  *
@@ -81,8 +82,8 @@
 
     // The termination condition.
     NewtonRaphson::TerminationFunction terminationConditionFunction =
-            boost::bind( &RootAbsoluteToleranceTerminationCondition::checkTerminationCondition,
-                         boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
+            boost::bind( &RootAbsoluteToleranceTerminationCondition< double >::checkTerminationCondition,
+                         boost::make_shared< RootAbsoluteToleranceTerminationCondition< double > >(
                              testFunction->getTrueRootAccuracy( ) ), _1, _2, _3, _4, _5 );
 
     // Test Newton-Raphson object.
@@ -104,8 +105,8 @@
 
     // The termination condition.
     NewtonRaphson::TerminationFunction terminationConditionFunction =
-            boost::bind( &RootAbsoluteToleranceTerminationCondition::checkTerminationCondition,
-                         boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
+            boost::bind( &RootAbsoluteToleranceTerminationCondition< double >::checkTerminationCondition,
+                         boost::make_shared< RootAbsoluteToleranceTerminationCondition< double > >(
                              testFunction->getTrueRootAccuracy( ) ), _1, _2, _3, _4, _5 );
     
     // Test Newton-Raphson object.
@@ -127,8 +128,8 @@
 
     // The termination condition.
     NewtonRaphson::TerminationFunction terminationConditionFunction =
-            boost::bind( &RootAbsoluteToleranceTerminationCondition::checkTerminationCondition,
-                         boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
+            boost::bind( &RootAbsoluteToleranceTerminationCondition< double >::checkTerminationCondition,
+                         boost::make_shared< RootAbsoluteToleranceTerminationCondition< double > >(
                              testFunction->getTrueRootAccuracy( ) ), _1, _2, _3, _4, _5 );
 
     // Test Newton-Raphson object.
@@ -165,8 +166,8 @@
 
     // The termination condition.
     NewtonRaphson::TerminationFunction terminationConditionFunction
-            = boost::bind( &RootRelativeToleranceTerminationCondition::checkTerminationCondition,
-                           boost::make_shared< RootRelativeToleranceTerminationCondition >(
+            = boost::bind( &RootRelativeToleranceTerminationCondition< >::checkTerminationCondition,
+                           boost::make_shared< RootRelativeToleranceTerminationCondition< > >(
                                1.0e-10 ), _1, _2, _3, _4, _5 );
 
     // Make the Newton-Raphson object.
@@ -193,10 +194,11 @@
 
     // The termination condition.
     NewtonRaphson::TerminationFunction terminationConditionFunction
-            = boost::bind( &RootAbsoluteOrRelativeToleranceTerminationCondition::
-                           checkTerminationCondition,
-                           boost::make_shared< RootAbsoluteOrRelativeToleranceTerminationCondition >(
-                               1.0e-308, 1.0e-15 ), _1, _2, _3, _4, _5 );
+            = boost::bind(
+                &RootAbsoluteOrRelativeToleranceTerminationCondition< >::
+                checkTerminationCondition,
+                boost::make_shared< RootAbsoluteOrRelativeToleranceTerminationCondition< > >(
+                    1.0e-308, 1.0e-15 ), _1, _2, _3, _4, _5 );
 
     // Test Newton-Raphson object.
     NewtonRaphson newtonRaphson( terminationConditionFunction );
Index: Tudat/Mathematics/RootFinders/UnitTests/unitTestSecantRootFinder.cpp
===================================================================
--- Tudat/Mathematics/RootFinders/UnitTests/unitTestSecantRootFinder.cpp	(revision 586)
+++ Tudat/Mathematics/RootFinders/UnitTests/unitTestSecantRootFinder.cpp	(revision 588)
@@ -25,6 +25,7 @@
  *    Changelog
  *      YYMMDD    Author            Comment
  *      140219    E. Brandon        File copied from Newton-Raphson unit test.
+ *      150417    D. Dirkx          Made modifications for templated root finding.
  *
  *    References
  *
@@ -63,9 +64,10 @@
 
     // The termination condition.
     SecantRootFinder::TerminationFunction terminationConditionFunction =
-            boost::bind( &RootAbsoluteToleranceTerminationCondition::checkTerminationCondition,
-                         boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
-                             testFunction->getTrueRootAccuracy( ) ), _1, _2, _3, _4, _5 );
+            boost::bind(
+                &RootAbsoluteToleranceTerminationCondition< double >::checkTerminationCondition,
+                boost::make_shared< RootAbsoluteToleranceTerminationCondition< double > >(
+                    testFunction->getTrueRootAccuracy( ) ), _1, _2, _3, _4, _5 );
 
     // Test Secant object. Use the default value of the first initial guess.
     SecantRootFinder secantRootFinder( terminationConditionFunction );
@@ -86,9 +88,10 @@
 
     // The termination condition.
     SecantRootFinder::TerminationFunction terminationConditionFunction =
-            boost::bind( &RootAbsoluteToleranceTerminationCondition::checkTerminationCondition,
-                         boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
-                             testFunction->getTrueRootAccuracy( ) ), _1, _2, _3, _4, _5 );
+            boost::bind(
+                &RootAbsoluteToleranceTerminationCondition< double >::checkTerminationCondition,
+                boost::make_shared< RootAbsoluteToleranceTerminationCondition< double > >(
+                    testFunction->getTrueRootAccuracy( ) ), _1, _2, _3, _4, _5 );
 
     // Test Secant object. Use the default value of the first initial guess.
     SecantRootFinder secantRootFinder( terminationConditionFunction );
@@ -109,9 +112,10 @@
 
     // The termination condition.
     SecantRootFinder::TerminationFunction terminationConditionFunction =
-            boost::bind( &RootAbsoluteToleranceTerminationCondition::checkTerminationCondition,
-                         boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
-                             testFunction->getTrueRootAccuracy( ) ), _1, _2, _3, _4, _5 );
+            boost::bind(
+                &RootAbsoluteToleranceTerminationCondition< double >::checkTerminationCondition,
+                boost::make_shared< RootAbsoluteToleranceTerminationCondition< double > >(
+                    testFunction->getTrueRootAccuracy( ) ), _1, _2, _3, _4, _5 );
 
     // Test Secant object. Use the default value of the first initial guess.
     SecantRootFinder secantRootFinder( terminationConditionFunction );
@@ -147,8 +151,8 @@
 
     // The termination condition.
     SecantRootFinder::TerminationFunction terminationConditionFunction
-            = boost::bind( &RootRelativeToleranceTerminationCondition::checkTerminationCondition,
-                           boost::make_shared< RootRelativeToleranceTerminationCondition >(
+            = boost::bind( &RootRelativeToleranceTerminationCondition< >::checkTerminationCondition,
+                           boost::make_shared< RootRelativeToleranceTerminationCondition< > >(
                                1.0e-10 ), _1, _2, _3, _4, _5 );
 
     // Test Secant object, per case.
@@ -176,9 +180,10 @@
 
     // The termination condition.
     SecantRootFinder::TerminationFunction terminationConditionFunction =
-            boost::bind( &RootAbsoluteToleranceTerminationCondition::checkTerminationCondition,
-                         boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
-                             1.0e-150 ), _1, _2, _3, _4, _5 );
+            boost::bind(
+                &RootAbsoluteToleranceTerminationCondition< double >::checkTerminationCondition,
+                boost::make_shared< RootAbsoluteToleranceTerminationCondition< double > >(
+                    1.0e-150 ), _1, _2, _3, _4, _5 );
 
     // Test Secant object. Use the default value of the first initial guess.
     SecantRootFinder secantRootFinder( terminationConditionFunction );
Index: Tudat/Mathematics/RootFinders/UnitTests/unitTestHalleyRootFinder.cpp
===================================================================
--- Tudat/Mathematics/RootFinders/UnitTests/unitTestHalleyRootFinder.cpp	(revision 586)
+++ Tudat/Mathematics/RootFinders/UnitTests/unitTestHalleyRootFinder.cpp	(revision 588)
@@ -25,6 +25,7 @@
  *    Changelog
  *      YYMMDD    Author            Comment
  *      140219    E. Brandon        File copied from Newton-Raphson unit test.
+ *      150417    D. Dirkx          Made modifications for templated root finding.
  *
  *    References
  *
@@ -65,8 +66,8 @@
 
     // The termination condition.
     HalleyRootFinder::TerminationFunction terminationConditionFunction =
-            boost::bind( &RootAbsoluteToleranceTerminationCondition::checkTerminationCondition,
-                         boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
+            boost::bind( &RootAbsoluteToleranceTerminationCondition< double >::checkTerminationCondition,
+                         boost::make_shared< RootAbsoluteToleranceTerminationCondition< double > >(
                              testFunction->getTrueRootAccuracy( ) ), _1, _2, _3, _4, _5 );
 
     // Test Halley object.
@@ -88,8 +89,8 @@
 
     // The termination condition.
     HalleyRootFinder::TerminationFunction terminationConditionFunction =
-            boost::bind( &RootAbsoluteToleranceTerminationCondition::checkTerminationCondition,
-                         boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
+            boost::bind( &RootAbsoluteToleranceTerminationCondition< double >::checkTerminationCondition,
+                         boost::make_shared< RootAbsoluteToleranceTerminationCondition< double > >(
                              testFunction->getTrueRootAccuracy( ) ), _1, _2, _3, _4, _5 );
 
     // Test Halley object.
@@ -111,8 +112,8 @@
 
     // The termination condition.
     HalleyRootFinder::TerminationFunction terminationConditionFunction =
-            boost::bind( &RootAbsoluteToleranceTerminationCondition::checkTerminationCondition,
-                         boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
+            boost::bind( &RootAbsoluteToleranceTerminationCondition< double >::checkTerminationCondition,
+                         boost::make_shared< RootAbsoluteToleranceTerminationCondition< double > >(
                              testFunction->getTrueRootAccuracy( ) ), _1, _2, _3, _4, _5 );
 
     // Test Halley object.
@@ -138,9 +139,9 @@
 
     // The termination condition.
     HalleyRootFinder::TerminationFunction terminationConditionFunction
-            = boost::bind( &RootAbsoluteToleranceTerminationCondition::
+            = boost::bind( &RootAbsoluteToleranceTerminationCondition< double >::
                            checkTerminationCondition,
-                           boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
+                           boost::make_shared< RootAbsoluteToleranceTerminationCondition< double > >(
                                1.0e-150 ), _1, _2, _3, _4, _5 );
 
     // Test Halley object.
Index: Tudat/Mathematics/RootFinders/bisection.h
===================================================================
--- Tudat/Mathematics/RootFinders/bisection.h	(revision 586)
+++ Tudat/Mathematics/RootFinders/bisection.h	(revision 588)
@@ -26,6 +26,7 @@
  *      YYMMDD    Author            Comment
  *      120208    S. Billemont      Creation of code.
  *      140219    E. Brandon        Adapted to current Tudat root-finder structure.
+ *      150417    D. Dirkx          Made modifications for templated root finding.
  *
  *    References
  *      Press W.H., et al. Numerical Recipes in C++: The Art of Scientific Computing. Cambridge
@@ -125,16 +126,17 @@
      * \param lowerBound Lower bound of the interval containing a root. (Default is -1.0).
      * \param upperBound Upper bound of the interval containing a root. (Default is 1.0).
      */
-    BisectionCore( const double relativeXTolerance, const unsigned int maxIterations,
+    BisectionCore( const DataType relativeXTolerance, const unsigned int maxIterations,
                    const DataType lowerBound = -1.0, const DataType upperBound = 1.0 ):
         RootFinderCore< DataType >(
-            boost::bind( &termination_conditions::RootRelativeToleranceTerminationCondition::
-                         checkTerminationCondition, boost::make_shared<
-                         termination_conditions::RootRelativeToleranceTerminationCondition >(
-                             relativeXTolerance, maxIterations ), _1, _2, _3, _4, _5 ) ),
+            boost::bind(
+                &termination_conditions::RootRelativeToleranceTerminationCondition< DataType >::
+                checkTerminationCondition, boost::make_shared<
+                termination_conditions::RootRelativeToleranceTerminationCondition< DataType > >(
+                    relativeXTolerance, maxIterations ), _1, _2, _3, _4, _5 ) ),
         lowerBound_( lowerBound ),
         upperBound_( upperBound )
-  { }
+    { }
 
     //! Default destructor.
     ~BisectionCore( ) { }
@@ -181,9 +183,9 @@
         if( currentLowerBoundFunctionValue * currentUpperBoundFunctionValue > 0.0 )
         {
             boost::throw_exception( boost::enable_error_info( std::runtime_error(
-                boost::str( boost::format(
-                         "The Bisection algorithm requires that the values at the upper "
-                         "and lower bounds have a different sign." ) ) ) ) );
+                                                                  boost::str( boost::format(
+                                                                                  "The Bisection algorithm requires that the values at the upper "
+                                                                                  "and lower bounds have a different sign." ) ) ) ) );
         }
 
         // Loop counter.
@@ -216,7 +218,13 @@
             rootFunctionValue = this->rootFunction->evaluate( rootValue );
 
             // Sanity check.
-            assert( currentLowerBoundFunctionValue * currentUpperBoundFunctionValue < 0.0 );
+            if( currentLowerBoundFunctionValue * currentUpperBoundFunctionValue > 0.0 )
+            {
+                boost::throw_exception( boost::enable_error_info( std::runtime_error(
+                                                                      boost::str( boost::format(
+                                                                                      "The Bisection algorithm requires that the values at the upper "
+                                                                                      "and lower bounds have a different sign, error during iteration." ) ) ) ) );
+            }
 
             counter++;
         }
@@ -223,6 +231,8 @@
         while( !this->terminationFunction( rootValue, previousRootValue, rootFunctionValue,
                                            previousRootFunctionValue, counter ) );
 
+        //std::cout<<"Ecc B: "<<rootValue<<" "<<this->rootFunction->evaluate( rootValue )<<std::endl;
+
         return rootValue;
 
     }
Index: Tudat/Mathematics/RootFinders/terminationConditions.h
===================================================================
--- Tudat/Mathematics/RootFinders/terminationConditions.h	(revision 586)
+++ Tudat/Mathematics/RootFinders/terminationConditions.h	(revision 588)
@@ -95,9 +95,10 @@
  * \param absoluteTolerance Absolute tolerance.
  * \return Flag indicating if absolute tolerance has been achieved.
  */
-inline bool checkRootAbsoluteTolerance( const double currentRootGuess,
-                                        const double previousRootGuess,
-                                        const double absoluteTolerance )
+template< typename ScalarType >
+inline bool checkRootAbsoluteTolerance( const ScalarType currentRootGuess,
+                                        const ScalarType previousRootGuess,
+                                        const ScalarType absoluteTolerance )
 {
     return std::fabs( currentRootGuess - previousRootGuess ) < absoluteTolerance;
 }
@@ -111,9 +112,10 @@
  * \param relativeTolerance Relative tolerance.
  * \return Flag indicating if relative tolerance has been achieved.
  */
-inline bool checkRootRelativeTolerance( const double currentRootGuess,
-                                        const double previousRootGuess,
-                                        const double relativeTolerance )
+template< typename ScalarType >
+inline bool checkRootRelativeTolerance( const ScalarType currentRootGuess,
+                                        const ScalarType previousRootGuess,
+                                        const ScalarType relativeTolerance )
 {
     return std::fabs( ( currentRootGuess - previousRootGuess )
                       / currentRootGuess ) < relativeTolerance;
@@ -124,6 +126,7 @@
  * This base class should be used for all termination condition classes, as it specifies the
  * checkTerminationCondition()-function used by the root-finders in Tudat.
  */
+template< typename ScalarType = double >
 class TerminationConditionBase
 {
 public:
@@ -144,10 +147,10 @@
      * \param numberOfIterations Number of iterations that have been completed.
      * \return Flag indicating if termination condition has been reached.
      */
-    virtual bool checkTerminationCondition( const double currentRootGuess,
-                                            const double previousRootGuess,
-                                            const double currentRootFunctionValue,
-                                            const double previousRootFunctionValue,
+    virtual bool checkTerminationCondition( const ScalarType currentRootGuess,
+                                            const ScalarType previousRootGuess,
+                                            const ScalarType currentRootFunctionValue,
+                                            const ScalarType previousRootFunctionValue,
                                             const unsigned int numberOfIterations ) = 0;
 };
 
@@ -158,7 +161,7 @@
  * class effectively serves as a wrapper for the checkMaximumIterationsExceeded()-function.
  * \sa checkMaximumIterationsExceeded().
  */
-class MaximumIterationsTerminationCondition : public TerminationConditionBase
+class MaximumIterationsTerminationCondition : public TerminationConditionBase< double >
 {
 public:
 
@@ -206,7 +209,8 @@
  * checkRootAbsoluteTolerance()- and checkMaximumIterationsExceeded()-functions.
  * \sa checkRootAbsoluteTolerance(), checkMaximumIterationsExceeded().
  */
-class RootAbsoluteToleranceTerminationCondition : public TerminationConditionBase
+template< typename ScalarType = double >
+class RootAbsoluteToleranceTerminationCondition : public TerminationConditionBase< ScalarType >
 {
 public:
 
@@ -221,7 +225,7 @@
      * \param aThrowRunTimeExceptionFlag Flag that indicates if run-time error should be triggered
      * if maximum number of iterations is exceeded (default=true).
      */
-    RootAbsoluteToleranceTerminationCondition( const double anAbsoluteTolerance = 1.0e-15,
+    RootAbsoluteToleranceTerminationCondition( const ScalarType anAbsoluteTolerance = 1.0e-15,
                                                const unsigned int aMaximumNumberOfIterations = 1000,
                                                const bool aThrowRunTimeExceptionFlag = true )
         : absoluteTolerance( anAbsoluteTolerance ),
@@ -242,13 +246,14 @@
      * \param numberOfIterations Number of iterations that have been completed.
      * \return Flag indicating if termination condition has been reached.
      */
-    bool checkTerminationCondition( const double currentRootGuess,
-                                    const double previousRootGuess,
-                                    const double currentRootFunctionValue,
-                                    const double previousRootFunctionValue,
+    bool checkTerminationCondition( const ScalarType currentRootGuess,
+                                    const ScalarType previousRootGuess,
+                                    const ScalarType currentRootFunctionValue,
+                                    const ScalarType previousRootFunctionValue,
                                     const unsigned int numberOfIterations )
     {
-        return checkRootAbsoluteTolerance( currentRootGuess, previousRootGuess, absoluteTolerance )
+        return checkRootAbsoluteTolerance< ScalarType >(
+                    currentRootGuess, previousRootGuess, absoluteTolerance )
                 || checkMaximumIterationsExceeded(
                     numberOfIterations, maximumNumberOfIterations, throwRunTimeException );
     }
@@ -256,7 +261,7 @@
 private:
 
     //! Absolute tolerance.
-    const double absoluteTolerance;
+    const ScalarType absoluteTolerance;
 
     //! Maximum number of iterations.
     const unsigned int maximumNumberOfIterations;
@@ -274,7 +279,8 @@
  * checkRootRelativeTolerance()- and checkMaximumIterationsExceeded()-functions.
  * \sa checkRootRelativeTolerance(), checkMaximumIterationsExceeded().
  */
-class RootRelativeToleranceTerminationCondition : public TerminationConditionBase
+template< typename ScalarType = double >
+class RootRelativeToleranceTerminationCondition : public TerminationConditionBase< ScalarType >
 {
 public:
 
@@ -289,9 +295,9 @@
      * \param aThrowRunTimeExceptionFlag Flag that indicates if run-time error should be triggered
      *        if maximum number of iterations is exceeded (default=true).
      */
-    RootRelativeToleranceTerminationCondition( const double aRelativeTolerance = 1.0e-12,
+    RootRelativeToleranceTerminationCondition( const ScalarType aRelativeTolerance = 1.0e-12,
                                                const unsigned int aMaximumNumberOfIterations = 1000,
-                                               const bool aThrowRunTimeExceptionFlag = true )
+                                               const ScalarType aThrowRunTimeExceptionFlag = true )
         : relativeTolerance( aRelativeTolerance ),
           maximumNumberOfIterations( aMaximumNumberOfIterations ),
           throwRunTimeException( aThrowRunTimeExceptionFlag )
@@ -310,10 +316,10 @@
      * \param numberOfIterations Number of iterations that have been completed.
      * \return Flag indicating if termination condition has been reached.
      */
-    bool checkTerminationCondition( const double currentRootGuess,
-                                    const double previousRootGuess,
-                                    const double currentRootFunctionValue,
-                                    const double previousRootFunctionValue,
+    bool checkTerminationCondition( const ScalarType currentRootGuess,
+                                    const ScalarType previousRootGuess,
+                                    const ScalarType currentRootFunctionValue,
+                                    const ScalarType previousRootFunctionValue,
                                     const unsigned int numberOfIterations )
     {
         return checkRootRelativeTolerance( currentRootGuess, previousRootGuess, relativeTolerance )
@@ -324,7 +330,7 @@
 private:
 
     //! Relative tolerance.
-    const double relativeTolerance;
+    const ScalarType relativeTolerance;
 
     //! Maximum number of iterations.
     const unsigned int maximumNumberOfIterations;
@@ -344,7 +350,9 @@
  * \sa checkRootAbsoluteTolerance(), checkRootRelativeTolerance(),
  *      checkMaximumIterationsExceeded().
  */
-class RootAbsoluteOrRelativeToleranceTerminationCondition : public TerminationConditionBase
+template< typename ScalarType = double >
+class RootAbsoluteOrRelativeToleranceTerminationCondition :
+        public TerminationConditionBase< ScalarType >
 {
 public:
 
@@ -362,8 +370,8 @@
      *        if maximum number of iterations is exceeded (default=true).
      */
     RootAbsoluteOrRelativeToleranceTerminationCondition(
-            const double anAbsoluteTolerance = 1.0e-15,
-            const double aRelativeTolerance = 1.0e-12,
+            const ScalarType anAbsoluteTolerance = 1.0e-15,
+            const ScalarType aRelativeTolerance = 1.0e-12,
             const unsigned int aMaximumNumberOfIterations = 1000,
             const bool aThrowRunTimeExceptionFlag = true )
         : absoluteTolerance( anAbsoluteTolerance ),
@@ -385,10 +393,10 @@
      * \param numberOfIterations Number of iterations that have been completed.
      * \return Flag indicating if termination condition has been reached.
      */
-    bool checkTerminationCondition( const double currentRootGuess,
-                                    const double previousRootGuess,
-                                    const double currentRootFunctionValue,
-                                    const double previousRootFunctionValue,
+    bool checkTerminationCondition( const ScalarType currentRootGuess,
+                                    const ScalarType previousRootGuess,
+                                    const ScalarType currentRootFunctionValue,
+                                    const ScalarType previousRootFunctionValue,
                                     const unsigned int numberOfIterations )
     {
         return checkRootAbsoluteTolerance( currentRootGuess, previousRootGuess, absoluteTolerance )
@@ -401,10 +409,10 @@
 private:
 
     //! Absolute tolerance.
-    const double absoluteTolerance;
+    const ScalarType absoluteTolerance;
 
     //! Relative tolerance.
-    const double relativeTolerance;
+    const ScalarType relativeTolerance;
 
     //! Maximum number of iterations.
     const unsigned int maximumNumberOfIterations;
@@ -413,25 +421,10 @@
     const bool throwRunTimeException;
 };
 
-//! Typedef for shared-pointer to TerminationConditionBase object.
-typedef boost::shared_ptr< TerminationConditionBase > TerminationConditionBasePointer;
-
 //! Typedef for shared-pointer to MaximumIterationsTerminationCondition object.
 typedef boost::shared_ptr< MaximumIterationsTerminationCondition >
 MaximumIterationsTerminationConditionPointer;
 
-//! Typedef for shared-pointer to RootAbsoluteToleranceTerminationCondition object.
-typedef boost::shared_ptr< RootAbsoluteToleranceTerminationCondition >
-RootAbsoluteToleranceTerminationConditionPointer;
-
-//! Typedef for shared-pointer to RootRelativeToleranceTerminationCondition object.
-typedef boost::shared_ptr< RootRelativeToleranceTerminationCondition >
-RootRelativeToleranceTerminationConditionPointer;
-
-//! Typedef for shared-pointer to RootAbsoluteOrRelativeToleranceTerminationCondition object.
-typedef boost::shared_ptr< RootAbsoluteOrRelativeToleranceTerminationCondition >
-RootAbsoluteOrRelativeToleranceTerminationConditionPointer;
-
 } // namespace termination_conditions
 } // namespace root_finders
 } // namespace tudat
Index: Tudat/Mathematics/RootFinders/newtonRaphson.h
===================================================================
--- Tudat/Mathematics/RootFinders/newtonRaphson.h	(revision 586)
+++ Tudat/Mathematics/RootFinders/newtonRaphson.h	(revision 588)
@@ -42,6 +42,7 @@
  *      120810    P. Musegaas       Code-check.
  *      140312    E. Brandon        Removed unneccesary include statement, minor correction Doxygen
  *                                  comments.
+ *      150417    D. Dirkx          Made modifications for templated root finding.
  *
  *    References
  *
@@ -114,13 +115,20 @@
      *  \param maxIterations Maximum number of iterations after which the root finder is
      *  terminated, i.e. convergence is assumed
      */
-    NewtonRaphsonCore( const double relativeXTolerance, const unsigned int maxIterations );
-	
+    NewtonRaphsonCore( const DataType relativeXTolerance, const unsigned int maxIterations )
+        : RootFinderCore< DataType >(
+              boost::bind(
+                  &termination_conditions::RootRelativeToleranceTerminationCondition< DataType >::
+                  checkTerminationCondition, boost::make_shared<
+                  termination_conditions::RootRelativeToleranceTerminationCondition< DataType > >(
+                      relativeXTolerance, maxIterations ), _1, _2, _3, _4, _5 ) )
+    {}
+
     //! Default destructor.
     /*!
      * Default destructor.
      */
-    virtual ~NewtonRaphsonCore( ) { }
+     ~NewtonRaphsonCore( ) { }
 
     //! Find a root of the function provided as input.
     /*!
@@ -158,7 +166,7 @@
 
             // Compute next value of root using the following algorithm (see class documentation):
             nextRootValue          = currentRootValue -
-                                     currentFunctionValue / currentDerivativeValue;
+                    currentFunctionValue / currentDerivativeValue;
             nextFunctionValue      = this->rootFunction->evaluate( nextRootValue );
             nextDerivativeValue    = this->rootFunction->computeDerivative( 1, nextRootValue );
 
@@ -167,7 +175,7 @@
         }
         while( !this->terminationFunction( nextRootValue, currentRootValue, nextFunctionValue,
                                            currentFunctionValue, counter ) );
-		
+
         return nextRootValue;
     }
 
@@ -174,19 +182,9 @@
 protected:
 
 private:
+
 };
 
-//! Constructor taking typical convergence criteria.
-template< typename DataType >
-NewtonRaphsonCore< DataType >::NewtonRaphsonCore( const double relativeXTolerance,
-                                                  const unsigned int maxIterations )
-    : RootFinderCore< DataType >(
-          boost::bind( &termination_conditions::RootRelativeToleranceTerminationCondition::
-                       checkTerminationCondition, boost::make_shared<
-                       termination_conditions::RootRelativeToleranceTerminationCondition >(
-                           relativeXTolerance, maxIterations ), _1, _2, _3, _4, _5 ) )
-{ }
-
 // Some handy typedefs.
 typedef NewtonRaphsonCore< > NewtonRaphson;
 typedef boost::shared_ptr< NewtonRaphson > NewtonRaphsonPointer;
Index: Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.cpp
===================================================================
--- Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.cpp	(revision 586)
+++ Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.cpp	(revision 588)
@@ -1,765 +0,0 @@
-/*    Copyright (c) 2010-2015, Delft University of Technology
- *    All rights reserved.
- *
- *    Redistribution and use in source and binary forms, with or without modification, are
- *    permitted provided that the following conditions are met:
- *      - Redistributions of source code must retain the above copyright notice, this list of
- *        conditions and the following disclaimer.
- *      - Redistributions in binary form must reproduce the above copyright notice, this list of
- *        conditions and the following disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *      - Neither the name of the Delft University of Technology nor the names of its contributors
- *        may be used to endorse or promote products derived from this software without specific
- *        prior written permission.
- *
- *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
- *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- *    OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *    Changelog
- *      YYMMDD    Author            Comment
- *      101020    K. Kumar          First creation of code.
- *      101025    E. Iorfida        First development of the code with conversion equations.
- *      101028    E. Iorfida        Modification of code for updating of the  Keplerian elements
- *                                  and Cartesian elements classes.
- *      101103    E. Iorfida        Additional conversion equations for extra  Keplerian elements.
- *      101104    E. Iorfida        Modification of the code (no pointers, but directly call of
- *                                  variables).
- *      101119    E. Iorfida        Removed computation for extra Keplerian elements.
- *      101130    E. Iorfida        Added different orbital cases with if-else operators.
- *      101202    J. Melman         Compile errors taken out.
- *      101203    E. Iorfida        Added gravitational parameter, and modified punctuation.
- *      101215    E. Iorfida        Added tolerance, modified punctuation, added comments, deleted
- *                                  raiseToIntegerExponent, used pow.
- *      101219    J. Melman         Suggested efficiency improvement of if-statements.
- *      110107    E. Iorfida        Written a better definition of the range in which angles are
- *                                  computed, and made some punctuation modifications.
- *      110109    J. Melman         Incorporated function computeModulo and
- *                                  determineAngleBetweenVectors. Reduced number of if-statements
- *                                  considerably and bundled all eccentricity and inclination
- *                                  checks in convertCartesianTopointerToCartesianElements_
- *      110128    K. Kumar          Changed references to pointers.
- *      110204    K. Kumar          Removed "vector" naming.
- *      110310    K. Kumar          Changed right ascension of ascending node to longitude of
- *                                  ascending node.
- *      110510    K. Kumar          Updated conversion functions to not use dynamic memory
- *                                  allocation.
- *      110805    K. Kumar          Added mean motion to semi-major axis conversion.
- *      120131    K. Kumar          Adapted for Tudat Core, interfaces changed to use VectorXd,
- *                                  only Keplerian <-> Cartesian conversions included.
- *      120206    K. Kumar          Added wrapper functions for orbital element conversions when
- *                                  eccentricity is not known a priori (if-statement to choose
- *                                  between elliptical and hyperbolic orbits).
- *      120422    K. Kumar          Rewrote Cartesian -> Keplerian conversion; now handles circular
- *                                  and/or equatorial solutions correctly.
- *      121205    D. Dirkx          Migrated namespace to directory-based protocol.
- *      130122    K. Kumar          Debugged true anomaly computation for limit cases in
- *                                  convertCartesianToKeplerianElements().
- *
- *    References
- *      Chobotov, V.A. Orbital Mechanics, Third Edition, AIAA Education Series, VA, 2002.
- *      Wertz, J. R. Mission geometry; orbit and constellation design and management.
- *      Mengali, G., Quarta, A.A. Fondamenti di meccanica del volo spaziale.
- *      Advanced Concepts Team, ESA. Keplerian Toolbox, http://sourceforge.net/projects/keptoolbox,
- *          last accessed: 21st April, 2012.
- *
- *    Notes
- *
- */
-
-#include <cmath>
-#include <limits>
-#include <numeric>
-#include <stdexcept>
-
-#include <boost/exception/all.hpp>
-#include <boost/math/special_functions/atanh.hpp>
-
-#include <Eigen/Geometry>
-
-#include "Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h"
-#include "Tudat/Mathematics/BasicMathematics/linearAlgebra.h"
-#include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
-
-namespace tudat
-{
-
-namespace orbital_element_conversions
-{
-
-//! Convert Keplerian to Cartesian orbital elements.
-basic_mathematics::Vector6d convertKeplerianToCartesianElements(
-        const basic_mathematics::Vector6d& keplerianElements,
-        const double centralBodyGravitationalParameter )
-{
-    using std::cos;
-    using std::fabs;
-    using std::pow;
-    using std::sin;
-    using std::sqrt;
-    using Eigen::Vector2d;
-    using Eigen::Vector3d;
-
-    // Set tolerance.
-    const double tolerance_ = std::numeric_limits< double >::epsilon( );
-
-    // Set local keplerian elements.
-    double semiMajorAxis_ = keplerianElements( semiMajorAxisIndex );
-    double eccentricity_ = keplerianElements( eccentricityIndex );
-    double inclination_ = keplerianElements( inclinationIndex );
-    double argumentOfPeriapsis_ = keplerianElements( argumentOfPeriapsisIndex );
-    double longitudeOfAscendingNode_ = keplerianElements( longitudeOfAscendingNodeIndex );
-    double trueAnomaly_ = keplerianElements( trueAnomalyIndex );
-
-    // Pre-compute sines and cosines of involved angles for efficient computation.
-    double cosineOfInclination_ = cos( inclination_ );
-    double sineOfInclination_ = sin( inclination_ );
-    double cosineOfArgumentOfPeriapsis_ = cos( argumentOfPeriapsis_ );
-    double sineOfArgumentOfPeriapsis_ = sin( argumentOfPeriapsis_ );
-    double cosineOfLongitudeOfAscendingNode_ = cos( longitudeOfAscendingNode_ );
-    double sineOfLongitudeOfAscendingNode_ = sin( longitudeOfAscendingNode_ );
-    double cosineOfTrueAnomaly_ = cos( trueAnomaly_ );
-    double sineOfTrueAnomaly_ = sin( trueAnomaly_ );
-
-    // Declare semi-latus rectum.
-    double semiLatusRectum_ = -0.0;
-
-    // Compute semi-latus rectum in the case it is not a parabola.
-    if ( fabs( eccentricity_ - 1.0 ) > tolerance_  )
-    {  semiLatusRectum_ = semiMajorAxis_ * ( 1.0 - pow( eccentricity_, 2 ) ); }
-
-    // Else set the semi-latus rectum given for a parabola as the first element in the vector
-    // of Keplerian elements..
-    else  { semiLatusRectum_ = semiMajorAxis_; }
-
-    // Definition of position in the perifocal coordinate system.
-    Vector2d positionPerifocal_ = Eigen::Vector2d::Zero( 2 );
-    positionPerifocal_.x( ) = semiLatusRectum_ * cosineOfTrueAnomaly_
-            / ( 1.0 + eccentricity_ * cosineOfTrueAnomaly_ );
-    positionPerifocal_.y( ) = semiLatusRectum_ * sineOfTrueAnomaly_
-            / ( 1.0 + eccentricity_ * cosineOfTrueAnomaly_ );
-
-    // Definition of velocity in the perifocal coordinate system.
-    Vector2d velocityPerifocal_(
-                -sqrt( centralBodyGravitationalParameter / semiLatusRectum_ ) * sineOfTrueAnomaly_,
-                sqrt( centralBodyGravitationalParameter / semiLatusRectum_ )
-                * ( eccentricity_ + cosineOfTrueAnomaly_ ) );
-
-    // Definition of the transformation matrix.
-    Eigen::MatrixXd transformationMatrix_ = Eigen::MatrixXd::Zero( 3, 2 );
-
-    // Compute the transformation matrix.
-    transformationMatrix_( 0, 0 ) = cosineOfLongitudeOfAscendingNode_
-            * cosineOfArgumentOfPeriapsis_ -sineOfLongitudeOfAscendingNode_
-            * sineOfArgumentOfPeriapsis_ * cosineOfInclination_;
-    transformationMatrix_( 0, 1 ) = -cosineOfLongitudeOfAscendingNode_
-            * sineOfArgumentOfPeriapsis_ -sineOfLongitudeOfAscendingNode_
-            * cosineOfArgumentOfPeriapsis_ * cosineOfInclination_;
-    transformationMatrix_( 1, 0 ) = sineOfLongitudeOfAscendingNode_
-            * cosineOfArgumentOfPeriapsis_ + cosineOfLongitudeOfAscendingNode_
-            * sineOfArgumentOfPeriapsis_ * cosineOfInclination_;
-    transformationMatrix_( 1, 1 ) = -sineOfLongitudeOfAscendingNode_
-            * sineOfArgumentOfPeriapsis_ + cosineOfLongitudeOfAscendingNode_
-            * cosineOfArgumentOfPeriapsis_ * cosineOfInclination_;
-    transformationMatrix_( 2, 0 ) = sineOfArgumentOfPeriapsis_ * sineOfInclination_;
-    transformationMatrix_( 2, 1 ) = cosineOfArgumentOfPeriapsis_ * sineOfInclination_;
-
-    // Declare converted Cartesian elements.
-    basic_mathematics::Vector6d convertedCartesianElements_ = basic_mathematics::Vector6d::Zero( );
-
-    // Compute value of position in Cartesian coordinates.
-    Vector3d position_ = transformationMatrix_ * positionPerifocal_;
-    convertedCartesianElements_.segment( 0, 3 ) = position_;
-
-    // Compute value of velocity in Cartesian coordinates.
-    Vector3d velocity_ = transformationMatrix_ * velocityPerifocal_;
-    convertedCartesianElements_.segment( 3, 3 ) = velocity_;
-
-    // Return Cartesian elements.
-    return convertedCartesianElements_;
-}
-
-//! Convert Cartesian to Keplerian orbital elements.
-basic_mathematics::Vector6d convertCartesianToKeplerianElements(
-        const basic_mathematics::Vector6d& cartesianElements,
-        const double centralBodyGravitationalParameter )
-{
-    // Set tolerance.
-    const double tolerance = 1.0e-15;
-
-    // Declare converted Keplerian elements.
-    basic_mathematics::Vector6d computedKeplerianElements_ = basic_mathematics::Vector6d::Zero( );
-
-    // Set position and velocity vectors.
-    const Eigen::Vector3d position_( cartesianElements.segment( 0, 3 ) );
-    const Eigen::Vector3d velocity_( cartesianElements.segment( 3, 3 ) );
-
-    // Compute orbital angular momentum vector.
-    const Eigen::Vector3d angularMomentum_( position_.cross( velocity_ ) );
-
-    // Compute semi-latus rectum.
-    const double semiLatusRectum_ = angularMomentum_.squaredNorm( )
-            / centralBodyGravitationalParameter;
-
-    // Compute unit vector to ascending node.
-    Eigen::Vector3d unitAscendingNodeVector_(
-                ( Eigen::Vector3d::UnitZ( ).cross(
-                      angularMomentum_.normalized( ) ) ).normalized( ) );
-
-    // Compute eccentricity vector.
-    Eigen::Vector3d eccentricityVector_(
-                velocity_.cross( angularMomentum_ ) / centralBodyGravitationalParameter
-                - position_.normalized( ) );
-
-    // Store eccentricity.
-    computedKeplerianElements_( eccentricityIndex ) = eccentricityVector_.norm( );
-
-    // Compute and store semi-major axis.
-    // Check if orbit is parabolic. If it is, store the semi-latus rectum instead of the
-    // semi-major axis.
-    if ( std::fabs( computedKeplerianElements_( eccentricityIndex ) - 1.0 ) < tolerance )
-    {
-        computedKeplerianElements_( semiLatusRectumIndex ) = semiLatusRectum_;
-    }
-
-    // Else the orbit is either elliptical or hyperbolic, so store the semi-major axis.
-    else
-    {
-        computedKeplerianElements_( semiMajorAxisIndex ) = semiLatusRectum_
-                / ( 1.0 - computedKeplerianElements_( eccentricityIndex )
-                    * computedKeplerianElements_( eccentricityIndex ) );
-    }
-
-    // Compute and store inclination.
-    computedKeplerianElements_( inclinationIndex ) = std::acos( angularMomentum_.z( )
-                                                                / angularMomentum_.norm( ) );
-
-    // Compute and store longitude of ascending node.
-    // Define the quadrant condition for the argument of perigee.
-    double argumentOfPeriapsisQuandrantCondition = eccentricityVector_.z( );
-
-    // Check if the orbit is equatorial. If it is, set the vector to the line of nodes to the
-    // x-axis.
-    if ( std::fabs( computedKeplerianElements_( inclinationIndex ) ) < tolerance )
-    {
-        unitAscendingNodeVector_ = Eigen::Vector3d::UnitX( );
-
-        // If the orbit is equatorial, eccentricityVector_.z( ) is zero, therefore the quadrant
-        // condition is taken to be the y-component, eccentricityVector_.y( ).
-        argumentOfPeriapsisQuandrantCondition = eccentricityVector_.y( );
-    }
-
-    // Compute and store the resulting longitude of ascending node.
-    computedKeplerianElements_( longitudeOfAscendingNodeIndex )
-            = acos( unitAscendingNodeVector_.x( ) );
-
-    // Check if the quandrant is correct.
-    using mathematical_constants::PI;
-    if ( unitAscendingNodeVector_.y( ) < 0.0 )
-    {
-        computedKeplerianElements_( longitudeOfAscendingNodeIndex ) =
-                2.0 * PI - computedKeplerianElements_( longitudeOfAscendingNodeIndex );
-    }
-
-    // Compute and store argument of periapsis.
-    // Define the quadrant condition for the true anomaly.
-    double trueAnomalyQuandrantCondition = position_.dot( velocity_ );
-
-    // Check if the orbit is circular. If it is, set the eccentricity vector to unit vector
-    // pointing to the ascending node, i.e. set the argument of periapsis to zero.
-    if ( std::fabs( computedKeplerianElements_( eccentricityIndex ) ) < tolerance )
-    {
-        eccentricityVector_ = unitAscendingNodeVector_;
-
-        computedKeplerianElements_( argumentOfPeriapsisIndex ) = 0.0;
-
-        // Check if orbit is also equatorial and set true anomaly quandrant check condition
-        // accordingly.
-        if ( unitAscendingNodeVector_ == Eigen::Vector3d::UnitX( ) )
-        {
-            // If the orbit is circular, position_.dot( velocity_ ) = 0, therefore this value
-            // cannot be used as a quadrant condition. Moreover, if the orbit is equatorial,
-            // position_.z( ) is also zero and therefore the quadrant condition is taken to be the
-            // y-component, position_.y( ).
-            trueAnomalyQuandrantCondition = position_.y( );
-        }
-
-        else
-        {
-            // If the orbit is circular, position_.dot( velocity_ ) = 0, therefore the quadrant
-            // condition is taken to be the z-component of the position, position_.z( ).
-            trueAnomalyQuandrantCondition = position_.z( );
-        }
-    }
-
-    // Else, compute the argument of periapsis as the angle between the eccentricity vector and
-    // the unit vector to the ascending node.
-    else
-    {
-        computedKeplerianElements_( argumentOfPeriapsisIndex )
-                = std::acos( eccentricityVector_.normalized( ).dot( unitAscendingNodeVector_ ) );
-
-        // Check if the quadrant is correct.
-        using mathematical_constants::PI;
-        if ( argumentOfPeriapsisQuandrantCondition < 0.0 )
-        {
-           computedKeplerianElements_( argumentOfPeriapsisIndex ) =
-                   2.0 * PI - computedKeplerianElements_( argumentOfPeriapsisIndex );
-        }
-    }
-
-    // Compute dot-product of position and eccentricity vectors.
-    double dotProductPositionAndEccentricityVectors
-            = position_.normalized( ).dot( eccentricityVector_.normalized( ) );
-
-    // Check if the dot-product is one of the limiting cases: 0.0 or 1.0
-    // (within prescribed tolerance).
-    if ( std::fabs( 1.0 - dotProductPositionAndEccentricityVectors ) < tolerance )
-    {
-        dotProductPositionAndEccentricityVectors = 1.0;
-    }
-
-    if ( std::fabs( dotProductPositionAndEccentricityVectors ) < tolerance )
-    {
-        dotProductPositionAndEccentricityVectors  = 0.0;
-    }
-
-    // Compute and store true anomaly.
-    computedKeplerianElements_( trueAnomalyIndex )
-            = std::acos( dotProductPositionAndEccentricityVectors );
-
-    // Check if the quandrant is correct.
-    if ( trueAnomalyQuandrantCondition < 0.0 )
-    {
-        computedKeplerianElements_( trueAnomalyIndex ) =
-                2.0 * PI - computedKeplerianElements_( trueAnomalyIndex );
-    }
-
-    // Return converted Keplerian elements.
-    return computedKeplerianElements_;
-}
-
-//! Convert true anomaly to (elliptic) eccentric anomaly.
-double convertTrueAnomalyToEllipticalEccentricAnomaly( const double trueAnomaly,
-                                                       const double eccentricity )
-{
-    if ( eccentricity >= 1.0 || eccentricity < 0.0 )
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error( "Eccentricity is invalid." ) ) );
-    }
-
-    else
-    {
-        using std::cos;
-        using std::sqrt;
-
-        // Declare and compute sine and cosine of eccentric anomaly.
-        double sineOfEccentricAnomaly_ = sqrt( 1.0 - std::pow( eccentricity, 2.0 ) )
-                * std::sin( trueAnomaly ) / ( 1.0 + eccentricity * cos( trueAnomaly ) );
-        double cosineOfEccentricAnomaly_ = ( eccentricity + cos( trueAnomaly ) )
-                / ( 1.0 + eccentricity * cos( trueAnomaly ) );
-
-        // Return elliptic eccentric anomaly.
-        return std::atan2( sineOfEccentricAnomaly_, cosineOfEccentricAnomaly_ );
-    }
-}
-
-//! Convert true anomaly to hyperbolic eccentric anomaly.
-double convertTrueAnomalyToHyperbolicEccentricAnomaly( const double trueAnomaly,
-                                                       const double eccentricity )
-{
-    if ( eccentricity <= 1.0 )
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error( "Eccentricity is invalid." ) ) );
-    }
-
-    else
-    {
-        using std::cos;
-
-        // Compute hyperbolic sine and hyperbolic cosine of hyperbolic eccentric anomaly.
-        double hyperbolicSineOfHyperbolicEccentricAnomaly_
-                = std::sqrt( std::pow( eccentricity, 2.0 ) - 1.0 )
-                * std::sin( trueAnomaly ) / ( 1.0 + cos( trueAnomaly ) );
-
-        double hyperbolicCosineOfHyperbolicEccentricAnomaly_
-                = ( cos( trueAnomaly ) + eccentricity ) / ( 1.0 + cos( trueAnomaly ) );
-
-        // Return hyperbolic eccentric anomaly.
-        return boost::math::atanh( hyperbolicSineOfHyperbolicEccentricAnomaly_
-                      / hyperbolicCosineOfHyperbolicEccentricAnomaly_ );
-    }
-}
-
-//! Convert true anomaly to eccentric anomaly.
-double convertTrueAnomalyToEccentricAnomaly( const double trueAnomaly,
-                                             const double eccentricity )
-{
-    // Declare computed eccentric anomaly.
-    double eccentricAnomaly_ = -0.0;
-
-    // Check if eccentricity is invalid and throw an error if true.
-    if ( eccentricity < 0.0 )
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error( "Eccentricity is invalid." ) ) );
-    }
-
-    // Check if orbit is parabolic and throw an error if true.
-    else if ( std::fabs( eccentricity - 1.0 ) < std::numeric_limits< double >::epsilon( ) )
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error(
-                            "Parabolic orbits have not yet been implemented." ) ) );
-    }
-
-    // Check if orbit is elliptical and compute eccentric anomaly.
-    else if ( eccentricity >= 0.0 && eccentricity < 1.0 )
-    {
-        eccentricAnomaly_ = convertTrueAnomalyToEllipticalEccentricAnomaly( trueAnomaly,
-                                                                            eccentricity );
-    }
-
-    else if ( eccentricity > 1.0 )
-    {
-        eccentricAnomaly_ = convertTrueAnomalyToHyperbolicEccentricAnomaly( trueAnomaly,
-                                                                            eccentricity );
-    }
-
-    // Return computed eccentric anomaly.
-    return eccentricAnomaly_;
-}
-
-//! Convert (elliptic) eccentric anomaly to true anomaly.
-double convertEllipticalEccentricAnomalyToTrueAnomaly( const double ellipticEccentricAnomaly,
-                                                       const double eccentricity )
-{
-    if ( eccentricity >= 1.0 || eccentricity < 0.0 )
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error( "Eccentricity is invalid." ) ) );
-    }
-
-    else
-    {
-        using std::cos;
-        using std::sqrt;
-
-        // Compute sine and cosine of true anomaly.
-        double sineOfTrueAnomaly_ = sqrt( 1.0 - std::pow( eccentricity, 2.0 ) ) *
-                std::sin( ellipticEccentricAnomaly )
-                / ( 1.0 - eccentricity * cos( ellipticEccentricAnomaly ) );
-
-        double cosineOfTrueAnomaly_ = ( cos( ellipticEccentricAnomaly ) - eccentricity )
-                / ( 1.0 - eccentricity * cos( ellipticEccentricAnomaly ) );
-
-        // Return true anomaly.
-        return atan2( sineOfTrueAnomaly_, cosineOfTrueAnomaly_  );
-    }
-}
-
-//! Convert hyperbolic eccentric anomaly to true anomaly.
-double convertHyperbolicEccentricAnomalyToTrueAnomaly( const double hyperbolicEccentricAnomaly,
-                                                       const double eccentricity )
-{
-    if ( eccentricity <= 1.0 )
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error( "Eccentricity is invalid." ) ) );
-    }
-
-    else
-    {
-        using std::cosh;
-
-        // Compute sine and cosine of true anomaly.
-        double sineOfTrueAnomaly_
-                = std::sqrt( std::pow( eccentricity, 2.0 ) - 1.0 )
-                * std::sinh( hyperbolicEccentricAnomaly )
-                / ( eccentricity * cosh( hyperbolicEccentricAnomaly ) - 1.0 );
-
-        double cosineOfTrueAnomaly_
-                = ( eccentricity - cosh( hyperbolicEccentricAnomaly ) )
-                / ( eccentricity * cosh( hyperbolicEccentricAnomaly ) - 1.0 );
-
-        // Return true anomaly.
-        return std::atan2( sineOfTrueAnomaly_, cosineOfTrueAnomaly_ );
-    }
-
-}
-
-//! Convert eccentric anomaly to true anomaly.
-double convertEccentricAnomalyToTrueAnomaly( const double eccentricAnomaly,
-                                             const double eccentricity )
-{
-    // Declare computed true anomaly.
-    double trueAnomaly_ = -0.0;
-
-    // Check if eccentricity is invalid and throw an error if true.
-    if ( eccentricity < 0.0 )
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error( "Eccentricity is invalid." ) ) );
-    }
-
-    // Check if orbit is parabolic and throw an error if true.
-    else if ( std::fabs( eccentricity - 1.0 ) < std::numeric_limits< double >::epsilon( ) )
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error(
-                            "Parabolic orbits have not yet been implemented." ) ) );
-    }
-
-    // Check if orbit is elliptical and compute true anomaly.
-    else if ( eccentricity >= 0.0 && eccentricity < 1.0 )
-    {
-        trueAnomaly_ = convertEllipticalEccentricAnomalyToTrueAnomaly( eccentricAnomaly,
-                                                                       eccentricity );
-    }
-
-    else if ( eccentricity > 1.0 )
-    {
-        trueAnomaly_ = convertHyperbolicEccentricAnomalyToTrueAnomaly( eccentricAnomaly,
-                                                                       eccentricity );
-    }
-
-    // Return computed true anomaly.
-    return trueAnomaly_;
-}
-
-//! Convert (elliptical) eccentric anomaly to mean anomaly.
-double convertEllipticalEccentricAnomalyToMeanAnomaly( const double ellipticalEccentricAnomaly,
-                                                       const double eccentricity )
-{
-    return ellipticalEccentricAnomaly - eccentricity * std::sin( ellipticalEccentricAnomaly );
-}
-
-//! Convert hyperbolic eccentric anomaly to mean anomaly.
-double convertHyperbolicEccentricAnomalyToMeanAnomaly(
-    const double hyperbolicEccentricAnomaly, const double eccentricity )
-{
-    return eccentricity * std::sinh( hyperbolicEccentricAnomaly ) - hyperbolicEccentricAnomaly;
-}
-
-//! Convert eccentric anomaly to mean anomaly.
-double convertEccentricAnomalyToMeanAnomaly( const double eccentricAnomaly,
-                                             const double eccentricity )
-{
-    // Declare computed mean anomaly.
-    double meanAnomaly_ = -0.0;
-
-    // Check if eccentricity is invalid and throw an error if true.
-    if ( eccentricity < 0.0 )
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error( "Eccentricity is invalid." ) ) );
-    }
-
-    // Check if orbit is parabolic and throw an error if true.
-    else if ( std::fabs( eccentricity - 1.0 ) < std::numeric_limits< double >::epsilon( ) )
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error(
-                            "Parabolic orbits have not yet been implemented." ) ) );
-    }
-
-    // Check if orbit is elliptical and compute true anomaly.
-    else if ( eccentricity >= 0.0 && eccentricity < 1.0 )
-    {
-        meanAnomaly_ = convertEllipticalEccentricAnomalyToMeanAnomaly( eccentricAnomaly,
-                                                                       eccentricity );
-    }
-
-    else if ( eccentricity > 1.0 )
-    {
-        meanAnomaly_ = convertHyperbolicEccentricAnomalyToMeanAnomaly( eccentricAnomaly,
-                                                                       eccentricity );
-    }
-
-    // Return computed mean anomaly.
-    return meanAnomaly_;
-}
-
-//! Convert elapsed time to (elliptical) mean anomaly change.
-double convertElapsedTimeToEllipticalMeanAnomalyChange(
-        const double elapsedTime, const double centralBodyGravitationalParameter,
-        const double semiMajorAxis )
-{
-    // Check if semi-major axis is invalid and throw error if true.
-    if ( semiMajorAxis < 0.0 )
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error( "Semi-major axis is invalid." ) ) );
-    }
-
-    // Else return elliptical mean anomaly change.
-    else
-    {
-        return std::sqrt( centralBodyGravitationalParameter
-                          / std::pow( semiMajorAxis, 3.0 ) ) * elapsedTime;
-    }
-}
-
-//! Convert elapsed time to mean anomaly change for hyperbolic orbits.
-double convertElapsedTimeToHyperbolicMeanAnomalyChange(
-        const double elapsedTime, const double centralBodyGravitationalParameter,
-        const double semiMajorAxis )
-{
-    // Check if semi-major axis is invalid and throw error if true.
-    if ( semiMajorAxis > 0.0 )
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error( "Semi-major axis is invalid." ) ) );
-    }
-
-    // Else return hyperbolic mean anomaly change.
-    else
-    {
-        return std::sqrt( centralBodyGravitationalParameter
-                          / std::pow( -semiMajorAxis, 3.0 ) ) * elapsedTime;
-    }
-}
-
-//! Convert elapsed time to mean anomaly change.
-double convertElapsedTimeToMeanAnomalyChange(
-        const double elapsedTime, const double centralBodyGravitationalParameter,
-        const double semiMajorAxis )
-{
-    // Declare computed mean anomaly change.
-    double meanAnomalyChange_ = -0.0;
-
-    // Check if orbit is elliptical and compute mean anomaly change.
-    if ( semiMajorAxis > 0.0 )
-    {
-        meanAnomalyChange_ = convertElapsedTimeToEllipticalMeanAnomalyChange(
-                    elapsedTime, centralBodyGravitationalParameter, semiMajorAxis );
-    }
-
-    // Else orbit is hyperbolic; compute mean anomaly change.
-    else if ( semiMajorAxis < 0.0 )
-    {
-        meanAnomalyChange_ = convertElapsedTimeToHyperbolicMeanAnomalyChange(
-                    elapsedTime, centralBodyGravitationalParameter, semiMajorAxis );
-    }
-
-    // Return computed mean anomaly change.
-    return meanAnomalyChange_;
-}
-
-//! Convert (elliptical) mean anomaly change to elapsed time.
-double convertEllipticalMeanAnomalyChangeToElapsedTime(
-        const double ellipticalMeanAnomalyChange, const double centralBodyGravitationalParameter,
-        const double semiMajorAxis )
-{
-    // Check if semi-major axis is invalid and throw error if true.
-    if ( semiMajorAxis < 0.0 )
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error( "Semi-major axis is invalid." ) ) );
-    }
-
-    // Else return elapsed time.
-    else
-    {
-        return ellipticalMeanAnomalyChange * std::sqrt( std::pow( semiMajorAxis, 3.0 )
-                                                        / centralBodyGravitationalParameter );
-    }
-}
-
-//! Convert hyperbolic mean anomaly change to elapsed time.
-double convertHyperbolicMeanAnomalyChangeToElapsedTime(
-        const double hyperbolicMeanAnomalyChange, const double centralBodyGravitationalParameter,
-        const double semiMajorAxis )
-{
-    // Check if semi-major axis is invalid and throw error if true.
-    if ( semiMajorAxis > 0.0 )
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error( "Semi-major axis is invalid." ) ) );
-    }
-
-    // Else return elapsed time.
-    else
-    {
-        return std::sqrt( std::pow( -semiMajorAxis, 3.0 )
-                          / centralBodyGravitationalParameter ) * hyperbolicMeanAnomalyChange;
-    }
-}
-
-//! Convert mean anomaly change to elapsed time.
-double convertMeanAnomalyChangeToElapsedTime(
-        const double meanAnomalyChange, const double centralBodyGravitationalParameter,
-        const double semiMajorAxis )
-{
-    // Declare computed elapsed time.
-    double elapsedTime_ = -0.0;
-
-    // Check if orbit is elliptical and compute elapsed time.
-    if ( semiMajorAxis > 0.0 )
-    {
-        elapsedTime_ = convertEllipticalMeanAnomalyChangeToElapsedTime(
-                    meanAnomalyChange, centralBodyGravitationalParameter, semiMajorAxis );
-    }
-
-    // Else orbit is hyperbolic; compute elapsed time.
-    else if ( semiMajorAxis < 0.0 )
-    {
-        elapsedTime_ = convertHyperbolicMeanAnomalyChangeToElapsedTime(
-                    meanAnomalyChange, centralBodyGravitationalParameter, semiMajorAxis );
-    }
-
-    // Return computed elapsed time.
-    return elapsedTime_;
-}
-
-//! Convert (elliptical) mean motion to semi-major axis.
-double convertEllipticalMeanMotionToSemiMajorAxis(
-        const double ellipticalMeanMotion, const double centralBodyGravitationalParameter )
-{
-    return std::pow( centralBodyGravitationalParameter
-                   / std::pow( ellipticalMeanMotion, 2.0 ), 1.0 / 3.0 );
-}
-
-//! Convert semi-major axis to elliptical mean motion.
-double convertSemiMajorAxisToEllipticalMeanMotion(
-        const double semiMajorAxis, const double centralBodyGravitationalParameter )
-{
-    // Check if semi-major axis is invalid and throw error if true.
-    if ( semiMajorAxis < 0.0 )
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error( "Semi-major axis is invalid." ) ) );
-    }
-
-    // Else compute and return elliptical mean motion.
-    {
-        return std::sqrt( centralBodyGravitationalParameter / std::pow( semiMajorAxis, 3.0 ) );
-    }
-}
-
-} // namespace orbital_element_conversions
-
-} // namespace tudat
Index: Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToEccentricAnomaly.cpp
===================================================================
--- Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToEccentricAnomaly.cpp	(revision 586)
+++ Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToEccentricAnomaly.cpp	(revision 588)
@@ -1,168 +0,0 @@
-/*    Copyright (c) 2010-2015, Delft University of Technology
- *    All rights reserved.
- *
- *    Redistribution and use in source and binary forms, with or without modification, are
- *    permitted provided that the following conditions are met:
- *      - Redistributions of source code must retain the above copyright notice, this list of
- *        conditions and the following disclaimer.
- *      - Redistributions in binary form must reproduce the above copyright notice, this list of
- *        conditions and the following disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *      - Neither the name of the Delft University of Technology nor the names of its contributors
- *        may be used to endorse or promote products derived from this software without specific
- *        prior written permission.
- *
- *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
- *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- *    OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *    Changelog
- *      YYMMDD    Author            Comment
- *      110210    K. Kumar          File created.
- *      111209    T. Secretin       Relaxed constraints on near-parabolic check.
- *      111221    T. Secretin       Added zero eccentricity case and check for negative
- *                                  eccentricities.
- *      120326    D. Dirkx          Changed raw pointers to shared pointers.
- *      120813    P. Musegaas       Changed code to new root finding structure.
- *      120822    P. Musegaas       Tested and improved initial guess of eccentric anomaly. Added
- *                                  functionality for near-parabolic cases. Added option for user
- *                                  to specifiy initial guess. Changed error message to a runtime
- *                                  error.
- *      120903    P. Musegaas       Added additional warning message.
- *      121205    P. Musegaas       Updated code to final version of rootfinders.
- *      130116    E. Heeren         Changed RootAbsoluteToleranceTerminationCondition to work on
- *                                  all systems.
- *
- *    References
- *      Regarding method in general:
- *          Chobotov, V.A. Orbital Mechanics, Third Edition, AIAA Education Series, VA, 2002.
- *          Wakker, K. F. Astrodynamics I + II. Lecture Notes AE4-874, Delft University of
- *              Technology, Delft, Netherlands.
- *      Regarding the choice of initial guess:
- *          Musegaas, P., Optimization of Space Trajectories Including Multiple Gravity Assists and
- *              Deep Space Maneuvers, MSc thesis report, Delft University of Technology, 2012.
- *              [unpublished so far]. Section available on tudat website (tudat.tudelft.nl)
- *              under issue #539.
- *
- *    Notes
- *
- */
-
-#include <cmath>
-#include <iostream>
-#include <limits>
-#include <sstream>
-#include <stdexcept>
-
-#include <boost/exception/all.hpp>
-
-#include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
-#include "Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.h"
-
-#include "Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToEccentricAnomaly.h"
-#include "Tudat/Mathematics/BasicMathematics/functionProxy.h"
-
-namespace tudat
-{
-
-namespace orbital_element_conversions
-{
-
-using namespace root_finders;
-using namespace root_finders::termination_conditions;
-
-//! Construct converter with eccentricity and mean anomaly.
-ConvertMeanAnomalyToEccentricAnomaly::ConvertMeanAnomalyToEccentricAnomaly( 
-        const double anEccentricity, const double aMeanAnomaly,
-        const bool useDefaultInitialGuess_,
-        const double userSpecifiedInitialGuess_,
-        root_finders::RootFinderPointer aRootFinder )
-    : eccentricity( anEccentricity ),
-      useDefaultInitialGuess( useDefaultInitialGuess_ ),
-      userSpecifiedInitialGuess( userSpecifiedInitialGuess_ ),
-      rootFinder( aRootFinder )
-
-{
-    // Set mean anomaly to region between 0 and 2 PI.
-    meanAnomaly = basic_mathematics::computeModulo( aMeanAnomaly, 2.0 * mathematical_constants::PI );
-
-    // Required because the make_shared in the function definition gives problems for MSVC.
-    if ( !rootFinder.get( ) )
-    {
-        rootFinder = boost::make_shared< NewtonRaphson >(
-            boost::bind( &RootAbsoluteToleranceTerminationCondition::checkTerminationCondition,
-            boost::make_shared< RootAbsoluteToleranceTerminationCondition >( 1.0e-13, 1000 ),
-            _1, _2, _3, _4, _5 ) );
-    }
-}
-
-//! Convert mean anomaly to eccentric anomaly.
-double ConvertMeanAnomalyToEccentricAnomaly::convert( )
-{
-    // Declare eccentric anomaly.
-    double eccentricAnomaly = TUDAT_NAN;
-
-    // Check if orbit is elliptical, and not near-parabolic.
-    if ( eccentricity < 1.0 && eccentricity >= 0.0 )
-    {
-        // Create an object containing the function of which we whish to obtain the root from.
-        basic_mathematics::UnivariateProxyPointer rootFunction
-                = boost::make_shared< basic_mathematics::UnivariateProxy >(
-                    boost::bind( &ConvertMeanAnomalyToEccentricAnomaly::
-                                 computeKeplersFunctionForEllipticalOrbits, this, _1 ) );
-
-        // Add the first derivative of the root function.
-        rootFunction->addBinding( -1, boost::bind( &ConvertMeanAnomalyToEccentricAnomaly::
-                computeFirstDerivativeKeplersFunctionForEllipticalOrbits, this, _1 ) );
-
-        // Declare initial guess.
-        double initialGuess = TUDAT_NAN;
-
-        // Set the initial guess. Check if the default scheme is to be used or a user specified
-        // value should be used.
-        // !!!!!!!!!!!!!     IMPORTANT     !!!!!!!!!!!!!
-        // If this scheme is changed, please run a very extensive test suite. The root finder
-        // function tends to be chaotic for some very specific combinations of mean anomaly and
-        // eccentricity. Various random tests of 100.000.000 samples were done to verify the
-        // functionality of this one, and of another option for the starter: PI. [Musegaas,2012]
-        if ( useDefaultInitialGuess )
-        {
-            if ( meanAnomaly > mathematical_constants::PI )
-            {
-                initialGuess =  meanAnomaly - eccentricity;
-            }
-            else
-            {
-                initialGuess = meanAnomaly + eccentricity;
-            }
-        }
-        else
-        {
-            initialGuess = userSpecifiedInitialGuess;
-        }
-
-        // Set eccentric anomaly based on result of Newton-Raphson root-finding algorithm.
-        eccentricAnomaly = rootFinder->execute( rootFunction, initialGuess );
-    }
-
-    //  Eccentricity is invalid: eccentricity < 0.0 or eccentricity >= 1.0.
-    else
-    {
-        boost::throw_exception( std::runtime_error( boost::str( boost::format(
-                "Invalid eccentricity. Valid range is 0.0 <= e < 1.0. Eccentricity was: '%f'." )
-                    % eccentricity ) ) );
-    }
-
-    // Return eccentric anomaly.
-    return eccentricAnomaly;
-}
-
-} // namespace orbital_element_conversions
-
-} // namespace tudat
Index: Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToEccentricAnomaly.h
===================================================================
--- Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToEccentricAnomaly.h	(revision 586)
+++ Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToEccentricAnomaly.h	(revision 588)
@@ -1,203 +0,0 @@
-/*    Copyright (c) 2010-2015, Delft University of Technology
- *    All rights reserved.
- *
- *    Redistribution and use in source and binary forms, with or without modification, are
- *    permitted provided that the following conditions are met:
- *      - Redistributions of source code must retain the above copyright notice, this list of
- *        conditions and the following disclaimer.
- *      - Redistributions in binary form must reproduce the above copyright notice, this list of
- *        conditions and the following disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *      - Neither the name of the Delft University of Technology nor the names of its contributors
- *        may be used to endorse or promote products derived from this software without specific
- *        prior written permission.
- *
- *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
- *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- *    OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *    Changelog
- *      YYMMDD    Author            Comment
- *      110210    K. Kumar          File created.
- *      110215    E. Iorfida        Minor changes made.
- *      110810    J. Leloux         Corrected doxygen documentation.
- *      120326    D. Dirkx          Changed raw pointers to shared pointers.
- *      120421    K. Kumar          Removed base class; updated to set values through constructor.
- *      120813    P. Musegaas       Changed code to new root finding structure. Added option to
- *                                  specify which rootfinder and termination conditions to use.
- *      120822    P. Musegaas       Added functionality for near-parabolic cases. Added option for
- *                                  user to specifiy initial guess.
- *      120903    P. Musegaas       Added additional comments on the scope of the method and
- *                                  the 'conversion' of mean anomaly to 0 to 2*PI regime.
- *      121205    P. Musegaas       Updated code to final version of rootfinders.
- *      130116    E. Heeren         Minor changes to comments.
- *      130120    K. Kumar          Added shared-pointer typedef.
- *      130123    K. Kumar          Added note about near-parabolic cases.
- *      140110    E. Brandon        Fixed Doxygen comments.
- *
- *    References
- *      Regarding method in general:
- *          Chobotov, V.A. Orbital Mechanics, Third Edition, AIAA Education Series, VA, 2002.
- *          Wakker, K. F. Astrodynamics I + II. Lecture Notes AE4-874, Delft University of
- *              Technology, Delft, Netherlands.
- *      Regarding the choice of initial guess:
- *          Musegaas, P., Optimization of Space Trajectories Including Multiple Gravity Assists and
- *              Deep Space Maneuvers, MSc thesis report, Delft University of Technology, 2012.
- *              [unpublished so far]. Section available on tudat website (tudat.tudelft.nl)
- *              under issue #539.
- *
- *    Notes
- *      There are known to be some issues on some systems with near-parabolic orbits that are very
- *      close to eccentricity=1.0. For these orbits, the unit tests establish that they are able
- *      to generate consistent results by converting to and from eccentric anomaly to a precision
- *      of 1.0e-9. If this quality of solution is not adequate for specific applications, the user
- *      should investigate the code further.
- *
- */
-
-#ifndef TUDAT_CONVERT_MEAN_ANOMALY_TO_ECCENTRIC_ANOMALY_H
-#define TUDAT_CONVERT_MEAN_ANOMALY_TO_ECCENTRIC_ANOMALY_H
-
-#include <cmath>
-
-#include <boost/bind.hpp>
-#include <boost/make_shared.hpp>
-#include <boost/shared_ptr.hpp>
-
-#include "Tudat/Mathematics/RootFinders/newtonRaphson.h"
-#include "Tudat/Mathematics/RootFinders/rootFinder.h"
-#include "Tudat/Mathematics/RootFinders/terminationConditions.h"
-
-namespace tudat
-{
-
-namespace orbital_element_conversions
-{
-
-//! Converter for Mean to Eccentric anomaly.
-/*!
- * Conversion utility to convert the mean anomaly to eccentric anomaly for elliptical orbits.
- */
-class ConvertMeanAnomalyToEccentricAnomaly
-{
-public:
-
-    //! Construct converter with eccentricity and mean anomaly.
-    /*!
-     * This constructor initializes the eccentricity and the mean anomaly for the conversion
-     * routine. Optionally also the rootfinder (with termination conditions specified inside) can
-     * be given.
-     * \param anEccentricity Eccentricity of the orbit [-].
-     * \param aMeanAnomaly Mean anomaly to convert to eccentric anomaly [rad].
-     * \param useDefaultInitialGuess_ Boolean specifying whether to use default initial guess [-].
-     * \param userSpecifiedInitialGuess_ Initial guess for rootfinder [rad].
-     * \param aRootFinder Shared-pointer to the rootfinder that is to be used. Default is
-     *          Newton-Raphson using 1000 iterations as maximum and 1.0e-13 absolute X-tolerance.
-     *          Higher precision may invoke machine precision problems for some values.
-     */
-    ConvertMeanAnomalyToEccentricAnomaly(
-            const double anEccentricity, const double aMeanAnomaly,
-            const bool useDefaultInitialGuess_ = true,
-            const double userSpecifiedInitialGuess_ = TUDAT_NAN,
-            root_finders::RootFinderPointer aRootFinder = root_finders::RootFinderPointer( ) );
-
-    //! Convert mean anomaly to eccentric anomaly.
-    /*!
-     * Converts mean anomaly to eccentric anomaly for elliptical orbits for all eccentricities >=
-     * 0.0 and < 1.0. If the conversion fails or the eccentricity falls outside the valid range,
-     * then double::NaN is returned. Calculated with an accuracy of 1.0e-13 for all cases, except
-     * for some near-parabolic cases in which macine precision problems occur. These are tested
-     * against an accuracy of 1.0e-9. Near-parabolic in this sense means e > 1.0-1.0e-11. Also
-     * note that your mean anomaly is automatically transformed to fit within the 0 to 2.0*PI
-     * spectrum.
-     * \return Eccentric anomaly [rad].
-     */
-    double convert( );
-
-protected:
-
-private:
-
-    //! Eccentricity.
-    /*!
-     * Eccentricity.
-     */
-    const double eccentricity;
-
-    //! Mean anomaly.
-    /*!
-     * Mean anomaly.
-     */
-    double meanAnomaly;
-
-    //! Boolean indicating whether default initial guess is used.
-    /*!
-     * A boolean that indicates whether the default initial guess is to be used. This may be useful,
-     * because the current guess may not be ideal for certain regions in the eccentricity <-> mean
-     * anomaly domain.
-     */
-    bool useDefaultInitialGuess;
-
-    //! User-specified initial guess for root finder.
-    /*!
-     * The initial guess for the root finder can be passed as a double. This may be useful, because
-     * the current guess may not be ideal for certain regions in the eccentricity<->mean anomaly
-     * domain.
-     */
-    double userSpecifiedInitialGuess;
-
-    //! Shared pointer to the rootfinder.
-    /*!
-     * Shared pointer to the rootfinder. The rootfinder contains termination conditions inside.
-     */
-    root_finders::RootFinderPointer rootFinder;
-
-    //! Compute Kepler's function for elliptical orbits.
-    /*!
-     * Computes Kepler's function, given as:
-     * \f[
-     *      f( E ) = E - e * sin( E ) - M
-     * \f]
-     * for elliptical orbits, where \f$ E \f$ is the eccentric anomaly, \f$ e \f$ is the
-     * eccentricity, \f$ M \f$ is the mean anomaly. All eccentricities >= 0.0 and < 1.0 are valid.
-     * \param eccentricAnomaly Eccentric anomaly.
-     * \return Value of Kepler's function for elliptical orbits.
-     */
-    double computeKeplersFunctionForEllipticalOrbits( const double eccentricAnomaly )
-    {
-        return eccentricAnomaly - eccentricity * std::sin( eccentricAnomaly ) - meanAnomaly;
-    }
-
-    //! Compute first-derivative of Kepler's function for elliptical orbits.
-    /*!
-     * Computes the first-derivative of Kepler's function, given as:
-     * \f[
-     *      \frac{ df( E ) } { dE } = 1 - e * cos( E )
-     * \f]
-     * for elliptical orbits, where \f$ E \f$ is the eccentric anomaly, and \f$ e \f$ is the
-     * eccentricity. All eccentricities >= 0.0 and < 1.0 are valid.
-     * \param eccentricAnomaly Eccentric anomaly.
-     * \return Value of first-derivative of Kepler's function for elliptical orbits.
-     */
-    double computeFirstDerivativeKeplersFunctionForEllipticalOrbits(
-            const double eccentricAnomaly )
-    {
-        return 1.0 - eccentricity * std::cos( eccentricAnomaly );
-    }
-};
-
-//! Typedef for shared-pointer to ConvertMeanAnomalyToEccentricAnomaly object.
-typedef boost::shared_ptr< ConvertMeanAnomalyToEccentricAnomaly >
-ConvertMeanAnomalyToEccentricAnomalyPointer;
-
-} // namespace orbital_element_conversions
-
-} // namespace tudat
-
-#endif // TUDAT_CONVERT_MEAN_ANOMALY_TO_ECCENTRIC_ANOMALY_H
Index: Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.cpp
===================================================================
--- Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.cpp	(revision 586)
+++ Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.cpp	(revision 588)
@@ -1,187 +0,0 @@
-/*    Copyright (c) 2010-2015, Delft University of Technology
- *    All rights reserved.
- *
- *    Redistribution and use in source and binary forms, with or without modification, are
- *    permitted provided that the following conditions are met:
- *      - Redistributions of source code must retain the above copyright notice, this list of
- *        conditions and the following disclaimer.
- *      - Redistributions in binary form must reproduce the above copyright notice, this list of
- *        conditions and the following disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *      - Neither the name of the Delft University of Technology nor the names of its contributors
- *        may be used to endorse or promote products derived from this software without specific
- *        prior written permission.
- *
- *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
- *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- *    OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *    Changelog
- *      YYMMDD    Author            Comment
- *      110203    K. Kumar          File created.
- *      110207    E. Iorfida        Minor changes.
- *      110214    K. Kumar          Updated code based on new orbital conversion functions;
- *                                  optimized code.
- *      110215    E. Iorfida        Minor changes.
- *      110920    K. Kumar          Corrected simple errors outlined by M. Persson.
- *      120217    K. Kumar          Updated computeModuloForSignedValues() to computeModulo() from
- *                                  Tudat Core.
- *      120326    D. Dirkx          Changed raw pointers to shared pointers.
- *      120607    P. Musegaas       Changed interface (propagation time instead of two epochs).
- *      120713    P. Musegaas       Changed tolerance in root finder to relative tolerance.
- *      120813    P. Musegaas       Changed code to new root finding structure.
- *      120823    P. Musegaas       Added functionality for hyperbolic and near-parabolic orbits.
- *                                  Changed some parameters to const. Various small changes.
- *      120903    P. Musegaas       Removed modulo option, due to errors with it. Kepler propagator
- *                                  now simply return true anomaly in -PI to PI spectrum.
- *      121205    P. Musegaas       Updated code to final version of rootfinders.
- *
- *    References
- *
- *    Notes
- *
- */
-
-#include <cmath>
-#include <stdexcept>
-
-#include <boost/exception/all.hpp>
-
-#include "Tudat/Astrodynamics/BasicAstrodynamics/astrodynamicsFunctions.h"
-#include "Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h"
-#include "Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.h"
-#include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
-
-#include "Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h"
-#include "Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToEccentricAnomaly.h"
-#include "Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToHyperbolicEccentricAnomaly.h"
-
-namespace tudat
-{
-\
-namespace orbital_element_conversions
-{
-
-using namespace root_finders;
-
-//! Propagate Kepler orbit.
-basic_mathematics::Vector6d propagateKeplerOrbit(
-        const basic_mathematics::Vector6d &initialStateInKeplerianElements,
-        const double propagationTime,
-        const double centralBodyGravitationalParameter,
-        RootFinderPointer rootFinder )
-{
-    if ( !rootFinder.get( ) )
-    {
-        rootFinder = boost::make_shared< NewtonRaphson >(
-                    boost::bind( &root_finders::termination_conditions::
-                                 RootAbsoluteToleranceTerminationCondition::
-                                 checkTerminationCondition,
-                                 boost::make_shared< root_finders::termination_conditions::
-                                 RootAbsoluteToleranceTerminationCondition >( 5.0e-14, 1000 ),
-                                 _1, _2, _3, _4, _5 ) );
-    }
-
-    // Create final state in Keplerian elements.
-    Eigen::VectorXd finalStateInKeplerianElements = initialStateInKeplerianElements;
-
-    // Check if eccentricity is valid.
-    if ( initialStateInKeplerianElements( eccentricityIndex ) < 0.0 )
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error( "Eccentricity is invalid (smaller than 0)." ) ) );
-    }
-
-    // Check if orbit is elliptical.
-    else if ( initialStateInKeplerianElements( eccentricityIndex ) < 1.0 )
-    {
-        // Convert initial true anomaly to eccentric anomaly.
-        const double initialEccentricAnomaly = convertTrueAnomalyToEccentricAnomaly(
-                    initialStateInKeplerianElements( trueAnomalyIndex ),
-                    initialStateInKeplerianElements( eccentricityIndex ) );
-
-        // Convert initial eccentric anomaly to mean anomaly.
-        const double initialMeanAnomaly = convertEccentricAnomalyToMeanAnomaly(
-                    initialEccentricAnomaly,
-                    initialStateInKeplerianElements( eccentricityIndex ) );
-
-        // Compute change of mean anomaly between start and end of propagation.
-        const double meanAnomalyChange = convertElapsedTimeToEllipticalMeanAnomalyChange(
-                    propagationTime, centralBodyGravitationalParameter,
-                    initialStateInKeplerianElements( semiMajorAxisIndex ) );
-
-        // Set Keplerian elements and Newton-Raphson root-finder for mean anomaly to eccentric
-        // anomaly conversion.
-        ConvertMeanAnomalyToEccentricAnomaly convertMeanAnomalyToEccentricAnomaly(
-                    initialStateInKeplerianElements( eccentricityIndex ),
-                    initialMeanAnomaly + meanAnomalyChange,
-                    rootFinder );
-
-        // Compute eccentric anomaly for mean anomaly.
-        const double finalEccentricAnomaly = convertMeanAnomalyToEccentricAnomaly.convert( );
-
-        // Compute true anomaly for computed eccentric anomaly.
-        finalStateInKeplerianElements( trueAnomalyIndex ) = convertEccentricAnomalyToTrueAnomaly(
-                    finalEccentricAnomaly, finalStateInKeplerianElements( eccentricityIndex ) );
-    }
-
-    // Check if the orbit is hyperbolic.
-    else if ( initialStateInKeplerianElements( eccentricityIndex ) > 1.0 )
-    {
-        // Convert initial true anomaly to hyperbolic eccentric anomaly.
-        const double initialHyperbolicEccentricAnomaly =
-                convertTrueAnomalyToHyperbolicEccentricAnomaly(
-                    initialStateInKeplerianElements( trueAnomalyIndex ),
-                    initialStateInKeplerianElements( eccentricityIndex ) );
-
-        // Convert initial hyperbolic eccentric anomaly to the hyperbolic mean anomaly.
-        const double initialHyperbolicMeanAnomaly =
-                convertHyperbolicEccentricAnomalyToMeanAnomaly(
-                    initialHyperbolicEccentricAnomaly,
-                    initialStateInKeplerianElements( eccentricityIndex ) );
-
-        // Compute change of mean anomaly because of the propagation time.
-        const double hyperbolicMeanAnomalyChange =
-                convertElapsedTimeToHyperbolicMeanAnomalyChange(
-                    propagationTime, centralBodyGravitationalParameter,
-                    initialStateInKeplerianElements( semiMajorAxisIndex ) );
-
-        // Set Keplerian elements and Newton-Raphson root-finder for mean anomaly to eccentric
-        // anomaly conversion.
-        ConvertMeanAnomalyToHyperbolicEccentricAnomaly
-                convertMeanAnomalyToHyperbolicEccentricAnomaly(
-                    initialStateInKeplerianElements( eccentricityIndex ),
-                    initialHyperbolicMeanAnomaly + hyperbolicMeanAnomalyChange,
-                    rootFinder );
-
-        // Compute hyperbolic eccentric anomaly for mean anomaly.
-        const double finalHyperbolicEccentricAnomaly =
-                convertMeanAnomalyToHyperbolicEccentricAnomaly.convert( );
-
-        // Compute true anomaly for computed hyperbolic eccentric anomaly.
-        finalStateInKeplerianElements( trueAnomalyIndex ) =
-                convertHyperbolicEccentricAnomalyToTrueAnomaly(
-                               finalHyperbolicEccentricAnomaly,
-                               finalStateInKeplerianElements( eccentricityIndex ) );
-    }
-
-    // In this case the eccentricity has to be 1.0, hence the orbit is parabolic.
-    else
-    {
-        boost::throw_exception(
-                    boost::enable_error_info(
-                        std::runtime_error( "Parabolic orbits are not (yet) supported." ) ) );
-    }
-
-    return finalStateInKeplerianElements;
-}
-
-} // namespace orbital_element_conversions
-} // namespace tudat
Index: Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToHyperbolicEccentricAnomaly.cpp
===================================================================
--- Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToHyperbolicEccentricAnomaly.cpp	(revision 586)
+++ Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToHyperbolicEccentricAnomaly.cpp	(revision 588)
@@ -1,177 +0,0 @@
-/*    Copyright (c) 2010-2015, Delft University of Technology
- *    All rights reserved.
- *
- *    Redistribution and use in source and binary forms, with or without modification, are
- *    permitted provided that the following conditions are met:
- *      - Redistributions of source code must retain the above copyright notice, this list of
- *        conditions and the following disclaimer.
- *      - Redistributions in binary form must reproduce the above copyright notice, this list of
- *        conditions and the following disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *      - Neither the name of the Delft University of Technology nor the names of its contributors
- *        may be used to endorse or promote products derived from this software without specific
- *        prior written permission.
- *
- *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
- *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- *    OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *    Changelog
- *      YYMMDD    Author            Comment
- *      110214    K. Kumar          File created.
- *      120326    D. Dirkx          Changed raw pointers to shared pointers.
- *      120813    P. Musegaas       Changed code to new root finding structure.
- *      120822    P. Musegaas       Tested and improved initial guess of hyperbolic eccentric
- *                                  anomaly. Added functionality for near-parabolic cases. Added
- *                                  option for user to specifiy initial guess. Changed error
- *                                  message to a runtime error.
- *      120903    P. Musegaas       Added additional warning message.
- *      121205    P. Musegaas       Updated code to final version of rootfinders.
- *
- *    References
- *      Regarding method in general, including starter values used:
- *          Wakker, K. F. Astrodynamics I + II. Lecture Notes AE4-874, Delft University of
- *              Technology, Delft, Netherlands.
- *      Regarding the performance of different starter values and performance near-parabolic.
- *          Musegaas, P., Optimization of Space Trajectories Including Multiple Gravity Assists and
- *              Deep Space Maneuvers, MSc thesis report, Delft University of Technology, 2012.
- *              [unpublished so far]. Section available on tudat website (tudat.tudelft.nl)
- *              under issue #539.
- *      Regarding older versions of the code (120813 and before):
- *          Chobotov, V.A. Orbital Mechanics, Third Edition, AIAA Education Series, VA, 2002.
- *          http://www.cdeagle.com/omnum/pdf/demokep1.pdf, last accessed: 16th February, 2011.
- *
- *    Notes
- *
- */
-
-#include <iostream>
-#include <sstream>
-#include <stdexcept>
-
-#include <boost/math/special_functions/asinh.hpp>
-
-#include <boost/exception/all.hpp>
-
-#include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
-
-#include "Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToHyperbolicEccentricAnomaly.h"
-#include "Tudat/Mathematics/BasicMathematics/functionProxy.h"
-
-namespace tudat
-{
-
-namespace orbital_element_conversions
-{
-
-using namespace root_finders;
-using namespace root_finders::termination_conditions;
-
-//! Construct converter with eccentricity and mean anomaly.
-ConvertMeanAnomalyToHyperbolicEccentricAnomaly::ConvertMeanAnomalyToHyperbolicEccentricAnomaly( 
-        const double anEccentricity, 
-        const double aHyperbolicMeanAnomaly,
-        const bool useDefaultInitialGuess_,
-        const double userSpecifiedInitialGuess_,
-        RootFinderPointer aRootFinder )
-    : eccentricity( anEccentricity ),
-      hyperbolicMeanAnomaly( aHyperbolicMeanAnomaly ),
-      useDefaultInitialGuess( useDefaultInitialGuess_ ),
-      userSpecifiedInitialGuess( userSpecifiedInitialGuess_ ),
-      rootFinder( aRootFinder )
-{
-    // Required because the make_shared in the function definition gives problems for MSVC.
-    if ( !rootFinder.get( ) )
-    {
-        rootFinder = boost::make_shared< NewtonRaphson >(
-                    boost::bind(
-                        &RootAbsoluteToleranceTerminationCondition::
-                        checkTerminationCondition,
-                        boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
-                            5.0e-15, 1000 ), _1, _2, _3, _4, _5 ) );
-    }
-}
-
-//! Convert mean anomaly to hyperbolic eccentric anomaly.
-double ConvertMeanAnomalyToHyperbolicEccentricAnomaly::convert( )
-{
-    // Declare hyperbolic eccentric anomaly.
-    double hyperbolicEccentricAnomaly = TUDAT_NAN;
-
-    // Check if orbit is hyperbolic.
-    if ( eccentricity > 1.0 )
-    {
-        // Create an object containing the function of which we whish to obtain the root from.
-        basic_mathematics::UnivariateProxyPointer rootFunction
-                = boost::make_shared< basic_mathematics::UnivariateProxy >(
-                    boost::bind( &ConvertMeanAnomalyToHyperbolicEccentricAnomaly::
-                                 computeKeplersFunctionForHyperbolicOrbits, this, _1 ) );
-
-        // Add the first derivative of the root function.
-        rootFunction->addBinding(
-                    -1, boost::bind( &ConvertMeanAnomalyToHyperbolicEccentricAnomaly::
-                                     computeFirstDerivativeKeplersFunctionForHyperbolicOrbits,
-                                     this, _1 ) );
-
-        // Declare initial guess.
-        double initialGuess = TUDAT_NAN;
-
-        // Set the initial guess. Check if the default scheme is to be used or a user specified
-        // value should be used. See [Wakker, 2007] for derivations of the default values.
-        // Note that an error was detected in these starter values, as is discussed in
-        // [Musegaas,2012].
-        // !!!!!!!!!!!!!     IMPORTANT     !!!!!!!!!!!!!
-        // If this scheme is changed, please run a very extensive test suite. The root finder
-        // function tends to be chaotic for some very specific combinations of mean anomaly and
-        // eccentricity. Various random tests of 100.000.000 samples were done to verify the
-        // functionality of this one. [Musegaas,2012]
-        if ( useDefaultInitialGuess )
-        {
-            if ( std::abs( hyperbolicMeanAnomaly ) < 6.0 * eccentricity )
-            {
-                initialGuess =
-                        std::sqrt( 8.0 * ( eccentricity - 1.0 ) / eccentricity ) *
-                        std::sinh( 1.0 / 3.0 * boost::math::asinh( 3.0 * hyperbolicMeanAnomaly /
-                                ( std::sqrt( 8.0 * ( eccentricity - 1.0 ) / eccentricity ) *
-                                             ( eccentricity - 1.0 ) ) ) );
-            }
-            else if ( hyperbolicMeanAnomaly > 6.0 * eccentricity )
-            {
-                initialGuess = ( std::log( 2.0 * hyperbolicMeanAnomaly / eccentricity ) );
-            }
-            else
-            {
-                initialGuess = ( - std::log( -2.0 * hyperbolicMeanAnomaly / eccentricity ) );
-            }
-        }
-        else
-        {
-            initialGuess = userSpecifiedInitialGuess;
-        }
-
-        // Set hyperbolic eccentric anomaly based on result of Newton-Raphson root-finding
-        // algorithm.
-        hyperbolicEccentricAnomaly = rootFinder->execute( rootFunction, initialGuess );
-    }
-
-    // In this case the orbit is not hyperbolic.
-    else
-    {
-        boost::throw_exception( std::runtime_error( boost::str( boost::format(
-                "Invalid eccentricity. Valid range is e > 1.0. Eccentricity was: '%f'." )
-                    % eccentricity ) ) );
-    }
-
-    // Return hyperbolic eccentric anomaly.
-    return hyperbolicEccentricAnomaly;
-}
-
-} // namespace orbital_element_conversions
-
-} // namespace tudat
Index: Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToHyperbolicEccentricAnomaly.h
===================================================================
--- Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToHyperbolicEccentricAnomaly.h	(revision 586)
+++ Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToHyperbolicEccentricAnomaly.h	(revision 588)
@@ -1,200 +0,0 @@
-/*    Copyright (c) 2010-2015, Delft University of Technology
- *    All rights reserved.
- *
- *    Redistribution and use in source and binary forms, with or without modification, are
- *    permitted provided that the following conditions are met:
- *      - Redistributions of source code must retain the above copyright notice, this list of
- *        conditions and the following disclaimer.
- *      - Redistributions in binary form must reproduce the above copyright notice, this list of
- *        conditions and the following disclaimer in the documentation and/or other materials
- *        provided with the distribution.
- *      - Neither the name of the Delft University of Technology nor the names of its contributors
- *        may be used to endorse or promote products derived from this software without specific
- *        prior written permission.
- *
- *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
- *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
- *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- *    OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *    Changelog
- *      YYMMDD    Author            Comment
- *      110214    K. Kumar          File created.
- *      110810    J. Leloux         Corrected doxygen documentation.
- *      120326    D. Dirkx          Changed raw pointers to shared pointers.
- *      120421    K. Kumar          Removed base class; updated to set values through constructor.
- *      120813    P. Musegaas       Changed code to new root finding structure. Added option to
- *                                  specify which rootfinder and termination conditions to use.
- *      120822    P. Musegaas       Added functionality for near-parabolic cases. Added option for
- *                                  user to specifiy initial guess.
- *      121205    P. Musegaas       Updated code to final version of rootfinders.
- *      130116    E. Heeren         Minor changes to comments.
- *      130120    K. Kumar          Added shared-ptr typedef.
- *      130123    K. Kumar          Added note about near-parabolic cases.
- *      140110    E. Brandon        Fixed Doxygen comments.
- *
- *    References
- *      Regarding method in general, including starter values used:
- *          Wakker, K. F. Astrodynamics I + II. Lecture Notes AE4-874, Delft University of
- *              Technology, Delft, Netherlands.
- *      Regarding the performance of different starter values and performance near-parabolic.
- *          Musegaas, P., Optimization of Space Trajectories Including Multiple Gravity Assists and
- *              Deep Space Maneuvers, MSc thesis report, Delft University of Technology, 2012.
- *              [unpublished so far]. Section available on tudat website (tudat.tudelft.nl)
- *              under issue #539.
- *      Regarding older versions of the code (120813 and before):
- *          Chobotov, V.A. Orbital Mechanics, Third Edition, AIAA Education Series, VA, 2002.
- *          http://www.cdeagle.com/omnum/pdf/demokep1.pdf, last accessed: 16th February, 2011.
- *
- *    Notes
- *      There are known to be some issues on some systems with near-parabolic orbits that are very
- *      close to eccentricity=1.0. For these orbits, the unit tests establish that they are able
- *      to generate consistent results by converting to and from hyperbolic eccentric anomaly to a
- *      precision of 1.0e-9. If this quality of solution is not adequate for specific applications,
- *      the user should investigate the code further.
- *
- */
-
-#ifndef TUDAT_CONVERT_MEAN_ANOMALY_TO_HYPERBOLIC_ECCENTRIC_ANOMALY_H
-#define TUDAT_CONVERT_MEAN_ANOMALY_TO_HYPERBOLIC_ECCENTRIC_ANOMALY_H
-
-#include <cmath>
-
-#include <boost/bind.hpp>
-#include <boost/make_shared.hpp>
-#include <boost/shared_ptr.hpp>
-
-#include "Tudat/Mathematics/RootFinders/newtonRaphson.h"
-#include "Tudat/Mathematics/RootFinders/rootFinder.h"
-#include "Tudat/Mathematics/RootFinders/terminationConditions.h"
-
-namespace tudat
-{
-
-namespace orbital_element_conversions
-{
-
-//! Definition of mean anomaly to hyperbolic eccentric anomaly converter class.
-/*!
- * Definition of mean anomaly to hyperbolic eccentric anomaly converter class.
- */
-class ConvertMeanAnomalyToHyperbolicEccentricAnomaly
-{
-public:
-
-    //! Construct converter with eccentricity and mean anomaly.
-    /*!
-     * This constructor initializes the eccentricity and the mean anomaly for the conversion
-     * routine. Optionally also the rootfinder (with termination conditions specified inside) can
-     * be given.
-     * \param anEccentricity Eccentricity of the orbit [-].
-     * \param aHyperbolicMeanAnomaly Hyperbolic mean anomaly to convert to eccentric anomaly [rad].
-     * \param useDefaultInitialGuess_ Boolean specifying whether to use default initial guess [-].
-     * \param userSpecifiedInitialGuess_ Initial guess for rootfinder [rad].
-     * \param aRootFinder Shared-pointer to the rootfinder that is to be used. Default is
-     *          Newton-Raphson using 1000 iterations as maximum and 5.0e-15 absolute X-tolerance.
-     *          Higher precision may invoke machine precision problems for some values.
-     */
-    ConvertMeanAnomalyToHyperbolicEccentricAnomaly(
-            const double anEccentricity, const double aHyperbolicMeanAnomaly,
-            const bool useDefaultInitialGuess_ = true,
-            const double userSpecifiedInitialGuess_ = TUDAT_NAN,
-            root_finders::RootFinderPointer aRootFinder = root_finders::RootFinderPointer( ) );
-
-    //! Convert mean anomaly to hyperbolic eccentric anomaly.
-    /*!
-     * Converts mean anomaly to hyperbolic eccentric anomaly for hyperbolic orbits for all
-     * eccentricities > 1.0. If the conversion fails or the eccentricity falls outside the valid
-     * range, then double::NaN is returned. Calculated with an accuracy of 1.0e-14 for all
-     * reasonable cases (eccentricities up to 1.0e15, mean anomalies -1.2e12 to 1.2e12).
-     * \return Hyperbolic eccentric anomaly.
-     */
-    double convert( );
-
-protected:
-
-private:
-
-    //! Eccentricity.
-    /*!
-     * Eccentricity.
-     */
-    const double eccentricity;
-
-    //! Mean anomaly.
-    /*!
-     * Mean anomaly.
-     */
-    const double hyperbolicMeanAnomaly;
-
-    //! Boolean indicating whether default initial guess is used.
-    /*!
-     * A boolean that indicates whether the default initial guess is to be used. This may be
-     * useful, because the current guess may not be ideal for certain regions in the
-     * eccentricity<->hyperbolic mean anomaly domain.
-     */
-    bool useDefaultInitialGuess;
-
-    //! User-specified initial guess for root finder.
-    /*!
-     * The initial guess for the root finder can be passed as a double. This may be useful, because
-     * the current guess may not be ideal for certain regions in the eccentricity<->hyperbolic mean
-     * anomaly spectrum.
-     */
-    double userSpecifiedInitialGuess;
-
-    //! Shared pointer to the rootfinder.
-    /*!
-     * Shared pointer to the rootfinder. The rootfinder contains termination conditions inside.
-     */
-    root_finders::RootFinderPointer rootFinder;
-
-    //! Compute Kepler's function for hyperbolic orbits.
-    /*!
-     * Computes Kepler's function, given as:
-     * \f[
-     *      f( F ) = e * sinh( F ) - F - M
-     * \f]
-     * for hyperbolic orbits, where \f$ F \f$ is the hyperbolic eccentric anomaly, \f$ e \f$ is the
-     * eccentricity, \f$ M \f$ is the mean anomaly. All eccentricities > 1.0 are valid.
-     * \param hyperbolicEccentricAnomaly Hyperbolic eccentric anomaly.
-     * \return Value of Kepler's function for hyperbolic orbits.
-     */
-    double computeKeplersFunctionForHyperbolicOrbits( const double hyperbolicEccentricAnomaly )
-    {
-        return eccentricity * std::sinh( hyperbolicEccentricAnomaly )
-                - hyperbolicEccentricAnomaly - hyperbolicMeanAnomaly;
-    }
-
-    //! Compute first-derivative of Kepler's function for hyperbolic orbits.
-    /*!
-     * Computes the first-derivative of Kepler's function, given as:
-     * \f[
-     *      \frac{ df( F ) } { dF } = e * cosh( F ) - 1
-     * \f]
-     * for hyperbolic orbits, where \f$ F \f$ is the hyperbolic eccentric anomaly, and \f$ e \f$ is
-     * the eccentricity. All eccentricities > 1.0 are valid.
-     * \param hyperbolicEccentricAnomaly Hyperbolic eccentric anomaly
-     * \return Value of first-derivative of Kepler's function for hyperbolic orbits.
-     */
-    double computeFirstDerivativeKeplersFunctionForHyperbolicOrbits(
-        const double hyperbolicEccentricAnomaly )
-    {
-        return eccentricity * std::cosh( hyperbolicEccentricAnomaly ) - 1.0;
-    }
-};
-
-//! Typedef for shared-pointer to ConvertMeanAnomalyToHyperbolicEccentricAnomaly object.
-typedef boost::shared_ptr< ConvertMeanAnomalyToHyperbolicEccentricAnomaly >
-ConvertMeanAnomalyToHyperbolicEccentricAnomalyPointer;
-
-} // namespace orbital_element_conversions
-
-} // namespace tudat
-
-#endif // TUDAT_CONVERT_MEAN_ANOMALY_TO_HYPERBOLIC_ECCENTRIC_ANOMALY_H
Index: Tudat/Astrodynamics/BasicAstrodynamics/convertMeanToEccentricAnomalies.h
===================================================================
--- Tudat/Astrodynamics/BasicAstrodynamics/convertMeanToEccentricAnomalies.h	(revision 0)
+++ Tudat/Astrodynamics/BasicAstrodynamics/convertMeanToEccentricAnomalies.h	(revision 588)
@@ -0,0 +1,450 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      110210    K. Kumar          File created.
+ *      110215    E. Iorfida        Minor changes made.
+ *      110810    J. Leloux         Corrected doxygen documentation.
+ *      120326    D. Dirkx          Changed raw pointers to shared pointers.
+ *      120421    K. Kumar          Removed base class; updated to set values through constructor.
+ *      120813    P. Musegaas       Changed code to new root finding structure. Added option to
+ *                                  specify which rootfinder and termination conditions to use.
+ *      120822    P. Musegaas       Added functionality for near-parabolic cases. Added option for
+ *                                  user to specifiy initial guess.
+ *      120903    P. Musegaas       Added additional comments on the scope of the method and
+ *                                  the 'conversion' of mean anomaly to 0 to 2*PI regime.
+ *      121205    P. Musegaas       Updated code to final version of rootfinders.
+ *      130116    E. Heeren         Minor changes to comments.
+ *      130120    K. Kumar          Added shared-pointer typedef.
+ *      130123    K. Kumar          Added note about near-parabolic cases.
+ *      140110    E. Brandon        Fixed Doxygen comments.
+ *      150417    D. Dirkx          Made modifications for templated element conversions.
+ *
+ *    References
+ *      Regarding method in general:
+ *          Chobotov, V.A. Orbital Mechanics, Third Edition, AIAA Education Series, VA, 2002.
+ *          Wakker, K. F. Astrodynamics I + II. Lecture Notes AE4-874, Delft University of
+ *              Technology, Delft, Netherlands.
+ *      Regarding the choice of initial guess:
+ *          Musegaas, P., Optimization of Space Trajectories Including Multiple Gravity Assists and
+ *              Deep Space Maneuvers, MSc thesis report, Delft University of Technology, 2012.
+ *              [unpublished so far]. Section available on tudat website (tudat.tudelft.nl)
+ *              under issue #539.
+ *
+ *    Notes
+ *      There are known to be some issues on some systems with near-parabolic orbits that are very
+ *      close to eccentricity=1.0. For these orbits, the unit tests establish that they are able
+ *      to generate consistent results by converting to and from eccentric anomaly to a precision
+ *      of 1.0e-9. If this quality of solution is not adequate for specific applications, the user
+ *      should investigate the code further.
+ *
+ */
+
+#ifndef TUDAT_CONVERT_MEAN_ANOMALY_TO_ECCENTRIC_ANOMALY_H
+#define TUDAT_CONVERT_MEAN_ANOMALY_TO_ECCENTRIC_ANOMALY_H
+
+#include <cmath>
+#include <stdexcept>
+
+#include <boost/bind.hpp>
+#include <boost/make_shared.hpp>
+#include <boost/shared_ptr.hpp>
+#include <boost/exception/all.hpp>
+#include <boost/math/special_functions/asinh.hpp>
+
+#include "Tudat/Mathematics/RootFinders/newtonRaphson.h"
+#include "Tudat/Mathematics/RootFinders/rootFinder.h"
+#include "Tudat/Mathematics/RootFinders/bisection.h"
+#include "Tudat/Mathematics/RootFinders/terminationConditions.h"
+#include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
+#include "Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.h"
+#include "Tudat/Mathematics/BasicMathematics/functionProxy.h"
+
+namespace tudat
+{
+
+namespace orbital_element_conversions
+{
+
+//! Compute Kepler's function for elliptical orbits.
+/*!
+ * Computes Kepler's function, given as:
+ * \f[
+ *      f( E ) = E - e * sin( E ) - M
+ * \f]
+ * for elliptical orbits, where \f$ E \f$ is the eccentric anomaly, \f$ e \f$ is the
+ * eccentricity, \f$ M \f$ is the mean anomaly. All eccentricities >= 0.0 and < 1.0 are valid.
+ * \param eccentricAnomaly Eccentric anomaly.
+ * \param eccentricity Eccentricity.
+ * \param meanAnomaly Mean anomaly.
+ * \return Value of Kepler's function for elliptical orbits.
+ */
+template< typename ScalarType = double >
+ScalarType computeKeplersFunctionForEllipticalOrbits( const ScalarType eccentricAnomaly,
+                                                      const ScalarType eccentricity,
+                                                      const ScalarType meanAnomaly )
+{
+    return eccentricAnomaly - eccentricity * std::sin( eccentricAnomaly ) - meanAnomaly;
+}
+
+//! Compute first-derivative of Kepler's function for elliptical orbits.
+/*!
+ * Computes the first-derivative of Kepler's function, given as:
+ * \f[
+ *      \frac{ df( E ) } { dE } = 1 - e * cos( E )
+ * \f]
+ * for elliptical orbits, where \f$ E \f$ is the eccentric anomaly, and \f$ e \f$ is the
+ * eccentricity. All eccentricities >= 0.0 and < 1.0 are valid.
+ * \param eccentricAnomaly Eccentric anomaly.
+ * \param eccentricity Eccentricity.
+ * \return Value of first-derivative of Kepler's function for elliptical orbits.
+ */
+template< typename ScalarType = double >
+ScalarType computeFirstDerivativeKeplersFunctionForEllipticalOrbits(
+        const ScalarType eccentricAnomaly,
+        const ScalarType eccentricity )
+{
+    return mathematical_constants::getFloatingInteger< ScalarType >( 1 )-
+            eccentricity * std::cos( eccentricAnomaly );
+}
+
+//! Compute Kepler's function for hyperbolic orbits.
+/*!
+ * Computes Kepler's function, given as:
+ * \f[
+ *      f( F ) = e * sinh( F ) - F - M
+ * \f]
+ * for hyperbolic orbits, where \f$ F \f$ is the hyperbolic eccentric anomaly, \f$ e \f$ is the
+ * eccentricity, \f$ M \f$ is the mean anomaly. All eccentricities > 1.0 are valid.
+ * \param hyperbolicEccentricAnomaly Hyperbolic eccentric anomaly.
+ * \param eccentricity Eccentricity.
+ * \param hyperbolicMeanAnomaly Hyperbolic mean anomaly..
+ * \return Value of Kepler's function for hyperbolic orbits.
+ */
+template< typename ScalarType = double >
+ScalarType computeKeplersFunctionForHyperbolicOrbits( const ScalarType hyperbolicEccentricAnomaly,
+                                                      const ScalarType eccentricity,
+                                                      const ScalarType hyperbolicMeanAnomaly )
+{
+    return eccentricity * std::sinh( hyperbolicEccentricAnomaly )
+            - hyperbolicEccentricAnomaly - hyperbolicMeanAnomaly;
+}
+
+//! Compute first-derivative of Kepler's function for hyperbolic orbits.
+/*!
+ * Computes the first-derivative of Kepler's function, given as:
+ * \f[
+ *      \frac{ df( F ) } { dF } = e * cosh( F ) - 1
+ * \f]
+ * for hyperbolic orbits, where \f$ F \f$ is the hyperbolic eccentric anomaly, and \f$ e \f$ is
+ * the eccentricity. All eccentricities > 1.0 are valid.
+ * \param hyperbolicEccentricAnomaly Hyperbolic eccentric anomaly
+ * \param eccentricity Eccentricity.
+ * \return Value of first-derivative of Kepler's function for hyperbolic orbits.
+ */
+template< typename ScalarType = double >
+ScalarType computeFirstDerivativeKeplersFunctionForHyperbolicOrbits(
+        const ScalarType hyperbolicEccentricAnomaly,
+        const ScalarType eccentricity)
+{
+    return eccentricity * std::cosh( hyperbolicEccentricAnomaly ) - 1.0;
+}
+
+//! Convert mean anomaly to eccentric anomaly.
+/*!
+ * Converts mean anomaly to eccentric anomaly for elliptical orbits for all eccentricities >=
+ * 0.0 and < 1.0. If the conversion fails or the eccentricity falls outside the valid range,
+ * then ScalarType::NaN is returned. Calculated with an accuracy of 1.0e-13 for all cases, except
+ * for some near-parabolic cases in which macine precision problems occur. These are tested
+ * against an accuracy of 1.0e-9. Near-parabolic in this sense means e > 1.0-1.0e-11. Also
+ * note that your mean anomaly is automatically transformed to fit within the 0 to 2.0*PI
+ * spectrum. Numerical tests performed using double ScalarType.
+ * \param eccentricity Eccentricity of the orbit [-].
+ * \param aMeanAnomaly Mean anomaly to convert to eccentric anomaly [rad].
+ * \param useDefaultInitialGuess Boolean specifying whether to use default initial guess [-].
+ * \param userSpecifiedInitialGuess Initial guess for rootfinder [rad].
+ * \param aRootFinder Shared-pointer to the rootfinder that is to be used. Default is
+ *          Newton-Raphson using 1000 iterations as maximum and apprximately 1.0e-13 absolute
+ *          X-tolerance (for doubles; 500 times ScalarType resolution ).
+ *          Higher precision may invoke machine precision problems for some values.
+ * \return Eccentric anomaly [rad].
+ */
+template< typename ScalarType = double >
+ScalarType convertMeanAnomalyToEccentricAnomaly(
+        const ScalarType eccentricity, const ScalarType aMeanAnomaly,
+        const bool useDefaultInitialGuess = true,
+        const ScalarType userSpecifiedInitialGuess = TUDAT_NAN,
+        boost::shared_ptr< root_finders::RootFinderCore< ScalarType > > aRootFinder =
+        boost::shared_ptr< root_finders::RootFinderCore< ScalarType > >( ) )
+{
+    using namespace mathematical_constants;
+    using namespace root_finders;
+    using namespace root_finders::termination_conditions;
+
+    // Set mean anomaly to region between 0 and 2 PI.
+    ScalarType meanAnomaly = basic_mathematics::computeModulo< ScalarType >(
+                aMeanAnomaly, getFloatingInteger< ScalarType >( 2 ) *
+                getPi< ScalarType >( ) );
+
+    boost::shared_ptr< RootFinderCore< ScalarType > > rootFinder = aRootFinder;
+
+    // Required because the make_shared in the function definition gives problems for MSVC.
+    if ( !rootFinder.get( ) )
+    {
+        ScalarType tolerance = 200.0 * std::numeric_limits< ScalarType >::epsilon( );
+
+        // Loosen tolerance for near-parabolic orbits
+        if( std::fabs( eccentricity - getFloatingInteger< ScalarType >( 1 ) ) <
+                1.0E5 * std::numeric_limits< ScalarType >::epsilon( ) )
+        {
+            tolerance *= 2.5;
+        }
+
+        rootFinder = boost::make_shared< NewtonRaphsonCore< ScalarType > >(
+                    boost::bind(
+                        &RootAbsoluteToleranceTerminationCondition< ScalarType >::
+                        checkTerminationCondition,
+                        boost::make_shared< RootAbsoluteToleranceTerminationCondition
+                        < ScalarType > >( tolerance, 1000 ), _1, _2, _3, _4, _5 ) );
+    }
+
+    // Declare eccentric anomaly.
+    ScalarType eccentricAnomaly = TUDAT_NAN;
+
+    // Check if orbit is elliptical, and not near-parabolic.
+    if ( eccentricity < getFloatingInteger< ScalarType >( 1 ) &&
+         eccentricity >= getFloatingInteger< ScalarType >( 0 ) )
+    {
+        // Create an object containing the function of which we whish to obtain the root from.
+        boost::shared_ptr< basic_mathematics::FunctionProxy< ScalarType, ScalarType > > rootFunction
+                = boost::make_shared< basic_mathematics::FunctionProxy< ScalarType, ScalarType >  >(
+                    boost::bind( &computeKeplersFunctionForEllipticalOrbits< ScalarType >, _1,
+                                 eccentricity, meanAnomaly ) );
+
+        // Add the first derivative of the root function.
+        rootFunction->addBinding(
+                    -1, boost::bind(
+                        &computeFirstDerivativeKeplersFunctionForEllipticalOrbits< ScalarType >, _1,
+                        eccentricity ) );
+
+        // Declare initial guess.
+        ScalarType initialGuess = TUDAT_NAN;
+
+        // Set the initial guess. Check if the default scheme is to be used or a user specified
+        // value should be used.
+        // !!!!!!!!!!!!!     IMPORTANT     !!!!!!!!!!!!!
+        // If this scheme is changed, please run a very extensive test suite. The root finder
+        // function tends to be chaotic for some very specific combinations of mean anomaly and
+        // eccentricity. Various random tests of 100.000.000 samples were done to verify the
+        // functionality of this one, and of another option for the starter: PI. [Musegaas,2012]
+        if ( useDefaultInitialGuess )
+        {
+            if ( meanAnomaly > getPi< ScalarType >( ) )
+            {
+                initialGuess =  meanAnomaly - eccentricity;
+            }
+            else
+            {
+                initialGuess = meanAnomaly + eccentricity;
+            }
+        }
+        else
+        {
+            initialGuess = userSpecifiedInitialGuess;
+        }
+
+        // Set eccentric anomaly based on result of Newton-Raphson root-finding algorithm.
+        eccentricAnomaly = rootFinder->execute( rootFunction, initialGuess );
+    }
+
+    //  Eccentricity is invalid: eccentricity < 0.0 or eccentricity >= 1.0.
+    else
+    {
+        boost::throw_exception(
+                    std::runtime_error(
+                        boost::str( boost::format(
+                                        "Invalid eccentricity. Valid range is 0.0 <= e < 1.0. "
+                                        "Eccentricity was: '%f'." )
+                                    % eccentricity ) ) );
+    }
+
+    // Return eccentric anomaly.
+    return eccentricAnomaly;
+}
+
+
+//! Convert mean anomaly to hyperbolic eccentric anomaly.
+/*!
+ * Converts mean anomaly to hyperbolic eccentric anomaly for hyperbolic orbits for all
+ * eccentricities > 1.0. If the conversion fails or the eccentricity falls outside the valid
+ * range, then double::NaN is returned. Calculated with an accuracy of 1.0e-14 for all
+ * reasonable cases (eccentricities up to 1.0e15, mean anomalies -1.2e12 to 1.2e12, test cases
+ * using doubles).
+ * \param eccentricity Eccentricity of the orbit [-].
+ * \param hyperbolicMeanAnomaly Hyperbolic mean anomaly to convert to eccentric anomaly [rad].
+ * \param useDefaultInitialGuess Boolean specifying whether to use default initial guess [-].
+ * \param userSpecifiedInitialGuess Initial guess for rootfinder [rad].
+ * \param aRootFinder Shared-pointer to the rootfinder that is to be used. Default is
+ *          Newton-Raphson using 1000 iterations as maximum and apprximately 5.0e-15 absolute
+ *          X-tolerance (for doubles; 25 times ScalarType resolution ).
+ *          Higher precision may invoke machine precision problems for some values.
+ * \return Hyperbolic eccentric anomaly.
+ */
+template< typename ScalarType = double >
+ScalarType convertMeanAnomalyToHyperbolicEccentricAnomaly(
+        const ScalarType eccentricity, const ScalarType hyperbolicMeanAnomaly,
+        const bool useDefaultInitialGuess = true,
+        const ScalarType userSpecifiedInitialGuess = TUDAT_NAN,
+        boost::shared_ptr< root_finders::RootFinderCore< ScalarType > > aRootFinder =
+        boost::shared_ptr< root_finders::RootFinderCore< ScalarType > >( ) )
+{
+    using namespace mathematical_constants;
+    using namespace root_finders;
+    using namespace root_finders::termination_conditions;
+
+    boost::shared_ptr< RootFinderCore< ScalarType > > rootFinder = aRootFinder;
+
+    // Required because the make_shared in the function definition gives problems for MSVC.
+    if ( !rootFinder.get( ) )
+    {
+        rootFinder = boost::make_shared< NewtonRaphsonCore< ScalarType > >(
+                    boost::bind(
+                        &RootAbsoluteToleranceTerminationCondition< ScalarType >::
+                        checkTerminationCondition,
+                        boost::make_shared<
+                        RootAbsoluteToleranceTerminationCondition< ScalarType > >(
+                            25.0 * std::numeric_limits< ScalarType >::epsilon( ), 1000 ),
+                        _1, _2, _3, _4, _5 ) );
+    }
+    // Declare hyperbolic eccentric anomaly.
+    ScalarType hyperbolicEccentricAnomaly = TUDAT_NAN;
+
+    // Check if orbit is hyperbolic.
+    if ( eccentricity > getFloatingInteger< ScalarType >( 1 ) )
+    {
+        // Create an object containing the function of which we whish to obtain the root from.
+        boost::shared_ptr< basic_mathematics::FunctionProxy< ScalarType, ScalarType > > rootFunction
+                = boost::make_shared< basic_mathematics::FunctionProxy< ScalarType, ScalarType > >(
+                    boost::bind( &computeKeplersFunctionForHyperbolicOrbits< ScalarType >, _1,
+                                 eccentricity, hyperbolicMeanAnomaly ) );
+
+        // Add the first derivative of the root function.
+        rootFunction->addBinding(
+                    -1, boost::bind(
+                        &computeFirstDerivativeKeplersFunctionForHyperbolicOrbits< ScalarType >,
+                        _1, eccentricity ) );
+
+        // Declare initial guess.
+        ScalarType initialGuess = TUDAT_NAN;
+
+        // Set the initial guess. Check if the default scheme is to be used or a user specified
+        // value should be used. See [Wakker, 2007] for derivations of the default values.
+        // Note that an error was detected in these starter values, as is discussed in
+        // [Musegaas,2012].
+        // !!!!!!!!!!!!!     IMPORTANT     !!!!!!!!!!!!!
+        // If this scheme is changed, please run a very extensive test suite. The root finder
+        // function tends to be chaotic for some very specific combinations of mean anomaly and
+        // eccentricity. Various random tests of 100.000.000 samples were done to verify the
+        // functionality of this one. [Musegaas,2012]
+        if ( useDefaultInitialGuess )
+        {
+            if ( std::abs( hyperbolicMeanAnomaly ) <
+                 getFloatingInteger< ScalarType >( 6 ) * eccentricity )
+            {
+                initialGuess =
+                        std::sqrt( getFloatingInteger< ScalarType >( 8 ) *
+                                   ( eccentricity - getFloatingInteger< ScalarType >( 1 ) ) /
+                                   eccentricity ) *
+                        std::sinh( getFloatingFraction< ScalarType >( 1, 3 ) * boost::math::asinh(
+                                       getFloatingInteger< ScalarType >( 3 ) *
+                                       hyperbolicMeanAnomaly /
+                                       ( std::sqrt( getFloatingInteger< ScalarType >( 8 ) *
+                                                    ( eccentricity -
+                                                      getFloatingInteger< ScalarType >( 1 ) ) /
+                                                    eccentricity ) *
+                                         ( eccentricity - getFloatingInteger< ScalarType >( 1 )
+                                           ) ) ) );
+            }
+            else if ( hyperbolicMeanAnomaly > getFloatingInteger< ScalarType >( 6 ) * eccentricity )
+            {
+                initialGuess = ( std::log( getFloatingInteger< ScalarType >( 2 ) *
+                                           hyperbolicMeanAnomaly / eccentricity ) );
+            }
+            else
+            {
+                initialGuess = ( - std::log( -getFloatingInteger< ScalarType >( 2 ) *
+                                             hyperbolicMeanAnomaly / eccentricity ) );
+            }
+        }
+        else
+        {
+            initialGuess = userSpecifiedInitialGuess;
+        }
+
+        // Set hyperbolic eccentric anomaly based on result of Newton-Raphson root-finding
+        // algorithm.
+        try
+        {
+            hyperbolicEccentricAnomaly = rootFinder->execute( rootFunction, initialGuess );
+
+        }
+        catch( std::runtime_error )
+        {
+            rootFinder = boost::make_shared< BisectionCore< ScalarType > >(
+                        boost::bind(
+                            &RootAbsoluteToleranceTerminationCondition< ScalarType >::
+                            checkTerminationCondition,
+                            boost::make_shared<
+                            RootAbsoluteToleranceTerminationCondition< ScalarType > >(
+                                20.0 * std::numeric_limits< ScalarType >::epsilon( ), 1000 ),
+                            _1, _2, _3, _4, _5 ), getFloatingInteger< ScalarType >( 0 ),
+                        getFloatingInteger< ScalarType >( 2 ) * getPi< ScalarType >( ) );
+
+            hyperbolicEccentricAnomaly = rootFinder->execute( rootFunction, initialGuess );
+        }
+
+    }
+
+    // In this case the orbit is not hyperbolic.
+    else
+    {
+        boost::throw_exception(
+                    std::runtime_error(
+                        boost::str(
+                            boost::format(
+                                "Invalid eccentricity. Valid range is e > 1.0."
+                                "Eccentricity was: '%f'." )
+                            % eccentricity ) ) );
+    }
+
+    // Return hyperbolic eccentric anomaly.
+    return hyperbolicEccentricAnomaly;
+}
+
+} // namespace orbital_element_conversions
+
+} // namespace tudat
+
+#endif // TUDAT_CONVERT_MEAN_ANOMALY_TO_ECCENTRIC_ANOMALY_H
Index: Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h
===================================================================
--- Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h	(revision 586)
+++ Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h	(revision 588)
@@ -43,6 +43,7 @@
  *      120422    K. Kumar          Added Doxygen notes for Cartesian -> Keplerian conversion.
  *      121205    K. Kumar          Migrated namespace to directory-based protocol and added
  *                                  backwards compatibility.
+ *      150417    D. Dirkx          Made modifications for templated element conversions.
  *
  *    References
  *      Chobotov, V.A. Orbital Mechanics, Third Edition, AIAA Education Series, VA, 2002.
@@ -62,10 +63,17 @@
 #ifndef TUDAT_ORBITAL_ELEMENT_CONVERSIONS_H
 #define TUDAT_ORBITAL_ELEMENT_CONVERSIONS_H
 
+#include <cmath>
+#include <limits>
+#include <numeric>
+
+#include <boost/exception/all.hpp>
+#include <boost/math/special_functions/atanh.hpp>
+
 #include <Eigen/Core>
+#include <Eigen/Geometry>
 
-#include "Tudat/Mathematics/BasicMathematics/linearAlgebra.h"
-#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+#include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
 #include "Tudat/Astrodynamics/BasicAstrodynamics/stateVectorIndices.h"
 
 namespace tudat
@@ -76,27 +84,27 @@
 
 //! Convert Keplerian to Cartesian orbital elements.
 /*!
- * Converts Keplerian to Cartesian orbital elements (Chobotov, 2002). Use the 
- * CartesianElementVectorIndices enum to access the individual orbital element components in the 
+ * Converts Keplerian to Cartesian orbital elements (Chobotov, 2002). Use the
+ * CartesianElementVectorIndices enum to access the individual orbital element components in the
  * storage vector.
  *
  * \param keplerianElements Vector containing Keplerian elements.                         \n
- *          <em>  
- *                          Order of elements is important! \n            
+ *          <em>
+ *                          Order of elements is important! \n
  *                          keplerianElements( 0 ) = semiMajorAxis,                   [m] \n
  *                          keplerianElements( 1 ) = eccentricity,                    [-] \n
  *                          keplerianElements( 2 ) = inclination,                   [rad] \n
  *                          keplerianElements( 3 ) = argument of periapsis,         [rad] \n
  *                          keplerianElements( 4 ) = longitude of ascending node,   [rad] \n
- *                          keplerianElements( 5 ) = true anomaly.                  [rad] \n 
+ *                          keplerianElements( 5 ) = true anomaly.                  [rad] \n
  *          </em>
- *        WARNING: If eccentricity is 1.0 within machine precision, 
- *        keplerianElements( 0 ) = semi-latus rectum.      
- *                                    
- * \param centralBodyGravitationalParameter Gravitational parameter of central body [m^3 s^-2]. 
- *   
+ *        WARNING: If eccentricity is 1.0 within machine precision,
+ *        keplerianElements( 0 ) = semi-latus rectum.
+ *
+ * \param centralBodyGravitationalParameter Gravitational parameter of central body [m^3 s^-2].
+ *
  * \return Converted state in Cartesian elements.                         \n
- *         <em>  
+ *         <em>
  *         Order of elements is important!                                \n
  *         cartesianElements( 0 ) = x-position coordinate,            [m] \n
  *         cartesianElements( 1 ) = y-position coordinate,            [m] \n
@@ -103,15 +111,112 @@
  *         cartesianElements( 2 ) = z-position coordinate,            [m] \n
  *         cartesianElements( 3 ) = x-velocity coordinate,          [m/s] \n
  *         cartesianElements( 4 ) = y-velocity coordinate,          [m/s] \n
- *         cartesianElements( 5 ) = z-velocity coordinate.          [m/s] \n 
+ *         cartesianElements( 5 ) = z-velocity coordinate.          [m/s] \n
  *         </em>
  *
  * \sa CartesianElementVectorIndices()
  */
-basic_mathematics::Vector6d convertKeplerianToCartesianElements(
-        const basic_mathematics::Vector6d& keplerianElements,
-        const double centralBodyGravitationalParameter );
+template< typename ScalarType = double >
+Eigen::Matrix< ScalarType, 6, 1 > convertKeplerianToCartesianElements(
+        const Eigen::Matrix< ScalarType, 6, 1 >& keplerianElements,
+        const ScalarType centralBodyGravitationalParameter )
+{
+    using std::cos;
+    using std::fabs;
+    using std::pow;
+    using std::sin;
+    using std::sqrt;
 
+    // Set tolerance.
+    const ScalarType tolerance_ = std::numeric_limits< ScalarType >::epsilon( );
+
+    // Set local keplerian elements.
+    ScalarType semiMajorAxis_ = keplerianElements( semiMajorAxisIndex );
+    ScalarType eccentricity_ = keplerianElements( eccentricityIndex );
+    ScalarType inclination_ = keplerianElements( inclinationIndex );
+    ScalarType argumentOfPeriapsis_ = keplerianElements( argumentOfPeriapsisIndex );
+    ScalarType longitudeOfAscendingNode_ = keplerianElements( longitudeOfAscendingNodeIndex );
+    ScalarType trueAnomaly_ = keplerianElements( trueAnomalyIndex );
+
+    // Pre-compute sines and cosines of involved angles for efficient computation.
+    ScalarType cosineOfInclination_ = cos( inclination_ );
+    ScalarType sineOfInclination_ = sin( inclination_ );
+    ScalarType cosineOfArgumentOfPeriapsis_ = cos( argumentOfPeriapsis_ );
+    ScalarType sineOfArgumentOfPeriapsis_ = sin( argumentOfPeriapsis_ );
+    ScalarType cosineOfLongitudeOfAscendingNode_ = cos( longitudeOfAscendingNode_ );
+    ScalarType sineOfLongitudeOfAscendingNode_ = sin( longitudeOfAscendingNode_ );
+    ScalarType cosineOfTrueAnomaly_ = cos( trueAnomaly_ );
+    ScalarType sineOfTrueAnomaly_ = sin( trueAnomaly_ );
+
+    // Declare semi-latus rectum.
+    ScalarType semiLatusRectum_ = -mathematical_constants::getFloatingInteger< ScalarType >( 0 );
+
+    // Compute semi-latus rectum in the case it is not a parabola.
+    if ( fabs( eccentricity_ - mathematical_constants::getFloatingInteger< ScalarType >( 1 ) ) >
+         tolerance_  )
+    {
+        semiLatusRectum_ = semiMajorAxis_ * (
+                    mathematical_constants::getFloatingInteger< ScalarType >( 1 ) -
+                    eccentricity_ * eccentricity_ );
+    }
+
+    // Else set the semi-latus rectum given for a parabola as the first element in the vector
+    // of Keplerian elements..
+    else
+    {
+        semiLatusRectum_ = semiMajorAxis_;
+    }
+
+    // Definition of position in the perifocal coordinate system.
+    Eigen::Matrix< ScalarType, 2, 1 > positionPerifocal_;
+    positionPerifocal_.x( ) = semiLatusRectum_ * cosineOfTrueAnomaly_
+            / ( mathematical_constants::getFloatingInteger< ScalarType >( 1 ) +
+                eccentricity_ * cosineOfTrueAnomaly_ );
+    positionPerifocal_.y( ) = semiLatusRectum_ * sineOfTrueAnomaly_
+            / ( mathematical_constants::getFloatingInteger< ScalarType >( 1 ) +
+                eccentricity_ * cosineOfTrueAnomaly_ );
+
+    // Definition of velocity in the perifocal coordinate system.
+    Eigen::Matrix< ScalarType, 2, 1 > velocityPerifocal_(
+                -sqrt( centralBodyGravitationalParameter / semiLatusRectum_ ) * sineOfTrueAnomaly_,
+                sqrt( centralBodyGravitationalParameter / semiLatusRectum_ )
+                * ( eccentricity_ + cosineOfTrueAnomaly_ ) );
+
+    // Definition of the transformation matrix.
+    Eigen::Matrix< ScalarType, 3, 2 > transformationMatrix_;
+
+    // Compute the transformation matrix.
+    transformationMatrix_( 0, 0 ) = cosineOfLongitudeOfAscendingNode_
+            * cosineOfArgumentOfPeriapsis_ -sineOfLongitudeOfAscendingNode_
+            * sineOfArgumentOfPeriapsis_ * cosineOfInclination_;
+    transformationMatrix_( 0, 1 ) = -cosineOfLongitudeOfAscendingNode_
+            * sineOfArgumentOfPeriapsis_ -sineOfLongitudeOfAscendingNode_
+            * cosineOfArgumentOfPeriapsis_ * cosineOfInclination_;
+    transformationMatrix_( 1, 0 ) = sineOfLongitudeOfAscendingNode_
+            * cosineOfArgumentOfPeriapsis_ + cosineOfLongitudeOfAscendingNode_
+            * sineOfArgumentOfPeriapsis_ * cosineOfInclination_;
+    transformationMatrix_( 1, 1 ) = -sineOfLongitudeOfAscendingNode_
+            * sineOfArgumentOfPeriapsis_ + cosineOfLongitudeOfAscendingNode_
+            * cosineOfArgumentOfPeriapsis_ * cosineOfInclination_;
+    transformationMatrix_( 2, 0 ) = sineOfArgumentOfPeriapsis_ * sineOfInclination_;
+    transformationMatrix_( 2, 1 ) = cosineOfArgumentOfPeriapsis_ * sineOfInclination_;
+
+    // Declare converted Cartesian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > convertedCartesianElements_;
+
+    // Compute value of position in Cartesian coordinates.
+    Eigen::Matrix< ScalarType, 3, 1 > position_ = transformationMatrix_ * positionPerifocal_;
+    convertedCartesianElements_.segment( 0, 3 ) = position_;
+
+    // Compute value of velocity in Cartesian coordinates.
+    Eigen::Matrix< ScalarType, 3, 1 > velocity_ = transformationMatrix_ * velocityPerifocal_;
+    convertedCartesianElements_.segment( 3, 3 ) = velocity_;
+
+    // Return Cartesian elements.
+    return convertedCartesianElements_;
+}
+
+
 //! Convert Cartesian to Keplerian orbital elements.
 /*!
  * Converts Cartesian to Keplerian orbital elements.
@@ -148,10 +253,181 @@
  *          modified equinoctial elements also suffer from singularities, but not for zero
  *          eccentricity and inclination.
  */
-basic_mathematics::Vector6d convertCartesianToKeplerianElements(
-        const basic_mathematics::Vector6d& cartesianElements,
-        const double centralBodyGravitationalParameter );
+template< typename ScalarType = double >
+Eigen::Matrix< ScalarType, 6, 1 > convertCartesianToKeplerianElements(
+        const Eigen::Matrix< ScalarType, 6, 1 >& cartesianElements,
+        const ScalarType centralBodyGravitationalParameter )
+{
+    // Set tolerance.
+    const ScalarType tolerance = 20.0 * std::numeric_limits< ScalarType >::epsilon( );
 
+    // Declare converted Keplerian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > computedKeplerianElements_;
+
+    // Set position and velocity vectors.
+    const Eigen::Matrix< ScalarType, 3, 1 > position_( cartesianElements.segment( 0, 3 ) );
+    const Eigen::Matrix< ScalarType, 3, 1 > velocity_( cartesianElements.segment( 3, 3 ) );
+
+    // Compute orbital angular momentum vector.
+    const Eigen::Matrix< ScalarType, 3, 1 > angularMomentum_( position_.cross( velocity_ ) );
+
+    // Compute semi-latus rectum.
+    const ScalarType semiLatusRectum_ = angularMomentum_.squaredNorm( )
+            / centralBodyGravitationalParameter;
+
+    // Compute unit vector to ascending node.
+    Eigen::Matrix< ScalarType, 3, 1 > unitAscendingNodeVector_(
+                ( Eigen::Matrix< ScalarType, 3, 1 >::UnitZ( ).cross(
+                      angularMomentum_.normalized( ) ) ).normalized( ) );
+
+    // Compute eccentricity vector.
+    Eigen::Matrix< ScalarType, 3, 1 > eccentricityVector_(
+                velocity_.cross( angularMomentum_ ) / centralBodyGravitationalParameter
+                - position_.normalized( ) );
+
+    // Store eccentricity.
+    computedKeplerianElements_( eccentricityIndex ) = eccentricityVector_.norm( );
+
+    // Compute and store semi-major axis.
+    // Check if orbit is parabolic. If it is, store the semi-latus rectum instead of the
+    // semi-major axis.
+    if ( std::fabs( computedKeplerianElements_( eccentricityIndex ) -
+                    mathematical_constants::getFloatingInteger< ScalarType >( 1 ) ) < tolerance )
+    {
+        computedKeplerianElements_( semiLatusRectumIndex ) = semiLatusRectum_;
+    }
+
+    // Else the orbit is either elliptical or hyperbolic, so store the semi-major axis.
+    else
+    {
+        computedKeplerianElements_( semiMajorAxisIndex ) = semiLatusRectum_
+                / ( mathematical_constants::getFloatingInteger< ScalarType >( 1 ) -
+                    computedKeplerianElements_( eccentricityIndex )
+                    * computedKeplerianElements_( eccentricityIndex ) );
+    }
+
+    // Compute and store inclination.
+    computedKeplerianElements_( inclinationIndex ) = std::acos( angularMomentum_.z( )
+                                                                / angularMomentum_.norm( ) );
+
+    // Compute and store longitude of ascending node.
+    // Define the quadrant condition for the argument of perigee.
+    ScalarType argumentOfPeriapsisQuandrantCondition = eccentricityVector_.z( );
+
+    // Check if the orbit is equatorial. If it is, set the vector to the line of nodes to the
+    // x-axis.
+    if ( std::fabs( computedKeplerianElements_( inclinationIndex ) ) < tolerance )
+    {
+        unitAscendingNodeVector_ = Eigen::Matrix< ScalarType, 3, 1 >::UnitX( );
+
+        // If the orbit is equatorial, eccentricityVector_.z( ) is zero, therefore the quadrant
+        // condition is taken to be the y-component, eccentricityVector_.y( ).
+        argumentOfPeriapsisQuandrantCondition = eccentricityVector_.y( );
+    }
+
+    // Compute and store the resulting longitude of ascending node.
+    computedKeplerianElements_( longitudeOfAscendingNodeIndex )
+            = std::acos( unitAscendingNodeVector_.x( ) );
+
+    // Check if the quandrant is correct.
+    if ( unitAscendingNodeVector_.y( ) <
+         mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        computedKeplerianElements_( longitudeOfAscendingNodeIndex ) =
+                mathematical_constants::getFloatingInteger< ScalarType >( 2 ) *
+                mathematical_constants::getPi< ScalarType >( ) -
+                computedKeplerianElements_( longitudeOfAscendingNodeIndex );
+    }
+
+    // Compute and store argument of periapsis.
+    // Define the quadrant condition for the true anomaly.
+    ScalarType trueAnomalyQuandrantCondition = position_.dot( velocity_ );
+
+    // Check if the orbit is circular. If it is, set the eccentricity vector to unit vector
+    // pointing to the ascending node, i.e. set the argument of periapsis to zero.
+    if ( std::fabs( computedKeplerianElements_( eccentricityIndex ) ) < tolerance )
+    {
+        eccentricityVector_ = unitAscendingNodeVector_;
+
+        computedKeplerianElements_( argumentOfPeriapsisIndex ) =
+                mathematical_constants::getFloatingInteger< ScalarType >( 0 );
+
+        // Check if orbit is also equatorial and set true anomaly quandrant check condition
+        // accordingly.
+        if ( unitAscendingNodeVector_ == Eigen::Matrix< ScalarType, 3, 1 >::UnitX( ) )
+        {
+            // If the orbit is circular, position_.dot( velocity_ ) = 0, therefore this value
+            // cannot be used as a quadrant condition. Moreover, if the orbit is equatorial,
+            // position_.z( ) is also zero and therefore the quadrant condition is taken to be the
+            // y-component, position_.y( ).
+            trueAnomalyQuandrantCondition = position_.y( );
+        }
+
+        else
+        {
+            // If the orbit is circular, position_.dot( velocity_ ) = 0, therefore the quadrant
+            // condition is taken to be the z-component of the position, position_.z( ).
+            trueAnomalyQuandrantCondition = position_.z( );
+        }
+    }
+
+    // Else, compute the argument of periapsis as the angle between the eccentricity vector and
+    // the unit vector to the ascending node.
+    else
+    {
+        computedKeplerianElements_( argumentOfPeriapsisIndex )
+                = std::acos( eccentricityVector_.normalized( ).dot( unitAscendingNodeVector_ ) );
+
+        // Check if the quadrant is correct.
+        if ( argumentOfPeriapsisQuandrantCondition <
+             mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+        {
+            computedKeplerianElements_( argumentOfPeriapsisIndex ) =
+                    mathematical_constants::getFloatingInteger< ScalarType >( 2 ) *
+                    mathematical_constants::getPi< ScalarType >( ) -
+                    computedKeplerianElements_( argumentOfPeriapsisIndex );
+        }
+    }
+
+    // Compute dot-product of position and eccentricity vectors.
+    ScalarType dotProductPositionAndEccentricityVectors
+            = position_.normalized( ).dot( eccentricityVector_.normalized( ) );
+
+    // Check if the dot-product is one of the limiting cases: 0.0 or 1.0
+    // (within prescribed tolerance).
+    if ( std::fabs( mathematical_constants::getFloatingInteger< ScalarType >( 1 ) -
+                    dotProductPositionAndEccentricityVectors ) < tolerance )
+    {
+        dotProductPositionAndEccentricityVectors =
+                mathematical_constants::getFloatingInteger< ScalarType >( 1 );
+    }
+
+    if ( std::fabs( dotProductPositionAndEccentricityVectors ) < tolerance )
+    {
+        dotProductPositionAndEccentricityVectors  =
+                mathematical_constants::getFloatingInteger< ScalarType >( 0 );
+    }
+
+    // Compute and store true anomaly.
+    computedKeplerianElements_( trueAnomalyIndex )
+            = std::acos( dotProductPositionAndEccentricityVectors );
+
+    // Check if the quandrant is correct.
+    if ( trueAnomalyQuandrantCondition <
+         mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        computedKeplerianElements_( trueAnomalyIndex ) =
+                mathematical_constants::getFloatingInteger< ScalarType >( 2 ) *
+                mathematical_constants::getPi< ScalarType >( ) -
+                computedKeplerianElements_( trueAnomalyIndex );
+    }
+
+    // Return converted Keplerian elements.
+    return computedKeplerianElements_;
+}
+
+
+
 //! Convert true anomaly to (elliptical) eccentric anomaly.
 /*!
  * Converts true anomaly to eccentric anomaly for elliptical orbits ( 0 <= eccentricity < 1.0 ).
@@ -160,9 +436,39 @@
  * \param eccentricity Eccentricity.                                                            [-]
  * \return (Elliptical) Eccentric anomaly.                                                    [rad]
  */
-double convertTrueAnomalyToEllipticalEccentricAnomaly( const double trueAnomaly,
-                                                       const double eccentricity );
+template< typename ScalarType = double >
+ScalarType convertTrueAnomalyToEllipticalEccentricAnomaly(
+        const ScalarType trueAnomaly, const ScalarType eccentricity )
 
+{
+    using std::cos;
+    using std::sqrt;
+    using std::atan2;
+
+    if ( eccentricity >= mathematical_constants::getFloatingInteger< ScalarType >( 1 ) ||
+         eccentricity < mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error( "Eccentricity is invalid." ) ) );
+    }
+    else
+    {
+        // Declare and compute sine and cosine of eccentric anomaly.
+        ScalarType sineOfEccentricAnomaly_ =
+                sqrt( mathematical_constants::getFloatingInteger< ScalarType >( 1 ) -
+                      eccentricity * eccentricity ) * std::sin( trueAnomaly ) /
+                ( mathematical_constants::getFloatingInteger< ScalarType >( 1 ) +
+                  eccentricity * cos( trueAnomaly ) );
+        ScalarType cosineOfEccentricAnomaly_ = ( eccentricity + cos( trueAnomaly ) )
+                / ( mathematical_constants::getFloatingInteger< ScalarType >( 1 ) +
+                    eccentricity * cos( trueAnomaly ) );
+
+        // Return elliptic eccentric anomaly.
+        return atan2( sineOfEccentricAnomaly_, cosineOfEccentricAnomaly_ );
+    }
+}
+
 //! Convert true anomaly to hyperbolic eccentric anomaly.
 /*!
  * Converts true anomaly to hyperbolic eccentric anomaly for hyperbolic orbits
@@ -171,9 +477,40 @@
  * \param eccentricity Eccentricity.                                                            [-]
  * \return Hyperbolic eccentric anomaly.                                                      [rad]
  */
-double convertTrueAnomalyToHyperbolicEccentricAnomaly( const double trueAnomaly,
-                                                       const double eccentricity );
+template< typename ScalarType = double >
+ScalarType convertTrueAnomalyToHyperbolicEccentricAnomaly( const ScalarType trueAnomaly,
+                                                           const ScalarType eccentricity )
+{
+    if ( eccentricity <= mathematical_constants::getFloatingInteger< ScalarType >( 1 ) )
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error( "Eccentricity is invalid." ) ) );
+    }
 
+    else
+    {
+        using std::cos;
+
+        // Compute hyperbolic sine and hyperbolic cosine of hyperbolic eccentric anomaly.
+        ScalarType hyperbolicSineOfHyperbolicEccentricAnomaly_
+                = std::sqrt( eccentricity * eccentricity -
+                             mathematical_constants::getFloatingInteger< ScalarType >( 1 ) )
+                * std::sin( trueAnomaly ) /
+                ( mathematical_constants::getFloatingInteger< ScalarType >( 1 ) +
+                  cos( trueAnomaly ) );
+
+        ScalarType hyperbolicCosineOfHyperbolicEccentricAnomaly_
+                = ( cos( trueAnomaly ) + eccentricity ) /
+                ( mathematical_constants::getFloatingInteger< ScalarType >( 1 ) +
+                  cos( trueAnomaly ) );
+
+        // Return hyperbolic eccentric anomaly.
+        return boost::math::atanh( hyperbolicSineOfHyperbolicEccentricAnomaly_
+                                   / hyperbolicCosineOfHyperbolicEccentricAnomaly_ );
+    }
+}
+
 //! Convert true anomaly to eccentric anomaly.
 /*!
  * Converts true anomaly to eccentric anomaly for elliptical and hyperbolic orbits
@@ -183,24 +520,97 @@
  * eccentricity of the orbit is not known a priori. Currently, this implementation performs a
  * check on the eccentricity and throws an error for eccentricity < 0.0 and parabolic orbits, which
  * have not been implemented. The equations used can be found in (Chobotov, 2002).
- * \param eccentricAnomaly Eccentric anomaly.                                                 [rad]
+ * \param trueAnomaly True anomaly.                                                           [rad]
  * \param eccentricity Eccentricity.                                                            [-]
- * \return True anomaly.                                                                      [rad]
+ * \return Eccentric anomaly.                                                                 [rad]
  */
-double convertTrueAnomalyToEccentricAnomaly( const double eccentricAnomaly,
-                                             const double eccentricity );
+template< typename ScalarType = double >
+ScalarType convertTrueAnomalyToEccentricAnomaly( const ScalarType trueAnomaly,
+                                                 const ScalarType eccentricity )
+{
+    // Declare computed eccentric anomaly.
+    ScalarType eccentricAnomaly_ = 0.0;
 
+    // Check if eccentricity is invalid and throw an error if true.
+    if ( eccentricity < mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error( "Eccentricity is invalid." ) ) );
+    }
+
+    // Check if orbit is parabolic and throw an error if true.
+    else if ( std::fabs( eccentricity -
+                         mathematical_constants::getFloatingInteger< ScalarType >( 1 ) ) <
+              std::numeric_limits< ScalarType >::epsilon( ) )
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error(
+                            "Parabolic orbits have not yet been implemented." ) ) );
+    }
+
+    // Check if orbit is elliptical and compute eccentric anomaly.
+    else if ( eccentricity >= mathematical_constants::getFloatingInteger< ScalarType >( 0 ) &&
+              eccentricity < mathematical_constants::getFloatingInteger< ScalarType >( 1 ) )
+    {
+        eccentricAnomaly_ = convertTrueAnomalyToEllipticalEccentricAnomaly< ScalarType >(
+                    trueAnomaly, eccentricity );
+    }
+
+    else if ( eccentricity > mathematical_constants::getFloatingInteger< ScalarType >( 1 ) )
+    {
+        eccentricAnomaly_ = convertTrueAnomalyToHyperbolicEccentricAnomaly< ScalarType >(
+                    trueAnomaly, eccentricity );
+    }
+
+    // Return computed eccentric anomaly.
+    return eccentricAnomaly_;
+}
+
 //! Convert (elliptical) eccentric anomaly to true anomaly.
 /*!
  * Converts eccentric anomaly to true anomaly for elliptical orbits ( 0 <= eccentricity < 1.0 ).
  * The equations used can be found in (Chobotov, 2002).
- * \param ellipticalEccentricAnomaly Elliptical eccentric anomaly.                            [rad]
+ * \param ellipticEccentricAnomaly Elliptical eccentric anomaly.                              [rad]
  * \param eccentricity Eccentricity.                                                            [-]
  * \return True anomaly.                                                                      [rad]
  */
-double convertEllipticalEccentricAnomalyToTrueAnomaly( const double ellipticalEccentricAnomaly,
-                                                       const double eccentricity );
+template< typename ScalarType = double >
+ScalarType convertEllipticalEccentricAnomalyToTrueAnomaly(
+        const ScalarType ellipticEccentricAnomaly,
+        const ScalarType eccentricity )
+{
+    if ( eccentricity >= mathematical_constants::getFloatingInteger< ScalarType >( 1 ) ||
+         eccentricity < mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error( "Eccentricity is invalid." ) ) );
+    }
 
+    else
+    {
+        using std::cos;
+        using std::sqrt;
+
+        // Compute sine and cosine of true anomaly.
+        ScalarType sineOfTrueAnomaly_ =
+                sqrt( mathematical_constants::getFloatingInteger< ScalarType >( 1 ) -
+                      eccentricity * eccentricity ) *
+                std::sin( ellipticEccentricAnomaly )
+                / ( mathematical_constants::getFloatingInteger< ScalarType >( 1 ) -
+                    eccentricity * cos( ellipticEccentricAnomaly ) );
+
+        ScalarType cosineOfTrueAnomaly_ = ( cos( ellipticEccentricAnomaly ) - eccentricity )
+                / ( mathematical_constants::getFloatingInteger< ScalarType >( 1 ) -
+                    eccentricity * cos( ellipticEccentricAnomaly ) );
+
+        // Return true anomaly.
+        return std::atan2( sineOfTrueAnomaly_, cosineOfTrueAnomaly_  );
+    }
+}
+
 //! Convert hyperbolic eccentric anomaly to true anomaly.
 /*!
  * Converts hyperbolic eccentric anomaly to true anomaly for hyperbolic orbits
@@ -209,9 +619,42 @@
  * \param eccentricity Eccentricity.                                                            [-]
  * \return True anomaly.                                                                      [rad]
  */
-double convertHyperbolicEccentricAnomalyToTrueAnomaly( const double hyperbolicEccentricAnomaly,
-                                                       const double eccentricity );
+template< typename ScalarType = double >
+ScalarType convertHyperbolicEccentricAnomalyToTrueAnomaly(
+        const ScalarType hyperbolicEccentricAnomaly,
+        const ScalarType eccentricity )
+{
+    if ( eccentricity <= mathematical_constants::getFloatingInteger< ScalarType >( 1 ) )
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error( "Eccentricity is invalid." ) ) );
+    }
 
+    else
+    {
+        using std::cosh;
+
+        // Compute sine and cosine of true anomaly.
+        ScalarType sineOfTrueAnomaly_
+                = std::sqrt( eccentricity * eccentricity -
+                             mathematical_constants::getFloatingInteger< ScalarType >( 1 ) )
+                * std::sinh( hyperbolicEccentricAnomaly )
+                / ( eccentricity * cosh( hyperbolicEccentricAnomaly ) -
+                    mathematical_constants::getFloatingInteger< ScalarType >( 1 ) );
+
+        ScalarType cosineOfTrueAnomaly_
+                = ( eccentricity - cosh( hyperbolicEccentricAnomaly ) )
+                / ( eccentricity * cosh( hyperbolicEccentricAnomaly ) -
+                    mathematical_constants::getFloatingInteger< ScalarType >( 1 ) );
+
+        // Return true anomaly.
+        return std::atan2( sineOfTrueAnomaly_, cosineOfTrueAnomaly_ );
+    }
+
+}
+
+
 //! Convert eccentric anomaly to true anomaly.
 /*!
  * Converts eccentric anomaly to true anomaly for elliptical and hyperbolic orbits
@@ -225,9 +668,51 @@
  * \param eccentricity Eccentricity.                                                            [-]
  * \return True anomaly.                                                                      [rad]
  */
-double convertEccentricAnomalyToTrueAnomaly( const double eccentricAnomaly,
-                                             const double eccentricity );
+template< typename ScalarType = double >
+ScalarType convertEccentricAnomalyToTrueAnomaly( const ScalarType eccentricAnomaly,
+                                                 const ScalarType eccentricity )
+{
+    // Declare computed true anomaly.
+    ScalarType trueAnomaly_ = -mathematical_constants::getFloatingInteger< ScalarType >( 0 );
 
+    // Check if eccentricity is invalid and throw an error if true.
+    if ( eccentricity < mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error( "Eccentricity is invalid." ) ) );
+    }
+
+    // Check if orbit is parabolic and throw an error if true.
+    else if ( std::fabs( eccentricity -
+                         mathematical_constants::getFloatingInteger< ScalarType >( 1 ) ) <
+              std::numeric_limits< ScalarType >::epsilon( ) )
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error(
+                            "Parabolic orbits have not yet been implemented." ) ) );
+    }
+
+    // Check if orbit is elliptical and compute true anomaly.
+    else if ( eccentricity >= mathematical_constants::getFloatingInteger< ScalarType >( 0 ) &&
+              eccentricity < mathematical_constants::getFloatingInteger< ScalarType >( 1 ) )
+    {
+        trueAnomaly_ = convertEllipticalEccentricAnomalyToTrueAnomaly( eccentricAnomaly,
+                                                                       eccentricity );
+    }
+
+    else if ( eccentricity > mathematical_constants::getFloatingInteger< ScalarType >( 1 ) )
+    {
+        trueAnomaly_ = convertHyperbolicEccentricAnomalyToTrueAnomaly( eccentricAnomaly,
+                                                                       eccentricity );
+    }
+
+    // Return computed true anomaly.
+    return trueAnomaly_;
+}
+
+
 //! Convert (elliptical) eccentric anomaly to mean anomaly.
 /*!
  * Converts eccentric anomaly to mean anomaly for elliptical orbits ( 0 <= eccentricity < 1.0 ).
@@ -236,9 +721,15 @@
  * \param ellipticalEccentricAnomaly (Elliptical) eccentric anomaly [rad].
  * \return Mean anomaly [rad].
  */
-double convertEllipticalEccentricAnomalyToMeanAnomaly( const double ellipticalEccentricAnomaly,
-                                                       const double eccentricity );
+template< typename ScalarType = double >
+ScalarType convertEllipticalEccentricAnomalyToMeanAnomaly(
+        const ScalarType ellipticalEccentricAnomaly,
+        const ScalarType eccentricity )
+{
+    return ellipticalEccentricAnomaly - eccentricity * std::sin( ellipticalEccentricAnomaly );
+}
 
+
 //! Convert hyperbolic eccentric anomaly to mean anomaly.
 /*!
  * Converts hyperbolic eccentric anomaly to mean anomaly for hyperbolic orbits
@@ -247,8 +738,13 @@
  * \param eccentricity Eccentricity.                                                            [-]
  * \return Mean anomaly.                                                                      [rad]
  */
-double convertHyperbolicEccentricAnomalyToMeanAnomaly( const double hyperbolicEccentricAnomaly,
-                                                       const double eccentricity );
+template< typename ScalarType = double >
+ScalarType convertHyperbolicEccentricAnomalyToMeanAnomaly(
+        const ScalarType hyperbolicEccentricAnomaly,
+        const ScalarType eccentricity )
+{
+    return eccentricity * std::sinh( hyperbolicEccentricAnomaly ) - hyperbolicEccentricAnomaly;
+}
 
 //! Convert eccentric anomaly to mean anomaly.
 /*!
@@ -263,9 +759,52 @@
  * \param eccentricAnomaly Eccentric anomaly.                                                 [rad]
  * \return Mean anomaly.                                                                      [rad]
  */
-double convertEccentricAnomalyToMeanAnomaly( const double eccentricAnomaly,
-                                             const double eccentricity );
+template< typename ScalarType = double >
+ScalarType convertEccentricAnomalyToMeanAnomaly(
+        const ScalarType eccentricAnomaly,
+        const ScalarType eccentricity )
+{
+    // Declare computed mean anomaly.
+    ScalarType meanAnomaly_ = 0.0;
 
+    // Check if eccentricity is invalid and throw an error if true.
+    if ( eccentricity < mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error( "Eccentricity is invalid." ) ) );
+    }
+
+    // Check if orbit is parabolic and throw an error if true.
+    else if ( std::fabs( eccentricity -
+                         mathematical_constants::getFloatingInteger< ScalarType >( 1 ) ) <
+              std::numeric_limits< ScalarType >::epsilon( ) )
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error(
+                            "Parabolic orbits have not yet been implemented." ) ) );
+    }
+
+    // Check if orbit is elliptical and compute true anomaly.
+    else if ( eccentricity >=
+              mathematical_constants::getFloatingInteger< ScalarType >( 0 ) &&
+              eccentricity < mathematical_constants::getFloatingInteger< ScalarType >( 1 ) )
+    {
+        meanAnomaly_ = convertEllipticalEccentricAnomalyToMeanAnomaly< ScalarType >(
+                    eccentricAnomaly, eccentricity );
+    }
+
+    else if ( eccentricity > mathematical_constants::getFloatingInteger< ScalarType >( 1 ) )
+    {
+        meanAnomaly_ = convertHyperbolicEccentricAnomalyToMeanAnomaly< ScalarType >(
+                    eccentricAnomaly, eccentricity );
+    }
+
+    // Return computed mean anomaly.
+    return meanAnomaly_;
+}
+
 //! Convert elapsed time to (elliptical) mean anomaly change.
 /*!
  * Converts elapsed time to mean anomaly change for elliptical orbits ( 0 <= eccentricity < 1.0 ).
@@ -276,10 +815,28 @@
  * \param semiMajorAxis Semi-major axis.                                                        [m]
  * \return (Elliptical) Mean anomaly change.                                                  [rad]
  */
-double convertElapsedTimeToEllipticalMeanAnomalyChange(
-        const double elapsedTime, const double centralBodyGravitationalParameter,
-        const double semiMajorAxis );
+template< typename ScalarType = double >
+ScalarType convertElapsedTimeToEllipticalMeanAnomalyChange(
+        const ScalarType elapsedTime, const ScalarType centralBodyGravitationalParameter,
+        const ScalarType semiMajorAxis )
+{
+    // Check if semi-major axis is invalid and throw error if true.
+    if ( semiMajorAxis < mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error( "Semi-major axis is invalid." ) ) );
+    }
 
+    // Else return elliptical mean anomaly change.
+    else
+    {
+        return std::sqrt( centralBodyGravitationalParameter
+                          / ( semiMajorAxis * semiMajorAxis * semiMajorAxis ) ) * elapsedTime;
+    }
+}
+
+
 //! Convert elapsed time to mean anomaly change for hyperbolic orbits.
 /*!
  * Converts elapsed time to mean anomaly change for hyperbolic orbits ( eccentricity > 1.0 ).
@@ -290,10 +847,27 @@
  * \param semiMajorAxis Semi-major axis.                                                        [m]
  * \return Mean anomaly change.                                                               [rad]
  */
-double convertElapsedTimeToHyperbolicMeanAnomalyChange(
-        const double elapsedTime, const double centralBodyGravitationalParameter,
-        const double semiMajorAxis );
+template< typename ScalarType = double >
+ScalarType convertElapsedTimeToHyperbolicMeanAnomalyChange(
+        const ScalarType elapsedTime, const ScalarType centralBodyGravitationalParameter,
+        const ScalarType semiMajorAxis )
+{
+    // Check if semi-major axis is invalid and throw error if true.
+    if ( semiMajorAxis > mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error( "Semi-major axis is invalid." ) ) );
+    }
 
+    // Else return hyperbolic mean anomaly change.
+    else
+    {
+        return std::sqrt( centralBodyGravitationalParameter
+                          / ( - semiMajorAxis * semiMajorAxis * semiMajorAxis ) ) * elapsedTime;
+    }
+}
+
 //! Convert elapsed time to mean anomaly change.
 /*!
  * Converts elapsed time to mean anomaly change for elliptical and hyperbolic orbits
@@ -307,10 +881,33 @@
  * \param semiMajorAxis Semi-major axis.                                                        [m]
  * \return Mean anomaly change.                                                               [rad]
  */
-double convertElapsedTimeToMeanAnomalyChange(
-        const double elapsedTime, const double centralBodyGravitationalParameter,
-        const double semiMajorAxis );
+template< typename ScalarType = double >
+ScalarType convertElapsedTimeToMeanAnomalyChange(
+        const ScalarType elapsedTime, const ScalarType centralBodyGravitationalParameter,
+        const ScalarType semiMajorAxis )
+{
+    // Declare computed mean anomaly change.
+    ScalarType meanAnomalyChange_ = -mathematical_constants::getFloatingInteger< ScalarType >( 0 );
 
+    // Check if orbit is elliptical and compute mean anomaly change.
+    if ( semiMajorAxis > mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        meanAnomalyChange_ = convertElapsedTimeToEllipticalMeanAnomalyChange(
+                    elapsedTime, centralBodyGravitationalParameter, semiMajorAxis );
+    }
+
+    // Else orbit is hyperbolic; compute mean anomaly change.
+    else if ( semiMajorAxis < mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        meanAnomalyChange_ = convertElapsedTimeToHyperbolicMeanAnomalyChange(
+                    elapsedTime, centralBodyGravitationalParameter, semiMajorAxis );
+    }
+
+    // Return computed mean anomaly change.
+    return meanAnomalyChange_;
+}
+
+
 //! Convert (elliptical) mean anomaly change to elapsed time.
 /*!
  * Converts mean anomaly change to elapsed time for elliptical orbits ( 0 <= eccentricity < 1.0 ).
@@ -321,10 +918,29 @@
  * \param semiMajorAxis Semi-major axis.                                                        [m]
  * \return Elapsed time.                                                                        [s]
  */
-double convertEllipticalMeanAnomalyChangeToElapsedTime(
-        const double ellipticalMeanAnomalyChange, const double centralBodyGravitationalParameter,
-        const double semiMajorAxis );
+template< typename ScalarType = double >
+ScalarType convertEllipticalMeanAnomalyChangeToElapsedTime(
+        const ScalarType ellipticalMeanAnomalyChange,
+        const ScalarType centralBodyGravitationalParameter,
+        const ScalarType semiMajorAxis )
+{
+    // Check if semi-major axis is invalid and throw error if true.
+    if ( semiMajorAxis < mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error( "Semi-major axis is invalid." ) ) );
+    }
 
+    // Else return elapsed time.
+    else
+    {
+        return ellipticalMeanAnomalyChange * std::sqrt(
+                    semiMajorAxis * semiMajorAxis * semiMajorAxis
+                    / centralBodyGravitationalParameter );
+    }
+}
+
 //! Convert hyperbolic mean anomaly change to elapsed time.
 /*!
  * Converts mean anomaly change to elapsed time for hyperbolic orbits ( eccentricity > 1.0 ).
@@ -335,10 +951,28 @@
  * \param semiMajorAxis Semi-major axis.                                                        [m]
  * \return Elapsed time.                                                                        [s]
  */
-double convertHyperbolicMeanAnomalyChangeToElapsedTime(
-        const double hyperbolicMeanAnomalyChange, const double centralBodyGravitationalParameter,
-        const double semiMajorAxis );
+template< typename ScalarType = double >
+ScalarType convertHyperbolicMeanAnomalyChangeToElapsedTime(
+        const ScalarType hyperbolicMeanAnomalyChange,
+        const ScalarType centralBodyGravitationalParameter,
+        const ScalarType semiMajorAxis )
+{
+    // Check if semi-major axis is invalid and throw error if true.
+    if ( semiMajorAxis > mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error( "Semi-major axis is invalid." ) ) );
+    }
 
+    // Else return elapsed time.
+    else
+    {
+        return std::sqrt( -semiMajorAxis * semiMajorAxis * semiMajorAxis
+                          / centralBodyGravitationalParameter ) * hyperbolicMeanAnomalyChange;
+    }
+}
+
 //! Convert mean anomaly change to elapsed time.
 /*!
  * Converts mean anomaly change to elapsed time for elliptical and hyperbolic orbits
@@ -352,10 +986,32 @@
  * \param semiMajorAxis Semi-major axis.                                                        [m]
  * \return Elapsed time.                                                                        [s]
  */
-double convertMeanAnomalyChangeToElapsedTime(
-        const double meanAnomalyChange, const double centralBodyGravitationalParameter,
-        const double semiMajorAxis );
+template< typename ScalarType = double >
+ScalarType convertMeanAnomalyChangeToElapsedTime(
+        const ScalarType meanAnomalyChange, const ScalarType centralBodyGravitationalParameter,
+        const ScalarType semiMajorAxis )
+{
+    // Declare computed elapsed time.
+    ScalarType elapsedTime_ = mathematical_constants::getFloatingInteger< ScalarType >( 0 );
 
+    // Check if orbit is elliptical and compute elapsed time.
+    if ( semiMajorAxis > mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        elapsedTime_ = convertEllipticalMeanAnomalyChangeToElapsedTime< ScalarType >(
+                    meanAnomalyChange, centralBodyGravitationalParameter, semiMajorAxis );
+    }
+
+    // Else orbit is hyperbolic; compute elapsed time.
+    else if ( semiMajorAxis < mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        elapsedTime_ = convertHyperbolicMeanAnomalyChangeToElapsedTime< ScalarType >(
+                    meanAnomalyChange, centralBodyGravitationalParameter, semiMajorAxis );
+    }
+
+    // Return computed elapsed time.
+    return elapsedTime_;
+}
+
 //! Convert (elliptical) mean motion to semi-major axis.
 /*!
  * Converts mean motion to semi-major axis for elliptical orbits.
@@ -363,8 +1019,14 @@
  * \param centralBodyGravitationalParameter Gravitational parameter of central body.      [m^3/s^2]
  * \return semiMajorAxis Semi-major axis.                                                       [m]
  */
-double convertEllipticalMeanMotionToSemiMajorAxis(
-        const double ellipticalMeanMotion, const double centralBodyGravitationalParameter );
+template< typename ScalarType = double >
+ScalarType convertEllipticalMeanMotionToSemiMajorAxis(
+        const ScalarType ellipticalMeanMotion, const ScalarType centralBodyGravitationalParameter )
+{
+    return std::pow( centralBodyGravitationalParameter
+                     / ( ellipticalMeanMotion * ellipticalMeanMotion ),
+                     mathematical_constants::getFloatingFraction< ScalarType >( 1, 3 ) );
+}
 
 //! Convert semi-major axis to elliptical mean motion.
 /*!
@@ -373,9 +1035,24 @@
  * \param centralBodyGravitationalParameter Gravitational parameter of central body.      [m^3/s^2]
  * \return ellipticalMeanMotion (Elliptical) Mean motion.                                   [rad/s]
  */
-double convertSemiMajorAxisToEllipticalMeanMotion(
-        const double semiMajorAxis, const double centralBodyGravitationalParameter );
+template< typename ScalarType = double >
+ScalarType convertSemiMajorAxisToEllipticalMeanMotion(
+        const ScalarType semiMajorAxis, const ScalarType centralBodyGravitationalParameter )
+{
+    // Check if semi-major axis is invalid and throw error if true.
+    if ( semiMajorAxis < mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error( "Semi-major axis is invalid." ) ) );
+    }
 
+    // Else compute and return elliptical mean motion.
+    {
+        return std::sqrt( centralBodyGravitationalParameter /
+                          ( semiMajorAxis * semiMajorAxis * semiMajorAxis ) );
+    }
+}
 } // namespace orbital_element_conversions
 
 } // namespace tudat
Index: Tudat/Astrodynamics/BasicAstrodynamics/stateVectorIndices.h
===================================================================
--- Tudat/Astrodynamics/BasicAstrodynamics/stateVectorIndices.h	(revision 586)
+++ Tudat/Astrodynamics/BasicAstrodynamics/stateVectorIndices.h	(revision 588)
@@ -44,12 +44,12 @@
 //! Keplerian elements indices.
 enum CartesianElementIndices
 {
-    xCartesianPositionIndex,
-    yCartesianPositionIndex,
-    zCartesianPositionIndex,
-    xCartesianVelocityIndex,
-    yCartesianVelocityIndex,
-    zCartesianVelocityIndex
+    xCartesianPositionIndex = 0,
+    yCartesianPositionIndex = 1,
+    zCartesianPositionIndex = 2,
+    xCartesianVelocityIndex = 3,
+    yCartesianVelocityIndex = 4,
+    zCartesianVelocityIndex = 5
 };
 
 //! Keplerian elements indices.
Index: Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestOrbitalElementConversions.cpp
===================================================================
--- Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestOrbitalElementConversions.cpp	(revision 586)
+++ Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestOrbitalElementConversions.cpp	(revision 588)
@@ -67,6 +67,7 @@
  *                                  testCartesianToKeplerianElementConversion to avoid failures
  *                                  under Windows. Added check for zero-valued angles in
  *                                  testCartesianToKeplerianElementConversion.
+ *      150417    D. Dirkx          Made modifications for templated element conversions.
  *
  *    References
  *      NASA, Goddard Spaceflight Center. Orbit Determination Toolbox (ODTBX), NASA - GSFC Open
@@ -111,7 +112,7 @@
 namespace unit_tests
 {
 
-using mathematical_constants::PI;
+using namespace mathematical_constants;
 
 BOOST_AUTO_TEST_SUITE( test_orbital_element_conversions )
 
@@ -128,7 +129,7 @@
         const double earthGravitationalParameter = 3.986004415e14;
 
         // Set Keplerian elements [m,-,rad,rad,rad,rad].
-        Eigen::VectorXd keplerianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > keplerianElements ;
         keplerianElements( semiMajorAxisIndex ) = 8000.0 * 1000.0;
         keplerianElements( eccentricityIndex ) = 0.23;
         keplerianElements( inclinationIndex ) = 20.6 / 180.0 * PI;
@@ -137,7 +138,7 @@
         keplerianElements( trueAnomalyIndex ) = 46.11 / 180.0 * PI;
 
         // Set expected Cartesian elements [m,m,m,m/s,m/s,m/s].
-        Eigen::VectorXd expectedCartesianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > expectedCartesianElements;
         expectedCartesianElements( xCartesianPositionIndex ) = 2.021874804243437e6;
         expectedCartesianElements( yCartesianPositionIndex ) = 6.042523817035284e6;
         expectedCartesianElements( zCartesianPositionIndex ) = -1.450371183512575e6;
@@ -146,7 +147,7 @@
         expectedCartesianElements( zCartesianVelocityIndex ) = 2.029066072016241e3;
 
         // Compute Cartesian elements.
-        Eigen::VectorXd computedCartesianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > computedCartesianElements;
         computedCartesianElements = orbital_element_conversions::
                 convertKeplerianToCartesianElements( keplerianElements,
                                                      earthGravitationalParameter );
@@ -166,7 +167,7 @@
         const double marsGravitationalParameter = 4.2828018915e13;
 
         // Set Keplerian elements [m,-,rad,rad,rad,rad].
-        Eigen::VectorXd keplerianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > keplerianElements;
         keplerianElements( semiMajorAxisIndex ) = 9201.61 * 1000.0;
         keplerianElements( eccentricityIndex ) = 0.0;
         keplerianElements( inclinationIndex ) = 0.0;
@@ -175,7 +176,7 @@
         keplerianElements( trueAnomalyIndex ) = -244.09 / 180.0 * PI;
 
         // Set expected Cartesian elements [m,m,m,m/s,m/s,m/s].
-        Eigen::VectorXd expectedCartesianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > expectedCartesianElements;
         expectedCartesianElements( xCartesianPositionIndex ) = 7.968828015716932e6;
         expectedCartesianElements( yCartesianPositionIndex ) = -4.600804999999997e6;
         expectedCartesianElements( zCartesianPositionIndex ) = 0.0;
@@ -184,7 +185,7 @@
         expectedCartesianElements( zCartesianVelocityIndex ) = 0.0;
 
         // Compute Cartesian elements.
-        Eigen::VectorXd computedCartesianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > computedCartesianElements;
         computedCartesianElements = orbital_element_conversions::
                 convertKeplerianToCartesianElements( keplerianElements,
                                                      marsGravitationalParameter );
@@ -204,7 +205,7 @@
         const double sunGravitationalParameter = 1.32712440018e20;
 
         // Set Keplerian elements [m,-,rad,rad,rad,rad].
-        Eigen::VectorXd keplerianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > keplerianElements;
         keplerianElements( semiMajorAxisIndex ) = -4.5e11;
         keplerianElements( eccentricityIndex ) = 2.3;
         keplerianElements( inclinationIndex ) = 25.5 / 180.0 * PI;
@@ -213,7 +214,7 @@
         keplerianElements( trueAnomalyIndex ) = 123.29 / 180.0 * PI;
 
         // Set expected Cartesian elements [m,m,m,m/s,m/s,m/s].
-        Eigen::VectorXd expectedCartesianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > expectedCartesianElements;
         expectedCartesianElements( xCartesianPositionIndex ) = -2.776328224174438e12;
         expectedCartesianElements( yCartesianPositionIndex ) = -6.053823869632723e12;
         expectedCartesianElements( zCartesianPositionIndex ) = 3.124576293512172e12;
@@ -222,7 +223,7 @@
         expectedCartesianElements( zCartesianVelocityIndex ) = -6.923442392618828e3;
 
         // Compute Cartesian elements.
-        Eigen::VectorXd computedCartesianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > computedCartesianElements;
         computedCartesianElements = orbital_element_conversions::
                 convertKeplerianToCartesianElements( keplerianElements,
                                                      sunGravitationalParameter );
@@ -242,7 +243,7 @@
         const double earthGravitationalParameter = 3.986005e14;
 
         // Set Keplerian elements [m,-,rad,rad,rad,rad].
-        Eigen::VectorXd keplerianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > keplerianElements;
         keplerianElements( semiLatusRectumIndex ) = 2.0 * 6678140.0;
         keplerianElements( eccentricityIndex ) = 1.0;
         keplerianElements( inclinationIndex ) = 45.0 / 180.0 * PI;
@@ -254,7 +255,7 @@
         const double expectedEscapeVelocity = 10926.0;
 
         // Compute Cartesian elements.
-        Eigen::VectorXd computedCartesianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > computedCartesianElements;
         computedCartesianElements = orbital_element_conversions::
                 convertKeplerianToCartesianElements( keplerianElements,
                                                      earthGravitationalParameter );
@@ -265,8 +266,9 @@
     }
 }
 
-//! Test if conversion from Cartesian elements to Keplerian elements is working correctly.
-BOOST_AUTO_TEST_CASE( testCartesianToKeplerianElementConversion )
+//! Test if conversion from Cartesian elements to Keplerian elements is working correctly, using
+//! benchmark data.
+BOOST_AUTO_TEST_CASE( testCartesianToKeplerianElementConversionBenchmark )
 {
     // Case 1: Elliptical orbit around the Earth.
     // The benchmark data is obtained by running ODTBX (NASA, 2012).
@@ -278,7 +280,7 @@
         const double earthGravitationalParameter = 3.986004415e14;
 
         // Set Cartesian elements.
-        Eigen::VectorXd cartesianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > cartesianElements;
         cartesianElements( xCartesianPositionIndex ) = 3.75e6;
         cartesianElements( yCartesianPositionIndex ) = 4.24e6;
         cartesianElements( zCartesianPositionIndex ) = -1.39e6;
@@ -287,7 +289,7 @@
         cartesianElements( zCartesianVelocityIndex ) = 1.66e3;
 
         // Set expected Keplerian elements.
-        Eigen::VectorXd expectedKeplerianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > expectedKeplerianElements;
         expectedKeplerianElements( semiMajorAxisIndex ) = 3.707478199246163e6;
         expectedKeplerianElements( eccentricityIndex ) = 0.949175203660321;
         expectedKeplerianElements( inclinationIndex ) = 0.334622356632438;
@@ -296,7 +298,7 @@
         expectedKeplerianElements( trueAnomalyIndex ) = 3.302032232567084;
 
         // Compute Keplerian elements.
-        Eigen::VectorXd computedKeplerianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > computedKeplerianElements;
         computedKeplerianElements = orbital_element_conversions::
                 convertCartesianToKeplerianElements( cartesianElements,
                                                      earthGravitationalParameter );
@@ -316,7 +318,7 @@
         const double venusGravitationalParameter = 3.2485504415e14;
 
         // Set Cartesian elements.
-        Eigen::VectorXd cartesianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > cartesianElements;
         cartesianElements( xCartesianPositionIndex ) = 5.580537430785387e6;
         cartesianElements( yCartesianPositionIndex ) = 2.816487703435473e6;
         cartesianElements( zCartesianPositionIndex ) = 0.0;
@@ -325,7 +327,7 @@
         cartesianElements( zCartesianVelocityIndex ) = 0.0;
 
         // Set expected Keplerian elements.
-        Eigen::VectorXd expectedKeplerianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > expectedKeplerianElements;
         expectedKeplerianElements( semiMajorAxisIndex ) = 6.251e6;
         expectedKeplerianElements( eccentricityIndex ) = 0.0;
         expectedKeplerianElements( inclinationIndex ) = 0.0;
@@ -334,7 +336,7 @@
         expectedKeplerianElements( trueAnomalyIndex ) = 26.78 / 180.0 * PI;
 
         // Declare and compute converted Keplerian elements.
-        Eigen::VectorXd computedKeplerianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > computedKeplerianElements;
         computedKeplerianElements = orbital_element_conversions::
                 convertCartesianToKeplerianElements( cartesianElements,
                                                      venusGravitationalParameter );
@@ -375,7 +377,7 @@
         const double sunGravitationalParameter = 1.32712440018e20;
 
         // Declare and set Cartesian elements.
-        Eigen::VectorXd cartesianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > cartesianElements;
         cartesianElements( xCartesianPositionIndex ) = 7.035635643405699e11;
         cartesianElements( yCartesianPositionIndex ) = -2.351218213055550e11;
         cartesianElements( zCartesianPositionIndex ) = 0.037960971564309e11;
@@ -384,7 +386,7 @@
         cartesianElements( zCartesianVelocityIndex ) = 0.423498718768347e4;
 
         // Set expected Keplerian elements.
-        Eigen::VectorXd expectedKeplerianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > expectedKeplerianElements;
         expectedKeplerianElements( semiMajorAxisIndex ) = -6.78e11;
         expectedKeplerianElements( eccentricityIndex ) = 1.89;
         expectedKeplerianElements( inclinationIndex ) = 167.91 / 180 * PI;
@@ -393,7 +395,7 @@
         expectedKeplerianElements( trueAnomalyIndex ) = 315.62 / 180.0 * PI;
 
         // Compute Keplerian elements.
-        Eigen::VectorXd computedKeplerianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > computedKeplerianElements;
         computedKeplerianElements = orbital_element_conversions::
                 convertCartesianToKeplerianElements( cartesianElements,
                                                      sunGravitationalParameter );
@@ -403,44 +405,7 @@
                                            computedKeplerianElements, 1.0e-15 );
     }
 
-    // Case 4: Parabolic orbit around the Sun.
-    // This test is based on converting Keplerian elements to Cartesian element and then
-    // recomputing the input Keplerian element values. Ideally, an independent check will replace
-    // this test in future.
-    {
-        // Using declarations.
-        using namespace orbital_element_conversions;
-
-        // Set Earth gravitational parameter [m^3/s^2].
-        const double earthGravitationalParameter = 3.986005e14;
-
-        // Set Keplerian elements [m,-,rad,rad,rad,rad].
-        Eigen::VectorXd keplerianElements( 6 );
-        keplerianElements( semiLatusRectumIndex ) = 2.0 * 6678140.0;
-        keplerianElements( eccentricityIndex ) = 1.0;
-        keplerianElements( inclinationIndex ) = 45.0 / 180.0 * PI;
-        keplerianElements( argumentOfPeriapsisIndex ) = 0.0;
-        keplerianElements( longitudeOfAscendingNodeIndex ) = 0.0;
-        keplerianElements( trueAnomalyIndex ) = 0.0;
-
-        // Compute Cartesian elements.
-        Eigen::VectorXd computedCartesianElements( 6 );
-        computedCartesianElements = orbital_element_conversions::
-                convertKeplerianToCartesianElements( keplerianElements,
-                                                     earthGravitationalParameter );
-
-        // Recompute Keplerian elements.
-        Eigen::VectorXd recomputedKeplerianElements( 6 );
-        recomputedKeplerianElements = orbital_element_conversions::
-                convertCartesianToKeplerianElements( computedCartesianElements,
-                                                     earthGravitationalParameter );
-
-        // Check if recomputed Keplerian elements match the expected values.
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( keplerianElements,
-                                           recomputedKeplerianElements, 1.0e-15 );
-    }
-
-    // Case 5: Low-eccentricity, low-inclination orbit around Uranus.
+    // Case 4: Low-eccentricity, low-inclination orbit around Uranus.
     // The benchmark data is obtained by running Keplerian Toolbox (ESA, 2012). It is important to
     // note that Keplerian Toolbox uses a different order of elements than Tudat (argument of
     // periapsis and longitude of ascending node positions in vector are switched). Not all values
@@ -456,7 +421,7 @@
         const double uranusGravitationalParameter = 5.793943348799999e15;
 
         // Declare and set Cartesian elements.
-        Eigen::VectorXd cartesianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > cartesianElements;
         cartesianElements( xCartesianPositionIndex ) = -33760437.1526459;
         cartesianElements( yCartesianPositionIndex ) = -91719029.3283878;
         cartesianElements( zCartesianPositionIndex ) = -757.744826269064;
@@ -465,7 +430,7 @@
         cartesianElements( zCartesianVelocityIndex ) = -0.0486289999748532;
 
         // Set expected Keplerian elements.
-        Eigen::VectorXd expectedKeplerianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > expectedKeplerianElements;
         expectedKeplerianElements( semiMajorAxisIndex ) = 97736000.0;
         expectedKeplerianElements( eccentricityIndex ) = 1.0e-5;
         expectedKeplerianElements( inclinationIndex ) = 1.0e-5;
@@ -474,7 +439,7 @@
         expectedKeplerianElements( trueAnomalyIndex ) = 5.914936209560839;
 
         // Compute Keplerian elements.
-        Eigen::VectorXd computedKeplerianElements( 6 );
+        Eigen::Matrix< double, 6, 1 > computedKeplerianElements;
         computedKeplerianElements = orbital_element_conversions::
                 convertCartesianToKeplerianElements( cartesianElements,
                                                      uranusGravitationalParameter );
@@ -505,204 +470,362 @@
                                     1.0e-6 );
     }
 
-    // Case 6: Converting to and fro between Keplerian and Cartesian elements for a
-    // zero-eccentricity, zero-inclination orbit (circular, equatorial) around the Earth. This
-    // test ensures internal consistency within Tudat between the Cartesian <-> Keplerian element
-    // converters.
-    {
-        // Using declarations.
-        using namespace orbital_element_conversions;
+}
 
-        // Earth gravitational parameter [m^3 s^-2].
-        const double earthGravitationalParameter = 3.9859383624e14;
+//! Test back and forth Kepler <-> Cartesian conversion for parabolic orbit
+template< typename ScalarType >
+void convertParabolicOrbitBackAndForth(
+        const ScalarType tolerance )
+{
+    // Using declarations.
+    using namespace orbital_element_conversions;
 
-        // Set Keplerian elements.
-        Eigen::VectorXd keplerianElements( 6 );
-        keplerianElements( semiMajorAxisIndex ) = 8000.0;
-        keplerianElements( eccentricityIndex ) = 0.0;
-        keplerianElements( inclinationIndex ) = 0.0;
-        keplerianElements( argumentOfPeriapsisIndex ) = 243 / 180.0 * PI;
-        keplerianElements( longitudeOfAscendingNodeIndex ) = -79.6 / 180.0 * PI;
-        keplerianElements( trueAnomalyIndex ) = 126.45 / 180.0 * PI;
+    // Set Earth gravitational parameter [m^3/s^2].
+    const ScalarType earthGravitationalParameter = 3.986005e14;
 
-        // Convert Keplerian elements to Cartesian elements.
-        Eigen::VectorXd computedCartesianElements( 6 );
-        computedCartesianElements = orbital_element_conversions::
-                convertKeplerianToCartesianElements( keplerianElements,
-                                                     earthGravitationalParameter );
+    // Set Keplerian elements [m,-,rad,rad,rad,rad].
+    Eigen::Matrix< ScalarType, 6, 1 > keplerianElements;
+    keplerianElements( semiLatusRectumIndex ) = static_cast< ScalarType >(
+                2.0 * 6678140.0 );
+    keplerianElements( eccentricityIndex ) = getFloatingInteger< ScalarType >( 1 );
+    keplerianElements( inclinationIndex ) = static_cast< ScalarType >(
+                45.0 / 180.0 * PI );
+    keplerianElements( argumentOfPeriapsisIndex ) = getFloatingInteger< ScalarType >( 0 );
+    keplerianElements( longitudeOfAscendingNodeIndex ) = getFloatingInteger< ScalarType >( 0 );
+    keplerianElements( trueAnomalyIndex ) = getFloatingInteger< ScalarType >( 0 );
 
-        // Convert Cartesian elements back to Keplerian elements.
-        Eigen::VectorXd recomputedKeplerianElements( 6 );
-        recomputedKeplerianElements = orbital_element_conversions::
-                convertCartesianToKeplerianElements( computedCartesianElements,
-                                                     earthGravitationalParameter );
+    // Compute Cartesian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > computedCartesianElements =
+            convertKeplerianToCartesianElements< ScalarType >(
+                keplerianElements, earthGravitationalParameter );
 
-        // Check that recomputed Keplerian elements match the input values. (In this limit case,
-        // the argument of periapsis and longitude of ascending node are set to zero, and the
-        // true anomaly "absorbs" everything).
-        BOOST_CHECK_CLOSE_FRACTION( keplerianElements( semiMajorAxisIndex ),
-                                    recomputedKeplerianElements( semiMajorAxisIndex ),
-                                    1.0e-15 );
+    // Recompute Keplerian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > recomputedKeplerianElements =
+            convertCartesianToKeplerianElements< ScalarType >(
+                computedCartesianElements, earthGravitationalParameter );
 
-        BOOST_CHECK_SMALL( recomputedKeplerianElements( eccentricityIndex ), 1.0e-15 );
+    // Check if recomputed Keplerian elements match the expected values.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( keplerianElements,
+                                       recomputedKeplerianElements, tolerance );
 
-        BOOST_CHECK_SMALL( recomputedKeplerianElements( inclinationIndex ),
-                           std::numeric_limits< double >::epsilon( ) );
+    // Convert recomputed Keplerian elements to Cartesian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > recomputedCartesianElements =
+            convertKeplerianToCartesianElements(
+                recomputedKeplerianElements, earthGravitationalParameter );
 
-        BOOST_CHECK_SMALL( recomputedKeplerianElements( argumentOfPeriapsisIndex ),
-                           std::numeric_limits< double >::epsilon( ) );
+    // Check that computed Cartesian elements match.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                computedCartesianElements, recomputedCartesianElements, ( 10.0 * tolerance ) );
+}
 
-        BOOST_CHECK_SMALL( recomputedKeplerianElements( longitudeOfAscendingNodeIndex ),
-                           std::numeric_limits< double >::epsilon( ) );
+//! Test back and forth Kepler <-> Cartesian conversion for circular equatorial orbit
+template< typename ScalarType >
+void convertCircularEquatorialOrbitBackAndForth(
+        const ScalarType tolerance )
+{
+    // Using declarations.
+    using namespace orbital_element_conversions;
 
-        BOOST_CHECK_CLOSE_FRACTION( std::fmod( keplerianElements( argumentOfPeriapsisIndex )
-                                               + keplerianElements( longitudeOfAscendingNodeIndex )
-                                               + keplerianElements( trueAnomalyIndex ), 2.0 * PI ),
-                                    recomputedKeplerianElements( trueAnomalyIndex ),
-                                    std::numeric_limits< double >::epsilon( ) );
+    // Earth gravitational parameter [m^3 s^-2].
+    const ScalarType earthGravitationalParameter = 3.9859383624e14;
 
-        // Convert recomputed Keplerian elements to Cartesian elements.
-        Eigen::VectorXd recomputedCartesianElements( 6 );
-        recomputedCartesianElements = orbital_element_conversions::
-                convertKeplerianToCartesianElements( recomputedKeplerianElements,
-                                                     earthGravitationalParameter );
+    // Set Keplerian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > keplerianElements;
+    keplerianElements( semiMajorAxisIndex ) =
+            static_cast< ScalarType >( 8000.0 );
+    keplerianElements( eccentricityIndex ) = getFloatingInteger< ScalarType >( 0 );
+    keplerianElements( inclinationIndex ) = getFloatingInteger< ScalarType >( 0 );
+    keplerianElements( argumentOfPeriapsisIndex ) =
+            static_cast< ScalarType >( 243.0 / 180.0 * PI );
+    keplerianElements( longitudeOfAscendingNodeIndex ) =
+            static_cast< ScalarType >( -79.6 / 180.0 * PI );
+    keplerianElements( trueAnomalyIndex ) =
+            static_cast< ScalarType >( 126.45 / 180.0 * PI );
 
-        // Check that computed Cartesian elements match.
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( computedCartesianElements, recomputedCartesianElements,
-                                           1.0e-14 );
-    }
+    // Convert Keplerian elements to Cartesian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > computedCartesianElements;
+    computedCartesianElements = convertKeplerianToCartesianElements< ScalarType >(
+                keplerianElements, earthGravitationalParameter );
 
-    // Case 7: Converting to and fro between Keplerian and Cartesian elements for a
-     // zero-eccentricity, non-zero-inclination orbit (circular, inclined) around the Earth. This
-    // test ensures internal consistency within Tudat between the Cartesian <-> Keplerian element
-    // converters.
-    {
-        // Using declarations.
-        using namespace orbital_element_conversions;
+    // Convert Cartesian elements back to Keplerian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > recomputedKeplerianElements;
+    recomputedKeplerianElements = convertCartesianToKeplerianElements< ScalarType >(
+                computedCartesianElements, earthGravitationalParameter );
 
-        // Earth gravitational parameter [m^3 s^-2].
-        const double earthGravitationalParameter = 3.9859383624e14;
+    // Check that recomputed Keplerian elements match the input values. (In this limit case,
+    // the argument of periapsis and longitude of ascending node are set to zero, and the
+    // true anomaly "absorbs" everything).
+    BOOST_CHECK_CLOSE_FRACTION( keplerianElements( semiMajorAxisIndex ),
+                                recomputedKeplerianElements( semiMajorAxisIndex ),
+                                tolerance );
 
-        // Set Keplerian elements.
-        Eigen::VectorXd keplerianElements( 6 );
-        keplerianElements( semiMajorAxisIndex ) = 8000.0;
-        keplerianElements( eccentricityIndex ) = 0.0;
-        keplerianElements( inclinationIndex ) = 176.11 / 180.0 * PI;
-        keplerianElements( argumentOfPeriapsisIndex ) = 243 / 180.0 * PI;
-        keplerianElements( longitudeOfAscendingNodeIndex ) = -79.6 / 180.0 * PI;
-        keplerianElements( trueAnomalyIndex ) = 126.45 / 180.0 * PI;
+    BOOST_CHECK_SMALL( recomputedKeplerianElements( eccentricityIndex ), tolerance );
 
-        // Convert Keplerian elements to Cartesian elements.
-        Eigen::VectorXd computedCartesianElements( 6 );
-        computedCartesianElements = orbital_element_conversions::
-                convertKeplerianToCartesianElements( keplerianElements,
-                                                     earthGravitationalParameter );
+    BOOST_CHECK_SMALL( recomputedKeplerianElements( inclinationIndex ),
+                       std::numeric_limits< ScalarType >::epsilon( ) );
 
-        // Convert Cartesian elements back to Keplerian elements.
-        Eigen::VectorXd recomputedKeplerianElements( 6 );
-        recomputedKeplerianElements = orbital_element_conversions::
-                convertCartesianToKeplerianElements( computedCartesianElements,
-                                                     earthGravitationalParameter );
+    BOOST_CHECK_SMALL( recomputedKeplerianElements( argumentOfPeriapsisIndex ),
+                       std::numeric_limits< ScalarType >::epsilon( ) );
 
-        // Check that recomputed Keplerian elements match the input values. (In this limit case,
-        // the argument of periapsis is set to zero, and the true anomaly "absorbs" this).
-        BOOST_CHECK_CLOSE_FRACTION( keplerianElements( semiMajorAxisIndex ),
-                                    recomputedKeplerianElements( semiMajorAxisIndex ), 1.0e-15 );
+    BOOST_CHECK_SMALL( recomputedKeplerianElements( longitudeOfAscendingNodeIndex ),
+                       std::numeric_limits< ScalarType >::epsilon( ) );
 
-        BOOST_CHECK_SMALL( recomputedKeplerianElements( eccentricityIndex ), 1.0e-15 );
+    BOOST_CHECK_CLOSE_FRACTION( std::fmod(
+                                    keplerianElements( argumentOfPeriapsisIndex )
+                                    + keplerianElements( longitudeOfAscendingNodeIndex )
+                                    + keplerianElements( trueAnomalyIndex ), 2.0 * PI ),
+                                recomputedKeplerianElements( trueAnomalyIndex ),
+                                std::numeric_limits< ScalarType >::epsilon( ) );
 
-        BOOST_CHECK_CLOSE_FRACTION( keplerianElements( inclinationIndex ),
-                                    recomputedKeplerianElements( inclinationIndex ), 1.0e-15 );
+    // Convert recomputed Keplerian elements to Cartesian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > recomputedCartesianElements =
+            convertKeplerianToCartesianElements(
+                recomputedKeplerianElements, earthGravitationalParameter );
 
-        BOOST_CHECK_SMALL( recomputedKeplerianElements( argumentOfPeriapsisIndex ),
-                           std::numeric_limits< double >::epsilon( ) );
+    // Check that computed Cartesian elements match.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                computedCartesianElements, recomputedCartesianElements, ( 10.0 * tolerance ) );
+}
 
-        BOOST_CHECK_CLOSE_FRACTION(
-                    keplerianElements( longitudeOfAscendingNodeIndex ) + 2.0 * PI,
-                    recomputedKeplerianElements( longitudeOfAscendingNodeIndex ), 1.0e-15 );
+//! Test back and forth Kepler <-> Cartesian conversion for circular non-equatorial orbit
+template< typename ScalarType >
+void convertCircularNonEquatorialOrbitBackAndForth(
+        const ScalarType tolerance )
+{
+    // Using declarations.
+    using namespace orbital_element_conversions;
 
-        BOOST_CHECK_CLOSE_FRACTION( std::fmod( keplerianElements( argumentOfPeriapsisIndex )
-                                               + keplerianElements( trueAnomalyIndex ), 2.0 * PI ),
-                                    recomputedKeplerianElements( trueAnomalyIndex ), 1.0e-14 );
+    // Earth gravitational parameter [m^3 s^-2].
+    const ScalarType earthGravitationalParameter = 3.9859383624e14;
 
-        // Convert recomputed Keplerian elements to Cartesian elements.
-        Eigen::VectorXd recomputedCartesianElements( 6 );
-        recomputedCartesianElements = orbital_element_conversions::
-                convertKeplerianToCartesianElements( recomputedKeplerianElements,
-                                                     earthGravitationalParameter );
+    // Set Keplerian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > keplerianElements;
+    keplerianElements( semiMajorAxisIndex ) = static_cast< ScalarType >( 8000.0 );
+    keplerianElements( eccentricityIndex ) =  getFloatingInteger< ScalarType >( 0 );
+    keplerianElements( inclinationIndex ) = static_cast< ScalarType >( 176.11 / 180.0 * PI );
+    keplerianElements( argumentOfPeriapsisIndex ) =
+            static_cast< ScalarType >(  243.0 / 180.0 * PI );
+    keplerianElements( longitudeOfAscendingNodeIndex ) =
+            static_cast< ScalarType >( -79.6 / 180.0 * PI );
+    keplerianElements( trueAnomalyIndex ) =
+            static_cast< ScalarType >( 126.45 / 180.0 * PI );
 
-        // Check that computed Cartesian elements match.
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( computedCartesianElements, recomputedCartesianElements,
-                                           1.0e-13 );
-    }
+    // Convert Keplerian elements to Cartesian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > computedCartesianElements =
+            convertKeplerianToCartesianElements< ScalarType >(
+                keplerianElements, earthGravitationalParameter );
 
-    // Case 8: Converting to and fro between Keplerian and Cartesian elements for a
-    // non-zero-eccentricity, zero-inclination orbit (non-circular, equatorial) around the Earth.
-    // This test ensures internal consistency within Tudat between the Cartesian <-> Keplerian
-    // element converters.
-    {
-        // Using declarations.
-        using namespace orbital_element_conversions;
+    // Convert Cartesian elements back to Keplerian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > recomputedKeplerianElements =
+            convertCartesianToKeplerianElements< ScalarType >(
+                computedCartesianElements, earthGravitationalParameter );
 
-        // Earth gravitational parameter [m^3 s^-2].
-        const double earthGravitationalParameter = 3.9859383624e14;
+    // Check that recomputed Keplerian elements match the input values. (In this limit case,
+    // the argument of periapsis is set to zero, and the true anomaly "absorbs" this).
+    BOOST_CHECK_CLOSE_FRACTION(
+                keplerianElements( semiMajorAxisIndex ),
+                recomputedKeplerianElements( semiMajorAxisIndex ), tolerance );
 
-        // Set Keplerian elements.
-        Eigen::VectorXd keplerianElements( 6 );
-        keplerianElements( semiMajorAxisIndex ) = 8000.0;
-        keplerianElements( eccentricityIndex ) = 0.2;
-        keplerianElements( inclinationIndex ) = 0.0;
-        keplerianElements( argumentOfPeriapsisIndex ) = 243 / 180.0 * PI;
-        keplerianElements( longitudeOfAscendingNodeIndex ) = -79.6 / 180.0 * PI;
-        keplerianElements( trueAnomalyIndex ) = 126.45 / 180.0 * PI;
+    BOOST_CHECK_SMALL( recomputedKeplerianElements( eccentricityIndex ), tolerance );
 
-        // Convert Keplerian elements to Cartesian elements.
-        Eigen::VectorXd computedCartesianElements( 6 );
-        computedCartesianElements = orbital_element_conversions::
-                convertKeplerianToCartesianElements( keplerianElements,
-                                                     earthGravitationalParameter );
+    BOOST_CHECK_CLOSE_FRACTION(
+                keplerianElements( inclinationIndex ),
+                recomputedKeplerianElements( inclinationIndex ), tolerance );
 
-        // Convert Cartesian elements back to Keplerian elements.
-        Eigen::VectorXd recomputedKeplerianElements( 6 );
-        recomputedKeplerianElements = orbital_element_conversions::
-                convertCartesianToKeplerianElements( computedCartesianElements,
-                                                     earthGravitationalParameter );
+    BOOST_CHECK_SMALL( recomputedKeplerianElements( argumentOfPeriapsisIndex ),
+                       std::numeric_limits< ScalarType >::epsilon( ) );
 
-        // Check that recomputed Keplerian elements match the input values. (In this limit case,
-        // the longitude of the ascending node is set to zero, and the argument of periapsis and
-        // true anomaly "absorb" this).
-        BOOST_CHECK_CLOSE_FRACTION( keplerianElements( semiMajorAxisIndex ),
-                                    recomputedKeplerianElements( semiMajorAxisIndex ),
-                                    1.0e-15 );
+    BOOST_CHECK_CLOSE_FRACTION(
+                keplerianElements( longitudeOfAscendingNodeIndex ) +
+                getFloatingInteger< ScalarType >( 2 ) * getPi< ScalarType >( ),
+                recomputedKeplerianElements( longitudeOfAscendingNodeIndex ), tolerance );
 
-        BOOST_CHECK_CLOSE_FRACTION( keplerianElements( eccentricityIndex ),
-                                    recomputedKeplerianElements( eccentricityIndex ),
-                                    1.0e-15 );
+    BOOST_CHECK_CLOSE_FRACTION(
+                std::fmod( keplerianElements( argumentOfPeriapsisIndex )
+                           + keplerianElements( trueAnomalyIndex ),
+                           getFloatingInteger< ScalarType >( 2 ) * getPi< ScalarType >( ) ),
+                recomputedKeplerianElements( trueAnomalyIndex ), 10.0 * tolerance );
 
-        BOOST_CHECK_CLOSE_FRACTION( keplerianElements( inclinationIndex ),
-                                    recomputedKeplerianElements( inclinationIndex ),
-                                    std::numeric_limits< double >::epsilon( ) );
+    // Convert recomputed Keplerian elements to Cartesian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > recomputedCartesianElements =
+            convertKeplerianToCartesianElements< ScalarType >(
+                recomputedKeplerianElements, earthGravitationalParameter );
 
-        BOOST_CHECK_SMALL( recomputedKeplerianElements( longitudeOfAscendingNodeIndex ),
-                           std::numeric_limits< double >::epsilon( ) );
+    // Check that computed Cartesian elements match.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                computedCartesianElements, recomputedCartesianElements, ( 100.0 * tolerance ) );
+}
 
-        BOOST_CHECK_CLOSE_FRACTION( keplerianElements( longitudeOfAscendingNodeIndex )
-                                    + keplerianElements( argumentOfPeriapsisIndex )
-                                    + keplerianElements( trueAnomalyIndex ),
-                                    recomputedKeplerianElements( argumentOfPeriapsisIndex )
-                                    + recomputedKeplerianElements( trueAnomalyIndex ),
-                                    std::numeric_limits< double >::epsilon( ) );
+//! Test back and forth Kepler <-> Cartesian conversion for non-circular equatorial orbit
+template< typename ScalarType >
+void convertNonCircularEquatorialOrbitBackAndForth(
+        const ScalarType tolerance )
+{
+    // Using declarations.
+    using namespace orbital_element_conversions;
 
-        // Convert recomputed Keplerian elements to Cartesian elements.
-        Eigen::VectorXd recomputedCartesianElements( 6 );
-        recomputedCartesianElements = orbital_element_conversions::
-                convertKeplerianToCartesianElements( recomputedKeplerianElements,
-                                                     earthGravitationalParameter );
+    // Earth gravitational parameter [m^3 s^-2].
+    const ScalarType earthGravitationalParameter = 3.9859383624e14;
 
-        // Check that computed Cartesian elements match.
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( computedCartesianElements, recomputedCartesianElements,
-                                           1.0e-14 );
+    // Set Keplerian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > keplerianElements;
+    keplerianElements( semiMajorAxisIndex ) = static_cast< ScalarType >( 8000.0 );
+    keplerianElements( eccentricityIndex ) = static_cast< ScalarType >( 0.2 );
+            keplerianElements( inclinationIndex ) = getFloatingInteger< ScalarType >( 0 );
+    keplerianElements( argumentOfPeriapsisIndex ) = static_cast< ScalarType >( 243.0 / 180.0 * PI );
+    keplerianElements( longitudeOfAscendingNodeIndex ) = static_cast< ScalarType >(
+                -79.6 / 180.0 * PI );
+    keplerianElements( trueAnomalyIndex ) = static_cast< ScalarType >( 126.45 / 180.0 * PI );
+
+    // Convert Keplerian elements to Cartesian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > computedCartesianElements =
+            convertKeplerianToCartesianElements( keplerianElements, earthGravitationalParameter );
+
+    // Convert Cartesian elements back to Keplerian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > recomputedKeplerianElements =
+            convertCartesianToKeplerianElements(
+                computedCartesianElements, earthGravitationalParameter );
+
+    // Check that recomputed Keplerian elements match the input values. (In this limit case,
+    // the longitude of the ascending node is set to zero, and the argument of periapsis and
+    // true anomaly "absorb" this).
+    BOOST_CHECK_CLOSE_FRACTION( keplerianElements( semiMajorAxisIndex ),
+                                recomputedKeplerianElements( semiMajorAxisIndex ),
+                                tolerance );
+
+    BOOST_CHECK_CLOSE_FRACTION( keplerianElements( eccentricityIndex ),
+                                recomputedKeplerianElements( eccentricityIndex ),
+                                tolerance );
+
+    BOOST_CHECK_CLOSE_FRACTION( keplerianElements( inclinationIndex ),
+                                recomputedKeplerianElements( inclinationIndex ),
+                                std::numeric_limits< ScalarType >::epsilon( ) );
+
+    BOOST_CHECK_SMALL( recomputedKeplerianElements( longitudeOfAscendingNodeIndex ),
+                       std::numeric_limits< ScalarType >::epsilon( ) );
+
+    BOOST_CHECK_CLOSE_FRACTION( keplerianElements( longitudeOfAscendingNodeIndex )
+                                + keplerianElements( argumentOfPeriapsisIndex )
+                                + keplerianElements( trueAnomalyIndex ),
+                                recomputedKeplerianElements( argumentOfPeriapsisIndex )
+                                + recomputedKeplerianElements( trueAnomalyIndex ),
+                                std::numeric_limits< ScalarType >::epsilon( ) );
+
+    // Convert recomputed Keplerian elements to Cartesian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > recomputedCartesianElements;
+    recomputedCartesianElements = orbital_element_conversions::
+            convertKeplerianToCartesianElements(
+                recomputedKeplerianElements, earthGravitationalParameter );
+
+    // Check that computed Cartesian elements match.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                computedCartesianElements, recomputedCartesianElements, ( 10.0 * tolerance ) );
+}
+
+//! Test back and forth Kepler <-> Cartesian conversion for non-circular non-equatorial orbit
+template< typename ScalarType >
+void convertNonCircularNonEquatorialOrbitBackAndForth(
+        const ScalarType tolerance )
+{
+    // Using declarations.
+    using namespace orbital_element_conversions;
+
+    // Earth gravitational parameter [m^3 s^-2].
+    const ScalarType earthGravitationalParameter = 3.9859383624e14;
+
+    // Set Keplerian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > keplerianElements;
+    keplerianElements( semiMajorAxisIndex ) = static_cast< ScalarType >( 8000.0 );
+    keplerianElements( eccentricityIndex ) = static_cast< ScalarType >( 0.2 );
+            keplerianElements( inclinationIndex ) = getFloatingInteger< ScalarType >(
+                        176.11 / 180.0 * PI );
+    keplerianElements( argumentOfPeriapsisIndex ) = static_cast< ScalarType >( 243.0 / 180.0 * PI );
+    keplerianElements( longitudeOfAscendingNodeIndex ) = static_cast< ScalarType >(
+                -79.6 / 180.0 * PI );
+    keplerianElements( trueAnomalyIndex ) = static_cast< ScalarType >( 126.45 / 180.0 * PI );
+
+    // Convert Keplerian elements to Cartesian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > computedCartesianElements =
+            convertKeplerianToCartesianElements( keplerianElements, earthGravitationalParameter );
+
+    // Convert Cartesian elements back to Keplerian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > recomputedKeplerianElements =
+            convertCartesianToKeplerianElements(
+                computedCartesianElements, earthGravitationalParameter );
+
+    recomputedKeplerianElements( longitudeOfAscendingNodeIndex ) =
+            recomputedKeplerianElements( longitudeOfAscendingNodeIndex ) -
+                       getFloatingInteger< ScalarType >( 2 ) * getPi< ScalarType >( );
+
+    // Check that recomputed Keplerian elements match the input values. (In this limit case,
+    // the longitude of the ascending node is set to zero, and the argument of periapsis and
+    // true anomaly "absorb" this).
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                keplerianElements, recomputedKeplerianElements, ( tolerance ) );
+
+    // Convert recomputed Keplerian elements to Cartesian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > recomputedCartesianElements;
+    recomputedCartesianElements = orbital_element_conversions::
+            convertKeplerianToCartesianElements(
+                recomputedKeplerianElements, earthGravitationalParameter );
+
+    // Check that computed Cartesian elements match.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                computedCartesianElements, recomputedCartesianElements, ( 10.0 * tolerance ) );
+}
+
+//! Test if conversion from Cartesian elements to Keplerian elements is working correctly, using
+//! back and forth conversion, for both double and long double precision.
+BOOST_AUTO_TEST_CASE( testCartesianToKeplerianElementConversionBackAndForth )
+{
+    double ratioOfPrecision = std::numeric_limits< long double >::epsilon( ) /
+            std::numeric_limits< double >::epsilon( );
+
+    // Case 1: Parabolic orbit around the Sun.
+    // This test is based on converting Keplerian elements to Cartesian element and then
+    // recomputing the input Keplerian element values. Ideally, an independent check will replace
+    // this test in future.
+    {
+        convertParabolicOrbitBackAndForth< double >( 1.0E-15 );
+        convertParabolicOrbitBackAndForth< long double >( 1.0E-15L * ratioOfPrecision );
     }
+    // Case 2: Converting to and fro between Keplerian and Cartesian elements for a
+    // zero-eccentricity, zero-inclination orbit (circular, equatorial) around the Earth. This
+    // test ensures internal consistency within Tudat between the Cartesian <-> Keplerian element
+    // converters.
+    {
+        convertCircularEquatorialOrbitBackAndForth< double >( 1.0E-15 );
+        convertCircularEquatorialOrbitBackAndForth< long double >( 1.0E-15L * ratioOfPrecision );
+    }
+
+    // Case 3: Converting to and fro between Keplerian and Cartesian elements for a
+    // zero-eccentricity, non-zero-inclination orbit (circular, inclined) around the Earth. This
+    // test ensures internal consistency within Tudat between the Cartesian <-> Keplerian element
+    // converters.
+    {
+        convertCircularNonEquatorialOrbitBackAndForth< double >( 1.0E-15 );
+        convertCircularNonEquatorialOrbitBackAndForth< long double >( 1.0E-15L * ratioOfPrecision );
+    }
+
+    // Case 4: Converting to and fro between Keplerian and Cartesian elements for a
+    // non-zero-eccentricity, zero-inclination orbit (non-circular, equatorial) around the Earth.
+    // This test ensures internal consistency within Tudat between the Cartesian <-> Keplerian
+    // element converters.
+    {
+        convertNonCircularEquatorialOrbitBackAndForth< double >( 1.0E-15 );
+        convertNonCircularEquatorialOrbitBackAndForth< long double >( 1.0E-15L * ratioOfPrecision );
+
+    }
+
+    // Case 5: Converting to and fro between Keplerian and Cartesian elements for a
+    // non-zero-eccentricity, non-zero-inclination orbit (non-circular, non-equatorial).
+    // This test ensures internal consistency within Tudat between the Cartesian <-> Keplerian
+    // element converters.
+    {
+        convertNonCircularNonEquatorialOrbitBackAndForth< double >( 5.0E-15 );
+        convertNonCircularNonEquatorialOrbitBackAndForth< long double >( 5.0E-15L * ratioOfPrecision );
+
+    }
 }
 
 //! Test if conversion from true anomaly to eccentric anomaly is working correctly.
Index: Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestConvertMeanAnomalyToEccentricAnomaly.cpp
===================================================================
--- Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestConvertMeanAnomalyToEccentricAnomaly.cpp	(revision 586)
+++ Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestConvertMeanAnomalyToEccentricAnomaly.cpp	(revision 588)
@@ -42,6 +42,7 @@
  *      121205    P. Musegaas       Updated code to final version of rootfinders.
  *      130123    K. Kumar          Updated test tolerance for near-parabolic cases in Test 5 to
  *                                  deal with conversion failure on some systems.
+ *      150417    D. Dirkx          Made modifications for templated element conversions.
  *
  *    References
  *      GTOP, http://www.esa.int/gsp/ACT/doc/INF/Code/globopt/GTOPtoolbox.rar
@@ -60,6 +61,7 @@
 #include <ctime>
 #include <fstream>
 #include <string>
+#include <iostream>
 
 #include <boost/date_time/posix_time/posix_time.hpp>
 #include <boost/math/special_functions/fpclassify.hpp>
@@ -72,7 +74,7 @@
 #include "Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h"
 #include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
 
-#include "Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToEccentricAnomaly.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/convertMeanToEccentricAnomalies.h"
 #include "Tudat/InputOutput/basicInputOutput.h"
 
 namespace tudat
@@ -80,68 +82,13 @@
 namespace unit_tests
 {
 
+
+using namespace mathematical_constants;
 using namespace unit_conversions;
+using namespace orbital_element_conversions;
 
-//! Conversion test fixture.
-/*!
- * Conversion test fixture used by the Boost unit test framework. This code is executed before each
- * test.
- */
-struct conversion_test_fixture
-{
-public:
+BOOST_AUTO_TEST_SUITE( test_mean_to_eccentric_anomaly_conversion )
 
-    //! Default constructor.
-    /*!
-     * Default constructor.
-     */
-    conversion_test_fixture( )
-    {
-        toleranceOrbitalElementConversion = 1.0e-13;
-        toleranceOrbitalElementConversionNearParabolic = 1.0e-9;
-    }
-
-    //! Conversion tolerance to test against.
-    /*!
-     * Conversion tolerance to test against.
-     */
-    double toleranceOrbitalElementConversion;
-
-    //! Conversion tolerance to test against for near-parabolic cases.
-    /*!
-     * Conversion tolerance to test against for near-parabolic cases.
-     */
-    double toleranceOrbitalElementConversionNearParabolic;
-
-    //! Convert mean anomaly to eccentric anomaly.
-    /*!
-     * Converts mean anomaly to eccentric anomaly by creating a conversion object to test and
-     * executing the conversion.
-     * \param eccentricity Eccentricity [-].
-     * \param meanAnomaly Mean anomaly [rad].
-     * \param useDefaultInitialGuess Boolean specifying whether to use default initial guess [-].
-     * \param initialGuessForRootFinder Initial guess for rootfinder [rad].
-     * \return eccentricAnomaly Eccentric anomaly [rad].
-     */
-    double convertMeanAnomalyToEccentricAnomaly( const double eccentricity,
-                                                 const double meanAnomaly,
-                                                 const bool useDefaultInitialGuess = true,
-                                                 const double initialGuess = TUDAT_NAN )
-    {
-        // Conversion object to test; mean anomaly to eccentric anomaly conversion.
-        orbital_element_conversions::ConvertMeanAnomalyToEccentricAnomaly
-                meanToEccentricAnomaly( eccentricity, meanAnomaly, useDefaultInitialGuess,
-                                        initialGuess );
-
-        // Convert to eccentric anomaly and return.
-        return meanToEccentricAnomaly.convert( );
-    }
-
-protected:
-
-private:
-};
-
 //! Error writing function.
 /*!
  * This function writes the input values that led to errors to a unique file, if any errors occured
@@ -161,10 +108,10 @@
     // time at which the code was executed. The default date format is: YYYYMMDDTHHMMSS, in which T
     // separates date and time.
     const std::string outputFileName = input_output::getTudatRootPath( ) +
-                                       "Astrodynamics/BasicAstrodynamics/UnitTests/" +
-                                       "ErrorReportConversionMeanToEccentricAnomaly" +
-                                       testName + "RunAt" + boost::posix_time::to_iso_string( now )
-                                       + ".txt";
+            "Astrodynamics/BasicAstrodynamics/UnitTests/" +
+            "ErrorReportConversionMeanToEccentricAnomaly" +
+            testName + "RunAt" + boost::posix_time::to_iso_string( now )
+            + ".txt";
 
     // Make a stream to a file.
     std::ofstream errorFile( outputFileName.c_str( ) );
@@ -196,9 +143,6 @@
               << std::endl << outputFileName;
 }
 
-// Declare Boost fixture test suite.
-BOOST_FIXTURE_TEST_SUITE( testsuite_convertMeanAnomalyToEccentricAnomaly, conversion_test_fixture )
-
 //! Test 1: Test conversion for circular orbits.
 BOOST_AUTO_TEST_CASE( test_convertMeanAnomalyToEccentricAnomaly_circular )
 {
@@ -217,7 +161,7 @@
 
     // Check if computed eccentric anomaly is less than error tolerance.
     BOOST_CHECK_CLOSE_FRACTION( eccentricAnomaly, referenceEccentricAnomaly,
-                                toleranceOrbitalElementConversion );
+                                1.0E-13 );
 }
 
 //! Test 2: Test conversion for valid range of eccentricities.
@@ -248,7 +192,7 @@
 
         // Check if computed eccentric anomaly is less than error tolerance.
         BOOST_CHECK_CLOSE_FRACTION( eccentricAnomaly, arrayOfReferenceEccentricAnomalies[ i ],
-                                    toleranceOrbitalElementConversion );
+                                    1.0E-13 );
     }
 }
 
@@ -289,23 +233,23 @@
     // Set test values for mean anomaly, to verify that a wide range can be handled. The set was
     // selected such that it contains all possible limit cases, and a wide enough variety of random
     // values.
-   const double arrayOfTestMeanAnomalies [ 17 ] = { 0.0,
-                                                    1.0e-10,
-                                                    0.5,
-                                                    mathematical_constants::PI / 2 - 1.0e-10,
-                                                    mathematical_constants::PI / 2,
-                                                    mathematical_constants::PI / 2 + 1.0e-10,
-                                                    2.5,
-                                                    mathematical_constants::PI - 1.0e-10,
-                                                    mathematical_constants::PI,
-                                                    mathematical_constants::PI + 1.0e-10,
-                                                    4.0,
-                                                    3.0 / 2.0 * mathematical_constants::PI - 1.0e-10,
-                                                    3.0 / 2.0 * mathematical_constants::PI,
-                                                    3.0 / 2.0 * mathematical_constants::PI + 1.0e-10,
-                                                    5.5,
-                                                    2.0 * mathematical_constants::PI - 1.0e-10,
-                                                    2.0 * mathematical_constants::PI };
+    const double arrayOfTestMeanAnomalies [ 17 ] = { 0.0,
+                                                     1.0e-10,
+                                                     0.5,
+                                                     PI / 2 - 1.0e-10,
+                                                     PI / 2,
+                                                     PI / 2 + 1.0e-10,
+                                                     2.5,
+                                                     PI - 1.0e-10,
+                                                     PI,
+                                                     PI + 1.0e-10,
+                                                     4.0,
+                                                     3.0 / 2.0 * PI - 1.0e-10,
+                                                     3.0 / 2.0 * PI,
+                                                     3.0 / 2.0 * PI + 1.0e-10,
+                                                     5.5,
+                                                     2.0 * PI - 1.0e-10,
+                                                     2.0 * PI };
 
     // Set the expected eccentric anomalies corresponding to the corresponding test mean anomaly
     // array. These values were obtained using the convertMeanAnomalyToEccentricAnomaly method,
@@ -334,10 +278,10 @@
     // Test the values which are supposed to be 0.0.
     double eccentricAnomaly = convertMeanAnomalyToEccentricAnomaly(
                 testEccentricity, arrayOfTestMeanAnomalies[ 0 ] );
-    BOOST_CHECK_SMALL( eccentricAnomaly, toleranceOrbitalElementConversionNearParabolic );
+    BOOST_CHECK_SMALL( eccentricAnomaly, 1.0E-9 );
     eccentricAnomaly = convertMeanAnomalyToEccentricAnomaly(
                 testEccentricity, arrayOfTestMeanAnomalies[ 16 ] );
-    BOOST_CHECK_SMALL( eccentricAnomaly, toleranceOrbitalElementConversionNearParabolic );
+    BOOST_CHECK_SMALL( eccentricAnomaly, 1.0E-9 );
 
     // Test the values that are supposed to be equal to certain other values.
     for ( int counter = 1; counter < 16; counter++ )
@@ -348,12 +292,37 @@
 
         // Check whether the expected value is set to the eccentric anomaly.
         BOOST_CHECK_CLOSE_FRACTION( eccentricAnomaly, arrayOfExpectedEccentricAnomalies[ counter ],
-                                    toleranceOrbitalElementConversionNearParabolic );
+                                    1.0E-9 );
     }
 }
 
-//! Test 6: Test large number of anomalies for near-parabolic orbits.
-BOOST_AUTO_TEST_CASE( test_convertMeanAnomalyToEccentricAnomaly_nearParabolic_random )
+//! Generalized function to test many to and fro mean to eccentric anomalies.
+/*!
+ *  Generalized function to test many to and fro mean to eccentric anomalies.
+ *  The function allows random variations of both the mean anomlay and eccentricity. The
+ *  eccentricity may be fixed, for instance to test near-parabolic orbits for many mean
+ *  anomalies.
+ *  \param caseId Name of test case, to be used for error output purposes.
+ *  \param testTolerance Absolute acceptance tolerance to be used for difference between original
+ *  and reconverted mean anomaly.
+ *  \param useConstantEccentricity Boolean determining if a constant eccentricity is used.
+ *  \param minimumEccentricity Minimum value to be used for random eccentricities (only used if
+ *  useConstantEccentricity is false).
+ *  \param maximumEccentricity Maximum value to be used for random eccentricities (only used if
+ *  useConstantEccentricity is false).
+ *  \param constantEccentricity Constant value to be used for eccentricity (only used if
+ *  useConstantEccentricity is true).
+ *  \param numberOfSamples Number of random cases that are to be tested.
+ */
+template< typename ScalarType >
+void testMeanToEccentricAnomalyConversions(
+        const std::string& caseId,
+        const ScalarType testTolerance,
+        const bool useConstantEccentricity = 0,
+        const ScalarType minimumEccentricity = TUDAT_NAN,
+        const ScalarType maximumEccentricity = TUDAT_NAN,
+        const ScalarType constantEccentricity = TUDAT_NAN,
+        const int numberOfSamples = 1E5 )
 {
     // Create vectors that will store the input variables of a test that resulted in an error, such
     // that the error scenario can be reproduced.
@@ -362,24 +331,30 @@
     // Boolean that will be set true if a runtime error occurred.
     bool aRuntimeErrorOccurred = false;
 
-    // Set test value for eccentricity, which is just below  1.0.
-    const double testEccentricity = 1.0 - 1.0e-15;
+    // Set test value for eccentricity.
+    ScalarType testEccentricity = constantEccentricity;
 
     // Initialize both test and reverse calculated mean anomaly and the eccentric anomaly.
-    double testMeanAnomaly, reverseCalculatedMeanAnomaly, eccentricAnomaly = 0.0;
+    ScalarType testMeanAnomaly, reverseCalculatedMeanAnomaly, eccentricAnomaly = 0.0;
 
     // Instantiate random number generator.
     boost::mt19937 randomNumbergenerator( time( 0 ) );
-    boost::random::uniform_real_distribution< > distribution0To2Pi( 0.0, 2 * mathematical_constants::PI );
+
+    // Create generator for eccentricity (only used if useConstantEccentricity is false).
+    boost::random::uniform_real_distribution< > eccentricityDistribution(
+                minimumEccentricity, maximumEccentricity );
     boost::variate_generator< boost::mt19937&, boost::random::uniform_real_distribution < > >
+            eccentricityGenerator(
+                randomNumbergenerator, eccentricityDistribution );
+
+    // Create generator for mean anomaly.
+    boost::random::uniform_real_distribution< ScalarType > distribution0To2Pi(
+                getFloatingInteger< ScalarType >( 0 ), getFloatingInteger< ScalarType >( 2 ) *
+                getPi< ScalarType >( ) );
+    boost::variate_generator<
+            boost::mt19937&, boost::random::uniform_real_distribution < ScalarType > >
             generateRandomNumber0To2Pi( randomNumbergenerator, distribution0To2Pi );
 
-    // Specify the number of random samples should be taken. A test of 100,000,000 was performed
-    // by the author before the code was submitted. This test remains included to verify that any
-    // future method will not fail. The behaviour of the conversion is namely very sensitive and
-    // non-converging cases are highly sensitive to input values and the initial guess that is used.
-    const int numberOfSamples = 10000;
-
     // Perform the conversion for the specified number of samples and test whether the values that
     // are subsequently converted back match the initial values.
     for ( int counter = 0; counter < numberOfSamples; counter++ )
@@ -387,6 +362,12 @@
         // Set random value in test mean anomaly.
         testMeanAnomaly = generateRandomNumber0To2Pi( );
 
+        // If eccentricity is to be varied, generate random value
+        if( !useConstantEccentricity )
+        {
+            testEccentricity = eccentricityGenerator( );
+        }
+
         // If the Rootfinder does not converge, it will produce a runtime error. In order to make
         // sure that these values that led to the error will not be lost, they will be stored in
         // the failed input data vectors. To do so, a try-catch sequence is used.
@@ -393,8 +374,8 @@
         try
         {
             // Compute eccentric anomaly.
-            eccentricAnomaly = convertMeanAnomalyToEccentricAnomaly( testEccentricity,
-                                                                     testMeanAnomaly );
+            eccentricAnomaly = convertMeanAnomalyToEccentricAnomaly< ScalarType>(
+                        testEccentricity, testMeanAnomaly );
         }
         catch( std::runtime_error )
         {
@@ -403,8 +384,8 @@
         }
 
         // Calculate the mean anomaly from this eccentric anomaly.
-        reverseCalculatedMeanAnomaly = orbital_element_conversions::
-                convertEccentricAnomalyToMeanAnomaly( eccentricAnomaly, testEccentricity );
+        reverseCalculatedMeanAnomaly = convertEccentricAnomalyToMeanAnomaly< ScalarType>(
+                    eccentricAnomaly, testEccentricity );
 
         // Test whether the computed mean anomaly is equal to the mean anomaly from the input and
         // that no runtime errors occurred. If an error was found, store the values leading to this
@@ -411,9 +392,10 @@
         // error in a vector for later use. '!' operator is there to ensure that a NaN value will
         // result in the values being written away. It is also checked that the mean anomaly is
         // not equal to 0.0, because that would result in falsely writing an error.
-        if ( ( ( !( std::abs( testMeanAnomaly - reverseCalculatedMeanAnomaly ) / testMeanAnomaly <
-                toleranceOrbitalElementConversionNearParabolic ) ) && ( testMeanAnomaly != 0.0 ) )
-             || aRuntimeErrorOccurred )
+        if ( ( ( !( std::abs( testMeanAnomaly - reverseCalculatedMeanAnomaly ) < testTolerance ) )
+               && !( testMeanAnomaly == getFloatingInteger< ScalarType >( 0 ) ||
+                  reverseCalculatedMeanAnomaly == getFloatingInteger< ScalarType >( 0 ) ) ) &&
+             !aRuntimeErrorOccurred )
         {
             failedMeanAnomalies.push_back( testMeanAnomaly );
             failedEccentricities.push_back( testEccentricity );
@@ -421,6 +403,7 @@
 
         // Reset boolean.
         aRuntimeErrorOccurred = false;
+
     }
 
     // Check that no values have been written to the failedMeanAnomalies vector.  If so, this test
@@ -430,98 +413,33 @@
     // If the vector is not empty, write the failed cases of this test case to a file.
     if ( !( failedMeanAnomalies.empty( ) ) )
     {
-        writeErrorsToFile( failedEccentricities, failedMeanAnomalies, "Test6" );
+        writeErrorsToFile( failedEccentricities, failedMeanAnomalies, caseId );
     }
 }
 
-//! Test 7: Test large number of anomalies with a large number of eccentricities.
-BOOST_AUTO_TEST_CASE( test_convertMeanAnomalyToEccentricAnomaly_random )
+//! Test 6: Test large number of anomalies for near-parabolic orbits (double).
+BOOST_AUTO_TEST_CASE( test_convertMeanAnomalyToEccentricAnomaly_nearParabolic_random_double )
 {
-    // Create vectors that will store the input variables of a test that resulted in an error, such
-    // that the error scenario can be reproduced.
-    std::vector< double > failedMeanAnomalies, failedEccentricities;
+    long double ratioOfPrecision = std::numeric_limits< long double >::epsilon( ) /
+            std::numeric_limits< double >::epsilon( );
 
-    // Boolean that will be set true if a runtime error occurred.
-    bool aRuntimeErrorOccurred = false;
+    // Test random conversions for near-parabolic orbits
+    testMeanToEccentricAnomalyConversions< double >(
+                "DoubleParabolic", 1.0E-13, 1, TUDAT_NAN, TUDAT_NAN, 1.0 - 1.0e-15 );
+    testMeanToEccentricAnomalyConversions< long double >(
+                "LongDoubleParabolic", 1.0E-13L * ratioOfPrecision, 1, TUDAT_NAN, TUDAT_NAN,
+                1.0L - 1.0e-15L * ratioOfPrecision );
 
-    // Initialize both test and reverse calculated mean anomaly, the eccentric anomaly and the
-    // eccentricity.
-    double testEccentricity, testMeanAnomaly, reverseCalculatedMeanAnomaly, eccentricAnomaly = 0.0;
+    // Test random conversions for random orbits
+    testMeanToEccentricAnomalyConversions< double >(
+                "DoubleEccentric", 1.0E-15, 0, 0.0, 1.0 - 1.0e-11 );
+    testMeanToEccentricAnomalyConversions< long double >(
+                "LongDoubleEccentric", 1.0E-15L * ratioOfPrecision, 0, 0.0,
+                1.0L - 1.0e-11L * ratioOfPrecision );
+}
 
-    // Instantiate random number generators. One for the mean anomaly generation, from 0 to 2pi,
-    // another one for the eccentricity generation, from 0 to 1.0 - 1.0e-11. This was selected
-    // lower than the limit (1.0 - 1.0e-15, because this could invoke machine precision problems
-    // with the sharp tolerance used: 1.0e-13 instead of 1.0e-9).
-    boost::mt19937 randomNumbergenerator( time( 0 ) );
-    boost::random::uniform_real_distribution< > distribution0To2Pi( 0.0, 2 * mathematical_constants::PI );
-    boost::variate_generator< boost::mt19937&, boost::random::uniform_real_distribution < > >
-            generateRandomNumber0To2Pi( randomNumbergenerator, distribution0To2Pi );
-    boost::random::uniform_real_distribution< > distribution0To1( 0.0, 1.0 - 1.0e-11 );
-    boost::variate_generator< boost::mt19937&, boost::random::uniform_real_distribution < > >
-            generateRandomNumber0To1( randomNumbergenerator, distribution0To1 );
 
-    // Specify the number of random samples should be taken. A test of 100,000,000 was performed
-    // by the author before the code was submitted. This test remains included to verify that any
-    // future method will not fail. The behaviour of the conversion is namely very sensitive and
-    // non-converging cases are highly sensitive to input values and the initial guess that is used.
-    const int numberOfSamples = 10000;
-
-    // Perform the conversion for the specified number of samples and test whether the values that
-    // are subsequently converted back match the initial values.
-    for ( int counter = 0; counter < numberOfSamples; counter++ )
-    {
-        // Set random value in test mean anomaly and the test eccentricity.
-        testMeanAnomaly = generateRandomNumber0To2Pi( );
-        testEccentricity = generateRandomNumber0To1( );
-
-        // If the Rootfinder does not converge, it will produce a runtime error. In order to make
-        // sure that these values that led to the error will not be lost, they will be stored in
-        // the failed input data vectors. To do so, a try-catch sequence is used.
-        try
-        {
-            // Compute eccentric anomaly.
-            eccentricAnomaly = convertMeanAnomalyToEccentricAnomaly( testEccentricity,
-                                                                     testMeanAnomaly );
-        }
-        catch( std::runtime_error )
-        {
-            // Store the fact that a runtime error occurred, such that the values will be stored.
-            aRuntimeErrorOccurred = true;
-        }
-
-        // Calculate the mean anomaly from this eccentric anomaly.
-        reverseCalculatedMeanAnomaly = orbital_element_conversions::
-                convertEccentricAnomalyToMeanAnomaly( eccentricAnomaly, testEccentricity );
-
-        // Test whether the computed mean anomaly is equal to the mean anomaly from the input and
-        // that no runtime errors occurred. If an error was found, store the values leading to this
-        // error in a vector for later use. '!' operator is there to ensure that a NaN value will
-        // result in the values being written away. It is also checked that the mean anomaly is
-        // not equal to 0.0, because that would result in falsely writing an error.
-        if ( ( ( !( std::abs( testMeanAnomaly - reverseCalculatedMeanAnomaly ) / testMeanAnomaly <
-                toleranceOrbitalElementConversion ) ) && ( testMeanAnomaly != 0.0 ) )
-             || aRuntimeErrorOccurred )
-        {
-            failedMeanAnomalies.push_back( testMeanAnomaly );
-            failedEccentricities.push_back( testEccentricity );
-        }
-
-        // Reset boolean.
-        aRuntimeErrorOccurred = false;
-    }
-
-    // Check that no values have been written to the failedMeanAnomalies vector.  If so, this test
-    // is passed. Otherwisely these values will be written away and this test will fail.
-    BOOST_CHECK( failedMeanAnomalies.empty( ) );
-
-    // If the vector is not empty, write the failed cases of this test case to a file.
-    if ( !( failedMeanAnomalies.empty( ) ) )
-    {
-        writeErrorsToFile( failedEccentricities, failedMeanAnomalies, "Test7" );
-    }
-}
-
-//! Test 8: Test functionality of specifying the initial guess. Case contained in Test 2 also.
+//! Test 7: Test functionality of specifying the initial guess. Case contained in Test 2 also.
 BOOST_AUTO_TEST_CASE( test_convertMeanAnomalyToEccentricAnomaly_specificInitialGuess )
 {
     // Set test value for eccentricity.
@@ -535,7 +453,7 @@
 
     // Specify initial guess.
     const bool useDefaultGuess = false;
-    const double initialGuess = mathematical_constants::PI;
+    const double initialGuess = PI;
 
     // Compute eccentric anomaly.
     const double eccentricAnomaly = convertMeanAnomalyToEccentricAnomaly(
@@ -544,7 +462,7 @@
     // Check if computed eccentric anomaly is less than error tolerance.
     BOOST_CHECK_CLOSE( eccentricAnomaly,
                        referenceEccentricAnomaly,
-                       toleranceOrbitalElementConversion );
+                       1.0E-13 );
 }
 
 // End Boost test suite.
@@ -551,4 +469,5 @@
 BOOST_AUTO_TEST_SUITE_END( )
 
 } // namespace unit_tests
+
 } // namespace tudat
Index: Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestKeplerPropagator.cpp
===================================================================
--- Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestKeplerPropagator.cpp	(revision 586)
+++ Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestKeplerPropagator.cpp	(revision 588)
@@ -43,6 +43,7 @@
  *                                  function in the Kepler propagator. Removed dedicated modulo
  *                                  unit test.
  *      121205    P. Musegaas       Updated code to final version of rootfinders.
+ *      150417    D. Dirkx          Made modifications for templated element conversions.
  *
  *    References
  *      Melman, J. Propagate software, J.C.P.Melman@tudelft.nl, 2010.
@@ -70,6 +71,7 @@
 #include "Tudat/Basics/testMacros.h"
 #include "Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.h"
 #include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
 
 #include "Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h"
 #include "Tudat/InputOutput/basicInputOutput.h"
@@ -225,7 +227,7 @@
     BOOST_CHECK_CLOSE_FRACTION(
                 benchmarkKeplerPropagationHistory.rbegin( )->second( 5 ),
                 basic_mathematics::computeModulo( computedFinalStateInKeplerianElements( 5 ),
-                                            2.0 * mathematical_constants::PI ), 1.0e-8 );
+                                                  2.0 * mathematical_constants::PI ), 1.0e-8 );
 }
 
 //! Test 2: Comparison of kepprop2b() test output from (GSFC, 2012) using modulo option.
@@ -326,7 +328,7 @@
                     computedPropagationHistory[ static_cast< double >( i ) * timeStep ]( 5 ),
                     expectedPropagationHistory[ static_cast< double >( i ) * timeStep ]( 5 ),
                     1.0e-15 );
-   }
+    }
 }
 
 //! Test 5: Unit test that failed on versions that caused the old modulo function to crash.
@@ -356,5 +358,100 @@
                                 1.0e-15 );
 }
 
+//! Test 6. Propagation test using ODTBX test Kepler elements.
+BOOST_AUTO_TEST_CASE( testMeanAnomalyAgainstMeanMotion )
+{
+    std::vector< double > doubleErrors;
+    // Test using double parameters.
+    {
+        double gravitationalParameter = 398600.4415e9;
+        basic_mathematics::Vector6d initialStateInKeplerianElements;
+
+        initialStateInKeplerianElements << 42165.3431351313e3, 0.26248354351331, 0.30281462522101,
+                4.71463172847351, 4.85569272927819, 2.37248926702153;
+        double timeStep = 600.0;
+        double meanMotion = std::sqrt( gravitationalParameter /
+                                       std::pow( initialStateInKeplerianElements( 0 ), 3.0 ) );
+
+        double initialMeanAnomaly = convertEccentricAnomalyToMeanAnomaly(
+                    convertTrueAnomalyToEccentricAnomaly(
+                        initialStateInKeplerianElements( 5 ), initialStateInKeplerianElements( 1 ) ),
+                    initialStateInKeplerianElements( 1 ) );
+
+        double propagationTime, propagatedMeanAnomaly;
+
+        basic_mathematics::Vector6d propagatedKeplerElements;
+
+
+        for( int i = -25; i < 26; i++ )
+        {
+            propagationTime = static_cast< double >( i ) * timeStep;
+            propagatedKeplerElements = propagateKeplerOrbit(
+                        initialStateInKeplerianElements, propagationTime, gravitationalParameter );
+            propagatedMeanAnomaly = convertEccentricAnomalyToMeanAnomaly(
+                        convertTrueAnomalyToEccentricAnomaly(
+                            propagatedKeplerElements( 5 ), initialStateInKeplerianElements( 1 ) ),
+                        initialStateInKeplerianElements( 1 ) );
+            doubleErrors.push_back( meanMotion * propagationTime - ( propagatedMeanAnomaly - initialMeanAnomaly ) );
+        }
+    }
+
+    std::vector< double > longDoubleErrors;
+    // Test using long double parameters.
+    {
+        long double gravitationalParameter = 398600.4415e9L;
+        Eigen::Matrix< long double, 6, 1 > initialStateInKeplerianElements;
+
+        initialStateInKeplerianElements << 42165.3431351313e3L, 0.26248354351331L, 0.30281462522101L,
+                4.71463172847351L, 4.85569272927819L, 2.37248926702153L;
+        long double timeStep = 600.0L;
+        long double meanMotion = std::sqrt( gravitationalParameter /
+                                            ( initialStateInKeplerianElements( 0 ) *
+                                              initialStateInKeplerianElements( 0 ) *
+                                              initialStateInKeplerianElements( 0 ) ) );
+
+        long double initialMeanAnomaly = convertEccentricAnomalyToMeanAnomaly< long double >(
+                    convertTrueAnomalyToEccentricAnomaly< long double >(
+                        initialStateInKeplerianElements( 5 ), initialStateInKeplerianElements( 1 ) ),
+                    initialStateInKeplerianElements( 1 ) );
+
+        long double propagationTime, propagatedMeanAnomaly;
+
+        Eigen::Matrix< long double, 6, 1 > propagatedKeplerElements;
+
+
+        for( int i = -25; i < 26; i++ )
+        {
+            propagationTime = static_cast< long double >( i ) * timeStep;
+
+            propagatedKeplerElements = propagateKeplerOrbit< long double >(
+                        initialStateInKeplerianElements, propagationTime, gravitationalParameter );
+            propagatedMeanAnomaly = convertEccentricAnomalyToMeanAnomaly< long double >(
+                        convertTrueAnomalyToEccentricAnomaly< long double >(
+                            propagatedKeplerElements( 5 ), initialStateInKeplerianElements( 1 ) ),
+                        initialStateInKeplerianElements( 1 ) );
+
+            longDoubleErrors.push_back( static_cast< double >(
+                                            meanMotion * propagationTime -
+                                            ( propagatedMeanAnomaly - initialMeanAnomaly ) ) );
+        }
+    }
+
+    for( unsigned int i = 0; i < doubleErrors.size( ); i++ )
+    {
+        if( std::fabs( doubleErrors.at( i ) ) > 0.0 )
+        {
+            BOOST_CHECK_SMALL(
+                        static_cast< double >( std::fabs( longDoubleErrors.at( i ) / doubleErrors.at( i ) ) ),
+                        static_cast< double >( 5.0 * std::numeric_limits< long double >::epsilon( ) /
+                        std::numeric_limits< double >::epsilon( ) ) );
+        }
+        else
+        {
+            BOOST_CHECK_SMALL( static_cast< double >( longDoubleErrors.at( i ) ),
+                               static_cast< double >( 5.0 * std::numeric_limits< long double >::epsilon( ) ) );
+        }
+    }
+}
 } // namespace unit_tests
 } // namespace tudat
Index: Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestConvertMeanAnomalyToHyperbolicEccentricAnomaly.cpp
===================================================================
--- Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestConvertMeanAnomalyToHyperbolicEccentricAnomaly.cpp	(revision 586)
+++ Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestConvertMeanAnomalyToHyperbolicEccentricAnomaly.cpp	(revision 588)
@@ -32,6 +32,7 @@
  *      121205    P. Musegaas       Updated code to final version of rootfinders.
  *      130123    K. Kumar          Added separated test tolerance for near-parabolic cases in
  *                                  Test 4 to deal with conversion failure on some systems.
+ *      150417    D. Dirkx          Made modifications for templated element conversions.
  *
  *    References
  *      GTOP, http://www.esa.int/gsp/ACT/doc/INF/Code/globopt/GTOPtoolbox.rar.
@@ -59,9 +60,9 @@
 
 #include "Tudat/Astrodynamics/BasicAstrodynamics/unitConversions.h"
 #include "Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/convertMeanToEccentricAnomalies.h"
 #include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
 
-#include "Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToHyperbolicEccentricAnomaly.h"
 #include "Tudat/InputOutput/basicInputOutput.h"
 
 namespace tudat
@@ -70,67 +71,8 @@
 {
 
 using namespace orbital_element_conversions;
+using namespace mathematical_constants;
 
-//! Conversion test fixture.
-/*!
- * Conversion test fixture used by the Boost unit test framework. This code is executed before each
- * test.
- */
-struct conversion_test_fixture
-{
-public:
-
-    //! Default constructor.
-    /*!
-     * Default constructor.
-     */
-    conversion_test_fixture( )
-    {
-        toleranceOrbitalElementConversion = 1.0e-14;
-        toleranceOrbitalElementConversionNearParabolic = 1.0e-9;
-    }
-
-    //! Conversion tolerance to test against.
-    /*!
-     * Conversion tolerance to test against.
-     */
-    double toleranceOrbitalElementConversion;
-
-    //! Conversion tolerance to test against for near-parabolic cases.
-    /*!
-     * Conversion tolerance to test against for near-parabolic cases.
-     */
-    double toleranceOrbitalElementConversionNearParabolic;
-
-    //! Convert mean anomaly to eccentric anomaly.
-    /*!
-     * Converts mean anomaly to eccentric anomaly by creating a conversion object to test and
-     * executing the conversion.
-     * \param eccentricity Eccentricity [-].
-     * \param meanAnomaly Mean anomaly [rad].
-     * \param useDefaultInitialGuess Boolean specifying whether to use default initial guess [-].
-     * \param initialGuess Initial guess for rootfinder [rad].
-     * \return eccentricAnomaly Eccentric anomaly [rad].
-     */
-    double convertMeanAnomalyToHyperbolicEccentricAnomaly( const double eccentricity,
-                                                           const double meanAnomaly,
-                                                           const bool useDefaultInitialGuess = true,
-                                                           const double initialGuess = TUDAT_NAN )
-    {
-        // Conversion object to test; mean anomaly to eccentric anomaly conversion.
-        orbital_element_conversions::
-                ConvertMeanAnomalyToHyperbolicEccentricAnomaly  meanToHyperbolicEccentricAnomaly(
-                    eccentricity, meanAnomaly, useDefaultInitialGuess, initialGuess );
-
-        // Convert to eccentric anomaly and return.
-        return meanToHyperbolicEccentricAnomaly.convert( );
-    }
-
-protected:
-
-private:
-};
-
 //! Error writing function.
 /*!
  * This function writes the input values that led to errors to a unique file, if any errors occured
@@ -150,10 +92,10 @@
     // time at which the code was executed. The default date format is: YYYYMMDDTHHMMSS, in which T
     // separates date and time.
     const std::string outputFileName = input_output::getTudatRootPath( ) +
-                                       "Astrodynamics/BasicAstrodynamics/UnitTests/" +
-                                       "ErrorReportConversionMeanToHyperbolicEccentricAnomaly" +
-                                       testName + "RunAt" + boost::posix_time::to_iso_string( now )
-                                       + ".txt";
+            "Astrodynamics/BasicAstrodynamics/UnitTests/" +
+            "ErrorReportConversionMeanToHyperbolicEccentricAnomaly" +
+            testName + "RunAt" + boost::posix_time::to_iso_string( now )
+            + ".txt";
 
     // Make a stream to a file.
     std::ofstream errorFile( outputFileName.c_str( ) );
@@ -185,9 +127,7 @@
               << std::endl << outputFileName;
 }
 
-// Declare Boost fixture test suite.
-BOOST_FIXTURE_TEST_SUITE( testsuite_convertMeanAnomalyToHyperbolicEccentricAnomaly,
-                          conversion_test_fixture )
+BOOST_AUTO_TEST_SUITE( test_mean_to_hyperbolic_eccentric_anomaly_conversion )
 
 //! Test 1: Test a range of values for the conversion.
 BOOST_AUTO_TEST_CASE( test_convertMeanAnomalyToHyperbolicEccentricAnomaly_range )
@@ -220,7 +160,7 @@
         // Check if computed eccentric anomaly is less than error tolerance.
         BOOST_CHECK_CLOSE_FRACTION( arrayOfExpectedHyperbolicAnomalies[ counter ],
                                     hyperbolicEccentricAnomaly,
-                                    toleranceOrbitalElementConversion );
+                                    1.0E-14 );
     }
 }
 
@@ -244,7 +184,7 @@
     // Set test value for eccentricity.
     const double testEccentricity = 1.0 + 1.0e-10;
 
-     // Set array of test values for mean anomaly.
+    // Set array of test values for mean anomaly.
     const double arrayOfTestMeanAnomalies[ 4 ] = { -10.0, -1.4, 0.5, 7.6 };
 
     // Set array of expected values for hyperbolic eccentric anomaly. These values were converted
@@ -267,13 +207,47 @@
         // Check if computed eccentric anomaly is less than error tolerance.
         BOOST_CHECK_CLOSE_FRACTION( arrayOfExpectedHyperbolicAnomalies[ counter ],
                                     hyperbolicEccentricAnomaly,
-                                    toleranceOrbitalElementConversion );
+                                    1.0E-14 );
     }
 
 }
 
-//! Test 4: Test a large number of anomalies for near-parabolic orbits.
-BOOST_AUTO_TEST_CASE( test_convertMeanAnomalyToHyperbolicEccentricAnomaly_randomNearParabolic )
+//! Generalized function to test many to and fro mean to hyperbolic eccentric anomalies.
+/*!
+ *  Generalized function to test many to and fro mean to hyperbolic eccentric anomalies.
+ *  The function allows random variations of both the mean anomlay and eccentricity. The
+ *  eccentricity may be fixed, for instance to test near-parabolic orbits for many mean
+ *  anomalies. Furthermore, the range of mean anomalies and eccentricities may be set
+ *  as exponential, so that a random number of 4.5 generates an eccentricity of 10^(4.5), to allow
+ *  testing of extreme orbits.
+ *  \param caseId Name of test case, to be used for error output purposes.
+ *  \param testTolerance Acceptance tolerance to be used for difference between original and
+ *  reconverted mean anomaly. Tolerance is absolute if useExponentialValues is false and relative
+ *  if useExponentialValues is true.
+ *  \param meanAnomalyLimit Limit of mean anomaly values, range of mean anomalies is set as
+ *  [-meanAnomalyLimit,meanAnomalyLimit].
+ *  \param useConstantEccentricity Boolean determining if a constant eccentricity is used.
+ *  \param useExponentialValues Boolean determining whether exponential values are used for
+ *  random mean anomalies and eccentricities.
+ *  \param minimumEccentricity Minimum value to be used for random eccentricities (only used if
+ *  useConstantEccentricity is false).
+ *  \param maximumEccentricity Maximum value to be used for random eccentricities (only used if
+ *  useConstantEccentricity is false).
+ *  \param constantEccentricity Constant value to be used for eccentricity (only used if
+ *  useConstantEccentricity is true).
+ *  \param numberOfSamples Number of random cases that are to be tested.
+ */
+template< typename ScalarType >
+void testMeanToHyperbolicEccentricAnomalyConversions(
+        const std::string& caseId,
+        const ScalarType testTolerance,
+        const ScalarType meanAnomalyLimit,
+        const bool useConstantEccentricity = 0,
+        const bool useExponentialValues = 0,
+        const ScalarType minimumEccentricity = TUDAT_NAN,
+        const ScalarType maximumEccentricity = TUDAT_NAN,
+        const ScalarType constantEccentricity = TUDAT_NAN,
+        const int numberOfSamples = 1E5)
 {
     // Create vectors that will store the input variables of a test that resulted in an error, such
     // that the error scenario can be reproduced.
@@ -282,119 +256,53 @@
     // Boolean that will be set true if a runtime error occurred.
     bool aRuntimeErrorOccurred = false;
 
-    // Set test value for eccentricity, which is just above 1.0.
-    const double testEccentricity = 1.0 + 1.0e-15;
+    // Set test value for eccentricity.
+    ScalarType testEccentricity = constantEccentricity;
 
-    // Initialize both test and reverse calculated hyperbolic mean anomaly and the hyperbolic
-    // eccentric anomaly.
-    double testMeanAnomaly, reverseCalculatedMeanAnomaly, hyperbolicEccentricAnomaly = TUDAT_NAN;
+    // Initialize both test and reverse calculated mean anomaly and the eccentric anomaly.
+    ScalarType testMeanAnomaly, reverseCalculatedMeanAnomaly, eccentricAnomaly = 0.0;
 
-    // Instantiate a random number generator for the mean anomaly generation, from -20 to 20.
+    // Instantiate random number generator.
     boost::mt19937 randomNumbergenerator( time( 0 ) );
-    boost::random::uniform_real_distribution< > distributionMinus20To20( -20.0, 20.0 );
+
+    // Create generator for eccentricity (only used if useConstantEccentricity is false).
+    boost::random::uniform_real_distribution< > eccentricityDistribution(
+                minimumEccentricity, maximumEccentricity );
     boost::variate_generator< boost::mt19937&, boost::random::uniform_real_distribution < > >
-            generateRandomNumberMinus20To20( randomNumbergenerator, distributionMinus20To20 );
+            eccentricityGenerator(
+                randomNumbergenerator, eccentricityDistribution );
 
-    // Specify the number of random samples should be taken. A test of 100,000,000 was performed
-    // by the author before the code was submitted. This test remains included to verify that any
-    // future method will not fail. The behaviour of the conversion is namely very sensitive and
-    // non-converging cases are highly sensitive to input values and the initial guess that is used.
-    const int numberOfSamples = 10000;
+    // Create generator for mean anomaly.
+    boost::random::uniform_real_distribution< ScalarType > meanAnomalyDistibution(
+                -meanAnomalyLimit, meanAnomalyLimit );
+    boost::variate_generator<
+            boost::mt19937&, boost::random::uniform_real_distribution < ScalarType > >
+            generateMeanAnomaly( randomNumbergenerator, meanAnomalyDistibution );
 
     // Perform the conversion for the specified number of samples and test whether the values that
     // are subsequently converted back match the initial values.
     for ( int counter = 0; counter < numberOfSamples; counter++ )
     {
-        // Set random value in test mean anomaly and the test eccentricity.
-        testMeanAnomaly = generateRandomNumberMinus20To20( );
+        // Set random value in test mean anomaly.
+        testMeanAnomaly = generateMeanAnomaly( );
 
-        // If the Rootfinder does not converge, it will produce a runtime error. In order to make
-        // sure that these values that led to the error will not be lost, they will be stored in
-        // the failed input data vectors. To do so, a try-catch sequence is used.
-        try
+        if( useExponentialValues )
         {
-            // Compute eccentric anomaly.
-            hyperbolicEccentricAnomaly = convertMeanAnomalyToHyperbolicEccentricAnomaly(
-                    testEccentricity, testMeanAnomaly );
+            testMeanAnomaly = testMeanAnomaly *
+                    std::pow( getFloatingInteger< ScalarType >( 10 ), generateMeanAnomaly( ) );
         }
-        catch( std::runtime_error )
+        // If eccentricity is to be varied, generate random value
+        if( !useConstantEccentricity )
         {
-            // Store the fact that a runtime error occurred, such that the values will be stored.
-            aRuntimeErrorOccurred = true;
-        }
+            testEccentricity = eccentricityGenerator( );
 
-        // Calculate the mean anomaly from this eccentric anomaly.
-        reverseCalculatedMeanAnomaly =
-                convertHyperbolicEccentricAnomalyToMeanAnomaly( hyperbolicEccentricAnomaly,
-                                                                testEccentricity );
-
-        // Test whether the computed mean anomaly is equal to the mean anomaly from the input and
-        // that no runtime errors occurred. If an error was found, store the values leading to this
-        // error in a vector for later use. '!' operator is there to ensure that a NaN value will
-        // result in the values being written away. It is also checked that the mean anomaly is
-        // not equal to 0.0, because that would result in falsely writing an error.
-        if ( ( ( !( std::abs( testMeanAnomaly - reverseCalculatedMeanAnomaly ) / testMeanAnomaly <
-                toleranceOrbitalElementConversionNearParabolic ) ) && ( testMeanAnomaly != 0.0 ) )
-             || aRuntimeErrorOccurred )
-        {
-            failedMeanAnomalies.push_back( testMeanAnomaly );
-            failedEccentricities.push_back( testEccentricity );
+            if( useExponentialValues )
+            {
+                testEccentricity = getFloatingInteger< ScalarType >( 1 ) +
+                        std::pow( getFloatingInteger< ScalarType >( 10 ), testEccentricity );
+            }
         }
 
-        // Reset boolean.
-        aRuntimeErrorOccurred = false;
-    }
-
-    // Check that no values have been written to the failedMeanAnomalies vector.  If so, this test
-    // is passed. Otherwisely these values will be written away and this test will fail.
-    BOOST_CHECK( failedMeanAnomalies.empty( ) );
-
-    // If the vector is not empty, write the failed cases of this test case to a file.
-    if ( !( failedMeanAnomalies.empty( ) ) )
-    {
-        writeErrorsToFile( failedEccentricities, failedMeanAnomalies, "Test4" );
-    }
-}
-
-//! Test 5: Test large number of anomalies with a large number of eccentricities, in common regime.
-BOOST_AUTO_TEST_CASE( test_convertMeanAnomalyToHyperbolicEccentricAnomaly_random )
-{
-    // Create vectors that will store the input variables of a test that resulted in an error, such
-    // that the error scenario can be reproduced.
-    std::vector< double > failedMeanAnomalies, failedEccentricities;
-
-    // Boolean that will be set true if a runtime error occurred.
-    bool aRuntimeErrorOccurred = false;
-
-    // Initialize both test and reverse calculated hyperbolic mean anomaly, the hyperbolic
-    // eccentric anomaly and the eccentricity.
-    double testEccentricity, testMeanAnomaly, reverseCalculatedMeanAnomaly,
-           hyperbolicEccentricAnomaly = TUDAT_NAN;
-
-    // Instantiate random number generators. One for the mean anomaly generation, from -20 to 20,
-    // another one for the eccentricity generation, from 1 to 10.
-    boost::mt19937 randomNumbergenerator( time( 0 ) );
-    boost::random::uniform_real_distribution< > distributionMinus20To20( -20.0, 20.0 );
-    boost::variate_generator< boost::mt19937&, boost::random::uniform_real_distribution < > >
-            generateRandomNumberMinus20To20( randomNumbergenerator, distributionMinus20To20 );
-    boost::random::uniform_real_distribution< > distribution1To10( 1.0 + 1.0e-15, 10.0 );
-    boost::variate_generator< boost::mt19937&, boost::random::uniform_real_distribution < > >
-            generateRandomNumber1To10( randomNumbergenerator, distribution1To10 );
-
-    // Specify the number of random samples should be taken. A test of 100,000,000 was performed
-    // by the author before the code was submitted. This test remains included to verify that any
-    // future method will not fail. The behaviour of the conversion is namely very sensitive and
-    // non-converging cases are highly sensitive to input values and the initial guess that is used.
-    const int numberOfSamples = 10000;
-
-    // Perform the conversion for the specified number of samples and test whether the values that
-    // are subsequently converted back match the initial values.
-    for ( int counter = 0; counter < numberOfSamples; counter++ )
-    {
-        // Set random value in test mean anomaly and the test eccentricity.
-        testMeanAnomaly = generateRandomNumberMinus20To20( );
-        testEccentricity = generateRandomNumber1To10( );
-
         // If the Rootfinder does not converge, it will produce a runtime error. In order to make
         // sure that these values that led to the error will not be lost, they will be stored in
         // the failed input data vectors. To do so, a try-catch sequence is used.
@@ -401,8 +309,8 @@
         try
         {
             // Compute eccentric anomaly.
-            hyperbolicEccentricAnomaly = convertMeanAnomalyToHyperbolicEccentricAnomaly(
-                    testEccentricity, testMeanAnomaly );
+            eccentricAnomaly = convertMeanAnomalyToHyperbolicEccentricAnomaly< ScalarType>(
+                        testEccentricity, testMeanAnomaly );
         }
         catch( std::runtime_error )
         {
@@ -411,9 +319,8 @@
         }
 
         // Calculate the mean anomaly from this eccentric anomaly.
-        reverseCalculatedMeanAnomaly =
-                convertHyperbolicEccentricAnomalyToMeanAnomaly( hyperbolicEccentricAnomaly,
-                                                                testEccentricity );
+        reverseCalculatedMeanAnomaly = convertHyperbolicEccentricAnomalyToMeanAnomaly< ScalarType>(
+                    eccentricAnomaly, testEccentricity );
 
         // Test whether the computed mean anomaly is equal to the mean anomaly from the input and
         // that no runtime errors occurred. If an error was found, store the values leading to this
@@ -420,13 +327,30 @@
         // error in a vector for later use. '!' operator is there to ensure that a NaN value will
         // result in the values being written away. It is also checked that the mean anomaly is
         // not equal to 0.0, because that would result in falsely writing an error.
-        if ( ( ( !( std::abs( testMeanAnomaly - reverseCalculatedMeanAnomaly ) / testMeanAnomaly <
-                toleranceOrbitalElementConversion ) ) && ( testMeanAnomaly != 0.0 ) )
-             || aRuntimeErrorOccurred )
+        if( !useExponentialValues )
         {
-            failedMeanAnomalies.push_back( testMeanAnomaly );
-            failedEccentricities.push_back( testEccentricity );
+            if ( ( ( !( std::abs( testMeanAnomaly - reverseCalculatedMeanAnomaly ) <
+                        testTolerance ) )
+                   && !( testMeanAnomaly == getFloatingInteger< ScalarType >( 0 ) ||
+                         reverseCalculatedMeanAnomaly == getFloatingInteger< ScalarType >( 0 ) ) )
+                 && !aRuntimeErrorOccurred )
+            {
+                failedMeanAnomalies.push_back( testMeanAnomaly );
+                failedEccentricities.push_back( testEccentricity );
+            }
         }
+        else
+        {
+            if ( ( ( !( std::abs( testMeanAnomaly - reverseCalculatedMeanAnomaly ) /
+                        testMeanAnomaly < testTolerance ) )
+                   && !( testMeanAnomaly == getFloatingInteger< ScalarType >( 0 ) ||
+                         reverseCalculatedMeanAnomaly == getFloatingInteger< ScalarType >( 0 ) ) )
+                 && !aRuntimeErrorOccurred )
+            {
+                failedMeanAnomalies.push_back( testMeanAnomaly );
+                failedEccentricities.push_back( testEccentricity );
+            }
+        }
 
         // Reset boolean.
         aRuntimeErrorOccurred = false;
@@ -439,99 +363,39 @@
     // If the vector is not empty, write the failed cases of this test case to a file.
     if ( !( failedMeanAnomalies.empty( ) ) )
     {
-        writeErrorsToFile( failedEccentricities, failedMeanAnomalies, "Test5" );
+        writeErrorsToFile( failedEccentricities, failedMeanAnomalies, caseId );
     }
 }
 
-//! Test 6: Test large number of high anomalies with a large number of high eccentricities.
-BOOST_AUTO_TEST_CASE( test_convertMeanAnomalyToHyperbolicEccentricAnomaly_random_high )
+//! Test 4: Test large number of anomalies and eccentricities
+BOOST_AUTO_TEST_CASE( test_convertMeanAnomalyToEccentricAnomaly_nearParabolic_random_double )
 {
-    // Create vectors that will store the input variables of a test that resulted in an error, such
-    // that the error scenario can be reproduced.
-    std::vector< double > failedMeanAnomalies, failedEccentricities;
+    long double ratioOfPrecision = std::numeric_limits< long double >::epsilon( ) /
+            std::numeric_limits< double >::epsilon( );
 
-    // Boolean that will be set true if a runtime error occurred.
-    bool aRuntimeErrorOccurred = false;
+    // Test random conversions for near-parabolic orbits
+    testMeanToHyperbolicEccentricAnomalyConversions< double >(
+                "DoubleParabolic", 1.0E-13, 20.0, 1, 0, TUDAT_NAN, TUDAT_NAN, 1.0 + 1.0e-15 );
+    testMeanToHyperbolicEccentricAnomalyConversions< long double >(
+                "LongDoubleParabolic", 1.0E-13L * ratioOfPrecision, 20.0L, 1, 0,
+                TUDAT_NAN, TUDAT_NAN, 1.0L + 1.0e-15L * ratioOfPrecision );
 
-    // Initialize both test and reverse calculated hyperbolic mean anomaly, the hyperbolic
-    // eccentric anomaly and the eccentricity.
-    double testEccentricity, testMeanAnomaly, reverseCalculatedMeanAnomaly,
-           hyperbolicEccentricAnomaly = TUDAT_NAN;
+    // Test random conversions for random orbits
+    testMeanToHyperbolicEccentricAnomalyConversions< double >(
+                "DoubleTypical", 1.0E-13, 20.0, 0, 0, 1.0 + 1.0e-15, 10.0, TUDAT_NAN );
+    testMeanToHyperbolicEccentricAnomalyConversions< long double >(
+                "LongDoubleTypical", 1.0E-13L, 20.0L, 0, 0, 1.0L + 1.0e-15L * ratioOfPrecision,
+                10.0L, TUDAT_NAN );
 
-    // Instantiate random number generators. One for the mean anomaly generation, from -1.2e12 to
-    // 1.2e12, another one for the eccentricity generation, from 1.0 to 1.0e15.
-    boost::mt19937 randomNumbergenerator( time( 0 ) );
-    boost::random::uniform_real_distribution< > distributionMinus12To12( -12, 12 );
-    boost::variate_generator< boost::mt19937&, boost::random::uniform_real_distribution < > >
-            generateRandomNumberMinus12To12( randomNumbergenerator, distributionMinus12To12 );
-    boost::random::uniform_real_distribution< > distribution0To15( 0, 15 );
-    boost::variate_generator< boost::mt19937&, boost::random::uniform_real_distribution < > >
-            generateRandomNumber0To15( randomNumbergenerator, distribution0To15 );
+    // Test random conversions for extreme values of eccentricity and mean anomaly.
+    testMeanToHyperbolicEccentricAnomalyConversions< double >(
+                "DoubleHighlyEccentric", 1.0E-14, 12.0, 0, 1, 0.0, 15.0, TUDAT_NAN );
+    testMeanToHyperbolicEccentricAnomalyConversions< long double >(
+                "LongDoubleHighlyEccentric", 1.0E-14L, 12.0L, 0, 1, 0.0L, 15.0L, TUDAT_NAN );
 
-    // Specify the number of random samples should be taken. A test of 100,000,000 was performed
-    // by the author before the code was submitted. This test remains included to verify that any
-    // future method will not fail. The behaviour of the conversion is namely very sensitive and
-    // non-converging cases are highly sensitive to input values and the initial guess that is used.
-    const int numberOfSamples = 10000;
-
-    // Perform the conversion for the specified number of samples and test whether the values that
-    // are subsequently converted back match the initial values.
-    for ( int counter = 0; counter < numberOfSamples; counter++ )
-    {
-        // Set random value in test mean anomaly and the test eccentricity.
-        testMeanAnomaly = generateRandomNumberMinus12To12( ) *
-                          std::pow( 10, generateRandomNumberMinus12To12( ) );
-        testEccentricity = 1.0 + 1.0 * std::pow( 10, generateRandomNumber0To15( ) );
-
-        // If the Rootfinder does not converge, it will produce a runtime error. In order to make
-        // sure that these values that led to the error will not be lost, they will be stored in
-        // the failed input data vectors. To do so, a try-catch sequence is used.
-        try
-        {
-            // Compute eccentric anomaly.
-            hyperbolicEccentricAnomaly = convertMeanAnomalyToHyperbolicEccentricAnomaly(
-                    testEccentricity, testMeanAnomaly );
-        }
-        catch( std::runtime_error )
-        {
-            // Store the fact that a runtime error occurred, such that the values will be stored.
-            aRuntimeErrorOccurred = true;
-        }
-
-        // Calculate the mean anomaly from this eccentric anomaly.
-        reverseCalculatedMeanAnomaly =
-                convertHyperbolicEccentricAnomalyToMeanAnomaly( hyperbolicEccentricAnomaly,
-                                                                testEccentricity );
-
-        // Test whether the computed mean anomaly is equal to the mean anomaly from the input and
-        // that no runtime errors occurred. If an error was found, store the values leading to this
-        // error in a vector for later use. '!' operator is there to ensure that a NaN value will
-        // result in the values being written away. It is also checked that the mean anomaly is
-        // not equal to 0.0, because that would result in falsely writing an error.
-        if ( ( ( !( std::abs( testMeanAnomaly - reverseCalculatedMeanAnomaly ) / testMeanAnomaly <
-                toleranceOrbitalElementConversion ) ) && ( testMeanAnomaly != 0.0 ) )
-             || aRuntimeErrorOccurred )
-        {
-            failedMeanAnomalies.push_back( testMeanAnomaly );
-            failedEccentricities.push_back( testEccentricity );
-        }
-
-        // Reset boolean.
-        aRuntimeErrorOccurred = false;
-    }
-
-    // Check that no values have been written to the failedMeanAnomalies vector.  If so, this test
-    // is passed. Otherwisely these values will be written away and this test will fail.
-    BOOST_CHECK( failedMeanAnomalies.empty( ) );
-
-    // If the vector is not empty, write the failed cases of this test case to a file.
-    if ( !( failedMeanAnomalies.empty( ) ) )
-    {
-        writeErrorsToFile( failedEccentricities, failedMeanAnomalies, "Test6" );
-    }
 }
 
-//! Test 7: Test functionality of specifying the initial guess.
+//! Test 5: Test functionality of specifying the initial guess.
 BOOST_AUTO_TEST_CASE( test_convertMeanAnomalyToHyperbolicEccentricAnomaly_specificInitialGuess )
 {
     // Set test value for eccentricity.
@@ -552,7 +416,7 @@
 
     // Check if computed eccentric anomaly is NaN for invalid eccentricity.
     BOOST_CHECK_CLOSE_FRACTION( expectedHyperbolicEccentricAnomaly, hyperbolicEccentricAnomaly,
-                                toleranceOrbitalElementConversion );
+                                1.0E-14 );
 }
 
 // End Boost test suite.
Index: Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h
===================================================================
--- Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h	(revision 586)
+++ Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h	(revision 588)
@@ -39,6 +39,7 @@
  *                                  Comments.
  *      121205    P. Musegaas       Updated code to final version of rootfinders.
  *      130120    K. Kumar          Updated VectorXd to Vector6d.
+ *      150417    D. Dirkx          Made modifications for templated element conversions.
  *
  *    References
  *
@@ -51,14 +52,17 @@
 
 #include <Eigen/Core>
 
-#include <boost/bind.hpp>
 #include <boost/make_shared.hpp>
+#include <boost/exception/all.hpp>
 
-#include "Tudat/Mathematics/RootFinders/newtonRaphson.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/astrodynamicsFunctions.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h"
+
 #include "Tudat/Mathematics/RootFinders/rootFinder.h"
-#include "Tudat/Mathematics/RootFinders/terminationConditions.h"
-#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+#include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/convertMeanToEccentricAnomalies.h"
 
+
 namespace tudat
 {
 
@@ -97,12 +101,107 @@
  *          finalStateInKeplerianElements( 4 ) = longitude of ascending node,                 [rad]
  *          finalStateInKeplerianElements( 5 ) = true anomaly.                                [rad]
  */
-basic_mathematics::Vector6d propagateKeplerOrbit(
-        const basic_mathematics::Vector6d& initialStateInKeplerianElements,
-        const double propagationTime,
-        const double centralBodyGravitationalParameter,
-        root_finders::RootFinderPointer aRootFinder = root_finders::RootFinderPointer( ) );
+template< typename ScalarType = double >
+Eigen::Matrix< ScalarType, 6, 1 > propagateKeplerOrbit(
+        const Eigen::Matrix< ScalarType, 6, 1 >& initialStateInKeplerianElements,
+        const ScalarType propagationTime,
+        const ScalarType centralBodyGravitationalParameter,
+        boost::shared_ptr< root_finders::RootFinderCore< ScalarType > > aRootFinder =
+        boost::shared_ptr< root_finders::RootFinderCore< ScalarType > >( ) )
+{
+    // Create final state in Keplerian elements.
+    Eigen::Matrix< ScalarType, 6, 1 > finalStateInKeplerianElements =
+            initialStateInKeplerianElements;
 
+    // Check if eccentricity is valid.
+    if ( initialStateInKeplerianElements( eccentricityIndex ) <
+         mathematical_constants::getFloatingInteger< ScalarType >( 0 ) )
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error( "Eccentricity is invalid (smaller than 0)." ) ) );
+    }
+
+    // Check if orbit is elliptical.
+    else if ( initialStateInKeplerianElements( eccentricityIndex ) <
+              mathematical_constants::getFloatingInteger< ScalarType >( 1 ) )
+    {
+        // Convert initial true anomaly to eccentric anomaly.
+        const ScalarType initialEccentricAnomaly =
+                convertTrueAnomalyToEccentricAnomaly< ScalarType >(
+                    initialStateInKeplerianElements( trueAnomalyIndex ),
+                    initialStateInKeplerianElements( eccentricityIndex ) );
+
+        // Convert initial eccentric anomaly to mean anomaly.
+        const ScalarType initialMeanAnomaly =
+                convertEccentricAnomalyToMeanAnomaly< ScalarType >(
+                    initialEccentricAnomaly,
+                    initialStateInKeplerianElements( eccentricityIndex ) );
+
+        // Compute change of mean anomaly between start and end of propagation.
+        const ScalarType meanAnomalyChange =
+                convertElapsedTimeToEllipticalMeanAnomalyChange< ScalarType >(
+                    propagationTime, centralBodyGravitationalParameter,
+                    initialStateInKeplerianElements( semiMajorAxisIndex ) );
+
+        // Compute eccentric anomaly for mean anomaly.
+        const ScalarType finalEccentricAnomaly =
+                convertMeanAnomalyToEccentricAnomaly< ScalarType >(
+                    initialStateInKeplerianElements( eccentricityIndex ),
+                    initialMeanAnomaly + meanAnomalyChange );
+
+        // Compute true anomaly for computed eccentric anomaly.
+        finalStateInKeplerianElements( trueAnomalyIndex ) =
+                convertEccentricAnomalyToTrueAnomaly< ScalarType >(
+                    finalEccentricAnomaly, finalStateInKeplerianElements( eccentricityIndex ) );
+    }
+
+    // Check if the orbit is hyperbolic.
+    else if ( initialStateInKeplerianElements( eccentricityIndex ) >
+              mathematical_constants::getFloatingInteger< ScalarType >( 1 ))
+    {
+        // Convert initial true anomaly to hyperbolic eccentric anomaly.
+        const ScalarType initialHyperbolicEccentricAnomaly =
+                convertTrueAnomalyToHyperbolicEccentricAnomaly(
+                    initialStateInKeplerianElements( trueAnomalyIndex ),
+                    initialStateInKeplerianElements( eccentricityIndex ) );
+
+        // Convert initial hyperbolic eccentric anomaly to the hyperbolic mean anomaly.
+        const ScalarType initialHyperbolicMeanAnomaly =
+                convertHyperbolicEccentricAnomalyToMeanAnomaly(
+                    initialHyperbolicEccentricAnomaly,
+                    initialStateInKeplerianElements( eccentricityIndex ) );
+
+        // Compute change of mean anomaly because of the propagation time.
+        const ScalarType hyperbolicMeanAnomalyChange =
+                convertElapsedTimeToHyperbolicMeanAnomalyChange(
+                    propagationTime, centralBodyGravitationalParameter,
+                    initialStateInKeplerianElements( semiMajorAxisIndex ) );
+
+        // Compute hyperbolic eccentric anomaly for mean anomaly.
+        const ScalarType finalHyperbolicEccentricAnomaly =
+                convertMeanAnomalyToHyperbolicEccentricAnomaly(
+                    initialStateInKeplerianElements( eccentricityIndex ),
+                    initialHyperbolicMeanAnomaly + hyperbolicMeanAnomalyChange );
+
+        // Compute true anomaly for computed hyperbolic eccentric anomaly.
+        finalStateInKeplerianElements( trueAnomalyIndex ) =
+                convertHyperbolicEccentricAnomalyToTrueAnomaly(
+                               finalHyperbolicEccentricAnomaly,
+                               finalStateInKeplerianElements( eccentricityIndex ) );
+    }
+
+    // In this case the eccentricity has to be 1.0, hence the orbit is parabolic.
+    else
+    {
+        boost::throw_exception(
+                    boost::enable_error_info(
+                        std::runtime_error( "Parabolic orbits are not (yet) supported." ) ) );
+    }
+
+    return finalStateInKeplerianElements;
+}
+
 } // namespace orbital_element_conversions
 
 } // namespace tudat
Index: Tudat/Astrodynamics/BasicAstrodynamics/CMakeLists.txt
===================================================================
--- Tudat/Astrodynamics/BasicAstrodynamics/CMakeLists.txt	(revision 586)
+++ Tudat/Astrodynamics/BasicAstrodynamics/CMakeLists.txt	(revision 588)
@@ -40,24 +40,19 @@
 
 # Set the source files.
 set(BASICASTRODYNAMICS_SOURCES
-  "${SRCROOT}${BASICASTRODYNAMICSDIR}/convertMeanAnomalyToEccentricAnomaly.cpp"
-  "${SRCROOT}${BASICASTRODYNAMICSDIR}/convertMeanAnomalyToHyperbolicEccentricAnomaly.cpp"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/clohessyWiltshirePropagator.cpp"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/geodeticCoordinateConversions.cpp"
-  "${SRCROOT}${BASICASTRODYNAMICSDIR}/keplerPropagator.cpp"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/missionGeometry.cpp"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/modifiedEquinoctialElementConversions.cpp"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/timeConversions.cpp"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/astrodynamicsFunctions.cpp"
-  "${SRCROOT}${BASICASTRODYNAMICSDIR}/orbitalElementConversions.cpp"
 )
 
 # Set the header files.
-set(BASICASTRODYNAMICS_HEADERS 
+set(BASICASTRODYNAMICS_HEADERS
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/accelerationModel.h"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/celestialBodyConstants.h"
-  "${SRCROOT}${BASICASTRODYNAMICSDIR}/convertMeanAnomalyToEccentricAnomaly.h"
-  "${SRCROOT}${BASICASTRODYNAMICSDIR}/convertMeanAnomalyToHyperbolicEccentricAnomaly.h"
+  "${SRCROOT}${BASICASTRODYNAMICSDIR}/convertMeanToEccentricAnomalies.h"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/clohessyWiltshirePropagator.h"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/geodeticCoordinateConversions.h"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/keplerPropagator.h"
@@ -102,13 +97,13 @@
 setup_custom_test_program(test_UnitConversions "${SRCROOT}${BASICASTRODYNAMICSDIR}")
 target_link_libraries(test_UnitConversions tudat_basic_astrodynamics tudat_basic_mathematics ${Boost_LIBRARIES})
 
-add_executable(test_MeanToEccenticAnomalyConversion "${SRCROOT}${BASICASTRODYNAMICSDIR}/UnitTests/unitTestConvertMeanAnomalyToEccentricAnomaly.cpp")
-setup_custom_test_program(test_MeanToEccenticAnomalyConversion "${SRCROOT}${BASICASTRODYNAMICSDIR}")
-target_link_libraries(test_MeanToEccenticAnomalyConversion tudat_basic_astrodynamics tudat_basic_mathematics tudat_root_finders ${Boost_LIBRARIES})
+add_executable(test_MeanToEccentricAnomalyConversion "${SRCROOT}${BASICASTRODYNAMICSDIR}/UnitTests/unitTestConvertMeanAnomalyToEccentricAnomaly.cpp")
+setup_custom_test_program(test_MeanToEccentricAnomalyConversion "${SRCROOT}${BASICASTRODYNAMICSDIR}")
+target_link_libraries(test_MeanToEccentricAnomalyConversion tudat_basic_astrodynamics tudat_basic_mathematics tudat_root_finders ${Boost_LIBRARIES})
 
-add_executable(test_MeanToHyperbolicEccenticAnomalyConversion "${SRCROOT}${BASICASTRODYNAMICSDIR}/UnitTests/unitTestConvertMeanAnomalyToHyperbolicEccentricAnomaly.cpp")
-setup_custom_test_program(test_MeanToHyperbolicEccenticAnomalyConversion "${SRCROOT}${BASICASTRODYNAMICSDIR}")
-target_link_libraries(test_MeanToHyperbolicEccenticAnomalyConversion tudat_basic_astrodynamics tudat_basic_mathematics tudat_root_finders ${Boost_LIBRARIES})
+add_executable(test_MeanToHyperbolicEccentricAnomalyConversion "${SRCROOT}${BASICASTRODYNAMICSDIR}/UnitTests/unitTestConvertMeanAnomalyToHyperbolicEccentricAnomaly.cpp")
+setup_custom_test_program(test_MeanToHyperbolicEccentricAnomalyConversion "${SRCROOT}${BASICASTRODYNAMICSDIR}")
+target_link_libraries(test_MeanToHyperbolicEccentricAnomalyConversion tudat_basic_astrodynamics tudat_basic_mathematics tudat_root_finders ${Boost_LIBRARIES})
 
 add_executable(test_KeplerPropagator "${SRCROOT}${BASICASTRODYNAMICSDIR}/UnitTests/unitTestKeplerPropagator.cpp")
 setup_custom_test_program(test_KeplerPropagator "${SRCROOT}${BASICASTRODYNAMICSDIR}")
Index: Tudat/Astrodynamics/MissionSegments/UnitTests/unitTestLambertRoutines.cpp
===================================================================
--- Tudat/Astrodynamics/MissionSegments/UnitTests/unitTestLambertRoutines.cpp	(revision 586)
+++ Tudat/Astrodynamics/MissionSegments/UnitTests/unitTestLambertRoutines.cpp	(revision 588)
@@ -253,7 +253,7 @@
     const double testSolarGravitationalParameter = 1.32712428e20;
 
     // Set Keplerian elements at departure and arrival.
-    Eigen::VectorXd keplerianStateAtDeparture( 6 ), keplerianStateAtArrival( 6 );
+    Eigen::Matrix< double, 6, 1 > keplerianStateAtDeparture, keplerianStateAtArrival;
     keplerianStateAtDeparture << convertAstronomicalUnitsToMeters( 1.0 ),
                                     0.0, 0.0, 0.0, 0.0, 0.0;
     keplerianStateAtArrival << convertAstronomicalUnitsToMeters( 1.5 ),
@@ -260,10 +260,10 @@
             0.0, 0.0, 0.0, 0.0, convertDegreesToRadians( 179.999 );
 
     //  Convert to Cartesian elements.
-    const Eigen::VectorXd cartesianStateAtDeparture =
+    const Eigen::Matrix< double, 6, 1 > cartesianStateAtDeparture =
             orbital_element_conversions::convertKeplerianToCartesianElements(
                 keplerianStateAtDeparture, testSolarGravitationalParameter );
-    const Eigen::VectorXd cartesianStateAtArrival =
+    const Eigen::Matrix< double, 6, 1 > cartesianStateAtArrival =
             orbital_element_conversions::convertKeplerianToCartesianElements(
                 keplerianStateAtArrival, testSolarGravitationalParameter );
 
Index: Tudat/Astrodynamics/MissionSegments/UnitTests/unitTestLambertTargeterIzzo.cpp
===================================================================
--- Tudat/Astrodynamics/MissionSegments/UnitTests/unitTestLambertTargeterIzzo.cpp	(revision 586)
+++ Tudat/Astrodynamics/MissionSegments/UnitTests/unitTestLambertTargeterIzzo.cpp	(revision 588)
@@ -308,7 +308,7 @@
     const double solarGravitationalParameter = 1.32712428e20;
 
     // Set Keplerian elements at departure and arrival.
-    Eigen::VectorXd keplerianStateAtDeparture( 6 ), keplerianStateAtArrival( 6 );
+    Eigen::Matrix< double, 6, 1 > keplerianStateAtDeparture, keplerianStateAtArrival;
     keplerianStateAtDeparture << convertAstronomicalUnitsToMeters( 1.0 ), 0.0,
             0.0, 0.0, 0.0, 0.0;
     keplerianStateAtArrival << convertAstronomicalUnitsToMeters( 1.5 ), 0.0, 0.0,
@@ -315,10 +315,10 @@
             0.0, 0.0, convertDegreesToRadians( 179.999 );
 
     //  Convert to Cartesian elements.
-    const Eigen::VectorXd cartesianStateAtDeparture =
+    const Eigen::Matrix< double, 6, 1 > cartesianStateAtDeparture =
             orbital_element_conversions::convertKeplerianToCartesianElements(
                 keplerianStateAtDeparture, solarGravitationalParameter );
-    const Eigen::VectorXd cartesianStateAtArrival =
+    const Eigen::Matrix< double, 6, 1 > cartesianStateAtArrival =
             orbital_element_conversions::convertKeplerianToCartesianElements(
                 keplerianStateAtArrival, solarGravitationalParameter );
 
Index: Tudat/Astrodynamics/MissionSegments/UnitTests/unitTestZeroRevolutionLambertTargeterIzzo.cpp
===================================================================
--- Tudat/Astrodynamics/MissionSegments/UnitTests/unitTestZeroRevolutionLambertTargeterIzzo.cpp	(revision 586)
+++ Tudat/Astrodynamics/MissionSegments/UnitTests/unitTestZeroRevolutionLambertTargeterIzzo.cpp	(revision 588)
@@ -270,7 +270,7 @@
     const double solarGravitationalParameter = 1.32712428e20;
 
     // Set Keplerian elements at departure and arrival.
-    Eigen::VectorXd keplerianStateAtDeparture( 6 ), keplerianStateAtArrival( 6 );
+    Eigen::Matrix< double, 6, 1 > keplerianStateAtDeparture, keplerianStateAtArrival;
     keplerianStateAtDeparture << convertAstronomicalUnitsToMeters( 1.0 ), 0.0,
             0.0, 0.0, 0.0, 0.0;
     keplerianStateAtArrival << convertAstronomicalUnitsToMeters( 1.5 ), 0.0, 0.0,
@@ -277,10 +277,10 @@
             0.0, 0.0, convertDegreesToRadians( 179.999 );
 
     //  Convert to Cartesian elements.
-    const Eigen::VectorXd cartesianStateAtDeparture =
+    const Eigen::Matrix< double, 6, 1 > cartesianStateAtDeparture =
             orbital_element_conversions::convertKeplerianToCartesianElements(
                 keplerianStateAtDeparture, solarGravitationalParameter );
-    const Eigen::VectorXd cartesianStateAtArrival =
+    const Eigen::Matrix< double, 6, 1 > cartesianStateAtArrival =
             orbital_element_conversions::convertKeplerianToCartesianElements(
                 keplerianStateAtArrival, solarGravitationalParameter );
 
Index: Tudat/Astrodynamics/StateDerivativeModels/UnitTests/unitTestCartesianStateDerivativeModel.cpp
===================================================================
--- Tudat/Astrodynamics/StateDerivativeModels/UnitTests/unitTestCartesianStateDerivativeModel.cpp	(revision 586)
+++ Tudat/Astrodynamics/StateDerivativeModels/UnitTests/unitTestCartesianStateDerivativeModel.cpp	(revision 588)
@@ -316,8 +316,8 @@
                 boost::bind( &TestBody2d::getCurrentTime, body ) );
 
     // Create list of acceleration models to provide to state derivative model.
-    CartesianStateDerivativeModel4d::AccelerationModelPointerVector listOfAccelerations;
-    listOfAccelerations = list_of( firstAccelerationModel2d )( secondAccelerationModel2d );
+    CartesianStateDerivativeModel4d::AccelerationModelPointerVector listOfAccelerations
+            = list_of( firstAccelerationModel2d )( secondAccelerationModel2d );
 
     // Declare Cartesian state derivative model.
     CartesianStateDerivativeModel4dPointer stateDerivativeModel
Index: Tudat/Astrodynamics/Ephemerides/approximatePlanetPositions.cpp
===================================================================
--- Tudat/Astrodynamics/Ephemerides/approximatePlanetPositions.cpp	(revision 586)
+++ Tudat/Astrodynamics/Ephemerides/approximatePlanetPositions.cpp	(revision 588)
@@ -145,16 +145,12 @@
         meanAnomalyAtGivenJulianDate_ -= 360.0;
     }
 
-    // Set eccentricity and mean anomaly for mean anomaly to eccentric anomaly conversion.
-    orbital_element_conversions::ConvertMeanAnomalyToEccentricAnomaly
-                convertMeanAnomalyToEccentricAnomaly_(
+    // Convert mean anomaly to eccentric anomaly.
+    eccentricAnomalyAtGivenJulianDate_ = convertMeanAnomalyToEccentricAnomaly(
                 planetKeplerianElementsAtGivenJulianDate_( eccentricityIndex ),
                 unit_conversions::convertDegreesToRadians(
                     meanAnomalyAtGivenJulianDate_ ) );
 
-    // Convert mean anomaly to eccentric anomaly.
-    eccentricAnomalyAtGivenJulianDate_ = convertMeanAnomalyToEccentricAnomaly_.convert( );
-
     // Convert eccentric anomaly to true anomaly and set in planet elements.
     trueAnomalyAtGivenJulianData_
             = orbital_element_conversions::convertEccentricAnomalyToTrueAnomaly(
Index: Tudat/Astrodynamics/Ephemerides/approximatePlanetPositions.h
===================================================================
--- Tudat/Astrodynamics/Ephemerides/approximatePlanetPositions.h	(revision 586)
+++ Tudat/Astrodynamics/Ephemerides/approximatePlanetPositions.h	(revision 588)
@@ -47,7 +47,7 @@
 
 #include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
 
-#include "Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToEccentricAnomaly.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/convertMeanToEccentricAnomalies.h"
 #include "Tudat/Astrodynamics/Ephemerides/approximatePlanetPositionsBase.h"
 
 #include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
Index: Tudat/Astrodynamics/Ephemerides/keplerStateExtractor.cpp
===================================================================
--- Tudat/Astrodynamics/Ephemerides/keplerStateExtractor.cpp	(revision 586)
+++ Tudat/Astrodynamics/Ephemerides/keplerStateExtractor.cpp	(revision 588)
@@ -46,7 +46,7 @@
 
 #include "Tudat/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h"
 
-#include "Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToEccentricAnomaly.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/convertMeanToEccentricAnomalies.h"
 #include "Tudat/Astrodynamics/BasicAstrodynamics/stateVectorIndices.h"
 #include "Tudat/Astrodynamics/Ephemerides/keplerStateExtractor.h"
 #include "Tudat/InputOutput/parsedDataVectorUtilities.h"
@@ -166,13 +166,10 @@
         const double eccentricity
                 = ( *keplerianElements )( orbital_element_conversions::eccentricityIndex );
 
-        // Declare mean to eccentric anomaly conversion class.
-        orbital_element_conversions::ConvertMeanAnomalyToEccentricAnomaly
+        // Convert to eccentric anomaly.
+        const double eccentricAnomaly = orbital_element_conversions::
                 convertMeanAnomalyToEccentricAnomaly( eccentricity, meanAnomaly );
 
-        // Convert to eccentric anomaly.
-        const double eccentricAnomaly = convertMeanAnomalyToEccentricAnomaly.convert( );
-
         // Convert eccentric anomaly to true anomaly and set the latter.
         ( *keplerianElements )( orbital_element_conversions::trueAnomalyIndex )
                 = orbital_element_conversions::
Index: Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestApproximatePlanetPositions.cpp
===================================================================
--- Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestApproximatePlanetPositions.cpp	(revision 586)
+++ Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestApproximatePlanetPositions.cpp	(revision 588)
@@ -84,7 +84,7 @@
     const double tolerance = 2.0e-2;
 
     // Expected result.
-    Eigen::VectorXd expectedKeplerianElements( 6 );
+    Eigen::Matrix< double, 6, 1 > expectedKeplerianElements;
     expectedKeplerianElements[ 0 ] = 2.279361944126564e11;
     expectedKeplerianElements[ 1 ] = 9.338126166083623e-2;
     expectedKeplerianElements[ 2 ] = convertDegreesToRadians( 1.848907897011101 );
Index: Tudat/InputOutput/CMakeLists.txt
===================================================================
--- Tudat/InputOutput/CMakeLists.txt	(revision 586)
+++ Tudat/InputOutput/CMakeLists.txt	(revision 588)
@@ -98,7 +98,7 @@
 
 add_executable(test_TwoLineElementsTextFileReader "${SRCROOT}${INPUTOUTPUTDIR}/UnitTests/unitTestTwoLineElementsTextFileReader.cpp")
 setup_custom_test_program(test_TwoLineElementsTextFileReader "${SRCROOT}${INPUTOUTPUTDIR}")
-target_link_libraries(test_TwoLineElementsTextFileReader tudat_input_output tudat_basic_astrodynamics ${Boost_LIBRARIES})
+target_link_libraries(test_TwoLineElementsTextFileReader tudat_input_output tudat_basic_astrodynamics tudat_basic_mathematics ${Boost_LIBRARIES})
 
 add_executable(test_BasicInputOutput "${SRCROOT}${INPUTOUTPUTDIR}/UnitTests/unitTestBasicInputOutput.cpp")
 setup_custom_test_program(test_BasicInputOutput "${SRCROOT}${INPUTOUTPUTDIR}")
Index: Tudat/CMakeLists.txt
===================================================================
--- Tudat/CMakeLists.txt	(revision 586)
+++ Tudat/CMakeLists.txt	(revision 588)
@@ -79,17 +79,17 @@
       endif(${flag_var} MATCHES "/MD")
     endforeach(flag_var)
   else()
-    set(CMAKE_CXX_FLAGS 
-        "${CMAKE_CXX_FLAGS} -Wall -g -Woverloaded-virtual -Wold-style-cast -Wnon-virtual-dtor")
+    set(CMAKE_CXX_FLAGS
+        "${CMAKE_CXX_FLAGS} -Wall -g -std=c++11 -Woverloaded-virtual -Wold-style-cast -Wnon-virtual-dtor")
   endif()
 else()
   set(CMAKE_CXX_FLAGS
-      "${CMAKE_CXX_FLAGS} -Wall -g -Woverloaded-virtual -Wold-style-cast -Wnon-virtual-dtor")
+      "${CMAKE_CXX_FLAGS} -Wall -g -std=c++11 -Woverloaded-virtual -Wold-style-cast -Wnon-virtual-dtor")
 endif()
 
 # -------------------------------------------------------------------------------------------------
 # DO NOT MANUALLY EDIT ANY SETTINGS AFTER THIS POINT IN THE FILE.
-# 
+#
 # Pass any additional settings directly to CMake (e.g., via command-line) or by using a config file
 # (e.g., UserSettings.txt).
 # -------------------------------------------------------------------------------------------------
@@ -104,7 +104,7 @@
   # Load the user specified file.
   if (TUDAT_USER_SETTINGS)
     include($TUDAT_USER_SETTINGS OPTIONAL)
-  else()  
+  else()
     include($ENV{TUDAT_USER_SETTINGS} OPTIONAL)
   endif()
 endif()
