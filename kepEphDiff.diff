=== modified file 'Tudat/Astrodynamics/BasicAstrodynamics/CMakeLists.txt'
--- Tudat/Astrodynamics/BasicAstrodynamics/CMakeLists.txt	2014-04-07 10:50:37 +0000
+++ Tudat/Astrodynamics/BasicAstrodynamics/CMakeLists.txt	2015-04-16 13:10:30 +0000
@@ -65,6 +65,7 @@
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/timeConversions.h"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/UnitTests/testAccelerationModels.h"
   "${SRCROOT}${BASICASTRODYNAMICSDIR}/UnitTests/testBody.h"
+  "${SRCROOT}${BASICASTRODYNAMICSDIR}/UnitTests/keplerPropagatorTestData.h"
 )
 
 # Add static libraries.

=== added file 'Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/keplerPropagatorTestData.h'
--- Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/keplerPropagatorTestData.h	1970-01-01 00:00:00 +0000
+++ Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/keplerPropagatorTestData.h	2015-04-16 13:10:30 +0000
@@ -0,0 +1,137 @@
+#ifndef KEPLERPROPAGATORTESTDATA_H
+#define KEPLERPROPAGATORTESTDATA_H
+
+#include <Eigen/Core>
+
+namespace tudat
+{
+namespace unit_tests
+{
+
+//! Typedef for propagation history.
+typedef std::map < double, Eigen::VectorXd > PropagationHistory;
+
+//! Get Earth gravitational parameter for benchmark data from (Melman, 2010).
+double getMelmanEarthGravitationalParameter( )
+{
+    // Return Earth gravitational parameter [m^3 s^-2].
+    return 3.986004415e14;
+}
+
+//! Get benchmark data from (Melman, 2010).
+PropagationHistory getMelmanBenchmarkData( )
+{
+    // Declare benchmark pragation history.
+    PropagationHistory benchmarkPropagationHistory;
+
+    // Populate benchmark propagation history.
+    Eigen::VectorXd stateInCartesianElements( 6 );
+    Eigen::VectorXd stateInKeplerianElements( 6 );
+
+    stateInCartesianElements << 6.75e6, 0.0, 0.0, 0.0, 8.0595973215e3, 0.0;
+    stateInKeplerianElements = orbital_element_conversions::convertCartesianToKeplerianElements(
+                stateInCartesianElements, getMelmanEarthGravitationalParameter( ) );
+    benchmarkPropagationHistory[ 0.0 ] = stateInKeplerianElements;
+
+    stateInCartesianElements << -6.1318272067e6, 5.1974105627e6, 0.0,
+            -4.7375063953e3, -4.8565484865e3, 0.0;
+    stateInKeplerianElements = orbital_element_conversions::convertCartesianToKeplerianElements(
+                stateInCartesianElements, getMelmanEarthGravitationalParameter( ) );
+    benchmarkPropagationHistory[ 86400.0 ] = stateInKeplerianElements;
+
+    // Return benchmark data.
+    return benchmarkPropagationHistory;
+}
+
+//! Get ODTBX benchmark data.
+PropagationHistory getODTBXBenchmarkData( )
+{
+    // Declare benchmark pragation history.
+    PropagationHistory benchmarkPropagationHistory;
+
+    // Populate benchmark propagation history.
+    Eigen::VectorXd stateInKeplerianElements( 6 );
+
+    stateInKeplerianElements << 42165.3431351313e3, 0.26248354351331, 0.30281462522101,
+            4.71463172847351, 4.85569272927819, 2.37248926702153;
+
+    // Set time step.
+    double timeStep = 8640.0;
+
+    for ( unsigned int i = 0; i < 11; i++ )
+    {
+        benchmarkPropagationHistory[ static_cast< double >( i ) * timeStep ]
+                = stateInKeplerianElements;
+    }
+
+    benchmarkPropagationHistory[ 1.0 * timeStep ]( 5 ) = 2.79722436211144;
+    benchmarkPropagationHistory[ 2.0 * timeStep ]( 5 ) = 3.18337407409023;
+    benchmarkPropagationHistory[ 3.0 * timeStep ]( 5 ) = 3.57400974200765;
+    benchmarkPropagationHistory[ 4.0 * timeStep ]( 5 ) = 4.01425565759545;
+    benchmarkPropagationHistory[ 5.0 * timeStep ]( 5 ) = 4.57232665706546;
+    benchmarkPropagationHistory[ 6.0 * timeStep ]( 5 ) = 5.35956850972672;
+    benchmarkPropagationHistory[ 7.0 * timeStep ]( 5 ) = 0.137251905665217;
+    benchmarkPropagationHistory[ 8.0 * timeStep ]( 5 ) = 1.14521863765007;
+    benchmarkPropagationHistory[ 9.0 * timeStep ]( 5 ) = 1.86433634881636;
+    benchmarkPropagationHistory[ 10.0 * timeStep ]( 5 ) = 2.38486787064101;
+
+    return benchmarkPropagationHistory;
+}
+
+//! Get GTOP gravitational parameter for benchmark data from GTOP.
+double getGTOPGravitationalParameter( )
+{
+    // Return inaccurate gravitational parameter of the Sun [m^3 s^-2].
+    return 1.327e20;
+}
+
+//! Get benchmark data from GTOP.
+PropagationHistory getGTOPBenchmarkData( )
+{
+    // Declare benchmark pragation history.
+    PropagationHistory benchmarkPropagationHistory;
+
+    // Populate benchmark propagation history. Obtained by propagating an orbit starting at
+    // x = 1.5e11, V_y = 6.0e4 for a period of 100 days four times consecutively. Since GTOP does
+    // not work with similar Keplerian orbital elements, the cartesian elements resulting from that
+    // are converted to Keplerian elements first. These initial starting coordinates correspond to
+    // a semi major axis of -7.24873e+010 meters and an eccentricity of 3.06933.
+    Eigen::VectorXd stateInCartesianElements( 6 ), stateInKeplerianElements( 6 );
+
+    stateInCartesianElements << 1.5e11, 0.0, 0.0, 0.0, 6.0e4, 0.0;
+    stateInKeplerianElements = orbital_element_conversions::convertCartesianToKeplerianElements(
+                stateInCartesianElements, getGTOPGravitationalParameter( ) );
+    benchmarkPropagationHistory[ 0.0 ] = stateInKeplerianElements;
+
+    stateInCartesianElements << 50369576778.98602, 453006898372.5074, 2.156946592732799e-005,
+            -14654.13750690802, 46884.94068619227, 4.665334803219454e-012;
+    stateInKeplerianElements = orbital_element_conversions::convertCartesianToKeplerianElements(
+                stateInCartesianElements, getGTOPGravitationalParameter( ) );
+    benchmarkPropagationHistory[ 8640000.0 ] = stateInKeplerianElements;
+
+    stateInCartesianElements << -76810236076.38216, 842661848023.4473, 6.100268297443444e-005,
+            -14683.57015580225, 43917.12010513522, 4.48721854707566e-012;
+    stateInKeplerianElements = orbital_element_conversions::convertCartesianToKeplerianElements(
+                stateInCartesianElements, getGTOPGravitationalParameter( ) );
+    benchmarkPropagationHistory[ 8640000.0 * 2.0 ] = stateInKeplerianElements;
+
+    stateInCartesianElements << -203052258817.9893, 1216808019495.603, 9.937145023346651e-005,
+            -14543.34378775917, 42828.66589049961, 4.403399939593385e-012;
+    stateInKeplerianElements = orbital_element_conversions::convertCartesianToKeplerianElements(
+                stateInCartesianElements, getGTOPGravitationalParameter( ) );
+    benchmarkPropagationHistory[ 8640000.0 * 3.0 ] = stateInKeplerianElements;
+
+    stateInCartesianElements << -328225472457.8796, 1584186440047.591, 0.0001371949389119038,
+            -14437.813524927732, 42264.20425643964, 4.355914471377053e-012;
+    stateInKeplerianElements = orbital_element_conversions::convertCartesianToKeplerianElements(
+                stateInCartesianElements, getGTOPGravitationalParameter( ) );
+    benchmarkPropagationHistory[ 8640000.0 * 4.0 ] = stateInKeplerianElements;
+
+    // Return benchmark data.
+    return benchmarkPropagationHistory;
+}
+
+}
+
+}
+#endif // KEPLERPROPAGATORTESTDATA_H

=== modified file 'Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestKeplerPropagator.cpp'
--- Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestKeplerPropagator.cpp	2014-04-07 10:50:37 +0000
+++ Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/unitTestKeplerPropagator.cpp	2015-04-16 13:10:30 +0000
@@ -71,6 +71,7 @@
 #include <TudatCore/Mathematics/BasicMathematics/basicMathematicsFunctions.h>
 #include <TudatCore/Mathematics/BasicMathematics/mathematicalConstants.h>
 
+#include "Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/keplerPropagatorTestData.h"
 #include "Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h"
 #include "Tudat/InputOutput/basicInputOutput.h"
 
@@ -79,129 +80,6 @@
 namespace unit_tests
 {
 
-//! Typedef for propagation history.
-typedef std::map < double, Eigen::VectorXd > PropagationHistory;
-
-//! Get Earth gravitational parameter for benchmark data from (Melman, 2010).
-double getMelmanEarthGravitationalParameter( )
-{
-    // Return Earth gravitational parameter [m^3 s^-2].
-    return 3.986004415e14;
-}
-
-//! Get benchmark data from (Melman, 2010).
-PropagationHistory getMelmanBenchmarkData( )
-{
-    // Declare benchmark pragation history.
-    PropagationHistory benchmarkPropagationHistory;
-
-    // Populate benchmark propagation history.
-    Eigen::VectorXd stateInCartesianElements( 6 );
-    Eigen::VectorXd stateInKeplerianElements( 6 );
-
-    stateInCartesianElements << 6.75e6, 0.0, 0.0, 0.0, 8.0595973215e3, 0.0;
-    stateInKeplerianElements = orbital_element_conversions::convertCartesianToKeplerianElements(
-                stateInCartesianElements, getMelmanEarthGravitationalParameter( ) );
-    benchmarkPropagationHistory[ 0.0 ] = stateInKeplerianElements;
-
-    stateInCartesianElements << -6.1318272067e6, 5.1974105627e6, 0.0,
-            -4.7375063953e3, -4.8565484865e3, 0.0;
-    stateInKeplerianElements = orbital_element_conversions::convertCartesianToKeplerianElements(
-                stateInCartesianElements, getMelmanEarthGravitationalParameter( ) );
-    benchmarkPropagationHistory[ 86400.0 ] = stateInKeplerianElements;
-
-    // Return benchmark data.
-    return benchmarkPropagationHistory;
-}
-
-//! Get ODTBX benchmark data.
-PropagationHistory getODTBXBenchmarkData( )
-{
-    // Declare benchmark pragation history.
-    PropagationHistory benchmarkPropagationHistory;
-
-    // Populate benchmark propagation history.
-    Eigen::VectorXd stateInKeplerianElements( 6 );
-
-    stateInKeplerianElements << 42165.3431351313e3, 0.26248354351331, 0.30281462522101,
-            4.71463172847351, 4.85569272927819, 2.37248926702153;
-
-    // Set time step.
-    double timeStep = 8640.0;
-
-    for ( unsigned int i = 0; i < 11; i++ )
-    {
-        benchmarkPropagationHistory[ static_cast< double >( i ) * timeStep ]
-                = stateInKeplerianElements;
-    }
-
-    benchmarkPropagationHistory[ 1.0 * timeStep ]( 5 ) = 2.79722436211144;
-    benchmarkPropagationHistory[ 2.0 * timeStep ]( 5 ) = 3.18337407409023;
-    benchmarkPropagationHistory[ 3.0 * timeStep ]( 5 ) = 3.57400974200765;
-    benchmarkPropagationHistory[ 4.0 * timeStep ]( 5 ) = 4.01425565759545;
-    benchmarkPropagationHistory[ 5.0 * timeStep ]( 5 ) = 4.57232665706546;
-    benchmarkPropagationHistory[ 6.0 * timeStep ]( 5 ) = 5.35956850972672;
-    benchmarkPropagationHistory[ 7.0 * timeStep ]( 5 ) = 0.137251905665217;
-    benchmarkPropagationHistory[ 8.0 * timeStep ]( 5 ) = 1.14521863765007;
-    benchmarkPropagationHistory[ 9.0 * timeStep ]( 5 ) = 1.86433634881636;
-    benchmarkPropagationHistory[ 10.0 * timeStep ]( 5 ) = 2.38486787064101;
-
-    return benchmarkPropagationHistory;
-}
-
-//! Get GTOP gravitational parameter for benchmark data from GTOP.
-double getGTOPGravitationalParameter( )
-{
-    // Return inaccurate gravitational parameter of the Sun [m^3 s^-2].
-    return 1.327e20;
-}
-
-//! Get benchmark data from GTOP.
-PropagationHistory getGTOPBenchmarkData( )
-{
-    // Declare benchmark pragation history.
-    PropagationHistory benchmarkPropagationHistory;
-
-    // Populate benchmark propagation history. Obtained by propagating an orbit starting at
-    // x = 1.5e11, V_y = 6.0e4 for a period of 100 days four times consecutively. Since GTOP does
-    // not work with similar Keplerian orbital elements, the cartesian elements resulting from that
-    // are converted to Keplerian elements first. These initial starting coordinates correspond to
-    // a semi major axis of -7.24873e+010 meters and an eccentricity of 3.06933.
-    Eigen::VectorXd stateInCartesianElements( 6 ), stateInKeplerianElements( 6 );
-
-    stateInCartesianElements << 1.5e11, 0.0, 0.0, 0.0, 6.0e4, 0.0;
-    stateInKeplerianElements = orbital_element_conversions::convertCartesianToKeplerianElements(
-                stateInCartesianElements, getGTOPGravitationalParameter( ) );
-    benchmarkPropagationHistory[ 0.0 ] = stateInKeplerianElements;
-
-    stateInCartesianElements << 50369576778.98602, 453006898372.5074, 2.156946592732799e-005,
-            -14654.13750690802, 46884.94068619227, 4.665334803219454e-012;
-    stateInKeplerianElements = orbital_element_conversions::convertCartesianToKeplerianElements(
-                stateInCartesianElements, getGTOPGravitationalParameter( ) );
-    benchmarkPropagationHistory[ 8640000.0 ] = stateInKeplerianElements;
-
-    stateInCartesianElements << -76810236076.38216, 842661848023.4473, 6.100268297443444e-005,
-            -14683.57015580225, 43917.12010513522, 4.48721854707566e-012;
-    stateInKeplerianElements = orbital_element_conversions::convertCartesianToKeplerianElements(
-                stateInCartesianElements, getGTOPGravitationalParameter( ) );
-    benchmarkPropagationHistory[ 8640000.0 * 2.0 ] = stateInKeplerianElements;
-
-    stateInCartesianElements << -203052258817.9893, 1216808019495.603, 9.937145023346651e-005,
-            -14543.34378775917, 42828.66589049961, 4.403399939593385e-012;
-    stateInKeplerianElements = orbital_element_conversions::convertCartesianToKeplerianElements(
-                stateInCartesianElements, getGTOPGravitationalParameter( ) );
-    benchmarkPropagationHistory[ 8640000.0 * 3.0 ] = stateInKeplerianElements;
-
-    stateInCartesianElements << -328225472457.8796, 1584186440047.591, 0.0001371949389119038,
-            -14437.813524927732, 42264.20425643964, 4.355914471377053e-012;
-    stateInKeplerianElements = orbital_element_conversions::convertCartesianToKeplerianElements(
-                stateInCartesianElements, getGTOPGravitationalParameter( ) );
-    benchmarkPropagationHistory[ 8640000.0 * 4.0 ] = stateInKeplerianElements;
-
-    // Return benchmark data.
-    return benchmarkPropagationHistory;
-}
-
 //! Test 1: Comparison of propagateKeplerOrbit() output with benchmark data from (Melman, 2010).
 BOOST_AUTO_TEST_CASE( testPropagateKeplerOrbit_Eccentric_Melman )
 {

=== modified file 'Tudat/Astrodynamics/Ephemerides/CMakeLists.txt'
--- Tudat/Astrodynamics/Ephemerides/CMakeLists.txt	2015-02-05 12:22:37 +0000
+++ Tudat/Astrodynamics/Ephemerides/CMakeLists.txt	2015-04-16 13:10:30 +0000
@@ -39,6 +39,7 @@
   "${SRCROOT}${EPHEMERIDESDIR}/approximatePlanetPositionsCircularCoplanar.cpp"
   "${SRCROOT}${EPHEMERIDESDIR}/cartesianStateExtractor.cpp"
   "${SRCROOT}${EPHEMERIDESDIR}/keplerStateExtractor.cpp"
+  "${SRCROOT}${EPHEMERIDESDIR}/keplerEphemeris.cpp"
   "${SRCROOT}${EPHEMERIDESDIR}/simpleRotationalEphemeris.cpp"
 )
 
@@ -51,6 +52,7 @@
   "${SRCROOT}${EPHEMERIDESDIR}/ephemeris.h"
   "${SRCROOT}${EPHEMERIDESDIR}/cartesianStateExtractor.h"
   "${SRCROOT}${EPHEMERIDESDIR}/keplerStateExtractor.h"
+  "${SRCROOT}${EPHEMERIDESDIR}/keplerEphemeris.h"
   "${SRCROOT}${EPHEMERIDESDIR}/rotationalEphemeris.h"
   "${SRCROOT}${EPHEMERIDESDIR}/simpleRotationalEphemeris.h"
   "${SRCROOT}${EPHEMERIDESDIR}/tabulatedEphemeris.h"
@@ -69,7 +71,6 @@
 setup_custom_test_program(test_TabulatedEphemeris "${SRCROOT}${EPHEMERIDESDIR}")
 target_link_libraries(test_TabulatedEphemeris tudat_ephemerides tudat_interpolators tudat_basic_astrodynamics  ${TUDAT_CORE_LIBRARIES} ${Boost_LIBRARIES})
 
-
 add_executable(test_CartesianStateExtractor "${SRCROOT}${EPHEMERIDESDIR}/UnitTests/unitTestCartesianStateExtractor.cpp")
 setup_custom_test_program(test_CartesianStateExtractor "${SRCROOT}${EPHEMERIDESDIR}")
 target_link_libraries(test_CartesianStateExtractor tudat_input_output tudat_ephemerides ${TUDAT_CORE_LIBRARIES} ${Boost_LIBRARIES})
@@ -81,3 +82,7 @@
 add_executable(test_SimpleRotationalEphemeris "${SRCROOT}${EPHEMERIDESDIR}/UnitTests/unitTestSimpleRotationalEphemeris.cpp")
 setup_custom_test_program(test_SimpleRotationalEphemeris "${SRCROOT}${EPHEMERIDESDIR}")
 target_link_libraries(test_SimpleRotationalEphemeris tudat_ephemerides tudat_reference_frames tudat_input_output tudat_basic_astrodynamics ${TUDAT_CORE_LIBRARIES} ${Boost_LIBRARIES})
+
+add_executable(test_KeplerEphemeris "${SRCROOT}${EPHEMERIDESDIR}/UnitTests/unitTestKeplerEphemeris.cpp")
+setup_custom_test_program(test_KeplerEphemeris "${SRCROOT}${EPHEMERIDESDIR}")
+target_link_libraries(test_KeplerEphemeris tudat_ephemerides tudat_reference_frames tudat_input_output tudat_basic_astrodynamics ${TUDAT_CORE_LIBRARIES} ${Boost_LIBRARIES})

=== added file 'Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestKeplerEphemeris.cpp'
--- Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestKeplerEphemeris.cpp	1970-01-01 00:00:00 +0000
+++ Tudat/Astrodynamics/Ephemerides/UnitTests/unitTestKeplerEphemeris.cpp	2015-04-18 13:48:40 +0000
@@ -0,0 +1,136 @@
+/*    Copyright (c) 2010-2014, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150411    D. Dirkx          Migrated and updated from personal code.
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#define BOOST_TEST_MAIN
+
+#include <fstream>
+#include <limits>
+#include <map>
+
+#include <boost/test/floating_point_comparison.hpp>
+#include <boost/test/unit_test.hpp>
+
+#include <Eigen/Core>
+
+#include <TudatCore/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h>
+#include <TudatCore/Basics/testMacros.h>
+#include <TudatCore/Mathematics/BasicMathematics/basicMathematicsFunctions.h>
+#include <TudatCore/Mathematics/BasicMathematics/mathematicalConstants.h>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/UnitTests/keplerPropagatorTestData.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/keplerPropagator.h"
+#include "Tudat/Astrodynamics/Ephemerides/keplerEphemeris.h"
+#include "Tudat/InputOutput/basicInputOutput.h"
+
+namespace tudat
+{
+namespace unit_tests
+{
+
+BOOST_AUTO_TEST_SUITE( test_keplerEphemeris )
+
+//! Test 1: Comparison of KeplerEphemeris output with benchmark data from (Melman, 2010).
+//! (see testPropagateKeplerOrbit_Eccentric_Melman).
+BOOST_AUTO_TEST_CASE( testKeplerEphemerisElliptical )
+{
+    // Load the expected propagation history.
+    // Create expected propagation history.
+    PropagationHistory expectedPropagationHistory = getODTBXBenchmarkData( );
+
+    // Set Earth gravitational parameter [m^3 s^-2].
+    const double earthGravitationalParameter = 398600.4415e9;
+
+    // Compute propagation history.
+    PropagationHistory computedPropagationHistory;
+    computedPropagationHistory[ 0.0 ] = expectedPropagationHistory[ 0.0 ];
+
+    ephemerides::KeplerEphemeris keplerEphemeris(
+                expectedPropagationHistory[ 0.0 ],
+                0.0, earthGravitationalParameter );
+
+    for( PropagationHistory::iterator stateIterator = expectedPropagationHistory.begin( );
+         stateIterator != expectedPropagationHistory.end( ); stateIterator++ )
+    {
+        // Compute next entry.
+        computedPropagationHistory[ stateIterator->first ] =
+                basic_astrodynamics::orbital_element_conversions::convertCartesianToKeplerianElements(
+                    keplerEphemeris.getCartesianStateFromEphemeris( stateIterator->first ),
+                    earthGravitationalParameter );
+
+        // Check that computed results match expected results.
+        BOOST_CHECK_CLOSE_FRACTION(
+                    computedPropagationHistory[ stateIterator->first ]( 5 ),
+                    expectedPropagationHistory[ stateIterator->first ]( 5 ),
+                    2.0e-14 );
+    }
+}
+
+//! Test 2: Comparison of KeplerEphemeris with that of GTOP (hyperbolic).
+//! (see testPropagateKeplerOrbit_hyperbolic_GTOP).
+BOOST_AUTO_TEST_CASE( testKeplerEphemerisHyperbolic )
+{
+    // Load the expected propagation history.
+    PropagationHistory expectedPropagationHistory = getGTOPBenchmarkData( );
+
+    // Compute propagation history.
+    PropagationHistory computedPropagationHistory;
+    computedPropagationHistory[ 0.0 ] = expectedPropagationHistory[ 0.0 ];
+
+    ephemerides::KeplerEphemeris keplerEphemeris(
+                expectedPropagationHistory[ 0.0 ],
+                0.0, getGTOPGravitationalParameter( ) );
+
+    for( PropagationHistory::iterator stateIterator = expectedPropagationHistory.begin( );
+         stateIterator != expectedPropagationHistory.end( ); stateIterator++ )
+    {
+        // Compute next entry.
+        computedPropagationHistory[ stateIterator->first ] =
+                basic_astrodynamics::orbital_element_conversions::convertCartesianToKeplerianElements(
+                    keplerEphemeris.getCartesianStateFromEphemeris( stateIterator->first ),
+                    getGTOPGravitationalParameter( ) );
+
+        // Check that computed results match expected results.
+        BOOST_CHECK_CLOSE_FRACTION(
+                    computedPropagationHistory[ stateIterator->first ]( 5 ),
+                    expectedPropagationHistory[ stateIterator->first ]( 5 ),
+                    1.0e-15 );
+    }
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+} // namespace unit_tests
+
+} // namespace tudat
+

=== added file 'Tudat/Astrodynamics/Ephemerides/keplerEphemeris.cpp'
--- Tudat/Astrodynamics/Ephemerides/keplerEphemeris.cpp	1970-01-01 00:00:00 +0000
+++ Tudat/Astrodynamics/Ephemerides/keplerEphemeris.cpp	2015-04-18 13:48:40 +0000
@@ -0,0 +1,190 @@
+/*    Copyright (c) 2010-2014, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150411    D. Dirkx          Migrated and updated from personal code.
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#include <TudatCore/Astrodynamics/BasicAstrodynamics/orbitalElementConversions.h>
+
+#include "Tudat/Astrodynamics/Ephemerides/keplerEphemeris.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToEccentricAnomaly.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/convertMeanAnomalyToHyperbolicEccentricAnomaly.h"
+
+namespace tudat
+{
+
+namespace ephemerides
+{
+
+//! Class constructor.
+KeplerEphemeris::KeplerEphemeris(
+        const basic_mathematics::Vector6d& initialStateInKeplerianElements,
+        const double epochOfInitialState,
+        const double centralBodyGravitationalParameter,
+        const std::string& referenceFrameOrigin,
+        const std::string& referenceFrameOrientation,
+        const double rootFinderAbsoluteTolerance,
+        const double rootFinderMaximumNumberOfIterations ):
+    Ephemeris( referenceFrameOrigin, referenceFrameOrientation ),
+    initialStateInKeplerianElements_( initialStateInKeplerianElements ),
+    epochOfInitialState_( epochOfInitialState ),
+    centralBodyGravitationalParameter_( centralBodyGravitationalParameter )
+{
+    using namespace tudat::basic_astrodynamics::orbital_element_conversions;
+    using namespace tudat::root_finders;
+    using namespace root_finders::termination_conditions;
+
+    // Check whether orbit is elliptical or hyperbolic (parabola not supported).
+    if( initialStateInKeplerianElements( eccentricityIndex ) < 1.0 )
+    {
+        isOrbitHyperbolic_ = 0;
+    }
+    else if( initialStateInKeplerianElements( eccentricityIndex ) > 1.0 )
+    {
+        isOrbitHyperbolic_ = 1;
+    }
+    else
+    {
+        boost::throw_exception(
+                    std::runtime_error(
+                        boost::str(
+                            boost::format(
+                                "Error, Kepler ephemeris cannot handle parabolic orbit" ) ) ) );
+    }
+
+    // Convert initial true anomaly to mean anomaly.
+    if( !isOrbitHyperbolic_ )
+    {
+        initialMeanAnomaly_ = convertEccentricAnomalyToMeanAnomaly(
+                    convertTrueAnomalyToEccentricAnomaly(
+                        initialStateInKeplerianElements_( trueAnomalyIndex ),
+                        initialStateInKeplerianElements_( eccentricityIndex ) ),
+                    initialStateInKeplerianElements_( eccentricityIndex ) );
+    }
+    else
+    {
+        initialMeanAnomaly_ = convertHyperbolicEccentricAnomalyToMeanAnomaly(
+                    convertTrueAnomalyToHyperbolicEccentricAnomaly(
+                        initialStateInKeplerianElements_( trueAnomalyIndex ),
+                        initialStateInKeplerianElements_( eccentricityIndex ) ),
+                    initialStateInKeplerianElements_( eccentricityIndex ) );
+    }
+
+
+    // Calculate ancilliary variables for conversion to Cartesian elements
+    eccentricity_ = initialStateInKeplerianElements_( eccentricityIndex );
+    semiLatusRectum_ = initialStateInKeplerianElements_( semiMajorAxisIndex ) *
+            ( 1.0 - pow( initialStateInKeplerianElements_( eccentricityIndex ), 2 ) );
+    meanMotion_ = convertSemiMajorAxisToMeanMotion(
+                initialStateInKeplerianElements_( semiMajorAxisIndex ),
+                centralBodyGravitationalParameter_ );
+    rotationFromOrbitalPlane_ =
+            Eigen::AngleAxisd(
+                initialStateInKeplerianElements_(
+                    longitudeOfAscendingNodeIndex ), Eigen::Vector3d::UnitZ( ) ) *
+            Eigen::AngleAxisd(
+                initialStateInKeplerianElements_(
+                    inclinationIndex ), Eigen::Vector3d::UnitX( ) ) *
+            Eigen::AngleAxisd(
+                initialStateInKeplerianElements_(
+                    argumentOfPeriapsisIndex ), Eigen::Vector3d::UnitZ( ) ) ;
+
+    // Create root finder to be used for converting mean to eccentric anomaly
+    rootFinder_ = boost::make_shared< NewtonRaphsonCore< double > >(
+                boost::bind( &RootAbsoluteToleranceTerminationCondition::checkTerminationCondition,
+                             boost::make_shared< RootAbsoluteToleranceTerminationCondition >(
+                                 rootFinderAbsoluteTolerance, rootFinderMaximumNumberOfIterations ),
+                             _1, _2, _3, _4, _5 ) );
+}
+
+//! Function to get state from ephemeris.
+basic_mathematics::Vector6d KeplerEphemeris::getCartesianStateFromEphemeris(
+        const double secondsSinceEpoch, const double julianDayAtEpoch )
+{
+    using namespace tudat::basic_astrodynamics::orbital_element_conversions;
+
+    basic_mathematics::Vector6d currentCartesianState = basic_mathematics::Vector6d::Zero( );
+
+    // Calculate mean anomaly at epoch.
+    double newMeanAnomaly = initialMeanAnomaly_ + meanMotion_ *
+            ( secondsSinceEpoch - epochOfInitialState_ );
+
+    // Calculate eccentric anomaly at epoch.
+    double eccentricAnomaly = TUDAT_NAN;
+    if( !isOrbitHyperbolic_ )
+    {
+        // Compute eccentric anomaly for mean anomaly.
+        ConvertMeanAnomalyToEccentricAnomaly convertMeanAnomalyToEccentricAnomaly(
+                    eccentricity_, newMeanAnomaly, rootFinder_ );
+        eccentricAnomaly = convertMeanAnomalyToEccentricAnomaly.convert( );
+
+    }
+    else
+    {
+
+        // Compute hyperbolci eccentric anomaly for mean anomaly.
+        ConvertMeanAnomalyToHyperbolicEccentricAnomaly
+                convertMeanAnomalyToHyperbolicEccentricAnomaly(
+                    eccentricity_, newMeanAnomaly,  rootFinder_ );
+        eccentricAnomaly = convertMeanAnomalyToHyperbolicEccentricAnomaly.convert( );
+    }
+
+    // Calculate true anomaly.
+    double trueAnomaly = convertEccentricAnomalyToTrueAnomaly(
+                eccentricAnomaly, eccentricity_ );
+    double cosineOfTrueAnomaly_ = cos( trueAnomaly );
+    double sineOfTrueAnomaly_ = sin( trueAnomaly );
+
+    // Definition of position in the perifocal coordinate system.
+    currentCartesianState( 0 ) = semiLatusRectum_ * cosineOfTrueAnomaly_
+            / ( 1.0 + eccentricity_ * cosineOfTrueAnomaly_ );
+    currentCartesianState( 1 ) = semiLatusRectum_ * sineOfTrueAnomaly_
+            / ( 1.0 + eccentricity_ * cosineOfTrueAnomaly_ );
+
+    // Definition of velocity in the perifocal coordinate system.
+    currentCartesianState( 3 ) =
+            -sqrt( centralBodyGravitationalParameter_ / semiLatusRectum_ ) * sineOfTrueAnomaly_;
+    currentCartesianState( 4 ) =
+            sqrt( centralBodyGravitationalParameter_ / semiLatusRectum_ )
+            * ( eccentricity_ + cosineOfTrueAnomaly_ );
+
+    // Rotate orbital plane to correct orientation.
+    currentCartesianState.segment( 0, 3 ) = rotationFromOrbitalPlane_ *
+            currentCartesianState.segment( 0, 3 );
+    currentCartesianState.segment( 3, 3 ) = rotationFromOrbitalPlane_ *
+            currentCartesianState.segment( 3, 3 );
+
+    return currentCartesianState;
+}
+
+}
+
+}

=== added file 'Tudat/Astrodynamics/Ephemerides/keplerEphemeris.h'
--- Tudat/Astrodynamics/Ephemerides/keplerEphemeris.h	1970-01-01 00:00:00 +0000
+++ Tudat/Astrodynamics/Ephemerides/keplerEphemeris.h	2015-04-18 13:48:40 +0000
@@ -0,0 +1,137 @@
+/*    Copyright (c) 2010-2014, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150411    D. Dirkx          Migrated and updated from personal code.
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#ifndef TUDAT_KEPLEREPHEMERIS_H
+#define TUDAT_KEPLEREPHEMERIS_H
+
+#include <Eigen/Geometry>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/timeConversions.h"
+#include "Tudat/Astrodynamics/Ephemerides/ephemeris.h"
+#include "Tudat/Mathematics/RootFinders/newtonRaphson.h"
+
+namespace tudat
+{
+
+namespace ephemerides
+{
+
+//! Ephemeris derived class that calculates the Cartesian position as a function of time assuming
+//! a Kepler orbit.
+/*!
+ *  Ephemeris derived class that calculates the Cartesian position as a function of time assuming
+ *  a Kepler orbit. In this class, both the Kepler propagation and conversion to Cartesian
+ *  coordinates is done internally using precomputed values of the initial Kepler elements,
+ *  thereby reducing computation time compared to succesively using the propagateKeplerOrbit or
+ *  convertKeplerianToCartesianElements functions.
+ */
+class KeplerEphemeris : public Ephemeris
+{
+public:
+
+    //! Class constructor.
+    /*!
+     *  Class constructor, sets the characteristics of the Kepler orbit and the root finder
+     *  used for converting mean to eccentric anomalies.
+     *  \param initialStateInKeplerianElements Kepler elements at time epochOfInitialState.
+     *  \param epochOfInitialState Time at which initialStateInKeplerianElements represents
+     *  the Keplerian state.
+     *  \param centralBodyGravitationalParameter Gravitational parameter of the central body
+     *  that is used in the computations.
+     *  \param referenceFrameOrigin Origin of reference frame (string identifier).
+     *  \param referenceFrameOrientation Orientation of reference frame (string identifier)
+     *  \param rootFinderAbsoluteTolerance Convergence tolerance for root finder used to
+     *  convert mean to eccentric anomaly on each call to getCartesianStateFromEphemeris.
+     *  \param rootFinderMaximumNumberOfIterations Maximum iteration for root finder used to
+     *  convert mean to eccentric anomaly on each call to getCartesianStateFromEphemeris.
+     */
+    KeplerEphemeris( const basic_mathematics::Vector6d& initialStateInKeplerianElements,
+                     const double epochOfInitialState,
+                     const double centralBodyGravitationalParameter,
+                     const std::string& referenceFrameOrigin = "SSB",
+                     const std::string& referenceFrameOrientation = "ECLIPJ2000",
+                     const double rootFinderAbsoluteTolerance =
+            200.0 * std::numeric_limits< double >::epsilon( ),
+                     const double rootFinderMaximumNumberOfIterations = 1000.0 );
+
+    //! Function to get state from ephemeris.
+    /*!
+     *  Returns state from ephemeris at given time, assuming a purely Keplerian orbit
+     *  \param secondsSinceEpoch Seconds since epoch (should be w.r.t. same reference time
+     *  as epochOfInitialState), and does not represent the time since epochOfInitialState.
+     *  \param julianDayAtEpoch Reference epoch in Julian day.
+     *  \return Keplerian orbit Cartesian state at given time.
+     */
+    basic_mathematics::Vector6d getCartesianStateFromEphemeris(
+            const double secondsSinceEpoch,
+            const double julianDayAtEpoch = basic_astrodynamics::JULIAN_DAY_ON_J2000 );
+
+private:
+
+    //! Kepler elements at time epochOfInitialState.
+    basic_mathematics::Vector6d initialStateInKeplerianElements_;
+
+    //! Semi-latus rectum of orbit.
+    double semiLatusRectum_;
+
+    //! Mean anomaly at epochOfInitialState.
+    double initialMeanAnomaly_;
+
+    //! Mean motion of orbit.
+    double meanMotion_;
+
+    //! Eccentricity of orbit.
+    double eccentricity_;
+
+    //! Rotation from orbital plane to frame in which the orbit is defined.
+    Eigen::Quaterniond rotationFromOrbitalPlane_;
+
+    //! Root finder used to convert mean to eccentric anomalies.
+    boost::shared_ptr< root_finders::RootFinderCore< double > > rootFinder_;
+
+    //! Initial epoch from which propagation of Kepler orbit is performed.
+    double epochOfInitialState_;
+
+    //! Gravitational parameter of central body about which the Kepler orbit is defined.
+    double centralBodyGravitationalParameter_;
+
+    //! Boolean denoting whether orbit is hyperbolic or elliptical (parabola not supported).
+    bool isOrbitHyperbolic_;
+};
+
+}
+
+}
+
+#endif // TUDAT_KEPLEREPHEMERIS_H

