=== modified file 'Tudat/Astrodynamics/Gravitation/centralGravityModel.h'
--- Tudat/Astrodynamics/Gravitation/centralGravityModel.h	2015-04-17 14:14:12 +0000
+++ Tudat/Astrodynamics/Gravitation/centralGravityModel.h	2015-06-08 14:14:24 +0000
@@ -197,7 +197,35 @@
             const typename Base::StateFunction positionOfBodyExertingAccelerationFunction
             = boost::lambda::constant( StateMatrix::Zero( ) ) )
         : Base( positionOfBodySubjectToAccelerationFunction,
-                aGravitationalParameter,
+                boost::lambda::constant( aGravitationalParameter ),
+                positionOfBodyExertingAccelerationFunction )
+    {
+        this->updateMembers( );
+    }
+
+    //! Constructor taking position-functions for bodies, and constant gravitational parameter.
+    /*!
+     * Constructor taking a pointer to a function returning the position of the body subject to
+     * gravitational acceleration, a constant gravitational parameter, and a pointer to a function
+     * returning the position of the body exerting the gravitational acceleration (typically the
+     * central body). This constructor uses the Boost::lambda library to create a function
+     * on-the-fly that returns the constant gravitational parameter provided. The constructor also
+     * updates all the internal members. The position of the body exerting the gravitational
+     * acceleration is an optional parameter; the default position is the origin.
+     * \param positionOfBodySubjectToAccelerationFunction Pointer to function returning position of
+     *          body subject to gravitational acceleration.
+     * \param aGravitationalParameterFunction Functioning returning a (constant) gravitational
+     *          parameter [m^2 s^-3].
+     * \param positionOfBodyExertingAccelerationFunction Pointer to function returning position of
+     *          body exerting gravitational acceleration (default = (0,0,0)).
+     */
+    CentralGravitationalAccelerationModel(
+            const typename Base::StateFunction positionOfBodySubjectToAccelerationFunction,
+            const boost::function< double( ) > aGravitationalParameterFunction,
+            const typename Base::StateFunction positionOfBodyExertingAccelerationFunction
+            = boost::lambda::constant( StateMatrix::Zero( ) ) )
+        : Base( positionOfBodySubjectToAccelerationFunction,
+                aGravitationalParameterFunction,
                 positionOfBodyExertingAccelerationFunction )
     {
         this->updateMembers( );

=== modified file 'Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h'
--- Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h	2015-04-17 14:14:12 +0000
+++ Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h	2015-06-08 14:14:24 +0000
@@ -233,7 +233,7 @@
      * gravitational acceleration is an optional parameter; the default position is the origin.
      * \param positionOfBodySubjectToAccelerationFunction Pointer to function returning position of
      *          body subject to gravitational acceleration.
-     * \param aGravitationalParameter Pointer to function returning gravitational parameter.
+     * \param aGravitationalParameterFunction Pointer to function returning gravitational parameter.
      * \param anEquatorialRadius Pointer to function returning equatorial radius.
      * \param cosineHarmonicCoefficientsFunction Pointer to function returning matrix of
                 cosine-coefficients of spherical harmonics expansion.
@@ -244,14 +244,14 @@
      */
     SphericalHarmonicsGravitationalAccelerationModel(
             const StateFunction positionOfBodySubjectToAccelerationFunction,
-            const double aGravitationalParameter,
+            const boost::function< double( ) > aGravitationalParameterFunction,
             const double anEquatorialRadius,
             const CoefficientMatrixReturningFunction cosineHarmonicCoefficientsFunction,
             const CoefficientMatrixReturningFunction sineHarmonicCoefficientsFunction,
             const StateFunction positionOfBodyExertingAccelerationFunction
             = boost::lambda::constant( Eigen::Vector3d::Zero( ) ) )
         : Base( positionOfBodySubjectToAccelerationFunction,
-                aGravitationalParameter,
+                aGravitationalParameterFunction,
                 positionOfBodyExertingAccelerationFunction ),
           equatorialRadius( anEquatorialRadius ),
           getCosineHarmonicsCoefficients( cosineHarmonicCoefficientsFunction ),

=== modified file 'Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModelBase.h'
--- Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModelBase.h	2015-04-17 14:14:12 +0000
+++ Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModelBase.h	2015-06-08 14:14:24 +0000
@@ -72,17 +72,40 @@
      * constructor also updates all the internal members.
      * \param positionOfBodySubjectToAccelerationFunction Pointer to function returning position of
      *          body subject to gravitational acceleration.
-     * \param aGravitationalParameter Pointer to function returning gravitational parameter
+     * \param aGravitationalParameter Gravitational parameter of body exerting gravitational acceleration.
+     * \param positionOfBodyExertingAccelerationFunction Pointer to function returning position of
+     *          body exerting gravitational acceleration.
+     */
+    SphericalHarmonicsGravitationalAccelerationModelBase(
+            const StateFunction positionOfBodySubjectToAccelerationFunction,
+            const double aGravitationalParameter,
+            const StateFunction positionOfBodyExertingAccelerationFunction )
+        : subjectPositionFunction( positionOfBodySubjectToAccelerationFunction ),
+          gravitationalParameterFunction( boost::lambda::constant( aGravitationalParameter ) ),
+          sourcePositionFunction( positionOfBodyExertingAccelerationFunction )
+    { }
+
+    //! Default constructor taking position of body subject to acceleration, variable
+    //! gravitational parameter, and position of body exerting acceleration.
+    /*!
+     * Constructor taking a pointer to a function returning the position of the body subject to
+     * gravitational acceleration, a pointer to a function returning the gravitational parameter of
+     * the body exerting the acceleration, and a pointer to a function returning the position of
+     * the body exerting the  gravitational acceleration (typically the central body). The
+     * constructor also updates all the internal members.
+     * \param positionOfBodySubjectToAccelerationFunction Pointer to function returning position of
+     *          body subject to gravitational acceleration.
+     * \param aGravitationalParameterFunction Pointer to function returning gravitational parameter
      *          of body exerting gravitational acceleration.
      * \param positionOfBodyExertingAccelerationFunction Pointer to function returning position of
      *          body exerting gravitational acceleration.
      */
     SphericalHarmonicsGravitationalAccelerationModelBase(
             const StateFunction positionOfBodySubjectToAccelerationFunction,
-            const double aGravitationalParameter,
+            const boost::function< double( ) > aGravitationalParameterFunction,
             const StateFunction positionOfBodyExertingAccelerationFunction )
         : subjectPositionFunction( positionOfBodySubjectToAccelerationFunction ),
-          gravitationalParameter( aGravitationalParameter ),
+          gravitationalParameterFunction( aGravitationalParameterFunction ),
           sourcePositionFunction( positionOfBodyExertingAccelerationFunction )
     { }
 
@@ -102,6 +125,7 @@
      */
     bool updateBaseMembers( )
     {
+        this->gravitationalParameter = this->gravitationalParameterFunction( );
         this->positionOfBodySubjectToAcceleration = this->subjectPositionFunction( );
         this->positionOfBodyExertingAcceleration  = this->sourcePositionFunction( );
         return true;
@@ -122,11 +146,17 @@
      */
     const StateFunction subjectPositionFunction;
 
+    //! Function returning a gravitational parameter [m^3 s^-2].
+    /*!
+     * Function returning current gravitational parameter of body exerting acceleration [m^3 s^-2].
+     */
+    const boost::function< double( ) > gravitationalParameterFunction;
+
     //! Gravitational parameter [m^3 s^-2].
     /*!
      * Current gravitational parameter of body exerting acceleration [m^3 s^-2].
      */
-    const double gravitationalParameter;
+    double gravitationalParameter;
 
     //! Position of body exerting acceleration.
     /*!

=== added directory 'Tudat/SimulationSetup'
=== added file 'Tudat/SimulationSetup/CMakeLists.txt'
--- Tudat/SimulationSetup/CMakeLists.txt	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/CMakeLists.txt	2015-06-16 11:38:27 +0000
@@ -0,0 +1,55 @@
+ #    Copyright (c) 2010-2012 Delft University of Technology.
+ #
+ #    This software is protected by national and international copyright.
+ #    Any unauthorized use, reproduction or modification is unlawful and
+ #    will be prosecuted. Commercial and non-private application of the
+ #    software in any form is strictly prohibited unless otherwise granted
+ #    by the authors.
+ #
+ #    The code is provided without any warranty; without even the implied
+ #    warranty of merchantibility or fitness for a particular purpose.
+ #
+ #    Changelog
+ #      YYMMDD    Author            Comment
+ #      110820    S.M. Persson      File created.
+ #      111025    K. Kumar          Adapted file to work with Revision 194.
+ #      111026    K. Kumar          Adapted file so all headers show in project tree in Qt Creator.
+ #
+
+# Add source files.
+set(SIMULATION_SETUP_SOURCES
+  "${SRCROOT}${SIMULATIONSETUPDIR}/accelerationModelTypes.cpp"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createAccelerationModels.cpp"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createAtmosphereModel.cpp"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createEphemeris.cpp"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createGravityField.cpp"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createRotationModel.cpp"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createBodies.cpp"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/defaultBodies.cpp"
+)
+
+# Add header files.
+set(SIMULATION_SETUP_HEADERS 
+  "${SRCROOT}${SIMULATIONSETUPDIR}/accelerationModelTypes.h"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createAccelerationModels.h"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createAtmosphereModel.h"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createEphemeris.h"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createGravityField.h"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createRotationModel.h"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/createBodies.h"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/defaultBodies.h"
+  "${SRCROOT}${SIMULATIONSETUPDIR}/body.h"
+)
+
+# Add static libraries.
+add_library(tudat_simulation_setup STATIC ${SIMULATION_SETUP_SOURCES} ${SIMULATION_SETUP_HEADERS} )
+setup_tudat_library_target(tudat_simulation_setup "${SRCROOT}${SIMULATIONSETUPDIR}")
+
+# Add unit tests.
+add_executable(test_EnvironmentSetup "${SRCROOT}${SIMULATIONSETUPDIR}/UnitTests/unitTestEnvironmentModelSetup.cpp")
+setup_custom_test_program(test_EnvironmentSetup "${SRCROOT}${SIMULATIONSETUPDIR}/")
+target_link_libraries(test_EnvironmentSetup tudat_simulation_setup tudat_gravitation tudat_ephemerides tudat_reference_frames tudat_aerodynamics tudat_spice_interface tudat_input_output tudat_basic_astrodynamics tudat_basic_mathematics cspice ${TUDAT_CORE_LIBRARIES} ${Boost_LIBRARIES})
+
+add_executable(test_AccelerationModelSetup "${SRCROOT}${SIMULATIONSETUPDIR}/UnitTests/unitTestAccelerationModelSetup.cpp")
+setup_custom_test_program(test_AccelerationModelSetup "${SRCROOT}${SIMULATIONSETUPDIR}/")
+target_link_libraries(test_AccelerationModelSetup tudat_simulation_setup tudat_gravitation tudat_ephemerides tudat_reference_frames tudat_aerodynamics tudat_spice_interface tudat_input_output tudat_basic_astrodynamics tudat_basic_mathematics cspice ${TUDAT_CORE_LIBRARIES} ${Boost_LIBRARIES})

=== added directory 'Tudat/SimulationSetup/UnitTests'
=== added file 'Tudat/SimulationSetup/UnitTests/unitTestAccelerationModelSetup.cpp'
--- Tudat/SimulationSetup/UnitTests/unitTestAccelerationModelSetup.cpp	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/UnitTests/unitTestAccelerationModelSetup.cpp	2015-06-16 11:38:27 +0000
@@ -0,0 +1,326 @@
+/*    Copyright (c) 2010-2014, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      110207    B. Romgens        File created.
+ *      110215    K. Kumar          Minor modifications to layout, comments
+ *                                  and variable-naming.
+ *      110411    K. Kumar          Added unit test for
+ *                                  convertCartesianToSpherical( ) function.
+ *      110701    K. Kumar          Updated failing tests with relative errors.
+ *      110708    K. Kumar          Added unit tests for computeSampleMean( )
+ *                                  and computeSampleVariance( ) functions.
+ *      110905    S. Billemont      Reorganized includes.
+ *                                  Moved (con/de)structors and getter/setters to header.
+ *      111111    K. Kumar          Strange error with convertCylindricalToCartesian function;
+ *                                  achieved precision of results is less than machine precision,
+ *                                  fixed by using slightly larger precision tolerance.
+ *      120202    K. Kumar          Separated from unitTestBasicMathematics.cpp into new
+ *                                  Interpolators sub-directory.
+ *      120529    E.A.G. Heeren     Boostified unit test.
+ *      120615    T. Secretin       Minor layout changes.
+ *      120716    D. Dirkx          Updated with interpolator architecture.
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#define BOOST_TEST_MAIN
+
+#include <limits>
+
+#include <boost/test/unit_test.hpp>
+#include <boost/make_shared.hpp>
+
+#include <Eigen/Core>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/unitConversions.h"
+#include "Tudat/Astrodynamics/Ephemerides/approximatePlanetPositions.h"
+#include "Tudat/Astrodynamics/Ephemerides/tabulatedEphemeris.h"
+#include "Tudat/Basics/testMacros.h"
+#include "Tudat/External/SpiceInterface/spiceEphemeris.h"
+#include "Tudat/InputOutput/basicInputOutput.h"
+#include "Tudat/Mathematics/Interpolators/linearInterpolator.h"
+#include "Tudat/SimulationSetup/createAccelerationModels.h"
+#include "Tudat/SimulationSetup/createBodies.h"
+
+namespace tudat
+{
+namespace unit_tests
+{
+
+using namespace simulation_setup;
+
+BOOST_AUTO_TEST_SUITE( test_acceleration_model_setup )
+
+//! Test set up of point mass gravitational accelerations, both direct and third-body.
+BOOST_AUTO_TEST_CASE( test_centralGravityModelSetup )
+{
+    // Load Spice kernel with gravitational parameters.
+    const std::string kernelsPath = input_output::getSpiceKernelPath( );
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de-403-masses.tpc" );
+
+    // Create bodies with gravitational parameters from Spice and JPL approximane positions
+    // as ephemerides
+    std::map< std::string, boost::shared_ptr< BodySettings > > bodySettings;
+    bodySettings[ "Mars" ] = boost::make_shared< BodySettings >( );
+    bodySettings[ "Jupiter" ] = boost::make_shared< BodySettings >( );
+    bodySettings[ "Sun" ] = boost::make_shared< BodySettings >( );
+    bodySettings[ "Mars" ]->ephemerisSettings = boost::make_shared< ApproximatePlanetPositionSettings >(
+                ephemerides::ApproximatePlanetPositionsBase::mars, 0 );
+    bodySettings[ "Jupiter" ]->ephemerisSettings = boost::make_shared< ApproximatePlanetPositionSettings >(
+                ephemerides::ApproximatePlanetPositionsBase::jupiter, 0 );
+    bodySettings[ "Mars" ]->gravityFieldSettings =
+            boost::make_shared< GravityFieldSettings >( central_spice );
+    bodySettings[ "Jupiter" ]->gravityFieldSettings =
+            boost::make_shared< GravityFieldSettings >( central_spice );
+    bodySettings[ "Sun" ]->gravityFieldSettings =
+            boost::make_shared< GravityFieldSettings >( central_spice );
+    NamedBodyMap bodyMap = createBodies( bodySettings );
+
+    // Defins state of Sun to be all zero.
+    std::map< double, basic_mathematics::Vector6d > sunStateHistory;
+    sunStateHistory[ -1.0E9 ] = basic_mathematics::Vector6d::Zero( );
+    sunStateHistory[ 0.0 ] = basic_mathematics::Vector6d::Zero( );
+    sunStateHistory[ -1.0E9 ] = basic_mathematics::Vector6d::Zero( );
+    boost::shared_ptr< interpolators::LinearInterpolator< double, basic_mathematics::Vector6d > >
+            sunStateInterpolaotor = boost::make_shared<
+            interpolators::LinearInterpolator< double, basic_mathematics::Vector6d > >(
+                sunStateHistory );
+    bodyMap[ "Sun" ] ->setEphemeris( boost::make_shared< ephemerides::TabulatedCartesianEphemeris >(
+                                         sunStateInterpolaotor ) );
+
+    // Update bodies to current state (normally done by numerical integrator).
+    for( NamedBodyMap::const_iterator bodyIterator = bodyMap.begin( ); bodyIterator !=
+         bodyMap.end( ); bodyIterator++ )
+    {
+        bodyIterator->second->updateStateFromEphemeris( 1.0E7 );
+    }
+
+
+    // Define settings for accelerations: point  mass atraction by Jupiter and Sun on Mars
+    SelectedAccelerationMap accelerationSettingsMap;
+    accelerationSettingsMap[ "Mars" ][ "Sun" ].push_back(
+                boost::make_shared< AccelerationSettings >( central_gravity ) );
+    accelerationSettingsMap[ "Mars" ][ "Jupiter" ].push_back(
+                boost::make_shared< AccelerationSettings >( central_gravity ) );
+
+    // Define origin of integration to be barycenter.
+    std::map< std::string, std::string > centralBodies;
+    centralBodies[ "Mars" ] = "SSB";
+
+    // Create accelerations
+    AccelerationMap accelerationsMap = createAccelerationModelsMap(
+                bodyMap, accelerationSettingsMap, centralBodies );
+
+    // Retrieve created accelerations.
+    boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > >
+            sunAcceleration = accelerationsMap[ "Mars" ][ "Sun" ][ 0 ];
+    boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > >
+            jupiterAcceleration = accelerationsMap[ "Mars" ][ "Jupiter" ][ 0 ];
+
+    // Create accelerations manually (point mass inertial).
+    boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > >
+            manualSunAcceleration =
+            boost::make_shared< gravitation::CentralGravitationalAccelerationModel< > >(
+                boost::bind( &Body::getPosition, bodyMap[ "Mars" ] ),
+                spice_interface::getBodyGravitationalParameter( "Sun" ),
+                boost::bind( &Body::getPosition, bodyMap[ "Sun" ] ) );
+    boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > >
+            manualJupiterAcceleration =
+            boost::make_shared< gravitation::CentralGravitationalAccelerationModel< > >(
+                boost::bind( &Body::getPosition, bodyMap[ "Mars" ] ),
+                spice_interface::getBodyGravitationalParameter( "Jupiter" ),
+                boost::bind( &Body::getPosition, bodyMap[ "Jupiter" ] ) );
+
+    // Test equivalence of two acceleration models.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                ( basic_astrodynamics::updateAndGetAcceleration( sunAcceleration ) ),
+                ( basic_astrodynamics::updateAndGetAcceleration( manualSunAcceleration ) ),
+                std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                ( basic_astrodynamics::updateAndGetAcceleration( jupiterAcceleration ) ),
+                ( basic_astrodynamics::updateAndGetAcceleration( manualJupiterAcceleration ) ),
+                std::numeric_limits< double >::epsilon( ) );
+
+    // Change central body to Sun, which will result in modified accelerations.
+    centralBodies[ "Mars" ] = "Sun";
+
+    // Recreate and retrieve accelerations.
+    accelerationsMap = createAccelerationModelsMap(
+                bodyMap, accelerationSettingsMap, centralBodies );
+    sunAcceleration = accelerationsMap[ "Mars" ][ "Sun" ][ 0 ];
+    jupiterAcceleration = accelerationsMap[ "Mars" ][ "Jupiter" ][ 0 ];
+
+    // Manually create Sun's acceleration on Mars, which now include's Mars'gravitational parameter,
+    // since the integration is done w.r.t. the Sun, not the barycenter.
+    manualSunAcceleration =
+            boost::make_shared< gravitation::CentralGravitationalAccelerationModel< > >(
+                boost::bind( &Body::getPosition, bodyMap[ "Mars" ] ),
+                spice_interface::getBodyGravitationalParameter( "Sun" ) +
+                spice_interface::getBodyGravitationalParameter( "Mars" ),
+                boost::bind( &Body::getPosition, bodyMap[ "Sun" ] ) );
+
+    // Manually create Jupiter's acceleration on Mars, which now a third body acceleration,
+    // with the Sun the central body.
+    manualJupiterAcceleration =
+            boost::make_shared< gravitation::ThirdBodyAcceleration<
+            gravitation::CentralGravitationalAccelerationModel< > > >(
+                boost::make_shared< gravitation::CentralGravitationalAccelerationModel< > >(
+                    boost::bind( &Body::getPosition, bodyMap[ "Mars" ] ),
+                    spice_interface::getBodyGravitationalParameter( "Jupiter" ),
+                    boost::bind( &Body::getPosition, bodyMap[ "Jupiter" ] ) ),
+                boost::make_shared< gravitation::CentralGravitationalAccelerationModel< > >(
+                    boost::bind( &Body::getPosition, bodyMap[ "Sun" ] ),
+                    spice_interface::getBodyGravitationalParameter( "Jupiter" ),
+                    boost::bind( &Body::getPosition, bodyMap[ "Jupiter" ] ) ) );
+
+    // Test equivalence of two acceleration models.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                ( basic_astrodynamics::updateAndGetAcceleration( sunAcceleration ) ),
+                ( basic_astrodynamics::updateAndGetAcceleration( manualSunAcceleration ) ),
+                std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                ( basic_astrodynamics::updateAndGetAcceleration( jupiterAcceleration ) ),
+                ( basic_astrodynamics::updateAndGetAcceleration( manualJupiterAcceleration ) ),
+                std::numeric_limits< double >::epsilon( ) );
+}
+
+//! Test set up of spherical harmonic gravitational accelerations.
+BOOST_AUTO_TEST_CASE( test_shGravityModelSetup )
+{
+    // Load Spice kernel with gravitational parameters.
+    const std::string kernelsPath = input_output::getSpiceKernelPath( );
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de-403-masses.tpc" );
+
+    // Create body map
+    NamedBodyMap bodyMap;
+    bodyMap[ "Earth" ] = boost::make_shared< Body >( );
+    bodyMap[ "Vehicle" ] = boost::make_shared< Body >( );
+
+    // Set constant state for Earth and Vehicle
+    basic_mathematics::Vector6d dummyEarthState =
+            ( basic_mathematics::Vector6d ( ) << 1.1E11, 0.5E11, 0.01E11, 0.0
+              ).finished( );
+    bodyMap[ "Earth" ]->setCurrentTimeAndState( 0.0, dummyEarthState );
+    bodyMap[ "Vehicle" ]->setCurrentTimeAndState(
+                0.0, ( basic_mathematics::Vector6d ( ) << 7.0e6, 8.0e6, 9.0e6, 0.0, 0.0, 0.0
+                       ).finished( ) + dummyEarthState );
+
+    // Define Earth gravity field.
+    double gravitationalParameter = 3.986004418e14;
+    double planetaryRadius = 6378137.0;
+    Eigen::MatrixXd cosineCoefficients =
+            ( Eigen::MatrixXd( 6, 6 ) <<
+              1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
+              0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
+              -4.841651437908150e-4, -2.066155090741760e-10, 2.439383573283130e-6, 0.0, 0.0, 0.0,
+              9.571612070934730e-7, 2.030462010478640e-6, 9.047878948095281e-7,
+              7.213217571215680e-7, 0.0, 0.0, 5.399658666389910e-7, -5.361573893888670e-7,
+              3.505016239626490e-7, 9.908567666723210e-7, -1.885196330230330e-7, 0.0,
+              6.867029137366810e-8, -6.292119230425290e-8, 6.520780431761640e-7,
+              -4.518471523288430e-7, -2.953287611756290e-7, 1.748117954960020e-7
+              ).finished( );
+    Eigen::MatrixXd sineCoefficients =
+            ( Eigen::MatrixXd( 6, 6 ) <<
+              0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
+              0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
+              0.0, 1.384413891379790e-9, -1.400273703859340e-6, 0.0, 0.0, 0.0,
+              0.0, 2.482004158568720e-7, -6.190054751776180e-7, 1.414349261929410e-6, 0.0, 0.0,
+              0.0, -4.735673465180860e-7, 6.624800262758290e-7, -2.009567235674520e-7,
+              3.088038821491940e-7, 0.0, 0.0, -9.436980733957690e-8, -3.233531925405220e-7,
+              -2.149554083060460e-7, 4.980705501023510e-8, -6.693799351801650e-7
+              ).finished( );
+    bodyMap[ "Earth" ]->setGravityFieldModel(
+                boost::make_shared< gravitation::SphericalHarmonicsGravityField >(
+                    gravitationalParameter, planetaryRadius, cosineCoefficients,
+                    sineCoefficients ) );
+
+    // Define settings for acceleration model (spherical harmonic due to Earth up to degree and
+    // order 5.
+    SelectedAccelerationMap accelerationSettingsMap;
+    accelerationSettingsMap[ "Vehicle" ][ "Earth" ].push_back(
+                boost::make_shared< SphericalHarmonicAccelerationSettings >( 5, 5 ) );
+
+    // Set accelerations to be calculated w.r.t. the Earth.
+    std::map< std::string, std::string > centralBodies;
+    centralBodies[ "Vehicle" ] = "Earth";
+
+    // Create and retrieve acceleration.
+    AccelerationMap accelerationsMap = createAccelerationModelsMap(
+                bodyMap, accelerationSettingsMap, centralBodies );
+    boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > >
+            directAcceleration = accelerationsMap[ "Vehicle" ][ "Earth" ][ 0 ];
+
+    // Manually create acceleration model.
+    boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > >
+            manualAcceleration =
+            boost::make_shared< gravitation::SphericalHarmonicsGravitationalAccelerationModel< > >(
+                boost::bind( &Body::getPosition, bodyMap[ "Vehicle" ] ),
+                gravitationalParameter,
+                planetaryRadius, cosineCoefficients, sineCoefficients,
+                boost::bind( &Body::getPosition, bodyMap[ "Earth" ] ) );
+
+    // Test equivalence of two acceleration models.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                ( basic_astrodynamics::updateAndGetAcceleration( manualAcceleration ) ),
+                ( basic_astrodynamics::updateAndGetAcceleration( directAcceleration ) ),
+                std::numeric_limits< double >::epsilon( ) );
+
+    // Set (unrealistically) a gravity field model on the Vehicle, to test its
+    // influence on acceleration.
+    bodyMap[ "Vehicle" ]->setGravityFieldModel( boost::make_shared< gravitation::GravityFieldModel >(
+                                                    0.1 * gravitationalParameter ) );
+
+    // Recreate and retrieve acceleration.
+    accelerationsMap = createAccelerationModelsMap(
+                bodyMap, accelerationSettingsMap, centralBodies );
+    directAcceleration = accelerationsMap[ "Vehicle" ][ "Earth" ][ 0 ];
+
+    // Manually create acceleration.
+    manualAcceleration =
+            boost::make_shared< gravitation::SphericalHarmonicsGravitationalAccelerationModel< > >(
+                boost::bind( &Body::getPosition, bodyMap[ "Vehicle" ] ),
+                gravitationalParameter * 1.1,
+                planetaryRadius, cosineCoefficients, sineCoefficients,
+                boost::bind( &Body::getPosition, bodyMap[ "Earth" ] ) );
+
+    // Test equivalence of two acceleration models.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                ( basic_astrodynamics::updateAndGetAcceleration( manualAcceleration ) ),
+                ( basic_astrodynamics::updateAndGetAcceleration( directAcceleration ) ),
+                std::numeric_limits< double >::epsilon( ) );
+
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+} // namespace unit_tests
+} // namespace tudat
+
+

=== added file 'Tudat/SimulationSetup/UnitTests/unitTestEnvironmentModelSetup.cpp'
--- Tudat/SimulationSetup/UnitTests/unitTestEnvironmentModelSetup.cpp	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/UnitTests/unitTestEnvironmentModelSetup.cpp	2015-06-16 11:38:27 +0000
@@ -0,0 +1,304 @@
+/*    Copyright (c) 2010-2014, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      110207    B. Romgens        File created.
+ *      110215    K. Kumar          Minor modifications to layout, comments
+ *                                  and variable-naming.
+ *      110411    K. Kumar          Added unit test for
+ *                                  convertCartesianToSpherical( ) function.
+ *      110701    K. Kumar          Updated failing tests with relative errors.
+ *      110708    K. Kumar          Added unit tests for computeSampleMean( )
+ *                                  and computeSampleVariance( ) functions.
+ *      110905    S. Billemont      Reorganized includes.
+ *                                  Moved (con/de)structors and getter/setters to header.
+ *      111111    K. Kumar          Strange error with convertCylindricalToCartesian function;
+ *                                  achieved precision of results is less than machine precision,
+ *                                  fixed by using slightly larger precision tolerance.
+ *      120202    K. Kumar          Separated from unitTestBasicMathematics.cpp into new
+ *                                  Interpolators sub-directory.
+ *      120529    E.A.G. Heeren     Boostified unit test.
+ *      120615    T. Secretin       Minor layout changes.
+ *      120716    D. Dirkx          Updated with interpolator architecture.
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#define BOOST_TEST_MAIN
+
+#include <limits>
+
+#include <boost/test/unit_test.hpp>
+#include <boost/make_shared.hpp>
+
+#include <Eigen/Core>
+
+#include "Tudat/Astrodynamics/Aerodynamics/exponentialAtmosphere.h"
+#include "Tudat/Astrodynamics/Aerodynamics/tabulatedAtmosphere.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/unitConversions.h"
+#include "Tudat/Astrodynamics/Ephemerides/approximatePlanetPositions.h"
+#include "Tudat/Astrodynamics/Ephemerides/simpleRotationalEphemeris.h"
+#include "Tudat/Astrodynamics/Gravitation/centralGravityModel.h"
+#include "Tudat/Basics/testMacros.h"
+#include "Tudat/External/SpiceInterface/spiceEphemeris.h"
+#include "Tudat/InputOutput/basicInputOutput.h"
+#include "Tudat/InputOutput/matrixTextFileReader.h"
+#include "Tudat/SimulationSetup/createAtmosphereModel.h"
+#include "Tudat/SimulationSetup/createEphemeris.h"
+#include "Tudat/SimulationSetup/createGravityField.h"
+#include "Tudat/SimulationSetup/createRotationModel.h"
+
+namespace tudat
+{
+namespace unit_tests
+{
+
+using namespace simulation_setup;
+
+BOOST_AUTO_TEST_SUITE( test_environment_model_setup )
+
+//! Test set up of atmosphere environment models.
+BOOST_AUTO_TEST_CASE( test_atmosphereModelSetup )
+{
+
+    // Create settings for tabulated atmosphere.
+    boost::shared_ptr< TabulatedAtmosphereSettings > tabulatedAtmosphereSettings =
+            boost::make_shared< TabulatedAtmosphereSettings >(
+                input_output::getTudatRootPath( ) + "/External/AtmosphereTables/" +
+                "USSA1976Until100kmPer100mUntil1000kmPer1000m.dat" );
+
+    // Create settings for exponential atmosphere
+    double densityScaleHeight = 8.0E3;
+    double constantTemperature = 270.0;
+    double densityAtZeroAltitude = 1.225;
+    double specificGasConstant = 287.1;
+    boost::shared_ptr< ExponentialAtmosphereSettings > exponentialAtmosphereSettings =
+            boost::make_shared< ExponentialAtmosphereSettings >(
+                densityScaleHeight, constantTemperature,
+                densityAtZeroAltitude, specificGasConstant );
+
+    // Create atmpshere models using setup function
+    boost::shared_ptr< aerodynamics::AtmosphereModel > exponentialAtmosphere =
+            createAtmosphereModel( exponentialAtmosphereSettings, "Earth" );
+    boost::shared_ptr< aerodynamics::AtmosphereModel > tabulatedAtmosphere =
+            createAtmosphereModel( tabulatedAtmosphereSettings, "Earth" );
+
+    // Create atmosphere models manually.
+    aerodynamics::TabulatedAtmosphere manualTabulatedAtmosphere(
+                input_output::getTudatRootPath( ) + "/External/AtmosphereTables/" +
+                "USSA1976Until100kmPer100mUntil1000kmPer1000m.dat" );
+    aerodynamics::ExponentialAtmosphere manualExponentialAtmosphere;
+    manualExponentialAtmosphere.setScaleHeight( densityScaleHeight );
+    manualExponentialAtmosphere.setConstantTemperature( constantTemperature );
+    manualExponentialAtmosphere.setDensityAtZeroAltitude( densityAtZeroAltitude );
+    manualExponentialAtmosphere.setSpecificGasConstant( specificGasConstant );
+
+    // Verify equivalence of automatically set up and manual models.
+    BOOST_CHECK_EQUAL( manualTabulatedAtmosphere.getDensity( 32.0, 0.0, 0.0, 0.0 ),
+                       tabulatedAtmosphere->getDensity( 32.0, 0.0, 0.0, 0.0 ) );
+    BOOST_CHECK_EQUAL( manualTabulatedAtmosphere.getPressure( 32.0, 0.0, 0.0, 0.0 ),
+                       tabulatedAtmosphere->getPressure( 32.0, 0.0, 0.0, 0.0 ) );
+    BOOST_CHECK_EQUAL( manualTabulatedAtmosphere.getTemperature( 32.0, 0.0, 0.0, 0.0 ),
+                       tabulatedAtmosphere->getTemperature( 32.0, 0.0, 0.0, 0.0 ) );
+
+    BOOST_CHECK_EQUAL( manualExponentialAtmosphere.getDensity( 32.0, 0.0, 0.0, 0.0 ),
+                       exponentialAtmosphere->getDensity( 32.0, 0.0, 0.0, 0.0 ) );
+    BOOST_CHECK_EQUAL( manualExponentialAtmosphere.getPressure( 32.0, 0.0, 0.0, 0.0 ),
+                       exponentialAtmosphere->getPressure( 32.0, 0.0, 0.0, 0.0 ) );
+    BOOST_CHECK_EQUAL( manualExponentialAtmosphere.getTemperature( 32.0, 0.0, 0.0, 0.0 ),
+                       exponentialAtmosphere->getTemperature( 32.0, 0.0, 0.0, 0.0 ) );
+
+}
+
+//! Test set up of ephemeris environment models.
+BOOST_AUTO_TEST_CASE( test_ephemerisSetup )
+{
+    // Create settings for approximate planet positions.
+    ephemerides::ApproximatePlanetPositionsBase::BodiesWithEphemerisData bodyIdentifier =
+            ephemerides::ApproximatePlanetPositionsBase::mars;
+    bool useCircularCoplanarApproximation = 0;
+    boost::shared_ptr< ApproximatePlanetPositionSettings > approximateEphemerisSettings =
+            boost::make_shared< ApproximatePlanetPositionSettings >(
+                bodyIdentifier, useCircularCoplanarApproximation );
+
+    // Create ephemeris using setup function.
+    boost::shared_ptr< ephemerides::Ephemeris > approximateEphemeris =
+            createBodyEphemeris( approximateEphemerisSettings, "Earth" );
+
+    // Create manual ephemeris.
+    ephemerides::ApproximatePlanetPositions manualApproximateEphemeris(
+                bodyIdentifier );
+
+    // Verify equivalence of automatically set up and manual models.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                ( manualApproximateEphemeris.getCartesianStateFromEphemeris( 1.0E7 ) ),
+                ( approximateEphemeris->getCartesianStateFromEphemeris( 1.0E7 ) ),
+                std::numeric_limits< double >::epsilon( ) );
+
+}
+
+//! Test set up of gravity field model environment models.
+BOOST_AUTO_TEST_CASE( test_gravityFieldSetup )
+{
+    // Load Spice kernel with gravitational parameters.
+    const std::string kernelsPath = input_output::getSpiceKernelPath( );
+    spice_interface::loadSpiceKernelInTudat( kernelsPath + "de-403-masses.tpc" );
+
+    // Create settings for spice central gravity field model.
+    boost::shared_ptr< GravityFieldSettings > spiceCentralGravityFieldSettings =
+            boost::make_shared< GravityFieldSettings >( central_spice );
+
+    // Create spice central gravity field model from setup function.
+    boost::shared_ptr< gravitation::GravityFieldModel > spiceCentralGravityField =
+            createGravityFieldModel( spiceCentralGravityFieldSettings, "Venus" );
+
+    // Check correct creation of gravity field.
+    BOOST_CHECK_EQUAL(
+                ( spice_interface::getBodyGravitationalParameter( "Venus" ) ),
+                ( spiceCentralGravityField->getGravitationalParameter( ) ) );
+
+    // Settings for spherical harmonic acceleration.
+    double gravitationalParameter = 398600.4418E9;
+    Eigen::Vector3d testPosition( 7.0e6, 8.0e6, 9.0e6 );
+    Eigen::MatrixXd cosineCoefficients =
+            ( Eigen::MatrixXd( 6, 6 ) <<
+              1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
+              0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
+              -4.841651437908150e-4, -2.066155090741760e-10, 2.439383573283130e-6, 0.0, 0.0, 0.0,
+              9.571612070934730e-7, 2.030462010478640e-6, 9.047878948095281e-7,
+              7.213217571215680e-7, 0.0, 0.0, 5.399658666389910e-7, -5.361573893888670e-7,
+              3.505016239626490e-7, 9.908567666723210e-7, -1.885196330230330e-7, 0.0,
+              6.867029137366810e-8, -6.292119230425290e-8, 6.520780431761640e-7,
+              -4.518471523288430e-7, -2.953287611756290e-7, 1.748117954960020e-7
+              ).finished( );
+    Eigen::MatrixXd sineCoefficients =
+            ( Eigen::MatrixXd( 6, 6 ) <<
+              0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
+              0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
+              0.0, 1.384413891379790e-9, -1.400273703859340e-6, 0.0, 0.0, 0.0,
+              0.0, 2.482004158568720e-7, -6.190054751776180e-7, 1.414349261929410e-6, 0.0, 0.0,
+              0.0, -4.735673465180860e-7, 6.624800262758290e-7, -2.009567235674520e-7,
+              3.088038821491940e-7, 0.0, 0.0, -9.436980733957690e-8, -3.233531925405220e-7,
+              -2.149554083060460e-7, 4.980705501023510e-8, -6.693799351801650e-7
+              ).finished( );
+
+    // Create settings for central gravity field.
+    boost::shared_ptr< CentralGravityFieldSettings > centralGravityFieldSettings =
+            boost::make_shared< CentralGravityFieldSettings >( gravitationalParameter );
+
+    // Create central gravity field with setup function.
+    boost::shared_ptr< gravitation::GravityFieldModel > centralGravityField =
+            createGravityFieldModel( centralGravityFieldSettings, "Earth" );
+
+    // Create central gravity field manually.
+    gravitation::GravityFieldModel manualCentralGravityField(
+                gravitationalParameter );
+
+    // Verify equivalence of automatically set up and manual models.
+    BOOST_CHECK_EQUAL(
+                ( manualCentralGravityField.getGravitationalParameter( ) ),
+                ( centralGravityField->getGravitationalParameter( ) ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                ( manualCentralGravityField.getGradientOfPotential( testPosition ) ),
+                ( centralGravityField->getGradientOfPotential( testPosition ) ),
+                std::numeric_limits< double >::epsilon( ) );
+
+    // Create settings for sh gravity field.
+    boost::shared_ptr< SphericalHarmonicsGravityFieldSettings > shGravityFieldSettings =
+            boost::make_shared< SphericalHarmonicsGravityFieldSettings >(
+                gravitationalParameter, 6378.0E3, cosineCoefficients, sineCoefficients,
+                "Earth_fixed" );
+
+    // Create sh gravity field with setup function.
+    boost::shared_ptr< gravitation::GravityFieldModel > shGravityField =
+            createGravityFieldModel( shGravityFieldSettings, "Earth" );
+
+    // Create sh gravity field manually.
+    gravitation::SphericalHarmonicsGravityField manualShGravityField(
+                gravitationalParameter, 6378.0E3, cosineCoefficients, sineCoefficients );
+
+    // Verify equivalence of automatically set up and manual models.
+    BOOST_CHECK_EQUAL(
+                ( manualShGravityField.getGravitationalParameter( ) ),
+                ( shGravityField->getGravitationalParameter( ) ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                ( manualShGravityField.getGradientOfPotential( testPosition ) ),
+                ( shGravityField->getGradientOfPotential( testPosition ) ),
+                std::numeric_limits< double >::epsilon( ) );
+
+}
+
+//! Test set up of rotation model environment models.
+BOOST_AUTO_TEST_CASE( test_rotationModelSetup )
+{
+
+    // Create settings for simple rotation model.
+    Eigen::Matrix3d spiceInitialRotationToTargetFrameMatrix;
+    spiceInitialRotationToTargetFrameMatrix
+            << -0.9548214974296336, 0.2665104385944917, 0.1314841974018291,
+            -0.296591573568662, -0.882413772579987, -0.3652114078848295,
+            0.01869081416890206, -0.3877088083617987, 0.9215923900425707;
+    double venusRotationRate = unit_conversions::convertDegreesToRadians( -1.4813688 ) /
+                physical_constants::JULIAN_DAY;
+    boost::shared_ptr< SimpleRotationModelSettings > simpleRotationSettings =
+            boost::make_shared< SimpleRotationModelSettings >
+            ( "IAU_VENUS", "J2000", Eigen::Quaterniond( spiceInitialRotationToTargetFrameMatrix ),
+                1.0E7, venusRotationRate );
+
+    // Create rotation model using setup function
+    boost::shared_ptr< ephemerides::RotationalEphemeris > approximateEphemeris =
+            createRotationModel( simpleRotationSettings, "Earth" );
+
+    // Create rotation model manually.
+    ephemerides::SimpleRotationalEphemeris manualApproximateEphemeris(
+                Eigen::Quaterniond( spiceInitialRotationToTargetFrameMatrix ),
+                venusRotationRate, 1.0E7, basic_astrodynamics::JULIAN_DAY_ON_J2000,
+                "J2000", "IAU_VENUS" );
+
+    // Verify equivalence of automatically set up and manual models.
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                ( Eigen::Matrix3d( manualApproximateEphemeris.getRotationToBaseFrame(
+                                       4.0E7, basic_astrodynamics::JULIAN_DAY_ON_J2000 ) ) ),
+                ( Eigen::Matrix3d( approximateEphemeris->getRotationToBaseFrame(
+                                       4.0E7, basic_astrodynamics::JULIAN_DAY_ON_J2000 ) ) ),
+                std::numeric_limits< double >::epsilon( ) );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION(
+                ( Eigen::Matrix3d( manualApproximateEphemeris.getRotationToTargetFrame(
+                                       4.0E7, basic_astrodynamics::JULIAN_DAY_ON_J2000 ) ) ),
+                ( Eigen::Matrix3d( approximateEphemeris->getRotationToTargetFrame(
+                                       4.0E7, basic_astrodynamics::JULIAN_DAY_ON_J2000 ) ) ),
+                std::numeric_limits< double >::epsilon( ) );
+
+}
+
+BOOST_AUTO_TEST_SUITE_END( )
+
+} // namespace unit_tests
+} // namespace tudat
+

=== added file 'Tudat/SimulationSetup/accelerationModelTypes.cpp'
--- Tudat/SimulationSetup/accelerationModelTypes.cpp	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/accelerationModelTypes.cpp	2015-06-16 11:38:27 +0000
@@ -0,0 +1,97 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#include <iostream>
+
+#include "Tudat/SimulationSetup/accelerationModelTypes.h"
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+//! Function to identify the derived class type of an acceleration model.
+AvailableAcceleration getAccelerationModelType(
+        const boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > >
+        accelerationModel )
+{
+    using namespace tudat::aerodynamics;
+    using namespace tudat::electro_magnetism;
+    using namespace tudat::gravitation;
+
+    // Nominal type is undefined
+    AvailableAcceleration accelerationType = undefined_acceleration;
+
+    // Check for each accelerarion mdoel type implemented as AvailableAcceleration.
+    if( boost::dynamic_pointer_cast< CentralGravitationalAccelerationModel3d >(
+                accelerationModel ) != NULL )
+    {
+        accelerationType = central_gravity;
+    }
+    else if( boost::dynamic_pointer_cast< CannonBallRadiationPressure >(
+                 accelerationModel ) != NULL )
+    {
+        accelerationType = cannon_ball_radiation_pressure;
+    }
+    else if( boost::dynamic_pointer_cast< ThirdBodyCentralGravityAcceleration >(
+                 accelerationModel ) != NULL )
+    {
+        accelerationType = third_body_central_gravity;
+    }
+    else if( boost::dynamic_pointer_cast< SphericalHarmonicsGravitationalAccelerationModelXd >(
+                 accelerationModel ) != NULL  )
+    {
+        accelerationType = spherical_harmonic_gravity;
+    }
+    else if( boost::dynamic_pointer_cast< AerodynamicAcceleration >(
+                 accelerationModel ) != NULL )
+    {
+        accelerationType = aerodynamic;
+    }
+    else
+    {
+        throw std::runtime_error(
+                    "Error, acceleration model not identified when getting acceleration type." );
+    }
+
+    // Return identified type.
+    return accelerationType;
+
+}
+
+
+}
+
+}

=== added file 'Tudat/SimulationSetup/accelerationModelTypes.h'
--- Tudat/SimulationSetup/accelerationModelTypes.h	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/accelerationModelTypes.h	2015-06-16 11:38:27 +0000
@@ -0,0 +1,156 @@
+#ifndef TUDAT_ACCELERATIONMODELTYPES_H
+#define TUDAT_ACCELERATIONMODELTYPES_H
+
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#include "Tudat/Astrodynamics/ElectroMagnetism/cannonBallRadiationPressureAcceleration.h"
+#include "Tudat/Astrodynamics/Gravitation/centralGravityModel.h"
+#include "Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.h"
+#include "Tudat/Astrodynamics/Gravitation/thirdBodyPerturbation.h"
+#include "Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.h"
+
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+//! List of accelerations available in simulations
+/*!
+ *  List of accelerations available in simulations. Acceleration models not defined by this
+ *  given enum cannot be used for automatic acceleration model setup.
+ */
+enum AvailableAcceleration
+{
+    undefined_acceleration,
+    central_gravity,
+    constant_drag_aerodynamic,
+    aerodynamic,
+    cannon_ball_radiation_pressure,
+    spherical_harmonic_gravity,
+    third_body_central_gravity,
+    third_body_spherical_harmonic_gravity
+};
+
+//! Class for providing settings for acceleration model.
+/*!
+ *  Class for providing settings for acceleration model. This class is a functional (base) class for
+ *  settings of acceleration models that  require no information in addition to their type.
+ *  Classes defining settings for acceleration models requiring additional information must be
+ *  derived from this class.
+ *  Bodies exerting and undergong acceleration are set externally from this class.
+ *  This class can be used for the easy setup of acceleration models
+ *  (see createAccelerationModels.h), but users may also chose to do so manually.
+ *  (Derived) Class members are all public, for ease of access and modification.
+ */
+class AccelerationSettings
+{
+public:
+    //! Constructor, sets type of acceleration.
+    /*!
+     *  Constructor, sets type of acceleration.
+     *  \param accelerationType Type of acceleration from AvailableAcceleration enum.
+     */
+    AccelerationSettings( const AvailableAcceleration accelerationType ):
+        accelerationType_( accelerationType ){ }
+
+    //! Destructor.
+    virtual ~AccelerationSettings( ){ }
+
+    //! Type of acceleration from AvailableAcceleration enum.
+    AvailableAcceleration accelerationType_;
+
+};
+
+//! Class for providing settings for spherical harmonics acceleration model.
+/*!
+ *  Class for providing settings for spherical harmonics acceleration model,
+ *  specifically the maximum degree and order up to which the field is to be expanded. Note that
+ *  the minimum degree and order are currently always set to zero.
+ */
+class SphericalHarmonicAccelerationSettings: public AccelerationSettings
+{
+public:
+    //! Constructor to set maximum degree and order that is to be taken into account.
+    /*!
+     *  Constructor to set maximum degree and order that is to be taken into account.
+     *  \param maximumDegree Maximum degree
+     *  \param maximumOrder Maximum order
+     */
+    SphericalHarmonicAccelerationSettings( const int maximumDegree,
+                                           const int maximumOrder ):
+        AccelerationSettings( spherical_harmonic_gravity ), maximumDegree_( maximumDegree ),
+        maximumOrder_( maximumOrder ){ }
+
+    //! Maximum degree that is to be used for spherical harmonic acceleration
+    int maximumDegree_;
+
+    //! Maximum order that is to be used for spherical harmonic acceleration
+    int maximumOrder_;
+};
+
+//! Function to identify the derived class type of an acceleration model.
+/*!
+ *  Function to identify the derived class type of an acceleration model. The type must be defined
+ *  in the AvailableAcceleration enum to be recognized by this function.
+ *  \param accelerationModel Acceleration model of which the type is to be identified.
+ *  \return Type of the accelerationModel, as identified by AvailableAcceleration enum.
+ */
+AvailableAcceleration getAccelerationModelType(
+        const boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > >
+        accelerationModel );
+
+//! Typedef defining a list of accelerations acting on a single body, key is the name of each
+//! body exerting a acceletation, value is a list of accelerations exerted by that body.
+typedef std::map< std::string, std::vector<
+boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > > >
+SingleBodyAccelerationMap;
+
+//! Typedef defining a list of accelerations acting on a set of bodies, key is the name of each
+//! body undergoing a acceletation, value is SingleBodyAccelerationMap, defining all accelerations
+//! acting on it.
+typedef std::map< std::string, SingleBodyAccelerationMap > AccelerationMap;
+
+//! Typedef defining a list of acceleration settings, set up in the same manner as the
+//! AccelerationMap typedef.
+typedef std::map< std::string, std::map< std::string, std::vector< boost::shared_ptr<
+AccelerationSettings > > > > SelectedAccelerationMap;
+
+}
+
+}
+
+#endif // TUDAT_ACCELERATIONMODELTYPES_H

=== added file 'Tudat/SimulationSetup/body.h'
--- Tudat/SimulationSetup/body.h	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/body.h	2015-06-16 11:38:27 +0000
@@ -0,0 +1,327 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      121030    K. Kumar          File created.
+ *      130225    K. Kumar          Updated include-guard and namespace names; updated Vector6d
+ *                                  references to use Tudat definition.
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#ifndef TUDAT__BODY_H
+#define TUDAT__BODY_H
+
+#include <map>
+#include <vector>
+
+#include <boost/shared_ptr.hpp>
+
+#include <Eigen/Core>
+
+#include <Tudat/Astrodynamics/Aerodynamics/atmosphereModel.h>
+#include <Tudat/Astrodynamics/BasicAstrodynamics/timeConversions.h>
+#include <Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h>
+#include <Tudat/Astrodynamics/Ephemerides/ephemeris.h>
+#include <Tudat/Astrodynamics/Ephemerides/rotationalEphemeris.h>
+#include <Tudat/Astrodynamics/Gravitation/gravityFieldModel.h>
+#include <Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h>
+#include <Tudat/Astrodynamics/Ephemerides/rotationalEphemeris.h>
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+//! Body class representing the properties of a celestial body (natural or artificial).
+/*!
+ *  Body class representing the properties of a celestial body (natural or artificial). By storing
+ *  all properties of bodies (ephemeris, rotation, gravity, etc.) in a set of body objects,
+ *  the simulation environment can be defined in a clear and modular way. To create body
+ *  objects, the createBodies.h function provides a range of functionality. The
+ *  createAccelerationModels.h file provides functions to use body objects to create acceleration
+ *  objects.
+ */
+class Body
+{
+public:
+
+    //! Constructor for a body
+    /*!
+     * Constructor for a body, sets current time, state, rotation and mass values
+     * (all with default parameters). The input state is used internally to
+     * set the current position (taken as a segment of the input state given by the indices
+     * (0, 3)) and the current velocity (taken as a segment of the input state given by the indices
+     * (3, 3).
+     * \param state Current state of body at initialization (default = zeroes).
+     * \param time Current time of body at initialization (default = zeroes).
+     * \param bodyMass Current mass of body at initialization (default = zeroes).
+     * \param currentRotationToGlobalFrame Current rotation of from body-fixed to inertial frames
+     *  at initialization (default = identity)
+     */
+    Body( const basic_mathematics::Vector6d& state =
+            basic_mathematics::Vector6d::Zero( ),
+          const double time = 0.0, const double bodyMass = 0.0,
+          const Eigen::Quaterniond currentRotationToGlobalFrame =
+            Eigen::Quaterniond( Eigen::Matrix3d::Identity( ) ) )
+        : currentState( state ),
+          currentPosition( state.segment( 0, 3 ) ),
+          currentVelocity( state.segment( 3, 3 ) ),
+          currentTime( time ),
+          currentRotationToGlobalFrame_( currentRotationToGlobalFrame ),
+          bodyMass_( bodyMass )
+    { }
+
+    //! Set current time and state.
+    /*!
+     *  Sets the current time, position and current velocity of the body based on the input
+     *  arguments. The current position is taken as a segment of the input state given by the
+     *  indices (0, 3)), and the current velocity is taken as a segment of the input state given by
+     *  the indices (3, 3).
+     *  Note: any updates of dependent variables which depend on time should be made here.
+     *  \param time Current time of body (from which to calculate any dependent variables in
+     *  future code modifications).
+     *  \param state Current state of body.
+     */
+    void setCurrentTimeAndState( const double time,
+                                 const basic_mathematics::Vector6d& state )
+    {
+        currentTime = time;
+        currentState = state;
+        currentPosition = state.segment( 0, 3 );
+        currentVelocity = state.segment( 3, 3 );
+
+        if( rotationalEphemeris_ != NULL )
+        {
+            currentRotationToGlobalFrame_ = rotationalEphemeris_->getRotationToBaseFrame(
+                        time );
+        }
+    }
+
+    //! Update body to current time
+    /*!
+     *  Update body to current time, calculating the current state from the ephemeris_ member
+     *  variable.
+     *  \param time Current time of body (from which to calculate the state, as well as any dependent
+     *  variables infuture code modifications).
+     */
+    void updateStateFromEphemeris( const double time )
+    {
+        setCurrentTimeAndState(
+                    time, bodyEphemeris_->getCartesianStateFromEphemeris(
+                        time, basic_astrodynamics::JULIAN_DAY_ON_J2000 ) );
+    }
+
+    //! Get current state.
+    /*!
+     * Returns the internally stored current state vector.
+     * \return Current state.
+     */
+    basic_mathematics::Vector6d getState( ) { return currentState; }
+
+    //! Get current position.
+    /*!
+     * Returns the internally stored current position vector.
+     * \return Current position.
+     */
+    Eigen::Vector3d getPosition( ) { return currentPosition; }
+
+    //! Get current velocity.
+    /*!
+     * Returns the internally stored current velocity vector.
+     * \return Current velocity.
+     */
+    Eigen::Vector3d getVelocity( ) { return currentVelocity; }
+
+    //! Get current time.
+    /*!
+     * Returns the internally stored current time.
+     * \return Current time.
+     */
+    double getCurrentTime( ) { return currentTime; }
+
+    //! Function to set the ephemeris of the body.
+    /*!
+     *  Function to set the ephemeris of the body, which is used to represent the (a priori)
+     *  state history of the body.
+     *  \param bodyEphemeris New ephemeris of the body.
+     */
+    void setEphemeris( const boost::shared_ptr< ephemerides::Ephemeris > bodyEphemeris )
+    {
+        bodyEphemeris_ = bodyEphemeris;
+    }
+
+    //! Function to set the gravity field of the body.
+    /*!
+     *  Function to set the gravity field of the body; input is also used to (re)set the mass
+     *  of the body.
+     *  \param gravityFieldModel New gravity field of the body.
+     */
+    void setGravityFieldModel(
+            const boost::shared_ptr< gravitation::GravityFieldModel > gravityFieldModel )
+    {
+        gravityFieldModel_ = gravityFieldModel;
+        bodyMass_ = gravityFieldModel_->getGravitationalParameter( );
+    }
+
+    //! Function to set the atmosphere model of the body.
+    /*!
+     *  Function to set the atmosphere model of the body.
+     *  \param atmosphereModel Atmosphere model of the body.
+     */
+    void setAtmosphereModel(
+            const boost::shared_ptr< aerodynamics::AtmosphereModel > atmosphereModel )
+    {
+        atmosphereModel_ = atmosphereModel;
+    }
+
+    //! Function to set the rotation model of the body.
+    /*!
+     *  Function to set the rotation model of the body.
+     *  \param rotationalEphemeris Rotation model of the body.
+     */
+    void setRotationalEphemeris(
+            const boost::shared_ptr< ephemerides::RotationalEphemeris > rotationalEphemeris )
+    {
+        rotationalEphemeris_ = rotationalEphemeris;
+    }
+
+
+    //! Function to get the gravity field model of the body.
+    /*!
+     *  Function to get the gravity field model of the body.
+     *  \return Gravity field model of the body.
+     */
+    boost::shared_ptr< gravitation::GravityFieldModel > getGravityFieldModel( )
+    {
+        return gravityFieldModel_;
+    }
+
+    //! Function to get the ephemeris of the body.
+    /*!
+     *  Function to get the ephemeris of the body.
+     *  \return Ephemeris of the body.
+     */
+    boost::shared_ptr< ephemerides::Ephemeris > getEphemeris( )
+    {
+        return bodyEphemeris_;
+    }
+
+    //! Function to get the atmosphere model of the body.
+    /*!
+     *  Function to get the atmosphere model of the body.
+     *  \return Atmosphere model of the body.
+     */
+    boost::shared_ptr< aerodynamics::AtmosphereModel > getAtmosphereModel( )
+    {
+        return atmosphereModel_;
+    }
+
+    //! Function to get the rotation model of the body.
+    /*!
+     *  Function to get the rotation model of the body.
+     *  \return Rotation model of the body.
+     */
+    boost::shared_ptr< ephemerides::RotationalEphemeris > getRotationalEphemeris( )
+    {
+        return rotationalEphemeris_;
+    }
+
+
+    //! Get current rotation from body-fixed to inertial frame.
+    /*!
+     *  Get current rotation from body-fixed to inertial frame, as set from the rotationalEphemeris_
+     *  by the setCurrentTimeAndState function. If body has no rotational ephemeris, an identity
+     *  quaternion (no rotation) is returned.
+     *  \return Current rotation from body-fixed to inertial frame
+     */
+    Eigen::Quaterniond getCurrentRotationToGlobalFrame( )
+    {
+        return currentRotationToGlobalFrame_;
+    }
+
+    //! Get current rotation from inertial to body-fixed frame.
+    /*!
+     *  Get current rotation from inertial to body-fixed frame, as set from the rotationalEphemeris_
+     *  by the setCurrentTimeAndState function. If body has no rotational ephemeris, an identity
+     *  quaternion (no rotation) is returned.
+     *  \return Current rotation from inertial to body-fixed frame
+     */
+    Eigen::Quaterniond getCurrentRotationToLocalFrame( )
+    {
+        return currentRotationToGlobalFrame_.inverse( );
+    }
+
+
+
+protected:
+
+private:
+
+    //! Current state.
+    basic_mathematics::Vector6d currentState;
+
+    //! Current position.
+    Eigen::Vector3d currentPosition;
+
+    //! Current position.
+    Eigen::Vector3d currentVelocity;
+
+    //! Current time.
+    double currentTime;
+
+    //! Current rotation from body-fixed to inertial frame.
+    Eigen::Quaterniond currentRotationToGlobalFrame_;
+
+    //! Mass of body (default set to zero, calculated from GravityFieldModel when it is set).
+    double bodyMass_;
+
+    //! Ephemeris of body.
+    boost::shared_ptr< ephemerides::Ephemeris > bodyEphemeris_;
+
+    //! Gravity field model of body.
+    boost::shared_ptr< gravitation::GravityFieldModel > gravityFieldModel_;
+
+    //! Atmosphere model of body.
+    boost::shared_ptr< aerodynamics::AtmosphereModel > atmosphereModel_;
+
+    //! Rotation model of body.
+    boost::shared_ptr< ephemerides::RotationalEphemeris > rotationalEphemeris_;
+
+
+};
+
+typedef std::map< std::string, boost::shared_ptr< Body > > NamedBodyMap;
+
+}
+
+}
+
+#endif // SATELLITE_PROPAGATOR_EXAMPLES_BODY_H

=== added file 'Tudat/SimulationSetup/createAccelerationModels.cpp'
--- Tudat/SimulationSetup/createAccelerationModels.cpp	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/createAccelerationModels.cpp	2015-06-16 11:38:27 +0000
@@ -0,0 +1,431 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#include <boost/make_shared.hpp>
+#include <boost/bind.hpp>
+#include <boost/lexical_cast.hpp>
+
+#include "Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.h"
+#include "Tudat/SimulationSetup/accelerationModelTypes.h"
+#include "Tudat/SimulationSetup/createAccelerationModels.h"
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+using namespace aerodynamics;
+using namespace gravitation;
+using namespace basic_astrodynamics;
+using namespace electro_magnetism;
+
+//! Function to determine if a given frame is an inertial frame.
+bool isFrameInertial( const std::string& frame )
+{
+    bool isFrameInertial_;
+    if( frame == "SSB" || frame == "" || frame == "Inertial" )
+    {
+        isFrameInertial_ = true;
+    }
+    else
+    {
+        isFrameInertial_ = false;
+    }
+    return isFrameInertial_;
+}
+
+
+double evaluateDoubleFunctions(
+        const boost::function< double( ) >& function1,
+        const boost::function< double( ) >& function2 )
+{
+    return function1( ) + function2( );
+}
+
+
+//! Function to create central gravity acceleration model.
+boost::shared_ptr< CentralGravitationalAccelerationModel3d > createCentralGravityAcceleratioModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const bool useCentralBodyFixedFrame )
+{
+    // Declare pointer to return object.
+    boost::shared_ptr< CentralGravitationalAccelerationModel3d > accelerationModelPointer;
+
+    // Check if body is endowed with a gravity field model (i.e. is capable of exerting
+    // gravitation acceleration).
+    if( bodyExertingAcceleration->getGravityFieldModel( ) == NULL )
+    {
+        throw std::runtime_error(
+                    std::string( "Error, gravity field model not set when making central ") +
+                    " gravitational acceleration of " + nameOfBodyExertingAcceleration + " on " +
+                    nameOfBodyUndergoingAcceleration );
+    }
+    else
+    {
+        boost::function< double( ) > gravitationalParameterFunction;
+
+        // Set correct value for gravitational parameter.
+        if( useCentralBodyFixedFrame == 0  ||
+                bodyUndergoingAcceleration->getGravityFieldModel( ) == NULL )
+        {
+            gravitationalParameterFunction =
+                    boost::bind( &gravitation::GravityFieldModel::getGravitationalParameter,
+                                 bodyExertingAcceleration->getGravityFieldModel( ) );
+        }
+        else
+        {
+            boost::function< double( ) > gravitationalParameterOfBodyExertingAcceleration =
+                    boost::bind( &gravitation::GravityFieldModel::getGravitationalParameter,
+                                 bodyExertingAcceleration->getGravityFieldModel( ) );
+            boost::function< double( ) > gravitationalParameterOfBodyUndergoingAcceleration =
+                    boost::bind( &gravitation::GravityFieldModel::getGravitationalParameter,
+                                 bodyUndergoingAcceleration->getGravityFieldModel( ) );
+            gravitationalParameterFunction =
+                    boost::bind( &evaluateDoubleFunctions,
+                                 gravitationalParameterOfBodyExertingAcceleration,
+                                 gravitationalParameterOfBodyUndergoingAcceleration );
+        }
+
+        // Create acceleration object.
+        accelerationModelPointer =
+                boost::make_shared< CentralGravitationalAccelerationModel3d >(
+                    boost::bind( &Body::getPosition, bodyUndergoingAcceleration ),
+                    gravitationalParameterFunction,
+                    boost::bind( &Body::getPosition, bodyExertingAcceleration ) );
+    }
+
+
+    return accelerationModelPointer;
+}
+
+//! Function to create spherical harmonic gravity acceleration model.
+boost::shared_ptr< gravitation::SphericalHarmonicsGravitationalAccelerationModelXd >
+createSphericalHarmonicsGravityAcceleration(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings,
+        const bool useCentralBodyFixedFrame )
+{
+    // Declare pointer to return object
+    boost::shared_ptr< SphericalHarmonicsGravitationalAccelerationModelXd > accelerationModel;
+
+    // Dynamic cast acceleration settings to required type and check consistency.
+    boost::shared_ptr< SphericalHarmonicAccelerationSettings > sphericalHarmonicsSettings =
+            boost::dynamic_pointer_cast< SphericalHarmonicAccelerationSettings >(
+                accelerationSettings );
+    if( sphericalHarmonicsSettings == NULL )
+    {
+        throw std::runtime_error(
+                    std::string( "Error, acceleration settings inconsistent ") +
+                    " making sh gravitational acceleration of " + nameOfBodyExertingAcceleration +
+                    " on " + nameOfBodyUndergoingAcceleration );
+    }
+    else
+    {
+        // Get pointer to gravity field of central body and cast to required type.
+        boost::shared_ptr< SphericalHarmonicsGravityField > sphericalHarmonicsGravityField =
+                boost::dynamic_pointer_cast< SphericalHarmonicsGravityField >(
+                    bodyExertingAcceleration->getGravityFieldModel( ) );
+        if( sphericalHarmonicsGravityField == NULL )
+        {
+            throw std::runtime_error(
+                        std::string( "Error, spherical harmonic gravity field model not set when ")
+                        + " making sh gravitational acceleration of " +
+                        nameOfBodyExertingAcceleration +
+                        " on " + nameOfBodyUndergoingAcceleration );
+        }
+        else
+        {
+            boost::function< double( ) > gravitationalParameterFunction;
+
+            // Check if mutual acceleration is to be used.
+            if( useCentralBodyFixedFrame == false ||
+                    bodyUndergoingAcceleration->getGravityFieldModel( ) == NULL )
+            {
+                gravitationalParameterFunction =
+                        boost::bind( &SphericalHarmonicsGravityField::getGravitationalParameter,
+                                     sphericalHarmonicsGravityField );
+            }
+            else
+            {
+                // Create function returning summed gravitational parameter of the two bodies.
+                boost::function< double( ) > gravitationalParameterOfBodyExertingAcceleration =
+                        boost::bind( &gravitation::GravityFieldModel::getGravitationalParameter,
+                                     sphericalHarmonicsGravityField );
+                boost::function< double( ) > gravitationalParameterOfBodyUndergoingAcceleration =
+                        boost::bind( &gravitation::GravityFieldModel::getGravitationalParameter,
+                                     bodyUndergoingAcceleration->getGravityFieldModel( ) );
+                gravitationalParameterFunction =
+                        boost::bind( &evaluateDoubleFunctions,
+                                     gravitationalParameterOfBodyExertingAcceleration,
+                                     gravitationalParameterOfBodyUndergoingAcceleration );
+            }
+
+            // Create acceleration object.
+            accelerationModel =
+                    boost::make_shared< SphericalHarmonicsGravitationalAccelerationModelXd >
+                    ( boost::bind( &Body::getPosition, bodyUndergoingAcceleration ),
+                      gravitationalParameterFunction,
+                      sphericalHarmonicsGravityField->getReferenceRadius( ),
+                      boost::bind( &SphericalHarmonicsGravityField::getCosineCoefficients,
+                                   sphericalHarmonicsGravityField,
+                                   sphericalHarmonicsSettings->maximumDegree_,
+                                   sphericalHarmonicsSettings->maximumOrder_ ),
+                      boost::bind( &SphericalHarmonicsGravityField::getSineCoefficients,
+                                   sphericalHarmonicsGravityField,
+                                   sphericalHarmonicsSettings->maximumDegree_,
+                                   sphericalHarmonicsSettings->maximumOrder_ ),
+                      boost::bind( &Body::getPosition, bodyExertingAcceleration ) );
+        }
+    }
+    return accelerationModel;
+}
+
+
+//! Function to create a third body central gravity acceleration model.
+boost::shared_ptr< gravitation::ThirdBodyCentralGravityAcceleration >
+createThirdBodyCentralGravityAccelerationModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const std::string& nameOfCentralBody )
+{
+    // Declare pointer to return object.
+    boost::shared_ptr< ThirdBodyCentralGravityAcceleration > accelerationModelPointer;
+
+    // Create acceleration object.
+    accelerationModelPointer =  boost::make_shared< ThirdBodyCentralGravityAcceleration >(
+                boost::dynamic_pointer_cast< CentralGravitationalAccelerationModel3d >(
+                    createCentralGravityAcceleratioModel( bodyUndergoingAcceleration,
+                                                          bodyExertingAcceleration,
+                                                          nameOfBodyUndergoingAcceleration,
+                                                          nameOfBodyExertingAcceleration, 0 ) ),
+                boost::dynamic_pointer_cast< CentralGravitationalAccelerationModel3d >(
+                    createCentralGravityAcceleratioModel( centralBody, bodyExertingAcceleration,
+                                                          nameOfCentralBody,
+                                                          nameOfBodyExertingAcceleration, 0 ) ) );
+
+    return accelerationModelPointer;
+}
+
+//! Function to create acceleration model object.
+boost::shared_ptr< AccelerationModel< Eigen::Vector3d > > createAccelerationModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfCentralBody )
+{
+    // Declare pointer to return object.
+    boost::shared_ptr< AccelerationModel< Eigen::Vector3d > > accelerationModelPointer;
+
+    // Switch to call correct acceleration model type factory function.
+    switch( accelerationSettings->accelerationType_ )
+    {
+    case central_gravity:
+        if( nameOfCentralBody == nameOfBodyExertingAcceleration ||
+                isFrameInertial( nameOfCentralBody ) )
+        {
+            bool useCentralBodyFixedFrame = 0;
+            if( nameOfCentralBody == nameOfBodyExertingAcceleration )
+            {
+                useCentralBodyFixedFrame = 1;
+            }
+
+            accelerationModelPointer = createCentralGravityAcceleratioModel(
+                        bodyUndergoingAcceleration,
+                        bodyExertingAcceleration,
+                        nameOfBodyUndergoingAcceleration,
+                        nameOfBodyExertingAcceleration, useCentralBodyFixedFrame );
+        }
+        else
+        {
+
+            accelerationModelPointer = createThirdBodyCentralGravityAccelerationModel(
+                        bodyUndergoingAcceleration,
+                        bodyExertingAcceleration,
+                        centralBody,
+                        nameOfBodyUndergoingAcceleration,
+                        nameOfBodyExertingAcceleration,
+                        nameOfCentralBody );
+        }
+        break;
+    case spherical_harmonic_gravity:
+        if( nameOfCentralBody == nameOfBodyExertingAcceleration ||
+                isFrameInertial( nameOfCentralBody ) )
+        {
+            bool useCentralBodyFixedFrame = 0;
+            if( nameOfCentralBody == nameOfBodyExertingAcceleration )
+            {
+                useCentralBodyFixedFrame = 1;
+            }
+
+            accelerationModelPointer = createSphericalHarmonicsGravityAcceleration(
+                        bodyUndergoingAcceleration,
+                        bodyExertingAcceleration,
+                        nameOfBodyUndergoingAcceleration,
+                        nameOfBodyExertingAcceleration,
+                        accelerationSettings, useCentralBodyFixedFrame );
+
+        }
+        else
+        {
+            throw std::runtime_error(
+                        "Error, cannot yet make third body spherical harmonic acceleration." );
+
+        }
+        break;
+    default:
+        throw std::runtime_error(
+                    std::string( "Error, acceleration model ") +
+                    boost::lexical_cast< std::string >( accelerationSettings->accelerationType_ ) +
+                    " not recognized when making acceleration model of" +
+                    nameOfBodyExertingAcceleration + " on " +
+                    nameOfBodyUndergoingAcceleration );
+        break;
+    }
+    return accelerationModelPointer;
+}
+
+//! Function to create a set of acceleration models from a map of bodies and acceleration model
+//! types.
+AccelerationMap createAccelerationModelsMap(
+        const NamedBodyMap& bodyMap,
+        const SelectedAccelerationMap& selectedAccelerationPerBody,
+        const std::map< std::string, std::string >& centralBodies )
+{
+    // Declare return map.
+    AccelerationMap accelerationModelMap;
+
+    // Iterate over all bodies which are undergoing acceleration
+    for( SelectedAccelerationMap::const_iterator bodyIterator =
+         selectedAccelerationPerBody.begin( ); bodyIterator != selectedAccelerationPerBody.end( );
+         bodyIterator++ )
+    {
+        boost::shared_ptr< Body > currentCentralBody;
+
+        // Retrieve name of body undergoing acceleration.
+        std::string bodyUndergoingAcceleration = bodyIterator->first;
+
+        // Retrieve name of current central body.
+        std::string currentCentralBodyName = centralBodies.at( bodyUndergoingAcceleration );
+
+        if( !isFrameInertial( currentCentralBodyName ) )
+        {
+            if( bodyMap.count( currentCentralBodyName ) == 0 )
+            {
+                throw std::runtime_error(
+                            std::string( "Error, could not find non-inertial central body ") +
+                            currentCentralBodyName + " of " + bodyUndergoingAcceleration +
+                            " when making acceleration model." );
+            }
+            else
+            {
+                currentCentralBody = bodyMap.at( currentCentralBodyName );
+            }
+        }
+
+        // Check if body undergoing acceleration is included in bodyMap
+        if( bodyMap.count( bodyUndergoingAcceleration ) ==  0 )
+        {
+            throw std::runtime_error(
+                        std::string( "Error when making acceleration models, requested forces" ) +
+                                     "acting on body " + bodyUndergoingAcceleration  +
+                                     ", but no such body found in map of bodies" );
+        }
+
+        // Declare map of acceleration models acting on current body.
+        SingleBodyAccelerationMap mapOfAccelerationsForBody;
+
+        // Retrieve list of required acceleration model types and bodies exerting accelerationd on
+        // current body.
+        std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > >
+                accelerationsForBody = bodyIterator->second;
+
+        // Iterate over all bodies exerting an acceleration
+        for( std::map< std::string, std::vector< boost::shared_ptr< AccelerationSettings > > >::
+             iterator body2Iterator = accelerationsForBody.begin( );
+             body2Iterator != accelerationsForBody.end( ); body2Iterator++ )
+        {
+            // Retrieve name of body exerting acceleration.
+            std::string bodyExertingAcceleration = body2Iterator->first;
+
+            // Check if body exerting acceleration is included in bodyMap
+            if( bodyMap.count( bodyExertingAcceleration ) ==  0 )
+            {
+                throw std::runtime_error(
+                            std::string( "Error when making acceleration models, requested forces ")
+                            + "acting on body " + bodyUndergoingAcceleration  + " due to body " +
+                            bodyExertingAcceleration +
+                            ", but no such body found in map of bodies" );
+            }
+
+            // Retrieve list of accelerations due to current body.
+            std::vector< boost::shared_ptr< AccelerationSettings > > accelerationList =
+                    body2Iterator->second;
+
+            for( unsigned int i = 0; i < accelerationList.size( ); i++ )
+            {
+                // Create acceleration model.
+                mapOfAccelerationsForBody[ bodyExertingAcceleration ].push_back(
+                            createAccelerationModel( bodyMap.at( bodyUndergoingAcceleration ),
+                                                     bodyMap.at( bodyExertingAcceleration ),
+                                                     accelerationList.at( i ),
+                                                     bodyUndergoingAcceleration,
+                                                     bodyExertingAcceleration,
+                                                     currentCentralBody,
+                                                     currentCentralBodyName ) );
+            }
+        }
+
+        // Put acceleration models on current body in return map.
+        accelerationModelMap[ bodyUndergoingAcceleration ] = mapOfAccelerationsForBody;
+    }
+
+    return accelerationModelMap;
+}
+
+}
+
+}

=== added file 'Tudat/SimulationSetup/createAccelerationModels.h'
--- Tudat/SimulationSetup/createAccelerationModels.h	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/createAccelerationModels.h	2015-06-16 11:38:27 +0000
@@ -0,0 +1,184 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#ifndef TUIDAT_CREATEACCELERATIONMODELS_H
+#define TUDAT_CREATEACCELERATIONMODELS_H
+
+#include <vector>
+#include <string>
+
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
+#include "Tudat/Astrodynamics/Gravitation/centralGravityModel.h"
+#include "Tudat/SimulationSetup/body.h"
+#include "Tudat/Astrodynamics/Aerodynamics/aerodynamicAcceleration.h"
+#include "Tudat/SimulationSetup/accelerationModelTypes.h"
+#include "Tudat/Astrodynamics/ElectroMagnetism/cannonBallRadiationPressureAcceleration.h"
+#include "Tudat/Astrodynamics/Gravitation/thirdBodyPerturbation.h"
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+//! Function to determine if a given frame is an inertial frame.
+/*!
+ *  Function to determine if a given frame is an inertial frame. Currently a frame identified as
+ *  "SSB" (solar system barycenter), "inertial" or "" (empty) is recognized as inertial.
+ *  \param frame Name of frame for which it is to be determined whether it is inertial.
+ *  \return True if inertial, false if not.
+ */
+bool isFrameInertial( const std::string& frame );
+
+//! Function to create central gravity acceleration model.
+/*!
+ *  Function to create central gravity acceleration model from bodies exerting and undergoing
+ *  acceleration.
+ *  \param bodyUndergoingAcceleration Pointer to object of body that is being accelerated.
+ *  \param bodyExertingAcceleration Pointer to object of body that is exerting the central gravity
+ *  acceleration.
+ *  \param nameOfBodyUndergoingAcceleration Name of body that is being accelerated.
+ *  \param nameOfBodyExertingAcceleration Name of body that is exerting the central gravity
+ *   acceleration.
+ *  \param useCentralBodyFixedFrame Boolean setting whether the central attraction of body
+ *  undergoing acceleration on body exerting acceleration is to be included in acceleration model.
+ *  Should be set to true in case the body undergoing acceleration is a celestial body
+ *  (with gravity field) and integration is performed in the frame centered at the body exerting
+ *  acceleration.
+ */
+boost::shared_ptr< gravitation::CentralGravitationalAccelerationModel3d >
+createCentralGravityAcceleratioModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const bool useCentralBodyFixedFrame );
+
+//! Function to create spherical harmonic gravity acceleration model.
+/*!
+ *  Function to create spherical harmonic gravity acceleration model from bodies exerting and
+ *  undergoing acceleration.
+ *  \param bodyUndergoingAcceleration Pointer to object of body that is being accelerated.
+ *  \param bodyExertingAcceleration Pointer to object of body that is exerting the spherical
+ *  harmonic gravity acceleration.
+ *  \param nameOfBodyUndergoingAcceleration Name of body that is being accelerated.
+ *  \param nameOfBodyExertingAcceleration Name of body that is exerting the spherical harmonic
+ *  gravity acceleration.
+ *  \param accelerationSettings Settings for acceleration model that is to be created (should
+ *  be of derived type associated with spherical harmonic acceleration.
+ *  \param useCentralBodyFixedFrame Boolean setting whether the central attraction of body
+ *  undergoing acceleration on body exerting acceleration is to be included in acceleration model.
+ *  Should be set to true in case the body undergoing acceleration is a celestial body
+ *  (with gravity field) and integration is performed in the frame centered at the body exerting
+ *  acceleration.
+ */
+boost::shared_ptr< gravitation::SphericalHarmonicsGravitationalAccelerationModelXd >
+createSphericalHarmonicsGravityAcceleration(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings,
+        const bool useCentralBodyFixedFrame );
+
+//! Function to create a third body central gravity acceleration model.
+/*!
+ *  Function to create a third body central gravity acceleration model from bodies exerting and
+ *  undergoing acceleration, as well as the central body, w.r.t. which the integration is to be
+ *  performed.
+ *  \param bodyUndergoingAcceleration Pointer to object of body that is being accelerated.
+ *  \param bodyExertingAcceleration Pointer to object of body that is exerting the acceleration.
+ *  \param centralBody Pointer to central body in frame centered at which acceleration is to be
+ *  calculated.
+ *  \param nameOfBodyUndergoingAcceleration Name of object of body that is being accelerated.
+ *  \param nameOfBodyExertingAcceleration Name of object of body that is exerting the central
+ *  gravity acceleration.
+ *  \param nameOfCentralBody Name of central body in frame cenetered at which acceleration is to
+ *  be calculated.
+ *  \return Pointer to object for calculating central gravity acceleration between bodies.
+ */
+boost::shared_ptr< gravitation::ThirdBodyCentralGravityAcceleration >
+createThirdBodyCentralGravityAccelerationModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const std::string& nameOfCentralBody );
+
+//! Function to create acceleration model object.
+/*!
+ *  Function to create acceleration model object.
+ *  Type of requested model is checked and corresponding factory function is called.
+ *  \param bodyUndergoingAcceleration Pointer to object of body that is being accelerated.
+ *  \param bodyExertingAcceleration Pointer to object of body that is exerting acceleration,
+ *  \param accelerationSettings Settings for acceleration model that is to be created.
+ *  \param nameOfBodyUndergoingAcceleration Name of object of body that is being accelerated.
+ *  \param nameOfBodyExertingAcceleration Name of object of body that is exerting the acceleration.
+ *  \param centralBody Pointer to central body in frame centered at which acceleration is to be
+ *  calculated (only relevant for third body accelerations).
+ *  \param nameOfCentralBody Name of central body in frame cenetered at which acceleration is to
+ *  be calculated (only relevant for third body accelerations).
+ *  \return Acceleration model pointer.
+ */
+boost::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > >
+createAccelerationModel(
+        const boost::shared_ptr< Body > bodyUndergoingAcceleration,
+        const boost::shared_ptr< Body > bodyExertingAcceleration,
+        const boost::shared_ptr< AccelerationSettings > accelerationSettings,
+        const std::string& nameOfBodyUndergoingAcceleration,
+        const std::string& nameOfBodyExertingAcceleration,
+        const boost::shared_ptr< Body > centralBody = boost::shared_ptr< Body >( ),
+        const std::string& nameOfCentralBody = "" );
+
+//! Function to create acceleration models from a map of bodies and acceleration model types.
+/*!
+ *  Function to create acceleration models from a map of bodies and acceleration model types.
+ *  The return type can be used to identify both the body undergoing and exerting acceleration.
+ *  \param bodyMap List of pointers to bodies required for the creation of the acceleration model
+ *  objects.
+ *  \param selectedAccelerationPerBody List identifying which bodies exert which type of
+ *  acceleration(s) on which bodies.
+ *  \param centralBodies Map of central bodies for each body undergoing acceleration.
+ *  \return List of acceleration model objects, in form of AccelerationMap.
+ */
+AccelerationMap createAccelerationModelsMap(
+        const NamedBodyMap& bodyMap,
+        const SelectedAccelerationMap& selectedAccelerationPerBody,
+        const std::map< std::string, std::string >& centralBodies );
+
+}
+
+}
+#endif // TUDAT_CREATEACCELERATIONMODELS_H

=== added file 'Tudat/SimulationSetup/createAtmosphereModel.cpp'
--- Tudat/SimulationSetup/createAtmosphereModel.cpp	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/createAtmosphereModel.cpp	2015-06-16 11:38:27 +0000
@@ -0,0 +1,117 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#include <boost/make_shared.hpp>
+#include <boost/lexical_cast.hpp>
+
+#include "Tudat/Astrodynamics/Aerodynamics/exponentialAtmosphere.h"
+#include "Tudat/Astrodynamics/Aerodynamics/tabulatedAtmosphere.h"
+#include "Tudat/SimulationSetup/createAtmosphereModel.h"
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+//! Function to create an atmosphere model.
+boost::shared_ptr< aerodynamics::AtmosphereModel > createAtmosphereModel(
+        const boost::shared_ptr< AtmosphereSettings > atmosphereSettings,
+        const std::string& body )
+{
+    using namespace tudat::aerodynamics;
+
+    // Declare return object.
+    boost::shared_ptr< AtmosphereModel > atmosphereModel;
+
+    // Check which type of atmosphere model is to be created.
+    switch( atmosphereSettings->getAtmosphereType( ) )
+    {
+    case exponential_atmosphere:
+    {
+        // Check whether settings for atmosphere are consistent with its type.
+        boost::shared_ptr< ExponentialAtmosphereSettings > exponentialAtmosphereSettings =
+                boost::dynamic_pointer_cast< ExponentialAtmosphereSettings >( atmosphereSettings );
+        if( exponentialAtmosphereSettings == NULL )
+        {
+            throw std::runtime_error(
+                        "Error, expected exponential atmosphere settings for body " + body );
+        }
+        else
+        {
+            // Create and initialize exponential atmosphere model.
+            boost::shared_ptr< ExponentialAtmosphere > exponentialAtmosphereModel =
+                    boost::make_shared< ExponentialAtmosphere >( );
+            exponentialAtmosphereModel->setScaleHeight(
+                        exponentialAtmosphereSettings->getDensityScaleHeight( ) );
+            exponentialAtmosphereModel->setDensityAtZeroAltitude(
+                        exponentialAtmosphereSettings->getDensityAtZeroAltitude( ) );
+            exponentialAtmosphereModel->setConstantTemperature(
+                        exponentialAtmosphereSettings->getConstantTemperature( ) );
+            exponentialAtmosphereModel->setSpecificGasConstant(
+                        exponentialAtmosphereSettings->getSpecificGasConstant( ) );
+            atmosphereModel = exponentialAtmosphereModel;
+        }
+        break;
+    }
+    case tabulated_atmosphere:
+    {
+        // Check whether settings for atmosphere are consistent with its type
+        boost::shared_ptr< TabulatedAtmosphereSettings > tabulatedAtmosphereSettings =
+                boost::dynamic_pointer_cast< TabulatedAtmosphereSettings >( atmosphereSettings );
+        if( tabulatedAtmosphereSettings == NULL )
+        {
+            throw std::runtime_error(
+                        "Error, expected tabulated atmosphere settings for body " + body );
+        }
+        else
+        {
+            // Create and initialize tabulatedl atmosphere model.
+            atmosphereModel = boost::make_shared< TabulatedAtmosphere >(
+                        tabulatedAtmosphereSettings->getAtmosphereFile( ) );
+        }
+        break;
+    }
+    default:
+        throw std::runtime_error(
+                 "Error, did not recognize atmosphere model settings type " +
+                  boost::lexical_cast< std::string >( atmosphereSettings->getAtmosphereType( ) ) );
+    }
+    return atmosphereModel;
+}
+
+
+}
+
+}

=== added file 'Tudat/SimulationSetup/createAtmosphereModel.h'
--- Tudat/SimulationSetup/createAtmosphereModel.h	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/createAtmosphereModel.h	2015-06-16 11:38:27 +0000
@@ -0,0 +1,210 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#ifndef TUDAT_CREATEATMOSPHEREMODEL_H
+#define TUDAT_CREATEATMOSPHEREMODEL_H
+
+#include <string>
+
+#include <boost/shared_ptr.hpp>
+
+#include "Tudat/Astrodynamics/Aerodynamics/atmosphereModel.h"
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+//! List of atmosphere models available in simulations
+/*!
+ *  List of atmosphere models available in simulations. Atmosphere models not defined by this
+ *  given enum cannot be used for automatic model setup.
+ */
+enum AtmosphereTypes
+{
+    exponential_atmosphere,
+    tabulated_atmosphere
+};
+
+//! Class for providing settings for atmosphere model.
+/*!
+ *  Class for providing settings for automatic atmosphere model creation. This class is a
+ *  functional (base) class for settings of atmosphere models that require no information in
+ *  addition to their type. Atmosphere model classes defining requiring additional information
+ *  must be created using an object derived from this class.
+ */
+class AtmosphereSettings
+{
+public:
+
+    //! Constructor, sets type of atmosphere model.
+    /*!
+     *  Constructor, sets type of atmosphere model. Settings for atmosphere models requiring
+     *  additional information should be defined in a derived class.
+     *  \param atmosphereType Type of atmosphere model that is to be created.
+     */
+    AtmosphereSettings( const AtmosphereTypes atmosphereType ):
+        atmosphereType_( atmosphereType ){ }
+
+    //! Destructor
+    virtual ~AtmosphereSettings( ){ }
+
+    //! Function to return type of atmosphere model that is to be created.
+    /*!
+     *  Function to return type of atmosphere model that is to be created.
+     *  \return Type of atmosphere model that is to be created.
+     */
+    AtmosphereTypes getAtmosphereType( ){ return atmosphereType_; }
+
+private:
+
+    //!  Type of atmosphere model that is to be created.
+    AtmosphereTypes atmosphereType_;
+};
+
+//! AtmosphereSettings for defining an exponential atmosphere.
+class ExponentialAtmosphereSettings: public AtmosphereSettings
+{
+public:
+    //! Constructor.
+    /*!
+     *  Constructor.
+     *  \param densityScaleHeight Scale heigh for density profile of atmosphere.
+     *  \param constantTemperature Constant atmospheric temperature.
+     *  \param densityAtZeroAltitude Atmospheric density at ground level.
+     *  \param specificGasConstant Specific gas constant for (constant) atmospheric chemical
+     *  composition.
+     */
+
+    ExponentialAtmosphereSettings(
+            const double densityScaleHeight, const double constantTemperature,
+            const double densityAtZeroAltitude, const double specificGasConstant ):
+        AtmosphereSettings( exponential_atmosphere ),
+        densityScaleHeight_( densityScaleHeight ), constantTemperature_( constantTemperature ),
+        densityAtZeroAltitude_( densityAtZeroAltitude ), specificGasConstant_( specificGasConstant )
+    { }
+
+    //! Function to return scale heigh for density profile of atmosphere.
+    /*!
+     *  Function to return scale heigh for density profile of atmosphere.
+     *  \return Scale heigh for density profile of atmosphere.
+     */
+    double getDensityScaleHeight( ){ return densityScaleHeight_; }
+
+    //! Function to return constant atmospheric temperature.
+    /*!
+     *  Function to return constant atmospheric temperature.
+     *  \return Constant atmospheric temperature.
+     */
+    double getConstantTemperature( ){ return constantTemperature_; }
+
+    //! Function to return atmospheric density at ground level.
+    /*!
+     *  Function to return atmospheric density at ground level.
+     *  \return Atmospheric density at ground level.
+     */
+    double getDensityAtZeroAltitude( ){ return densityAtZeroAltitude_; }
+
+    //! Function to return specific gas constant for (constant) atmospheric chemical
+    /*!
+     *  Function to return specific gas constant for (constant) atmospheric chemical
+     *  \return Specific gas constant for (constant) atmospheric chemical
+     */
+    double getSpecificGasConstant( ){ return specificGasConstant_; }
+private:
+
+    //! Scale heigh for density profile of atmosphere.
+    double densityScaleHeight_;
+
+    //! Constant atmospheric temperature.
+    double constantTemperature_;
+
+    //! Atmospheric density at ground level.
+    double densityAtZeroAltitude_;
+
+    //! Specific gas constant for (constant) atmospheric chemical
+    double specificGasConstant_;
+};
+
+//! AtmosphereSettings for defining an atmosphere with tabulated data from file.
+class TabulatedAtmosphereSettings: public AtmosphereSettings
+{
+public:
+
+    //! Constructor.
+    /*!
+     *  Constructor.
+     *  \param atmosphereFile File containing atmospheric properties, file should contain
+     *  four columns of atmospheric data with altitude, density, pressure and temperature,
+     *  respecrively.
+     */
+    TabulatedAtmosphereSettings( const std::string& atmosphereFile ):
+        AtmosphereSettings( tabulated_atmosphere ), atmosphereFile_( atmosphereFile ){ }
+
+    //! Function to return file containing atmospheric properties.
+    /*!
+     *  Function to return file containing atmospheric properties.
+     *  \return File containing atmospheric properties.
+     */
+    std::string getAtmosphereFile( ){ return atmosphereFile_; }
+
+private:
+
+    //! File containing atmospheric properties.
+    /*!
+     *  File containing atmospheric properties, file should contain
+     *  four columns of atmospheric data with altitude, density, pressure and temperature,
+     *  respecrively.
+     */
+    std::string atmosphereFile_;
+};
+
+//! Function to create an atmosphere model.
+/*!
+ *  Function to create an atmosphere model based on model-specific settings for the atmosphere.
+ *  \param atmosphereSettings Settings for the atmosphere model that is to be created, defined
+ *  a pointer to an object of class (derived from) AtmosphereSettings.
+ *  \param body Name of the body for which the atmosphere model is to be created.
+ *  \return Atmosphere model created according to settings in atmosphereSettings.
+ */
+boost::shared_ptr< aerodynamics::AtmosphereModel > createAtmosphereModel(
+        const boost::shared_ptr< AtmosphereSettings > atmosphereSettings,
+        const std::string& body );
+}
+
+}
+
+
+#endif // TUDAT_CREATEATMOSPHEREMODEL_H

=== added file 'Tudat/SimulationSetup/createBodies.cpp'
--- Tudat/SimulationSetup/createBodies.cpp	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/createBodies.cpp	2015-06-16 11:38:27 +0000
@@ -0,0 +1,127 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#include <boost/make_shared.hpp>
+#include <boost/lambda/lambda.hpp>
+#include <boost/assign/list_of.hpp>
+
+#include "Tudat/Mathematics/BasicMathematics/coordinateConversions.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/physicalConstants.h"
+#include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
+
+#include "Tudat/SimulationSetup/createBodies.h"
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+using namespace ephemerides;
+using namespace gravitation;
+
+//! Function to create a map of bodies objects.
+NamedBodyMap createBodies(
+        const std::map< std::string, boost::shared_ptr< BodySettings > >& bodySettings )
+{
+    // Declare map of bodies that is to be returned.
+    NamedBodyMap bodyMap;
+
+    // Create empty body objects.
+    for( std::map< std::string, boost::shared_ptr< BodySettings > >::const_iterator settingIterator
+         = bodySettings.begin( ); settingIterator != bodySettings.end( ); settingIterator++ )
+    {
+        bodyMap[ settingIterator->first ] = boost::make_shared< Body >( );
+    }
+
+    // Create ephemeris objects for each body (if required).
+    for( std::map< std::string, boost::shared_ptr< BodySettings > >::const_iterator settingIterator
+         = bodySettings.begin( ); settingIterator != bodySettings.end( ); settingIterator++ )
+    {
+        if( settingIterator->second->ephemerisSettings != NULL )
+        {
+            bodyMap[ settingIterator->first ]->setEphemeris(
+                        createBodyEphemeris( settingIterator->second->ephemerisSettings,
+                                                 settingIterator->first ) );
+        }
+        else
+        {
+            std::cerr<<"Warning, no ephemeris data found for body "<<
+                       settingIterator->first<<std::endl;
+        }
+    }
+
+    // Create atmosphere model objects for each body (if required).
+    for( std::map< std::string, boost::shared_ptr< BodySettings > >::const_iterator settingIterator
+         = bodySettings.begin( ); settingIterator != bodySettings.end( ); settingIterator++ )
+    {
+        if( settingIterator->second->atmosphereSettings != NULL )
+        {
+            bodyMap[ settingIterator->first ]->setAtmosphereModel(
+                        createAtmosphereModel( settingIterator->second->atmosphereSettings,
+                                               settingIterator->first ) );
+        }
+    }
+
+    // Create rotation model objects for each body (if required).
+    for( std::map< std::string, boost::shared_ptr< BodySettings > >::const_iterator settingIterator
+         = bodySettings.begin( ); settingIterator != bodySettings.end( ); settingIterator++ )
+    {
+        if( settingIterator->second->rotationModelSettings != NULL )
+        {
+            bodyMap[ settingIterator->first ]->setRotationalEphemeris(
+                        createRotationModel( settingIterator->second->rotationModelSettings,
+                                             settingIterator->first ) );
+        }
+    }
+
+    // Create gravity field model objects for each body (if required).
+    for( std::map< std::string, boost::shared_ptr< BodySettings > >::const_iterator settingIterator
+         = bodySettings.begin( ); settingIterator != bodySettings.end( ); settingIterator++ )
+    {
+        if( settingIterator->second->gravityFieldSettings != NULL )
+        {
+            bodyMap[ settingIterator->first ]->setGravityFieldModel(
+                        createGravityFieldModel( settingIterator->second->gravityFieldSettings,
+                                                 settingIterator->first ) );
+        }
+    }
+
+    return bodyMap;
+
+}
+
+}
+
+}

=== added file 'Tudat/SimulationSetup/createBodies.h'
--- Tudat/SimulationSetup/createBodies.h	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/createBodies.h	2015-06-16 11:38:27 +0000
@@ -0,0 +1,90 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#ifndef TUDAT_CREATEBODIES_H
+#define TUDAT_CREATEBODIES_H
+
+#include "Tudat/Astrodynamics/Ephemerides/ephemeris.h"
+#include "Tudat/Astrodynamics/BasicAstrodynamics/accelerationModel.h"
+
+#include "Tudat/SimulationSetup/body.h"
+#include "Tudat/SimulationSetup/createEphemeris.h"
+#include "Tudat/SimulationSetup/createAtmosphereModel.h"
+#include "Tudat/SimulationSetup/createEphemeris.h"
+#include "Tudat/SimulationSetup/createGravityField.h"
+#include "Tudat/SimulationSetup/createRotationModel.h"
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+//! Struct holding settings for a body to be created.
+/*!
+ *  Struct holding settings for a body to be created. From the settings, a CelestialBody object is
+ *  created by the createBodies function. Default values can be generated from the function in
+ *  defaultBodies.h.
+ */
+struct BodySettings
+{
+    //! Settings for the atmosphere model that the body is to contain.
+    boost::shared_ptr< AtmosphereSettings > atmosphereSettings;
+
+    //! Settings for the ephemeris model that the body is to contain.
+    boost::shared_ptr< EphemerisSettings > ephemerisSettings;
+
+    //! Settings for the gravity field model that the body is to contain.
+    boost::shared_ptr< GravityFieldSettings > gravityFieldSettings;
+
+    //! Settings for the rotation model that the body is to contain.
+    boost::shared_ptr< RotationModelSettings > rotationModelSettings;
+};
+
+//! Function to create a map of bodies objects.
+/*!
+ *  Function to create a msap of body objects based on model-specific settings for the bodies,
+ *  containing settings for each relevant environment model.
+ *  \param bodySettings List of settings for the bodies that are to be created, defined as a map of
+ *  pointers to an object of class BodySettings
+ *  \return List of bodies created according to settings in bodySettings.
+ */
+NamedBodyMap createBodies(
+        const std::map< std::string, boost::shared_ptr< BodySettings > >& bodySettings );
+
+}
+
+}
+
+#endif // TUDAT_CREATEBODIES_H

=== added file 'Tudat/SimulationSetup/createEphemeris.cpp'
--- Tudat/SimulationSetup/createEphemeris.cpp	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/createEphemeris.cpp	2015-06-16 11:38:27 +0000
@@ -0,0 +1,220 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#include <boost/lambda/lambda.hpp>
+#include <boost/lexical_cast.hpp>
+
+#include "Tudat/External/SpiceInterface/spiceEphemeris.h"
+#include "Tudat/Astrodynamics/Ephemerides/tabulatedEphemeris.h"
+#include "Tudat/Astrodynamics/Ephemerides/approximatePlanetPositions.h"
+#include "Tudat/Astrodynamics/Ephemerides/approximatePlanetPositionsCircularCoplanar.h"
+#include "Tudat/Mathematics/Interpolators/lagrangeInterpolator.h"
+#include "Tudat/SimulationSetup/createEphemeris.h"
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+using namespace ephemerides;
+
+//! Function to create a tabulated ephemeris using data from Spice.
+boost::shared_ptr< Ephemeris > createTabulatedEphemerisFromSpice(
+        const std::string& body,
+        const double initialTime,
+        const double endTime,
+        const double timeStep,
+        const std::string& observerName,
+        const std::string& referenceFrameName )
+{
+    using namespace interpolators;
+
+    std::map< double, basic_mathematics::Vector6d > timeHistoryOfState;
+
+    // Calculate state from spice at given time intervals and store in timeHistoryOfState.
+    double currentTime = initialTime;
+    while( currentTime < endTime )
+    {
+        timeHistoryOfState[ currentTime ] = spice_interface::getBodyCartesianStateAtEpoch(
+                    body, observerName, referenceFrameName, "none", currentTime );
+        currentTime += timeStep;
+    }
+
+    // Create interpolator.
+    boost::shared_ptr< LagrangeInterpolator< double, basic_mathematics::Vector6d > > interpolator =
+            boost::make_shared< LagrangeInterpolator< double, basic_mathematics::Vector6d > >(
+                timeHistoryOfState, 6, huntingAlgorithm,
+                lagrange_cubic_spline_boundary_interpolation );
+
+    // Create ephemeris and return.
+    return boost::make_shared< TabulatedCartesianEphemeris >(
+                interpolator, observerName, referenceFrameName );
+}
+//! Function to create a ephemeris model.
+boost::shared_ptr< ephemerides::Ephemeris > createBodyEphemeris(
+        const boost::shared_ptr< EphemerisSettings > ephemerisSettings,
+        const std::string& bodyName )
+{
+    // Declare return object.
+    boost::shared_ptr< ephemerides::Ephemeris > ephemeris;
+
+    // Check which type of ephemeris model is to be created.
+    switch( ephemerisSettings->getEphemerisType( ) )
+    {
+    case direct_spice_ephemeris:
+    {
+        // Check consistency of type and class.
+        boost::shared_ptr< DirectSpiceEphemerisSettings > directEphemerisSettings =
+                boost::dynamic_pointer_cast< DirectSpiceEphemerisSettings >( ephemerisSettings );
+        if( directEphemerisSettings == NULL )
+        {
+            throw std::runtime_error(
+                        "Error, expected direct spice ephemeris settings for body " + bodyName );
+        }
+        else
+        {
+            // Create corresponding ephemeris object.
+            ephemeris = boost::make_shared< SpiceEphemeris >(
+                        bodyName,
+                        directEphemerisSettings->getFrameOrigin( ),
+                        directEphemerisSettings->getCorrectForStellarAbberation( ),
+                        directEphemerisSettings->getCorrectForLightTimeAbberation( ),
+                        directEphemerisSettings->getConvergeLighTimeAbberation( ),
+                        directEphemerisSettings->getFrameOrientation( ) );
+        }
+        break;
+    }
+    case interpolated_spice:
+    {
+        // Check consistency of type and class.
+        boost::shared_ptr< InterpolatedSpiceEphemerisSettings > interpolatedEphemerisSettings =
+                boost::dynamic_pointer_cast< InterpolatedSpiceEphemerisSettings >(
+                    ephemerisSettings );
+        if( interpolatedEphemerisSettings == NULL )
+        {
+            throw std::runtime_error(
+                        "Error, expected tabulated spice ephemeris settings for body " + bodyName );
+        }
+        else
+        {
+            // Since only the barycenters of planetary systems are included in the standard DE
+            // ephemerides, append 'Barycenter' to body name.
+            std::string inputName;
+            inputName = bodyName;
+            if( bodyName == "Mercury" || bodyName == "Venus" || bodyName == "Mars" ||
+                    bodyName == "Jupiter"  || bodyName == "Saturn" ||
+                    bodyName == "Uranus" || bodyName == "Neptune" )
+            {
+                inputName += " Barycenter";
+                std::cerr<<"Warning, position of "<<bodyName<<" taken as baycenter of that body's "
+                        <<"planetary system."<<std::endl;
+            }
+
+            // Create corresponding ephemeris object.
+            ephemeris = createTabulatedEphemerisFromSpice(
+                        inputName,
+                        interpolatedEphemerisSettings->getInitialTime( ),
+                        interpolatedEphemerisSettings->getFinalTime( ),
+                        interpolatedEphemerisSettings->getTimeStep( ),
+                        interpolatedEphemerisSettings->getFrameOrigin( ),
+                        interpolatedEphemerisSettings->getFrameOrientation( ) );
+        }
+        break;
+    }
+    case tabulated_ephemeris:
+    {
+        // Check consistency of type and class.
+        boost::shared_ptr< TabulatedEphemerisSettings > tabulatedEphemerisSettings =
+                boost::dynamic_pointer_cast< TabulatedEphemerisSettings >( ephemerisSettings );
+        if( tabulatedEphemerisSettings == NULL )
+        {
+            throw std::runtime_error(
+                        "Error, expected tabulated ephemeris settings for body " + bodyName );
+        }
+        else
+        {
+            // Create corresponding ephemeris object.
+            ephemeris = boost::make_shared< TabulatedCartesianEphemeris >(
+                        boost::make_shared<
+                        interpolators::LagrangeInterpolator< double, basic_mathematics::Vector6d > >
+                        ( tabulatedEphemerisSettings->getBodyStateHistory( ), 6,
+                          interpolators::huntingAlgorithm,
+                          interpolators::lagrange_cubic_spline_boundary_interpolation ),
+                        tabulatedEphemerisSettings->getFrameOrigin( ),
+                        tabulatedEphemerisSettings->getFrameOrientation( ) );
+        }
+        break;
+    }
+    case approximate_planet_positions:
+    {
+        // Check consistency of type and class.
+        boost::shared_ptr< ApproximatePlanetPositionSettings > approximateEphemerisSettings =
+                boost::dynamic_pointer_cast< ApproximatePlanetPositionSettings >(
+                    ephemerisSettings );
+        if( approximateEphemerisSettings == NULL )
+        {
+            throw std::runtime_error(
+                        "Error, expected approximate ephemeris settings for body " + bodyName );
+        }
+        else
+        {
+            // Create corresponding ephemeris object.
+            if( approximateEphemerisSettings->getUseCircularCoplanarApproximation( ) )
+            {
+                ephemeris = boost::make_shared< ApproximatePlanetPositionsCircularCoplanar >(
+                            approximateEphemerisSettings->getBodyIdentifier( ) );
+            }
+            else
+            {
+                ephemeris = boost::make_shared< ApproximatePlanetPositions >(
+                            approximateEphemerisSettings->getBodyIdentifier( ) );
+            }
+        }
+        break;
+    }
+    default:
+    {
+        throw std::runtime_error(
+                    "Error, did not recognize ephemeris model settings type " +
+                    boost::lexical_cast< std::string >( ephemerisSettings->getEphemerisType( ) ) );
+    }
+    }
+    return ephemeris;
+
+}
+
+}
+
+}

=== added file 'Tudat/SimulationSetup/createEphemeris.h'
--- Tudat/SimulationSetup/createEphemeris.h	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/createEphemeris.h	2015-06-16 11:38:27 +0000
@@ -0,0 +1,411 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#ifndef TUDAT_CREATEEPHEMERIS_H
+#define TUDAT_CREATEEPHEMERIS_H
+
+#include <string>
+#include <map>
+
+#include <boost/shared_ptr.hpp>
+
+#include "Tudat/InputOutput/matrixTextFileReader.h"
+#include "Tudat/Astrodynamics/Ephemerides/ephemeris.h"
+#include "Tudat/Astrodynamics/Ephemerides/approximatePlanetPositionsBase.h"
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+//! List of ephemeris models available in simulations
+/*!
+ *  List of ephemeris models available in simulations. Ephemeris models not defined by this
+ *  given enum cannot be used for automatic model setup.
+ */
+enum EphemerisType
+{
+    approximate_planet_positions,
+    direct_spice_ephemeris,
+    tabulated_ephemeris,
+    interpolated_spice
+};
+
+//! Class for providing settings for ephemeris model.
+/*!
+ *  Class for providing settings for automatic ephemeris model creation. This class is a
+ *  functional (base) class for settings of ephemeris models that require no information in
+ *  addition to their type (and frame origin and orientation). Ephemeris model classes defining
+ *  requiring additional information must be created using an object derived from this class.
+ */
+class EphemerisSettings
+{
+public:
+
+    //! Constructor, sets type of ephemeris model.
+    /*!
+     *  Constructor, sets type of ephemeris model and frame origin and orientation.
+     *  Settings for ephemeris models requiring additional information should be defined in a
+     *  derived class.
+     *  \param ephemerisType Type of ephemeris model that is to be created.
+     *  \param frameOrigin Origin of frame in which ephemeris data is defined.
+     *  \param frameOrientation Orientation of frame in which ephemeris data is defined.
+     */
+    EphemerisSettings( const EphemerisType ephemerisType,
+                       const std::string& frameOrigin = "SSB",
+                       const  std::string& frameOrientation = "ECLIPJ2000" ):
+        ephemerisType_( ephemerisType ),
+        frameOrigin_( frameOrigin ),
+        frameOrientation_( frameOrientation ){ }
+
+    //! Destructor
+    virtual ~EphemerisSettings( ){ }
+
+    //! Function to return type of gravity field model that is to be created.
+    /*!
+     *  Function to return type of gravity field model that is to be created.
+     *  \return Type of gravity field model that is to be created.
+     */
+    EphemerisType getEphemerisType( ){ return ephemerisType_; }
+
+    //! Function to return the origin of frame in which ephemeris data is defined.
+    /*!
+     *  Function to return the origin of frame in which ephemeris data is defined.
+     *  \return Origin of frame in which ephemeris data is defined.
+     */
+    std::string getFrameOrigin( ){ return frameOrigin_; }
+
+    //! Function to return the orientation of frame in which ephemeris data is defined.
+    /*!
+     *  Function to return the orientation of frame in which ephemeris data is defined.
+     *  \return Orientation of frame in which ephemeris data is defined.
+     */
+    std::string getFrameOrientation( ){ return frameOrientation_;}
+
+protected:
+
+    //! Type of ephemeris model that is to be created.
+    EphemerisType ephemerisType_;
+
+    //! Origin of frame in which ephemeris data is defined.
+    std::string frameOrigin_;
+
+    //! Orientation of frame in which ephemeris data is defined.
+    std::string frameOrientation_;
+};
+
+//! EphemerisSettings derived class for defining settings of an ephemeris linked directly to Spice.
+class DirectSpiceEphemerisSettings: public EphemerisSettings
+{
+public:
+
+    //! Constructor.
+    /*! Constructor, sets the properties from which the Spice ephemeris is to be retrieved.
+     * \param frameOrigin Name of body relative to which the ephemeris is to be calculated.
+     * \param correctForStellarAbberation Boolean whether to correct for stellar Abberation in
+     *          retrieved values of (observed state).
+     * \param correctForLightTimeAbberation Boolean whether to correct for light time in
+     *          retrieved values of (observed state).
+     * \param convergeLighTimeAbberation Boolean whether to use single iteration or max. 3
+     *          iterations for calculating light time.
+     * \param frameOrientation Orientatioan of the reference frame in which the epehemeris is to be
+     *          calculated.
+     * \param ephemerisType Type of ephemeris that is to be created, always set to
+     *          direct_spice_ephemeris when using this class directly. The derived class
+     *          InterpolatedSpiceEphemerisSettings sets this parameter to a different value. Not
+     *          to be changed by used.
+     */
+    DirectSpiceEphemerisSettings( const std::string frameOrigin = "SSB",
+                                  const std::string frameOrientation = "ECLIPJ2000",
+                                  const bool correctForStellarAbberation = 0,
+                                  const bool correctForLightTimeAbberation = 0,
+                                  const bool convergeLighTimeAbberation = 0,
+                                  const EphemerisType ephemerisType = direct_spice_ephemeris ):
+        EphemerisSettings( ephemerisType, frameOrigin, frameOrientation ),
+        correctForStellarAbberation_( correctForStellarAbberation ),
+        correctForLightTimeAbberation_( correctForLightTimeAbberation ),
+        convergeLighTimeAbberation_( convergeLighTimeAbberation ){ }
+
+
+    //! Destructor
+    virtual ~DirectSpiceEphemerisSettings( ){ }
+
+    //! Returns whether to correct for stellar abberation in retrieved values of (observed state).
+    /*!
+     *  Returns whether to correct for stellar abberation in retrieved values of (observed state).
+     *  \return Boolean defining whether to correct for stellar abberation in retrieved
+     *  values of (observed state).
+     */
+    bool getCorrectForStellarAbberation( ){ return correctForStellarAbberation_; }
+
+    //! Returns whether to correct for light time in retrieved values of (observed state).
+    /*!
+     *  Returns whether to correct for light time in retrieved values of (observed state).
+     *  \return Boolean defining whether to correct for light time in retrieved values of
+     *  (observed state).
+     */
+    bool getCorrectForLightTimeAbberation( ){ return correctForLightTimeAbberation_; }
+
+    //! Returns whether to use single iteration or max. 3 iterations for calculating light time.
+    /*!
+     *  Returns whether to use single iteration or max. 3 iterations for calculating light time.
+     *  \return Boolean defining whether to use single iteration or max. 3 iterations for
+     *  calculating light time.
+     */
+    bool getConvergeLighTimeAbberation( ){ return convergeLighTimeAbberation_; }
+protected:
+
+    //! Boolean whether to correct for stellar abberation in retrieved values of (observed state).
+    bool correctForStellarAbberation_;
+
+    //! Boolean whether to correct for light time in retrieved values of (observed state).
+    bool correctForLightTimeAbberation_;
+
+    //! Boolean whether to use single iteration or max. 3 iterations for calculating light time.
+    bool convergeLighTimeAbberation_;
+};
+
+//! EphemerisSettings derived class for defining settings of a ephemeris interpolated from Spice
+//! data.
+/*!
+ *  EphemerisSettings derived class for defining settings of a ephemeris interpolated from Spice
+ *  data. Retrieving a state from Spice can be very computationally intensive. Using the
+ *  settings of this class, ephemeris data for a body is pre-computed using a limited number
+ *  of calls to Spice, which is then used to create an interpolator (6th order Lagrange). For
+ *  many numerical integration scenarios, this approach may be faster than using
+ *  DirectSpiceEphemerisSettings, with negligible influence on accuracy.
+ */
+class InterpolatedSpiceEphemerisSettings: public DirectSpiceEphemerisSettings
+{
+public:
+
+    //! Constructor.
+    /*! Constructor, sets the properties from which the tabulated spice data is to be created
+     *  from which an ephemeris is to be created.
+     * \param initialTime Initial time from which interpolated data from Spice should be created.
+     * \param finalTime Final time from which interpolated data from Spice should be created.
+     * \param timeStep Time step with which interpolated data from Spice should be created.
+     * \param frameOrigin Name of body relative to which the ephemeris is to be calculated.
+     * \param frameOrientation Orientatioan of the reference frame in which the epehemeris is to be
+     *          calculated.
+     */
+    InterpolatedSpiceEphemerisSettings( double initialTime,
+                                        double finalTime,
+                                        double timeStep,
+                                        std::string frameOrigin = "SSB",
+                                        std::string frameOrientation = "ECLIPJ2000" ):
+        DirectSpiceEphemerisSettings( frameOrigin, frameOrientation, 0, 0, 0,
+                                      interpolated_spice ),
+        initialTime_( initialTime ), finalTime_( finalTime ), timeStep_( timeStep ){ }
+
+    //! Function to returns initial time from which interpolated data from Spice should be created.
+    /*!
+     *  Function to returns initial time from which interpolated data from Spice should be created.
+     *  \return Initial time from which interpolated data from Spice should be created.
+     */
+    double getInitialTime( ){ return initialTime_; }
+
+    //! Function to returns final time from which interpolated data from Spice should be created.
+    /*!
+     *  Function to returns final time from which interpolated data from Spice should be created.
+     *  \return Final time from which interpolated data from Spice should be created.
+     */
+    double getFinalTime( ){ return finalTime_; }
+
+    //! Function to returns time step with which interpolated data from Spice should be created.
+    /*!
+     *  Function to returns time step with which interpolated data from Spice should be created.
+     *  \return Time step with which interpolated data from Spice should be created.
+     */
+    double getTimeStep( ){ return timeStep_; }
+
+private:
+
+    //! Initial time from which interpolated data from Spice should be created.
+    double initialTime_;
+
+    //! Final time from which interpolated data from Spice should be created.
+    double finalTime_;
+
+    //! Time step with which interpolated data from Spice should be created.
+    double timeStep_;
+
+};
+
+//! EphemerisSettings derived class for defining settings of an approximate ephemeris for major
+//! planets.
+/*!
+ *  EphemerisSettings derived class for defining settings of an approximate ephemeris for major
+ *  planets, as inplemented in ApproximatePlanetPositions class and derived class,
+ *  described on http://ssd.jpl.nasa.gov/txt/aprx_pos_planets.pdf.
+ */
+class ApproximatePlanetPositionSettings: public EphemerisSettings
+{
+public:
+
+    //! Constructor.
+    /*!
+     *  Constructor.
+     *  \param bodyIdentifier Parameter identifying for which body an ephemeris is to be created.
+     *  \param useCircularCoplanarApproximation Boolean defining whether a circular, coplanar
+     *  orbit of the body is to be assumed, or whether a non-zero inclination and long-period
+     *  changes in the orbit are to be included.
+     */
+    ApproximatePlanetPositionSettings(
+            const ephemerides::ApproximatePlanetPositionsBase::BodiesWithEphemerisData
+            bodyIdentifier,
+            const bool useCircularCoplanarApproximation ):
+        EphemerisSettings( approximate_planet_positions ),
+        bodyIdentifier_( bodyIdentifier ),
+        useCircularCoplanarApproximation_( useCircularCoplanarApproximation ){ }
+
+    //! Function to return parameter identifying for which body an ephemeris is to be created.
+    /*!
+     *  Function to return parameter identifying for which body an ephemeris is to be created.
+     *  \return Parameter identifying for which body an ephemeris is to be created.
+     */
+    ephemerides::ApproximatePlanetPositionsBase::BodiesWithEphemerisData getBodyIdentifier( )
+    {
+        return bodyIdentifier_;
+    }
+
+    //! Function to return whether a circular, coplanar orbit of the body is to be assumed.
+    /*!
+     *  Function to return whether a circular, coplanar orbit of the body is to be assumed.
+     *  \return Boolean defining whether a circular, coplanar orbit of the body is to be assumed.
+     */
+    bool getUseCircularCoplanarApproximation( )
+    {
+        return useCircularCoplanarApproximation_;
+    }
+
+private:
+
+    //! Parameter identifying for which body an ephemeris is to be created.
+    ephemerides::ApproximatePlanetPositionsBase::BodiesWithEphemerisData bodyIdentifier_;
+
+    //!  Boolean defining whether a circular, coplanar orbit of the body is to be assumed,
+    /*!
+     *  Boolean defining whether a circular, coplanar orbit of the body is to be assumed
+     *  (creating an ApproximatePlanetPositionsCircularCoplanar object), or whether
+     *  a non-zero inclination and long-period changes in the orbit are to be included
+     *  (creating an ApproximatePlanetPositions object).
+     */
+     bool useCircularCoplanarApproximation_;
+};
+
+//! EphemerisSettings derived class for defining settings of an ephemeris created from tabulated
+//! data.
+/*!
+ *  EphemerisSettings derived class for defining settings of an ephemeris created from tabulated
+ *  data. Currently the use of an 6th order Lagrange interpolator is hardcoded, which is created
+ *  from the data that is provided. Note that at the edges of the interpolation interval, a
+ *  Cubic spline interpolator is used to suppres the influence of Runge's phenomenon.
+ */
+class TabulatedEphemerisSettings: public EphemerisSettings
+{
+public:
+
+    //! Constructor.
+    /*!
+     *  Constructor.
+     *  \param bodyStateHistory Data map (time as key, Cartesian state as values) defining data
+     *  from which an interpolated ephemeris is to be creaed.
+     */
+    TabulatedEphemerisSettings(
+            const std::map< double, basic_mathematics::Vector6d >& bodyStateHistory ):
+        EphemerisSettings( tabulated_ephemeris ),
+        bodyStateHistory_( bodyStateHistory ){ }
+
+    //! Function returning data map defining discrete data from which an ephemeris is to be created.
+    /*!
+     *  Function returning data map defining discrete data from which an ephemeris is to be created.
+     *  \return Data map defining discrete data from which an ephemeris is to be created.
+     */
+    std::map< double, basic_mathematics::Vector6d > getBodyStateHistory( )
+    { return bodyStateHistory_; }
+
+private:
+
+    //! Data map defining discrete data from which an ephemeris is to be created.
+    /*!
+     *  Data map (time as key, Cartesian state as values) defining data from which an interpolated
+     *  ephemeris is to be created.
+     */
+    std::map< double, basic_mathematics::Vector6d > bodyStateHistory_;
+};
+
+//! Function to create a tabulated ephemeris using data from Spice.
+/*!
+ *  Function to create a tabulated ephemeris using data from Spice.
+ *  Retrieving a state from Spice can be very computationally intensive. Using this function,
+ *  ephemeris data for a body is pre-computed using a limited number
+ *  of calls to Spice, which is then used to create an interpolator (6th order Lagrange). For
+ *  many numerical integration scenarios, this approach may be faster than using
+ *  DirectSpiceEphemerisSettings, with negligible influence on accuracy.
+ * \param body Name of body for which ephemeris data is to be retrieved.
+ * \param initialTime Initial time from which interpolated data from Spice should be created.
+ * \param endTime Final time from which interpolated data from Spice should be created.
+ * \param timeStep Time step with which interpolated data from Spice should be created.
+ * \param observerName Name of body relative to which the ephemeris is to be calculated.
+ * \param referenceFrameName Orientatioan of the reference frame in which the epehemeris is to be
+ *          calculated.
+ */
+boost::shared_ptr< ephemerides::Ephemeris > createTabulatedEphemerisFromSpice(
+        const std::string& body,
+        const double initialTime,
+        const double endTime,
+        const double timeStep,
+        const std::string& observerName,
+        const std::string& referenceFrameName );
+
+//! Function to create a ephemeris model.
+/*!
+ *  Function to create a ephemeris model based on model-specific settings for the ephemeris.
+ *  \param ephemerisSettings Settings for the ephemeris model that is to be created, defined
+ *  a pointer to an object of class (derived from) EphemerisSettings.
+ *  \param bodyName Name of the body for which the ephemeris model is to be created.
+ *  \return Ephemeris model created according to settings in ephemerisSettings.
+ */
+boost::shared_ptr< ephemerides::Ephemeris > createBodyEphemeris(
+        const boost::shared_ptr< EphemerisSettings > ephemerisSettings,
+        const std::string& bodyName );
+
+
+}
+
+}
+
+#endif // TUDAT_CREATEEPHEMERIS_H

=== added file 'Tudat/SimulationSetup/createGravityField.cpp'
--- Tudat/SimulationSetup/createGravityField.cpp	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/createGravityField.cpp	2015-06-16 11:38:27 +0000
@@ -0,0 +1,138 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#include <boost/make_shared.hpp>
+
+#include "Tudat/External/SpiceInterface/spiceInterface.h"
+#include "Tudat/SimulationSetup/createGravityField.h"
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+//! Function to create a gravity field model.
+boost::shared_ptr< gravitation::GravityFieldModel > createGravityFieldModel(
+        const boost::shared_ptr< GravityFieldSettings > gravityFieldSettings,
+        const std::string& body )
+{
+    using namespace tudat::gravitation;
+
+    // Declare return object.
+    boost::shared_ptr< GravityFieldModel > gravityFieldModel;
+
+    // Check which type of gravity field model is to be created.
+    switch( gravityFieldSettings->getGravityFieldType( ) )
+    {
+    case central:
+    {
+        // Check whether settings for point mass gravity field model are consistent with its type.
+        boost::shared_ptr< CentralGravityFieldSettings > centralFieldSettings =
+                boost::dynamic_pointer_cast< CentralGravityFieldSettings >( gravityFieldSettings );
+        if( centralFieldSettings == NULL )
+        {
+            throw std::runtime_error(
+                "Error, expected central field settings when making gravity field model for body " +
+                 body);
+        }
+        else
+        {
+            // Create and initialize point mass gravity field model.
+            gravityFieldModel = boost::make_shared< GravityFieldModel >(
+                        centralFieldSettings->getGravitationalParameter( ) );
+        }
+        break;
+    }
+    case central_spice:
+    {
+        // Create and initialize point mass gravity field model from Spice.
+        gravityFieldModel = boost::make_shared< GravityFieldModel >(
+                    spice_interface::getBodyGravitationalParameter( body ) );
+
+        break;
+    }
+    case spherical_harmonic:
+    {
+        // Check whether settings for spherical harmonic gravity field model are consistent with
+        // its type.
+        boost::shared_ptr< SphericalHarmonicsGravityFieldSettings > sphericalHarmonicFieldSettings =
+                boost::dynamic_pointer_cast< SphericalHarmonicsGravityFieldSettings >(
+                    gravityFieldSettings );
+
+        if( sphericalHarmonicFieldSettings == NULL )
+        {
+            throw std::runtime_error(
+             "Error, expected spherical harmonic field settings when making gravity field model of "
+                        + body );
+        }
+        else
+        {
+            // Check consistency of cosine and sine coefficients.
+            if( ( sphericalHarmonicFieldSettings->getCosineCoefficients( ).rows( ) !=
+                  sphericalHarmonicFieldSettings->getSineCoefficients( ).rows( ) ) ||
+                    ( sphericalHarmonicFieldSettings->getCosineCoefficients( ).cols( ) !=
+                      sphericalHarmonicFieldSettings->getSineCoefficients( ).cols( ) ) )
+            {
+                throw std::runtime_error(
+                            std::string( "Error when making spherical harmonic field, sine and " ) +
+                            std::string( "cosine matrix  sizes are not equal for body " ) + body );
+            }
+            else
+            {
+                // Create and initialize spherical harmonic gravity field model.
+                gravityFieldModel = boost::make_shared< SphericalHarmonicsGravityField >(
+                            sphericalHarmonicFieldSettings->getGravitationalParameter( ),
+                            sphericalHarmonicFieldSettings->getReferenceRadius( ),
+                            sphericalHarmonicFieldSettings->getCosineCoefficients( ),
+                            sphericalHarmonicFieldSettings->getSineCoefficients( ) );
+            }
+
+
+        }
+        break;
+    }
+    default:
+        throw std::runtime_error(
+                 "Error, did not recognize gravity field model settings type " +
+                  boost::lexical_cast< std::string >(
+                        gravityFieldSettings->getGravityFieldType( ) ) );
+    }
+
+    return gravityFieldModel;
+}
+
+}
+
+}

=== added file 'Tudat/SimulationSetup/createGravityField.h'
--- Tudat/SimulationSetup/createGravityField.h	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/createGravityField.h	2015-06-16 11:38:27 +0000
@@ -0,0 +1,234 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#ifndef TUDAT_CREATEGRAVITYFIELD_H
+#define TUDAT_CREATEGRAVITYFIELD_H
+
+#include <iostream>
+
+#include <map>
+#include <vector>
+#include <fstream>
+#include <sstream>
+#include <string>
+#include <iostream>
+
+#include <boost/algorithm/string.hpp>
+#include <boost/algorithm/string/trim.hpp>
+#include <boost/lexical_cast.hpp>
+#include <boost/format.hpp>
+#include <boost/shared_ptr.hpp>
+
+#include "Tudat/SimulationSetup/body.h"
+#include "Tudat/Astrodynamics/Gravitation/gravityFieldModel.h"
+#include "Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.h"
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+//! List of gravity field models available in simulations
+/*!
+ *  List of gravity field models available in simulations. Gravity field models not defined by this
+ *  given enum cannot be used for automatic model setup.
+ */
+enum GravityFieldType
+{
+    central,
+    central_spice,
+    spherical_harmonic
+};
+
+//! Class for providing settings for gravity field model.
+/*!
+ *  Class for providing settings for automatic gravity field model creation. This class is a
+ *  functional (base) class for settings of gravity field models that require no information in
+ *  addition to their type. Gravity field model classes defining requiring additional information
+ *  must be created using an object derived from this class.
+ */
+class GravityFieldSettings
+{
+public:
+
+    //! Constructor, sets type of gravity field model.
+    /*!
+     *  Constructor, sets type of gravity field model. Settings for gravity field models requiring
+     *  additional information should be defined in a derived class.
+     *  \param gravityFieldType Type of gravity field model that is to be created.
+     */
+    GravityFieldSettings( const GravityFieldType gravityFieldType ):
+        gravityFieldType_( gravityFieldType ){ }
+
+    //! Destructor
+    virtual ~GravityFieldSettings( ){ }
+
+    //! Function to return type of gravity field model that is to be created.
+    /*!
+     *  Function to return type of gravity field model that is to be created.
+     *  \return Type of gravity field model that is to be created.
+     */
+    GravityFieldType getGravityFieldType( ){ return gravityFieldType_; }
+
+protected:
+
+    //! Type of gravity field model that is to be created.
+    GravityFieldType gravityFieldType_;
+};
+
+//! Derived class of GravityFieldSettings defining settings of point mass gravity field.
+class CentralGravityFieldSettings: public GravityFieldSettings
+{
+public:
+
+    //! Constructor.
+    /*!
+     *  Constructor.
+     *  \param gravitationalParameter Gravitational parameter of gravity field.
+     */
+    CentralGravityFieldSettings( double gravitationalParameter ):GravityFieldSettings( central ),
+        gravitationalParameter_( gravitationalParameter ){ }
+
+    //! Function to return gravitational parameter for gravity field.
+    /*!
+     *  Function to return gravitational parameter for gravity field.
+     *  \return Gravitational parameter for gravity field.
+     */
+    double getGravitationalParameter( ){ return gravitationalParameter_; }
+private:
+
+    //! Gravitational parameter for gravity field.
+    double gravitationalParameter_;
+};
+
+
+//! Derived class of GravityFieldSettings defining settings of spherical harmonic gravity
+//! field representation.
+class SphericalHarmonicsGravityFieldSettings: public GravityFieldSettings
+{
+public:
+    //! Constructor.
+    /*!
+     *  Constructor.
+     *  \param gravitationalParameter Gravitational parameter of gravity field.
+     *  \param referenceRadius Reference radius of spherical harmonic field expansion.
+     *  \param cosineCoefficients Cosine spherical harmonic coefficients (geodesy normalized).
+     *  \param sineCoefficients Sine spherical harmonic coefficients (geodesy normalized).
+     *  \param associatedReferenceFrame Identifier for body-fixed reference frame to which
+     *  the coefficients are referred.
+     */
+    SphericalHarmonicsGravityFieldSettings( const double gravitationalParameter,
+                                            const double referenceRadius,
+                                            const Eigen::MatrixXd cosineCoefficients,
+                                            const Eigen::MatrixXd sineCoefficients,
+                                            const std::string associatedReferenceFrame ):
+        GravityFieldSettings( spherical_harmonic ),
+        gravitationalParameter_( gravitationalParameter ),
+        referenceRadius_( referenceRadius ),
+        cosineCoefficients_( cosineCoefficients ),
+        sineCoefficients_( sineCoefficients ),
+        associatedReferenceFrame_( associatedReferenceFrame )
+    {  }
+
+    //! Function to return gravitational parameter for gravity field.
+    /*!
+     *  Function to return gravitational parameter for gravity field.
+     *  \return Gravitational parameter for gravity field.
+     */
+    double getGravitationalParameter( ){ return gravitationalParameter_; }
+
+    //! Function to return reference radius of spherical harmonic field expansion
+    /*!
+     *  Function to return reference radius of spherical harmonic field expansion
+     *  \return Reference radius of spherical harmonic field expansion
+     */
+    double getReferenceRadius( ){ return referenceRadius_; }
+
+    //! Function to return cosine spherical harmonic coefficients (geodesy normalized).
+    /*!
+     *  Function to return cosine spherical harmonic coefficients (geodesy normalized).
+     *  \return Cosine spherical harmonic coefficients (geodesy normalized).
+     */
+    Eigen::MatrixXd getCosineCoefficients( ){ return cosineCoefficients_; }
+
+    //! Function to return sine spherical harmonic coefficients (geodesy normalized).
+    /*!
+     *  Function to return sine spherical harmonic coefficients (geodesy normalized).
+     *  \return Sine spherical harmonic coefficients (geodesy normalized).
+     */
+    Eigen::MatrixXd getSineCoefficients( ){ return sineCoefficients_; }
+
+    //! Function to return identifier for body-fixed reference frame.
+    /*!
+     *  Function to return identifier for body-fixed reference frame to which the coefficients
+     *  are referred.
+     *  \return Identifier for body-fixed reference frame to which the coefficients are referred.
+     */
+    std::string getAssociatedReferenceFrame( ){ return associatedReferenceFrame_; }
+
+private:
+
+
+    //! Gravitational parameter for gravity field that is to be created.
+    double gravitationalParameter_;
+
+    //! Reference radius of spherical harmonic field expansion
+    double referenceRadius_;
+
+    //! Cosine spherical harmonic coefficients (geodesy normalized).
+    Eigen::MatrixXd cosineCoefficients_;
+
+    //! Sine spherical harmonic coefficients (geodesy normalized).
+    Eigen::MatrixXd sineCoefficients_;
+
+    //! Identifier for body-fixed reference frame to which the coefficients are referred.
+    std::string associatedReferenceFrame_;
+};
+
+//! Function to create a gravity field model.
+/*!
+ *  Function to create a gravity field model based on model-specific settings for the gravity field.
+ *  \param gravityFieldSettings Settings for the gravity field model that is to be created, defined
+ *  a pointer to an object of class (derived from) GravityFieldSettings.
+ *  \param body Name of the body for which the gravity field model is to be created.
+ *  \return Gravity field model created according to settings in gravityFieldSettings.
+ */
+boost::shared_ptr< gravitation::GravityFieldModel > createGravityFieldModel(
+        const boost::shared_ptr< GravityFieldSettings > gravityFieldSettings,
+        const std::string& body);
+}
+
+}
+#endif // TUDAT_CREATEGRAVITYFIELD_H

=== added file 'Tudat/SimulationSetup/createRotationModel.cpp'
--- Tudat/SimulationSetup/createRotationModel.cpp	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/createRotationModel.cpp	2015-06-16 11:38:27 +0000
@@ -0,0 +1,105 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#include <iostream>
+
+#include <boost/make_shared.hpp>
+#include <boost/lexical_cast.hpp>
+
+#include "Tudat/Astrodynamics/Ephemerides/simpleRotationalEphemeris.h"
+#include "Tudat/External/SpiceInterface/spiceRotationalEphemeris.h"
+#include "Tudat/SimulationSetup/createRotationModel.h"
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+//! Function to create a rotation model.
+boost::shared_ptr< ephemerides::RotationalEphemeris > createRotationModel(
+        const boost::shared_ptr< RotationModelSettings > rotationModelSettings,
+        const std::string& body )
+{
+    using namespace tudat::ephemerides;
+
+    // Declare return object.
+    boost::shared_ptr< RotationalEphemeris > rotationalEphemeris;
+
+    // Check which type of rotation model is to be created.
+    switch( rotationModelSettings->getRotationType( ) )
+    {
+    case simple_rotation_model:
+    {
+        // Check whether settings for simple rotation model are consistent with its type.
+        boost::shared_ptr< SimpleRotationModelSettings > simpleRotationSettings =
+                boost::dynamic_pointer_cast< SimpleRotationModelSettings >( rotationModelSettings );
+        if( simpleRotationSettings == NULL )
+        {
+            throw std::runtime_error(
+                        "Error, expected simple rotation model settings for " + body );
+        }
+        else
+        {
+            // Create and initialize simple rotation model.
+            rotationalEphemeris = boost::make_shared< SimpleRotationalEphemeris >(
+                        simpleRotationSettings->getInitialOrientation( ),
+                        simpleRotationSettings->getRotationRate( ),
+                        simpleRotationSettings->getInitialTime( ),
+                        basic_astrodynamics::JULIAN_DAY_ON_J2000,
+                        simpleRotationSettings->getOriginalFrame( ),
+                        simpleRotationSettings->getTargetFrame( ) );
+        }
+        break;
+    }
+    case spice_rotation_model:
+    {
+        // Create rotational ephemeris directly from Spice.
+        rotationalEphemeris = boost::make_shared< SpiceRotationalEphemeris >(
+                    rotationModelSettings->getOriginalFrame( ),
+                    rotationModelSettings->getTargetFrame( ) );
+        break;
+    }
+    default:
+        throw std::runtime_error(
+                 "Error, did not recognize rotation model settings type " +
+                  boost::lexical_cast< std::string >( rotationModelSettings->getRotationType( ) ) );
+    }
+
+    return rotationalEphemeris;
+}
+
+}
+
+}

=== added file 'Tudat/SimulationSetup/createRotationModel.h'
--- Tudat/SimulationSetup/createRotationModel.h	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/createRotationModel.h	2015-06-16 11:38:27 +0000
@@ -0,0 +1,197 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#ifndef TUDAT_CREATEROTATIONMODEL_H
+#define TUDAT_CREATEROTATIONMODEL_H
+
+#include <Eigen/Core>
+#include <Eigen/Geometry>
+
+#include <boost/shared_ptr.hpp>
+
+#include "Tudat/SimulationSetup/body.h"
+#include "Tudat/Astrodynamics/Ephemerides/rotationalEphemeris.h"
+
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+//! List of rotation models available in simulations
+/*!
+ *  List of rotation models available in simulations. Rotation models not defined by this
+ *  given enum cannot be used for automatic model setup.
+ */
+enum RotationModelType
+{
+    simple_rotation_model,
+    spice_rotation_model
+};
+
+//! Class for providing settings for rotation model.
+/*!
+ *  Class for providing settings for automatic rotation model creation. This class is a
+ *  functional (base) class for settings of rotation models that require no information in
+ *  addition to their type. Rotation model classes defining requiring additional information
+ *  must be created using an object derived from this class.
+ */
+class RotationModelSettings
+{
+public:
+
+    //! Constructor, sets type of rotation model.
+    /*!
+     *  Constructor, sets type of rotation model and base and target frame identifiers.
+     *  Settings for rotation models requiring additional information should be defined in a
+     *  derived class.
+     *  \param rotationType Type of rotation model that is to be created.
+     *  \param originalFrame Base frame of rotation model.
+     *  \param targetFrame Target frame of rotation model.
+     */
+    RotationModelSettings( const RotationModelType rotationType,
+                           const std::string& originalFrame,
+                           const std::string& targetFrame ):
+        rotationType_( rotationType ), originalFrame_( originalFrame ),
+        targetFrame_( targetFrame ){ }
+
+    //! Destructor.
+    virtual ~RotationModelSettings( ){ }
+
+    //! Function to return the type of rotation model that is to be created.
+    /*!
+     *  Function to return the type of rotation model that is to be created.
+     *  \return Type of rotation model that is to be created.
+     */
+    RotationModelType getRotationType( ){ return rotationType_; }
+
+    //! Function to return the base frame of rotation model.
+    /*!
+     *  Function to return the base frame of rotation model.
+     *  \return Base frame of rotation model.
+     */
+    std::string getOriginalFrame( ){ return originalFrame_; }
+
+    //! Function to return the target frame of rotation model.
+    /*!
+     *  Function to return the target frame of rotation model.
+     *  \return Target frame of rotation model.
+     */
+    std::string getTargetFrame( ){ return targetFrame_; }
+
+protected:
+
+    //! Type of rotation model that is to be created.
+    RotationModelType rotationType_;
+
+    //! Target frame of rotation model.
+    std::string originalFrame_;
+
+    //! Base frame of rotation model.
+    std::string targetFrame_;
+
+};
+
+//! RotationModelSettings derived class for defining settings of a simple rotational ephemeris.
+class SimpleRotationModelSettings: public RotationModelSettings
+{
+public:
+    //! Constructor,
+    /*!
+     *  Constructor, sets simple rotational ephemeris properties.
+     *  \param originalFrame Base frame of rotation model.
+     *  \param targetFrame Target frame of rotation model.
+     *  \param initialOrientation Rotation from base to target frame at initialTime.
+     *  \param initialTime Time at which initialOrientation represents the instantaneous rotation.
+     *  \param rotationRate Rotation rate of body about its local z-axis.
+     */
+    SimpleRotationModelSettings( const std::string& originalFrame,
+                                 const std::string& targetFrame,
+                                 const Eigen::Quaterniond& initialOrientation,
+                                 const double initialTime,
+                                 const double rotationRate ):
+        RotationModelSettings( simple_rotation_model, originalFrame, targetFrame ),
+        initialOrientation_( initialOrientation ),
+        initialTime_( initialTime ), rotationRate_( rotationRate ){ }
+
+    //! Function to return rotation from base to target frame at initialTime.
+    /*!
+     *  Function to return rotation from base to target frame at initialTime.
+     *  \return Rotation from base to target frame at initialTime.
+     */
+    Eigen::Quaterniond getInitialOrientation( ){ return initialOrientation_; }    
+
+    //! Function to return time at which initialOrientation represents the instantaneous rotation.
+    /*!
+     *  Function to return time at which initialOrientation represents the instantaneous rotation.
+     *  \return Time at which initialOrientation represents the instantaneous rotation.
+     */
+    double getInitialTime( ){ return initialTime_; }
+
+    //! Function to return rotation rate of body about its local z-axis.
+    /*!
+     *  Function to return rotation rate of body about its local z-axis.
+     *  \return Rotation rate of body about its local z-axis.
+     */
+    double getRotationRate( ){ return rotationRate_; }
+
+private:
+
+    //!  Rotation from base to target frame at initialTime.
+    Eigen::Quaterniond initialOrientation_;
+
+    //! Time at which initialOrientation represents the instantaneous rotation.
+    double initialTime_;
+
+    //! Rotation rate of body about its local z-axis.
+    double rotationRate_;
+};
+
+//! Function to create a rotation model.
+/*!
+ *  Function to create a rotation model based on model-specific settings for the rotation.
+ *  \param rotationModelSettings Settings for the rotation model that is to be created, defined
+ *  a pointer to an object of class (derived from) RotationSettings.
+ *  \param body Name of the body for which the rotation model is to be created.
+ *  \return Rotation model created according to settings in rotationModelSettings.
+ */
+boost::shared_ptr< ephemerides::RotationalEphemeris > createRotationModel(
+        const boost::shared_ptr< RotationModelSettings > rotationModelSettings,
+        const std::string& body );
+}
+
+}
+
+#endif // TUDAT_CREATEROTATIONMODEL_H

=== added file 'Tudat/SimulationSetup/defaultBodies.cpp'
--- Tudat/SimulationSetup/defaultBodies.cpp	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/defaultBodies.cpp	2015-06-16 11:38:27 +0000
@@ -0,0 +1,138 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#include "Tudat/InputOutput/basicInputOutput.h"
+#include "Tudat/SimulationSetup/defaultBodies.h"
+
+namespace tudat
+{
+namespace simulation_setup
+{
+
+//! Function to create default settings for a body's atmosphere model.
+boost::shared_ptr< AtmosphereSettings > getDefaultAtmosphereModelSettings(
+        const std::string& bodyName,
+        const double initialTime,
+        const double finalTime )
+{
+
+    boost::shared_ptr< AtmosphereSettings > atmosphereSettings;
+
+    // A default atmosphere is only implemented for Earth.
+    if( bodyName == "Earth" )
+    {
+        atmosphereSettings = boost::make_shared< TabulatedAtmosphereSettings >(
+                    input_output::getTudatRootPath( ) + "/External/AtmosphereTables/" +
+                    "USSA1976Until100kmPer100mUntil1000kmPer1000m.dat" );
+    }
+
+
+    return atmosphereSettings;
+}
+
+//! Function to create default settings for a body's ephemeris.
+boost::shared_ptr< EphemerisSettings > getDefaultEphemerisSettings(
+        const std::string& bodyName,
+        const double initialTime,
+        const double finalTime )
+{
+    // Create settings for an interpolated Spice ephemeris.
+    return boost::make_shared< InterpolatedSpiceEphemerisSettings >(
+                initialTime, finalTime, 300.0, "SSB", "ECLIPJ2000" );
+}
+
+//! Function to create default settings for a body's gravity field model.
+boost::shared_ptr< GravityFieldSettings > getDefaultGravityFieldSettings(
+        const std::string& bodyName,
+        const double initialTime,
+        const double finalTime )
+{
+    // Create settings for a point mass gravity with data from Spice
+    return boost::make_shared< GravityFieldSettings >( central_spice );
+}
+
+//! Function to create default settings from which to create a single body object.
+boost::shared_ptr< RotationModelSettings > getDefaultRotationModelSettings(
+        const std::string& bodyName,
+        const double initialTime,
+        const double finalTime )
+{
+    // Create settings for a rotation model taken directly from Spice.
+    return boost::make_shared< RotationModelSettings >(
+                spice_rotation_model, "ECLIPJ2000", "IAU_" + bodyName );
+}
+
+//! Function to create default settings for a body's rotation model.
+boost::shared_ptr< BodySettings > getDefaultSingleBodySettings(
+        const std::string& body,
+        const double initialTime,
+        const double finalTime )
+{
+    boost::shared_ptr< BodySettings > singleBodySettings = boost::make_shared< BodySettings >( );
+
+    // Get default settings for each of the environment models in the body.
+    singleBodySettings->atmosphereSettings = getDefaultAtmosphereModelSettings(
+                body, initialTime, finalTime );
+    singleBodySettings->rotationModelSettings = getDefaultRotationModelSettings(
+                body, initialTime, finalTime );
+    singleBodySettings->ephemerisSettings = getDefaultEphemerisSettings(
+                body, initialTime, finalTime );
+    singleBodySettings->gravityFieldSettings = getDefaultGravityFieldSettings(
+                body, initialTime, finalTime );
+
+    return singleBodySettings;
+}
+
+
+//! Function to create default settings from which to create a set of body objects.
+std::map< std::string, boost::shared_ptr< BodySettings > > getDefaultBodySettings(
+        const std::vector< std::string >& bodies,
+        const double initialTime,
+        const double finalTime )
+{
+    std::map< std::string, boost::shared_ptr< BodySettings > > settingsMap;
+
+    // Iterative over all bodies and get default settings.
+    for( unsigned int i = 0; i < bodies.size( ); i++ )
+    {
+        settingsMap[ bodies.at( i ) ] = getDefaultSingleBodySettings(
+                    bodies.at( i ), initialTime, finalTime );
+
+    }
+    return settingsMap;
+}
+
+}
+
+}

=== added file 'Tudat/SimulationSetup/defaultBodies.h'
--- Tudat/SimulationSetup/defaultBodies.h	1970-01-01 00:00:00 +0000
+++ Tudat/SimulationSetup/defaultBodies.h	2015-06-16 11:38:27 +0000
@@ -0,0 +1,147 @@
+/*    Copyright (c) 2010-2015, Delft University of Technology
+ *    All rights reserved.
+ *
+ *    Redistribution and use in source and binary forms, with or without modification, are
+ *    permitted provided that the following conditions are met:
+ *      - Redistributions of source code must retain the above copyright notice, this list of
+ *        conditions and the following disclaimer.
+ *      - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *        conditions and the following disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *      - Neither the name of the Delft University of Technology nor the names of its contributors
+ *        may be used to endorse or promote products derived from this software without specific
+ *        prior written permission.
+ *
+ *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ *    OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ *    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ *    GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ *    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ *    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ *    OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *    Changelog
+ *      YYMMDD    Author            Comment
+ *      150501    D. Dirkx          Ported from personal code
+ *
+ *    References
+ *
+ *    Notes
+ *
+ */
+
+#ifndef TUDAT_DEFAULTBODIES_H
+#define TUDAT_DEFAULTBODIES_H
+
+#include "Tudat/SimulationSetup/createBodies.h"
+
+namespace tudat
+{
+
+namespace simulation_setup
+{
+
+//! Function to create default settings for a body's atmosphere model.
+/*!
+ *  Function to create default settings for a body's atmosphere model. Currently set to no
+ *  atmosphere, except for Earth, for which a tabulated version of the 1976 Standard Atmosphere is
+ *  set.
+ *  \param bodyName Name of body for which default atmosphere settings are to be retrieved.
+ *  \param initialTime Start time at which environment models in body are to be created
+ *  (not currently used by this function, but included for consistency).
+ *  \param finalTime End time up to which environment models in body are to be created
+ *  (not currently used by this function, but included for consistency).
+ */
+boost::shared_ptr< AtmosphereSettings > getDefaultAtmosphereModelSettings(
+        const std::string& bodyName,
+        const double initialTime,
+        const double finalTime );
+
+//! Function to create default settings for a body's ephemeris.
+/*!
+ *  Function to create default settings for a body's ephemeris. Currently set to a
+ *  creating a 6th order Lagrange interpolator from Spice, with a 300 s time step.
+ *  \param bodyName Name of body for which default ephemeris settings are to be retrieved.
+ *  \param initialTime Start time at which ephemeris is to be created
+ *  \param finalTime End time up to which ephemeris is to be created
+ */
+boost::shared_ptr< EphemerisSettings > getDefaultEphemerisSettings(
+        const std::string& bodyName,
+        const double initialTime,
+        const double finalTime );
+
+//! Function to create default settings for a body's gravity field model.
+/*!
+ *  Function to create default settings for a body's gravity field model. Currently set to
+ *  a point mass gravty field, with the gravitational parameter obtained from Spice.
+ *  \param bodyName Name of body for which default gravity field settings are to be retrieved.
+ *  \param initialTime Start time at which environment models in body are to be created
+ *  (not currently used by this function, but included for consistency).
+ *  \param finalTime End time up to which environment models in body are to be created
+ *  (not currently used by this function, but included for consistency).
+ */
+boost::shared_ptr< GravityFieldSettings > getDefaultGravityFieldSettings(
+        const std::string& bodyName,
+        const double initialTime,
+        const double finalTime );
+
+//! Function to create default settings for a body's rotation model.
+/*!
+ *  Function to create default settings for a body's rotation model. Currently set to
+ *  a rotation model taken directly from Spice
+ *  \param bodyName Name of body for which default rotation model settings are to be retrieved.
+ *  \param initialTime Start time at which environment models in body are to be created
+ *  (not currently used by this function, but included for consistency).
+ *  \param finalTime End time up to which environment models in body are to be created
+ *  (not currently used by this function, but included for consistency).
+ */
+boost::shared_ptr< RotationModelSettings > getDefaultRotationModelSettings(
+        const std::string& bodyName,
+        const double initialTime,
+        const double finalTime );
+
+//! Function to create default settings from which to create a single body object.
+/*!
+ *  Function to create default settings from which to create a single body object using
+ *  the code in createBodies.h/.cpp. This function is included to streamline and simplify the
+ *  creation of typical celestial bodies. The default settings for the various
+ *  environment models of the body are defined in the various functions defined in this file.
+ *  \param bodyName Name of body for which default settings are to be retrieved.
+ *  \param initialTime Start time at which environment models in body are to be created
+ *  (included as some environment models require e.g., interpolators to be created over
+ *  a certain time period).
+ *  \param finalTime End time up to which environment models in body are to be created
+ *  (included as some environment models require e.g., interpolators to be created over
+ *  a certain time period).
+ */
+boost::shared_ptr< RotationModelSettings > getDefaultRotationModelSettings(
+        const std::string& bodyName,
+        const double initialTime,
+        const double finalTime );
+
+//! Function to create default settings from which to create a set of body objects.
+/*!
+ *  Function to create default settings from which to create a set of body objects using
+ *  the code in createBodies.h/.cpp. This function is included to streamline and simplify the
+ *  creation of typical celestial bodies. The default settings for the various
+ *  environment models of the body are defined in the various functions defined in this file.
+ *  \param bodies List of bodies for which default settings are to be retrieved.
+ *  \param initialTime Start time at which environment models in body are to be created
+ *  (included as some environment models require e.g., interpolators to be created over
+ *  a certain time period).
+ *  \param finalTime End time up to which environment models in body are to be created
+ *  (included as some environment models require e.g., interpolators to be created over
+ *  a certain time period).
+ */
+std::map< std::string, boost::shared_ptr< BodySettings > > getDefaultBodySettings(
+        const std::vector< std::string >& bodies,
+        const double initialTime,
+        const double finalTime );
+
+}
+
+}
+
+#endif // TUDAT_DEFAULTBODIES_H

