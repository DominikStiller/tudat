=== modified file 'Tudat/Astrodynamics/Gravitation/CMakeLists.txt'
--- Tudat/Astrodynamics/Gravitation/CMakeLists.txt	2015-04-17 14:14:12 +0000
+++ Tudat/Astrodynamics/Gravitation/CMakeLists.txt	2015-11-09 08:31:00 +0000
@@ -39,6 +39,8 @@
 
 # Set the source files.
 set(GRAVITATION_SOURCES
+  "${SRCROOT}${GRAVITATIONDIR}/basicSolidBodyTideGravityFieldVariations.cpp"
+  "${SRCROOT}${GRAVITATIONDIR}/gravityFieldVariations.cpp"
   "${SRCROOT}${GRAVITATIONDIR}/centralGravityModel.cpp"
   "${SRCROOT}${GRAVITATIONDIR}/centralJ2GravityModel.cpp"
   "${SRCROOT}${GRAVITATIONDIR}/centralJ2J3GravityModel.cpp"
@@ -50,13 +52,17 @@
   "${SRCROOT}${GRAVITATIONDIR}/sphericalHarmonicsGravityField.cpp"
   "${SRCROOT}${GRAVITATIONDIR}/stateDerivativeCircularRestrictedThreeBodyProblem.cpp"
   "${SRCROOT}${GRAVITATIONDIR}/thirdBodyPerturbation.cpp"
+  "${SRCROOT}${GRAVITATIONDIR}/timeDependentSphericalHarmonicsGravityField.cpp"
   "${SRCROOT}${GRAVITATIONDIR}/unitConversionsCircularRestrictedThreeBodyProblem.cpp"
   "${SRCROOT}${GRAVITATIONDIR}/UnitTests/planetTestData.cpp"
   "${SRCROOT}${GRAVITATIONDIR}/unitConversionsCircularRestrictedThreeBodyProblem.cpp"
+  "${SRCROOT}${GRAVITATIONDIR}/tabulatedGravityFieldVariations.cpp"
 )
 
 # Set the header files.
 set(GRAVITATION_HEADERS
+  "${SRCROOT}${GRAVITATIONDIR}/basicSolidBodyTideGravityFieldVariations.h"
+  "${SRCROOT}${GRAVITATIONDIR}/gravityFieldVariations.h"
   "${SRCROOT}${GRAVITATIONDIR}/centralGravityModel.h"
   "${SRCROOT}${GRAVITATIONDIR}/centralJ2GravityModel.h"
   "${SRCROOT}${GRAVITATIONDIR}/centralJ2J3GravityModel.h"
@@ -69,8 +75,10 @@
   "${SRCROOT}${GRAVITATIONDIR}/sphericalHarmonicsGravityField.h"
   "${SRCROOT}${GRAVITATIONDIR}/stateDerivativeCircularRestrictedThreeBodyProblem.h"
   "${SRCROOT}${GRAVITATIONDIR}/thirdBodyPerturbation.h"
+  "${SRCROOT}${GRAVITATIONDIR}/timeDependentSphericalHarmonicsGravityField.h"
   "${SRCROOT}${GRAVITATIONDIR}/unitConversionsCircularRestrictedThreeBodyProblem.h"
   "${SRCROOT}${GRAVITATIONDIR}/UnitTests/planetTestData.h"
+  "${SRCROOT}${GRAVITATIONDIR}/tabulatedGravityFieldVariations.h"
 )
 
 # Add static libraries.

=== added file 'Tudat/Astrodynamics/Gravitation/basicSolidBodyTideGravityFieldVariations.cpp'
--- Tudat/Astrodynamics/Gravitation/basicSolidBodyTideGravityFieldVariations.cpp	1970-01-01 00:00:00 +0000
+++ Tudat/Astrodynamics/Gravitation/basicSolidBodyTideGravityFieldVariations.cpp	2015-11-09 08:31:00 +0000
@@ -0,0 +1,127 @@
+
+#include "Tudat/Astrodynamics/Gravitation/basicSolidBodyTideGravityFieldVariations.h"
+#include "Tudat/Mathematics/BasicMathematics/mathematicalConstants.h"
+#include "Tudat/Mathematics/BasicMathematics/legendrePolynomials.h"
+
+namespace tudat
+{
+
+namespace gravitation
+{
+
+//! Function to calculate solid body tide gravity field variation due to single body at single
+//! degree and order.
+std::complex< double > calculateSolidBodyTideSingleCoefficientSetCorrectionFromAmplitude(
+        const std::complex< double > loveNumber, const double massRatio,
+        const double radiusRatioPowerN,
+        const double amplitude, const std::complex< double > tideArgument,
+        const int n, const int m )
+{
+    // Calculate and return corrections.
+    return loveNumber / ( 2.0 * static_cast< double >( n ) + 1.0 ) *
+            massRatio * radiusRatioPowerN *
+            amplitude * basic_mathematics::calculateLegendreGeodesyNormalizationFactor( n, m ) *
+            std::exp( -tideArgument );
+}
+
+//! Sets current properties (mass state) of body involved in tidal deformation.
+void BasicSolidBodyTideGravityFieldVariations::setBodyGeometryParameters(
+        const int bodyIndex, const double evaluationTime )
+{
+    // Calculate current state and orientation of deformed body.
+    if( bodyIndex == 0 )
+    {
+        deformedBodyPosition = deformedBodyStateFunction_( evaluationTime ).segment( 0, 3 );
+        toDeformedBodyFrameRotation = deformedBodyOrientationFunction_( evaluationTime );
+    }
+
+    // Calculate current state of body causing deformation.
+    Eigen::Vector3d relativeDeformingBodyPosition = toDeformedBodyFrameRotation * (
+                deformingBodyStateFunctions_[ bodyIndex ]( evaluationTime ).segment( 0, 3 ) -
+            deformedBodyPosition );
+    Eigen::Vector3d  relativeDeformingBodySphericalPosition =coordinate_conversions::
+            convertCartesianToSpherical( relativeDeformingBodyPosition );
+
+    // Set geometric parameters of body causing deformation.
+    radiusRatio = deformedBodyReferenceRadius_ / relativeDeformingBodySphericalPosition.x( );
+    iLongitude = mathematical_constants::COMPLEX_I * relativeDeformingBodySphericalPosition.z( );
+    sineOfLatitude = std::sin( mathematical_constants::PI / 2.0 -
+                               relativeDeformingBodySphericalPosition.y( ) );
+}
+
+//! Function for calculating spherical harmonic coefficient corrections.
+std::pair< Eigen::MatrixXd, Eigen::MatrixXd > BasicSolidBodyTideGravityFieldVariations::
+calculateBasicSphericalHarmonicsCorrections(
+        const double time )
+{
+    // Initialize corrections to zero.
+    Eigen::MatrixXd cTermCorrections = Eigen::MatrixXd::Zero( numberOfDegrees_, numberOfOrders_ );
+    Eigen::MatrixXd sTermCorrections = Eigen::MatrixXd::Zero( numberOfDegrees_, numberOfOrders_ );
+
+
+    // Iterate over all bodies causing deformation and calculate and add associated corrections
+    for( unsigned int i = 0; i < deformingBodyStateFunctions_.size( ); i++ )
+    {
+        setBodyGeometryParameters( i, time );
+
+        // Calculate properties of currently considered body
+        massRatio = deformingBodyMasses_[ i ]( ) / deformedBodyMass_( );
+
+        // Calculate all correction functions.
+        for( unsigned int j = 0; j < correctionFunctions.size( ); j++ )
+        {
+            correctionFunctions[ j ]( cTermCorrections, sTermCorrections );
+        }
+    }
+
+    return std::make_pair( cTermCorrections, sTermCorrections );
+}
+
+//! Calculates basic solid body gravity field corrections due to single body.
+void BasicSolidBodyTideGravityFieldVariations::addBasicSolidBodyTideCorrections(
+        Eigen::MatrixXd& cTermCorrections,
+        Eigen::MatrixXd& sTermCorrections )
+{
+    // Initialize power of radiusRatio^(N+1) (calculation starts at N=2)
+    radiusRatioPower = radiusRatio * radiusRatio * radiusRatio;
+
+    currentCosineCorrections_.setZero( );
+    currentSineCorrections_.setZero( );
+
+    // Iterate over all love
+    std::complex< double > stokesCoefficientCorrection( 0.0, 0.0 );
+
+    for( unsigned int n = 2; n < loveNumbers_.size( ) + 2; n++ )
+    {
+        for( unsigned int m = 0; m <= n; m++ )
+        {
+            updateTidalAmplitudeAndArgument( n, m );
+
+            // Calculate and add coefficients.
+            stokesCoefficientCorrection =
+                    calculateSolidBodyTideSingleCoefficientSetCorrectionFromAmplitude(
+                        loveNumbers_[ n - 2 ][ m ], massRatio, radiusRatioPower, tideAmplitude,
+                    tideArgument, n, m );
+
+
+            currentCosineCorrections_( n - 2, m ) += stokesCoefficientCorrection.real( );
+            if( m != 0 )
+            {
+                currentSineCorrections_( n - 2, m ) -= stokesCoefficientCorrection.imag( );
+            }
+        }
+
+        // Increment radius ratio power.
+        radiusRatioPower *= radiusRatio;
+    }
+
+    cTermCorrections.block( 0, 0, maximumDegree_ + 1, maximumOrder_ + 1 ) +=
+            currentCosineCorrections_;
+    sTermCorrections.block( 0, 0, maximumDegree_ + 1, maximumOrder_ + 1 ) +=
+            currentSineCorrections_;
+
+}
+
+}
+
+}

=== added file 'Tudat/Astrodynamics/Gravitation/basicSolidBodyTideGravityFieldVariations.h'
--- Tudat/Astrodynamics/Gravitation/basicSolidBodyTideGravityFieldVariations.h	1970-01-01 00:00:00 +0000
+++ Tudat/Astrodynamics/Gravitation/basicSolidBodyTideGravityFieldVariations.h	2015-11-09 08:31:00 +0000
@@ -0,0 +1,474 @@
+#ifndef BASICSOLIDBODYTIDEGRAVITYFIELDVARIATIONS_H
+#define BASICSOLIDBODYTIDEGRAVITYFIELDVARIATIONS_H
+
+#include <boost/function.hpp>
+#include <boost/multi_array.hpp>
+#include <boost/bind.hpp>
+
+#include <Eigen/Core>
+#include <Eigen/Geometry>
+
+#include <vector>
+#include <complex>
+#include <map>
+
+#include "Tudat/Mathematics/BasicMathematics/coordinateConversions.h"
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+#include "Tudat/Mathematics/BasicMathematics/legendrePolynomials.h"
+#include "Tudat/Astrodynamics/Gravitation/gravityFieldVariations.h"
+
+namespace tudat
+{
+
+namespace gravitation
+{
+
+//! Function to calculate solid body tide gravity field variations due to single body at single
+//! degree and order.
+/*!
+ *  Function to calculate solid body tide gravity field variations due to single body at single
+ *  degree and order, (frequency-independent part), after (Petit et al. 2010, eq. 6.6), using
+ *  complex tidal love numbers.
+ *  \param loveNumber Complex Love number for given degree and order.
+ *  \param massRatio Ratio of masses of body causing deformation to body being deformed.
+ *  \param radiusRatioPowerN Ratio of equatorial radius of body being deformed over distance
+ *  between center of body being deformed to center of body causing deformation to the power (n+1).
+ *  \param amplitude Amplitude of the tide.
+ *  \param tideArgument Argument of the tide.
+ *  \param degree Degree of current coefficients
+ *  \param order Order of current coefficients
+ *  \return Combined variation in cosine (Delta C_{n,m}) and sine (Delta S_{n,m}) coefficients as:
+ * Delta C_{n,m} - i * Delta S_{n,m}
+ */
+std::complex< double > calculateSolidBodyTideSingleCoefficientSetCorrectionFromAmplitude(
+        const std::complex< double > loveNumber, const double massRatio,
+        const double radiusRatioPowerN, const double amplitude,
+        const std::complex< double > tideArgument, const int degree, const int order );
+
+//! Class to calculate first-order solid body tide gravity field variations on a single body raised
+//! by any number of bodies up to any degree and order.
+class BasicSolidBodyTideGravityFieldVariations: public GravityFieldVariations
+{
+public:
+    //! Constructor
+    /*!
+     *  Contructor, sets Love numbers and properties of deformed and tide-raising bodies.
+     *  \param deformedBodyStateFunction Function returning state of body being deformed.
+     *  \param deformedBodyOrientationFunction Function providing rotation from inertial to body
+     *  being deformed-fixed frame
+     *  \param deformingBodyStateFunctions List of state functions of body causing deformations.
+     *  \param deformedBodyReferenceRadius Reference radius (typically equatorial) of body being
+     *  deformed's spherical harmonic gravity field.
+     *  \param deformedBodyMass Function returning mass of body being deformed.
+     *  \param deformingBodyMasses List of functions returning masses of bodies causing deformation.
+     *  \param loveNumbers List of love numbers for each degree and order. First vector level
+     *  denotes degree (index 0 = degree 2), second vector level must be of size
+     *  (loveNumbers.size( ) + 2, i.e. maximum degree == maximum order)
+     */
+    BasicSolidBodyTideGravityFieldVariations(
+            const boost::function< basic_mathematics::Vector6d( const double ) >
+            deformedBodyStateFunction,
+            const boost::function< Eigen::Quaterniond( const double ) >
+            deformedBodyOrientationFunction,
+            const std::vector< boost::function< basic_mathematics::Vector6d( const double ) > >
+            deformingBodyStateFunctions,
+            const double deformedBodyReferenceRadius,
+            const boost::function< double( ) > deformedBodyMass,
+            const std::vector< boost::function< double( ) > > deformingBodyMasses,
+            const std::vector< std::vector< std::complex< double > > > loveNumbers,
+            const std::vector< std::string > deformingBodies ):
+        GravityFieldVariations( 2, 0, 2 + loveNumbers.size( ) - 1, 2 + loveNumbers.size( ) - 1 ),
+        deformedBodyStateFunction_( deformedBodyStateFunction ),
+        deformedBodyOrientationFunction_( deformedBodyOrientationFunction ),
+        deformingBodyStateFunctions_( deformingBodyStateFunctions ),
+        deformedBodyReferenceRadius_( deformedBodyReferenceRadius ),
+        deformedBodyMass_( deformedBodyMass ),
+        deformingBodyMasses_( deformingBodyMasses ),
+        loveNumbers_( loveNumbers ),
+        deformingBodies_( deformingBodies )
+    {
+        // Set basic deformation functon as function to be evaluated when requesting variations.
+        correctionFunctions.push_back(
+                    boost::bind(
+                        &BasicSolidBodyTideGravityFieldVariations::addBasicSolidBodyTideCorrections,
+                        this, _1, _2 ) );
+        currentCosineCorrections_ = Eigen::MatrixXd::Zero( maximumDegree_ + 1, maximumOrder_ + 1 );
+        currentSineCorrections_ = Eigen::MatrixXd::Zero( maximumDegree_ + 1, maximumOrder_ + 1 );
+    }
+
+    //! Destructor
+    /*!
+     *  Destructor
+     */
+    virtual ~BasicSolidBodyTideGravityFieldVariations( ){ }
+
+    //! Function for calculating basic spherical harmonic coefficient corrections.
+    /*!
+     *  Function for calculating basic spherical harmonic coefficient corrections.
+     *  \param time Time at which variations are to be calculated.
+     *  \return Pair of matrices containing variations in (cosine,sine) coefficients.
+     */
+    std::pair< Eigen::MatrixXd, Eigen::MatrixXd > calculateBasicSphericalHarmonicsCorrections(
+            const double time );
+
+    //! Derived function for calculating spherical harmonic coefficient corrections.
+    /*!
+     *  Derived function for calculating spherical harmonic coefficient corrections.
+     *  \param time Time at which variations are to be calculated.
+     *  \return Pair of matrices containing variations in (cosine,sine) coefficients.
+     */
+    virtual std::pair< Eigen::MatrixXd, Eigen::MatrixXd > calculateSphericalHarmonicsCorrections(
+            const double time )
+    {
+        return calculateBasicSphericalHarmonicsCorrections( time );
+    }
+
+    //! Function to retrieve the love numbers at given degree.
+    /*!
+     *  Function to retrieve the love numbers at given degree. Returns a vector containing (complex)
+     *  love numbers at all orders in current degree.
+     *  \param degree Degree from which love numbers are to be retrieved.
+     *  \return Vector of love numbers (i^{th} entry representing i^{th} order in requested degree)
+     *  containing love numbers at current degree.
+     */
+    std::vector< std::complex< double > > getLoveNumbersOfDegree( const int degree )
+    {
+        return loveNumbers_[ degree - 2 ];
+    }
+
+    //! Function to return all love numbers.
+    /*!
+     *  Function to return all love numbers, i.e. at all degrees and orders.
+     *  \return Complete set of available love numbers.
+     */
+    std::vector< std::vector< std::complex< double > > > getLoveNumbers( )
+    {
+        return loveNumbers_;
+    }
+
+    //! Function to reset the love numbers at given degree.
+    /*!
+     *  Function to reset the love numbers at given degree. Input requires a vector containing
+     *  (complex) love numbers at all orders in current degree.
+     *  \param degree Degree from which love numbers are to be retrieved.
+     *  \param Vector of love numbers (i^{th} entry representing i^{th} order in requested degree)
+     *  containing new love numbers at current degree.
+     */
+    void resetLoveNumbersOfDegree( const std::vector< std::complex< double > > loveNumbers,
+                                   const int degree )
+    {
+        if( loveNumbers_.size( ) > static_cast< unsigned int >( degree - 2 ) )
+        {
+            if( loveNumbers.size( ) <= static_cast< unsigned int >( degree ) )
+            {
+                loveNumbers_[ degree - 2 ] = loveNumbers;
+            }
+            else
+            {
+                std::cerr<<"Error, tried to set love numbers at degree "<<degree<<
+                           " in BasicSolidBodyTideGravityFieldVariations with "<<
+                        loveNumbers.size( )<<" orders."<<std::endl;
+            }
+        }
+        else
+        {
+            std::cerr<<"Error, tried to set love numbers at degree "<<degree<<
+                       " in BasicSolidBodyTideGravityFieldVariations: not available "<<std::endl;
+        }
+    }
+
+    //! Function to return reference radius the spherical harmonic gravity field of deformed body.
+    /*!
+     *  Function to return reference radius (typically equatorial)  the spherical harmonic gravity
+     * field of deformed body.
+     *  \return Reference radius body being deformed's spherical harmonic gravity field.
+     */
+    double getDeformedBodyReferenceRadius( )
+    {
+        return deformedBodyReferenceRadius_;
+    }
+
+    //! Function to return the mass function of the deformed body.
+    /*!
+     *  Function to return the mass function of the deformed body.
+     *  \return Mass function of the deformed body.
+     */
+    boost::function< double( ) > getDeformedBodyMassFunction( )
+    {
+        return deformedBodyMass_;
+    }
+
+    //! Function to return list of the mass functions of the bodies causing the deformation.
+    /*!
+     *  Function to return list of the mass functions of the bodies causing the deformation.
+     *  \return List of the mass functions of the bodies causing the deformation.
+     */
+    std::vector< boost::function< double( ) > > getDeformingBodyMasses( )
+    {
+        return deformingBodyMasses_;
+    }
+
+    //! Function to return list of the names of the bodies causing the deformation
+    /*!
+     *  Function to return list of the names of the bodies causing the deformation
+     *  \return List of the names of the bodies causing the deformation
+     */
+    std::vector< std::string > getDeformingBodies( )
+    {
+        return deformingBodies_;
+    }
+
+    //! Function to return the state function of the deformed body.
+    /*!
+     *  Function to return the state function of the deformed body.
+     *  \return State function of the deformed body.
+     */
+    boost::function< basic_mathematics::Vector6d( const double ) > getDeformedBodyStateFunction( )
+    {
+        return deformedBodyStateFunction_;
+    }
+
+    //! Function to return the orientation function (rotation to body-fixed frame) of the deformed
+    //! body.
+    /*!
+     *  Function to return the orientation function (rotation to body-fixed frame) of the deformed
+     *  body.
+     *  \return Orientation function (rotation to body-fixed frame) of the deformed body.
+     */
+    boost::function< Eigen::Quaterniond( const double ) > getDeformedBodyOrientationFunction( )
+    {
+        return deformedBodyOrientationFunction_;
+    }
+
+    //! Function to return list of the state functions of the bodies causing the deformation.
+    /*!
+     *  Function to return list of the state functions of the bodies causing the deformation.
+     *  \return List of the state functions of the bodies causing the deformation.
+     */
+    std::vector< boost::function< basic_mathematics::Vector6d( const double ) > >
+    getDeformingBodyStateFunctions( )
+    {
+        return deformingBodyStateFunctions_;
+    }
+
+    //! Get a string with the concatenation of all the bodies causing the deformation.
+    /*!
+     *  Get a string with the concatenation of all the bodies causing the deformation.
+     *  \return A string with the concatenation of all the bodies causing the deformation.
+     */
+    std::string getConcatenatedDeformingBodies( )
+    {
+        // Initialize string
+        std::string id = "";
+
+        // Iterate over all bodies and add name to concatenates string
+        for( unsigned int i = 0; i < deformingBodies_.size( ); i++ )
+        {
+            id += deformingBodies_[ i ];
+            if( i != deformingBodies_.size( ) - 1 )
+            {
+                 id += "_";
+            }
+        }
+
+        return id;
+    }
+
+    //! Function to return the current corrections to the cosine coefficients.
+    /*!
+     * Function to return the current corrections to the cosine coefficients (as calculated by
+     * current instance of this class).
+     * \return Current corrections to the cosine coefficients.
+     */
+    Eigen::MatrixXd getCurrentCosineCorrections( )
+    {
+        return currentCosineCorrections_;
+    }
+
+    //! Function to return the current corrections to the sine coefficients.
+    /*!
+     * Function to return the current corrections to the sine coefficients (as calculated by
+     * current instance of this class).
+     * \return Current corrections to the sine coefficients.
+     */
+    Eigen::MatrixXd getCurrentSineCorrections( )
+    {
+        return currentSineCorrections_;
+    }
+
+protected:
+
+    //! List of functions to call for calculating spherical harmonic corrections.
+    /*!
+     *  List of functions to call for calculating spherical harmonic corrections. Each function
+     *  modifies MatrixXd arguments (cosine, sine) as they are passed by reference, and adds
+     *  the required (tidal) correction.
+     */
+    std::vector< boost::function< void( Eigen::MatrixXd&, Eigen::MatrixXd& ) > >
+    correctionFunctions;
+
+    //! Calculates basic solid body gravity field corrections due to single body.
+    /*!
+     *  Calculates basic solid body gravity field corrections for all degrees and orders set.
+     *  The arguments are modified as they are passed by reference, through which the corrections
+     *  are returned.
+     *  Class variables denoting properties of currently considered body must have been set before
+     *  this function is called.
+     *  \param cTermCorrections Corrections to cosine terms
+     *  (passed by reference; correction added to input value).
+     *  \param sTermCorrections Corrections to sine terms.
+     *
+     *  (passed by reference; correction added to input value).
+     */
+    virtual void addBasicSolidBodyTideCorrections(
+            Eigen::MatrixXd& cTermCorrections, Eigen::MatrixXd& sTermCorrections );
+
+    //! Sets current properties (mass state) of body causing tidal deformation.
+    /*!
+     *  Sets current properties (mass state) of body causing tidal deformation.
+     * \param bodyIndex Index of body causing deformation for which data is to be retrieved.
+     * Deformed body is also updated to bodyIndex = 0.
+     * \param evaluationTime Time at which properties are to be evaluated.
+     */
+    virtual void setBodyGeometryParameters(
+            const int bodyIndex, const double evaluationTime);
+
+    //! Calculate tidal amplitude and argument at current degree and order.
+    /*!
+     * Calculate tidal amplitude and argument at current degree and order.
+     * \param degree Degree of tide.
+     * \param order Order of tide.
+     */
+    virtual void updateTidalAmplitudeAndArgument(
+            const int degree, const int order )
+    {
+        tideAmplitude = basic_mathematics::computeLegendrePolynomialExplicit(
+                    degree, order, sineOfLatitude );
+        tideArgument = static_cast< double >( order ) * iLongitude;
+    }
+
+
+    //! Function returning state of body being deformed.
+    /*!
+     *  Function returning state of body being deformed.
+     */
+    boost::function< basic_mathematics::Vector6d( const double ) > deformedBodyStateFunction_;
+
+    //! Function providing rotation from inertial to body being deformed-fixed frame
+    /*!
+     *  Function providing rotation from inertial to body being deformed-fixed frame.
+     */
+    boost::function< Eigen::Quaterniond( const double ) > deformedBodyOrientationFunction_;
+
+    //! List of state functions of body causing deformations.
+    /*!
+     *  List of state functions of body causing deformations.
+     */
+    std::vector< boost::function< basic_mathematics::Vector6d( const double ) > >
+    deformingBodyStateFunctions_;
+
+    //! Reference radius (typically equatorial) of body being deformed's spherical harmonic
+    //! gravity field.
+    /*!
+     *  Reference radius (typically equatorial) of body being deformed's spherical harmonic gravity
+     *  field.
+     */
+    double deformedBodyReferenceRadius_;
+
+    //! Function returning mass of body being deformed.
+    /*!
+     *  Function returning mass of body being deformed.
+     */
+    boost::function< double( ) > deformedBodyMass_;
+
+    //! List of functions returning masses of bodies causing deformation.
+    /*!
+     *  List of functions returning masses of bodies causing deformation.
+     */
+    std::vector< boost::function< double( ) > > deformingBodyMasses_;
+
+    //! List of love numbers for each degree and order
+    /*!
+     *  List of love numbers for each degree and order. First vector level denotes degree
+     *  (index 0 = degree 2), second vector level must be of size (loveNumbers.size( ) + 2, i.e.
+     *  maximum degree == maximum order.
+     */
+    std::vector< std::vector< std::complex< double > > > loveNumbers_;
+
+
+    //! List of names of bodies causing deformation.
+    /*!
+     *  List of names of bodies causing deformation.
+     */
+    std::vector< std::string > deformingBodies_;
+
+
+    //! Ratio of masses in current calculation step
+    /*!
+     *  Ratio of masses of body causing deformation to body being deformed in current calculation
+     *  step.
+     */
+    double massRatio;
+
+    //! Ratio of radii in current calculation step.
+    /*!
+     *  Ratio of equatorial radius of body being deformed over distance between center of body
+     *  being deformed to center of body causing deformation in current calculation step
+     */
+    double radiusRatio;
+
+    //! Ratio of radii in current calculation step to the power (degree+1).
+    /*!
+     *  Ratio of equatorial radius of body being deformed over distance between center of body
+     *  being deformed to center of body causing deformation, to the power (degree+1), in current
+     *  calculation step
+     */
+    double radiusRatioPower;
+
+    //! Sine of latitude of currently considered body in current calculation step
+    /*!
+     *  Sine of latitude of body causing deformation in frame fixed to body being deformed in
+     *  current calculation step.
+     */
+    double sineOfLatitude;
+
+    //! Longitude of currently considered body times i in current calculation step
+    /*!
+     *  i (sqrt(-1)) times longitude of body causing deformation in frame fixed to body being
+     *  deformed in current calculation step.
+     */
+    std::complex< double > iLongitude;
+
+    //! Current argument of the tide.
+    /*!
+     *  Current argument of the tide, to be used as input to
+     *  calculateSolidBodyTideSingleCoefficientSetCorrectionFromAmplitude, modulates the tide as
+     *  exp( -tideArgument).
+     */
+    std::complex< double > tideArgument;
+
+    //! Current amplitude of the tide.
+    /*!
+     *  Current amplitude of the tide, to be used as input to
+     *  calculateSolidBodyTideSingleCoefficientSetCorrectionFromAmplitude.
+     */
+    double tideAmplitude;
+
+    //! Current position of body being deformed.
+    Eigen::Vector3d deformedBodyPosition;
+
+    //! Current rotation to frame fixed to deformed body.
+    Eigen::Quaterniond toDeformedBodyFrameRotation;
+
+    //! Tidal corrections to cosine coefficients at current calculation step.
+    Eigen::MatrixXd currentCosineCorrections_;
+
+    //! Tidal corrections to sine coefficients at current calculation step.
+    Eigen::MatrixXd currentSineCorrections_;
+
+};
+
+}
+
+}
+#endif // BASICSOLIDBODYTIDEGRAVITYFIELDVARIATIONS_H

=== added file 'Tudat/Astrodynamics/Gravitation/gravityFieldVariations.cpp'
--- Tudat/Astrodynamics/Gravitation/gravityFieldVariations.cpp	1970-01-01 00:00:00 +0000
+++ Tudat/Astrodynamics/Gravitation/gravityFieldVariations.cpp	2015-11-09 08:31:00 +0000
@@ -0,0 +1,246 @@
+#include "Tudat/Astrodynamics/Gravitation/gravityFieldVariations.h"
+#include "Tudat/Astrodynamics/Gravitation/basicSolidBodyTideGravityFieldVariations.h"
+#include "Tudat/Mathematics/Interpolators/linearInterpolator.h"
+
+namespace tudat
+{
+
+namespace gravitation
+{
+
+//! Function to add sine and cosine corrections at given time to coefficient matrices.
+void PairInterpolationInterface::getCosineSinePair(
+        const double time, Eigen::MatrixXd& sineCoefficients, Eigen::MatrixXd& cosineCoefficients )
+{
+    // Interpolate corrections
+    Eigen::MatrixXd cosineSinePair = cosineSineInterpolator_->interpolate( time );
+
+    // Split combined interpolated cosine/sine correction block and add to existing values
+    cosineCoefficients.block( startDegree_, startOrder_, numberOfDegrees_, numberOfOrders_ ) +=
+            cosineSinePair.block( 0, 0, cosineSinePair.rows( ), cosineSinePair.cols( ) / 2 );
+    sineCoefficients.block( startDegree_, startOrder_, numberOfDegrees_, numberOfOrders_ ) +=
+            cosineSinePair.block( 0, cosineSinePair.cols( ) / 2,
+                                  cosineSinePair.rows( ), cosineSinePair.cols( ) / 2 );
+}
+
+
+//! Function to add sine and cosine corrections at given time to coefficient matrices.
+void GravityFieldVariations::addSphericalHarmonicsCorrections(
+        const double time, Eigen::MatrixXd& sineCoefficients, Eigen::MatrixXd& cosineCoefficients )
+{
+    // Calculate corrections.
+    std::pair< Eigen::MatrixXd, Eigen::MatrixXd > correctionPair =
+            calculateSphericalHarmonicsCorrections( time );
+
+    // Add corrections to existing values
+    sineCoefficients.block( minimumDegree_, minimumOrder_, numberOfDegrees_, numberOfOrders_ )
+            += correctionPair.second;
+    cosineCoefficients.block( minimumDegree_, minimumOrder_, numberOfDegrees_, numberOfOrders_ )
+            += correctionPair.first;
+}
+
+//! Function to retrieve a variation object of given type (and name if necessary).
+std::pair< bool, boost::shared_ptr< gravitation::GravityFieldVariations > >
+GravityFieldVariationsSet::getGravityFieldVariation(
+        const BodyDeformationTypes deformationType,
+        const std::string identifier )
+{
+    // Declare return pointer.
+    boost::shared_ptr< gravitation::GravityFieldVariations > gravityFieldVariation;
+
+    // Check how many variation objects of request type are in list.
+    int numberOfEntries =
+            std::count( variationType_.begin( ), variationType_.end( ), deformationType );
+
+    // Check if number of variation objects of requested type is not zero.
+    bool isEntryFound = 1;
+    if( numberOfEntries == 0 )
+    {
+        isEntryFound = 0;
+    }
+    // If number of objects of requested type is 1, no further search is required
+    else if( numberOfEntries == 1 )
+    {
+        // Retrieve index of object and set as return pointer.
+        std::vector< BodyDeformationTypes >::iterator findIterator =
+                std::find( variationType_.begin( ), variationType_.end( ), deformationType );
+        int vectorIndex = std::distance( variationType_.begin( ), findIterator );
+        gravityFieldVariation = variationObjects_[ vectorIndex ];
+    }
+    // If number of objects of requested type is > 1, search for object with required identifier
+    else
+    {
+        bool isCorrectIdentifierFound = 0;
+
+        // Loop over all entries
+        for( unsigned int i = 0; i < variationType_.size( ); i++ )
+        {
+            // Check if type and identifer match
+            if( ( variationType_[ i ] == deformationType ) &&
+                    ( variationIdentifier_[ i ] == identifier ) )
+            {
+                // Set return pointer and exit loop.
+                gravityFieldVariation = variationObjects_[ i ];
+                isCorrectIdentifierFound = 1;
+                break;
+            }
+        }
+
+        // Provide warning if no matches are found
+        if( isCorrectIdentifierFound == 0 )
+        {
+            std::cerr<<"Error when retrieving gravity field variation of type "<<
+                       deformationType<<", none of "<<
+                       numberOfEntries<<" potential entries match identifier."<<std::endl;
+        }
+    }
+
+    return std::make_pair( isEntryFound, gravityFieldVariation );
+}
+
+//! Function to create a function linearly interpolating the sine and cosine correction coefficients
+//! produced by an object of GravityFieldVariations type.
+boost::function< void( const double, Eigen::MatrixXd&, Eigen::MatrixXd& ) >
+createInterpolatedSphericalHarmonicCorrectionFunctions(
+        boost::shared_ptr< GravityFieldVariations > variationObject,
+        const double initialTime,
+        const double finalTime,
+        const double timeStep,
+        const boost::shared_ptr< interpolators::InterpolatorSettings > interpolatorSettings )
+{
+    // Declare map of combined cosine and since corrections, to be filled and passed to interpolator
+    std::map< double, Eigen::MatrixXd > cosineSineCorrectionsMap;
+
+    // Perform once for matrices size determination.
+    double currentTime = initialTime;
+    std::pair< Eigen::MatrixXd, Eigen::MatrixXd > singleCorrections;
+    singleCorrections = variationObject->calculateSphericalHarmonicsCorrections( currentTime );
+    int correctionDegrees = singleCorrections.first.rows( );
+    int correctionOrders = singleCorrections.first.cols( );
+
+    // Loop over all times at which corrections are to be calculated.
+    Eigen::MatrixXd cosineSineCorrections;
+    while( currentTime < finalTime )
+    {
+        // Calculate current corrections.
+        singleCorrections = variationObject->calculateSphericalHarmonicsCorrections( currentTime );
+
+        // Set current corrections in single block.
+        cosineSineCorrections = Eigen::MatrixXd::Zero( correctionDegrees, 2 * correctionOrders );
+        cosineSineCorrections.block( 0, 0, correctionDegrees, correctionOrders ) +=
+                singleCorrections.first;
+        cosineSineCorrections.block( 0, correctionOrders, correctionDegrees, correctionOrders ) +=
+                singleCorrections.second;
+        cosineSineCorrectionsMap[ currentTime ] = cosineSineCorrections;
+
+        // Increment time.
+        currentTime += timeStep;
+    }
+
+
+    // Create interpolator
+    boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+            cosineSineCorrectionInterpolator =
+            interpolators::createOneDimensionalInterpolator< double, Eigen::MatrixXd >(
+                cosineSineCorrectionsMap, interpolatorSettings );
+
+    // Create pair interpolation interface for TimeDependentSphericalHarmonicsGravityField
+    boost::shared_ptr< PairInterpolationInterface > interpolationInterface =
+            boost::make_shared< PairInterpolationInterface >(
+                cosineSineCorrectionInterpolator, variationObject->getMinimumDegree( ),
+                variationObject->getMinimumOrder( ),
+                variationObject->getNumberOfDegrees( ), variationObject->getNumberOfOrders( ) );
+
+    // Create update function.
+    return boost::bind( &PairInterpolationInterface::getCosineSinePair,
+                        interpolationInterface, _1, _2, _3 );
+}
+
+//! Class constructor.
+GravityFieldVariationsSet::GravityFieldVariationsSet(
+        const std::vector< boost::shared_ptr< GravityFieldVariations > > variationObjects,
+        const std::vector< BodyDeformationTypes > variationType,
+        const std::vector< std::string > variationIdentifier,
+        const std::map< int, boost::shared_ptr< interpolators::InterpolatorSettings > >
+        createInterpolator,
+        const std::map< int, double > initialTimes,
+        const std::map< int, double > finalTimes,
+        const std::map< int, double > timeSteps ):
+    variationObjects_( variationObjects ), variationType_( variationType ),
+    variationIdentifier_( variationIdentifier ),
+    createInterpolator_( createInterpolator ),
+    initialTimes_( initialTimes ), finalTimes_( finalTimes ), timeSteps_( timeSteps )
+{
+    // Check consistency of input data vector sizes.
+    if( variationObjects_.size( ) != variationType_.size( ) )
+    {
+        std::cerr<<"Error when making GravityFieldVariationsSet, inconsistent input, type 1"<<std::endl;
+    }
+    if( variationObjects_.size( ) != variationIdentifier_.size( ) )
+    {
+        std::cerr<<"Error when making GravityFieldVariationsSet, inconsistent input, type 2"<<std::endl;
+    }
+
+    // Check if interpolation information is provided where required.
+    for( std::map< int, boost::shared_ptr< interpolators::InterpolatorSettings > >::iterator
+         interpolatorSettingsIterator =
+         createInterpolator_.begin( ); interpolatorSettingsIterator != createInterpolator_.end( );
+         interpolatorSettingsIterator++ )
+    {
+        if( initialTimes_.count( interpolatorSettingsIterator->first ) == 0 )
+        {
+            std::cerr<<"Error when making GravityFieldVariationsSet, inconsistent input, type 4, "<<
+                       interpolatorSettingsIterator->first<<std::endl;
+        }
+
+        if( finalTimes_.count( interpolatorSettingsIterator->first ) == 0 )
+        {
+            std::cerr<<"Error when making GravityFieldVariationsSet, inconsistent input, type 5, "<<
+                       interpolatorSettingsIterator->first<<std::endl;
+        }
+
+        if( timeSteps_.count( interpolatorSettingsIterator->first ) == 0 )
+        {
+            std::cerr<<"Error when making GravityFieldVariationsSet, inconsistent input, type 6, "<<
+                       interpolatorSettingsIterator->first<<std::endl;
+        }
+    }
+}
+
+//! Function to retrieve list of variation functions.
+std::vector< boost::function< void( const double, Eigen::MatrixXd&, Eigen::MatrixXd& ) > >
+GravityFieldVariationsSet::getVariationFunctions( )
+{
+    // Declare list
+    std::vector< boost::function< void( const double, Eigen::MatrixXd&, Eigen::MatrixXd& ) > >
+            variationFunctions;
+
+    // Iterate over all corrections and add correction function.
+    for( unsigned int i = 0; i < variationObjects_.size( ); i++ )
+    {
+        // If current variation is to be interpolated, create interpolation function and add to list
+        if( createInterpolator_.count( i ) > 0 )
+        {
+            variationFunctions.push_back(
+                        createInterpolatedSphericalHarmonicCorrectionFunctions(
+                            variationObjects_[ i ], initialTimes_[ i ], finalTimes_[ i ],
+                            timeSteps_[ i ], createInterpolator_[ i ] ) );
+        }
+        // If current variation is to not be interpolated, create function directly by function
+        // pointer by to current GravityFieldVariations object.
+        else
+        {
+            variationFunctions.push_back(
+                        boost::bind(
+                            &GravityFieldVariations::addSphericalHarmonicsCorrections,
+                            variationObjects_[ i ], _1, _2, _3 ) );
+        }
+    }
+
+    // Return list.
+    return variationFunctions;
+}
+
+}
+
+}

=== added file 'Tudat/Astrodynamics/Gravitation/gravityFieldVariations.h'
--- Tudat/Astrodynamics/Gravitation/gravityFieldVariations.h	1970-01-01 00:00:00 +0000
+++ Tudat/Astrodynamics/Gravitation/gravityFieldVariations.h	2015-11-04 10:21:27 +0000
@@ -0,0 +1,432 @@
+#ifndef GRAVITYFIELDVARIATIONS_H
+#define GRAVITYFIELDVARIATIONS_H
+
+#include <boost/function.hpp>
+#include <iostream>
+
+#include <Eigen/Core>
+
+#include "Tudat/Mathematics/BasicMathematics/linearAlgebraTypes.h"
+#include "Tudat/Mathematics/Interpolators/createInterpolator.h"
+
+namespace tudat
+{
+
+namespace gravitation
+{
+
+enum BodyDeformationTypes
+{
+    basic_solid_body,
+    tabulated_variation
+};
+
+
+//! Interface class between GravityFieldVariations objects that are interpolated and
+//! TimeDependentSphericalHarmonicsGravityField.
+/*!
+ *  Interface class between GravityFieldVariations objects that are interpolated and
+ *  TimeDependentSphericalHarmonicsGravityField, the getCosineSinePair function mimics the
+ *  addSphericalHarmonicsCorrections function of GravityFieldVariations.
+ *  All correction coefficients are calculated as rectnagular blocks in both the cosine and sine
+ *  matrices (of equal size)
+ */
+class PairInterpolationInterface
+{
+public:
+
+    //! Class constructor
+    /*!
+     *  Constructor, receives an interpolator (typically created from a GravityFieldVariations
+     *  object by the createInterpolatedSphericalHarmonicCorrectionFunctions function), which is
+     *  used to approximate the spherical harmonic coefficient corrections at any given time
+     * (inside the interpolation window). All correction coefficients are calculated as rectangular
+     *  blocks in both the cosine and sine matrices (of equal size)
+     *  \param cosineSineInterpolator Interpolator object for approximating coefficient corrections.
+     *  \param startDegree Degree where the rectangular correction block starts.
+     *  \param startOrder Order where the rectangular correction block starts.
+     *  \param numberOfDegrees Size of the rectangular correction block in the degree direction.
+     *  \param numberOfOrders Size of the rectangular correction block in the order direction.
+     */
+    PairInterpolationInterface(
+            const boost::shared_ptr< interpolators::OneDimensionalInterpolator<
+            double, Eigen::MatrixXd > > cosineSineInterpolator,
+            const int startDegree, const int startOrder,
+            const int numberOfDegrees, const int numberOfOrders ):
+        cosineSineInterpolator_( cosineSineInterpolator ),
+        startDegree_( startDegree ), startOrder_( startOrder ),
+        numberOfDegrees_( numberOfDegrees ), numberOfOrders_( numberOfOrders ){ }
+
+    //! Function to add sine and cosine corrections at given time to coefficient matrices.
+    /*!
+     *  Function to add sine and cosine corrections at given time to coefficient matrices.
+     *  The current sine and cosine matrices are passed by reference, the corrections are
+     *  calculated internally and added to them.
+     *  \param time Time at which corrections are to be evaluated.
+     *  \param sineCoefficients Current spherical harmonic sine coefficients, calculated
+     *  corrections are added and returned by reference
+     *  \param cosineCoefficients Current spherical harmonic cosine coefficients, calculated
+     *  corrections are added and returned by reference
+     */
+    void getCosineSinePair( const double time,
+                            Eigen::MatrixXd& sineCoefficients,
+                            Eigen::MatrixXd& cosineCoefficients );
+
+private:
+
+    //! Interpolator object for approximating coefficient corrections.
+    /*!
+     *  Interpolator object for approximating coefficient corrections, interpolates the cosine and
+     *  sine corrections, concatenated next to each other (i.e. as [C S] row 'vector' of
+     *  cosine and sine corrections C and S, respectively).
+     */
+    boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+    cosineSineInterpolator_;
+
+    //! Degree where the rectangular correction block starts.
+    /*!
+     *  Degree where the rectangular correction block starts.
+     */
+    int startDegree_;
+
+    //! Order where the rectangular correction block starts.
+    /*!
+     *  Order where the rectangular correction block starts.
+     */
+    int startOrder_;
+
+    //! Size of the rectangular correction block in the degree direction.
+    /*!
+     *  Size of the rectangular correction block in the degree direction.
+     */
+    int numberOfDegrees_;
+
+    //! Size of the rectangular correction block in the order direction.
+    /*!
+     *  Size of the rectangular correction block in the order direction.
+     */
+    int numberOfOrders_;
+};
+
+//! Virual base class for spherical harmonic gravity field variations
+//! (i.e. time-dependencies of sine and cosine coefficients)
+/*!
+ *  Virual base class for spherical harmonic gravity field variations
+ *  (i.e. time-dependencies of sine and cosine coefficients). The interface of derived classes
+ *  with TimeDependentSphericalHarmonicsGravityField, which combines all corrections and adds them
+ *  to nominal values, can be performed either directly, or through an interpolator
+ *  (see PairInterpolationInterface and createInterpolatedSphericalHarmonicCorrectionFunctions)
+ *  to save on computation time when evaluating slowly changing functions at very short intervals.
+ *  All correction coefficients are calculated as rectangular blocks in both the cosine and sine
+ *  matrices (of equal size).
+ */
+class GravityFieldVariations
+{
+public:
+
+    //! Base class constructor
+    /*!
+     *  Base class constructor, input defines the size and position of correction blocks in sine and
+     *  cosine matrices
+     *  \param minimumDegree Degree where the rectangular correction blocks start.
+     *  \param minimumOrder Order where the rectangular correction blocks start.
+     *  \param maximumDegree Degree where the rectangular correction blocks end.
+     *  \param maximumOrder Order where the rectangular correction blocks end.
+     */
+    GravityFieldVariations( const int minimumDegree, const int minimumOrder,
+                            const int maximumDegree, const int maximumOrder ):
+        minimumDegree_( minimumDegree ), minimumOrder_( minimumOrder ),
+        maximumDegree_( maximumDegree ), maximumOrder_( maximumOrder )
+    {
+        numberOfDegrees_ = maximumDegree_ - minimumDegree_ + 1;
+        numberOfOrders_ = maximumOrder_ - minimumOrder_ + 1;
+    }
+
+    //! Virtual destructor
+    /*!
+     *  Virtual destructor
+     */
+    virtual ~GravityFieldVariations( ){ }
+
+    //! Pure virtual function for calculating corrections.
+    /*!
+     *  Pure virtual function for calculating corrections at given time.
+     *  \param time Time at which variations are to be calculated.
+     *  \return Pair of  matrices containing variations in (cosine, sine) coefficients at block
+     *  positions in total matrices defined by minimumDegree_, minimumOrder_, numberOfDegrees_,
+     *  numberOfOrders_;
+     */
+    virtual std::pair< Eigen::MatrixXd, Eigen::MatrixXd > calculateSphericalHarmonicsCorrections(
+            const double time ) = 0;
+
+    //! Function to add sine and cosine corrections at given time to coefficient matrices.
+    /*!
+     *  Function to add sine and cosine corrections at given time to coefficient matrices.
+     *  The current sine and cosine matrices are passed by reference, the corrections are calculated
+     *  internally and added to them.
+     *  \param time Time at which corrections are to be evaluated.
+     *  \param sineCoefficients Current spherical harmonic sine coefficients, calculated
+     *  corrections are added and returned by reference
+     *  \param cosineCoefficients Current spherical harmonic cosine coefficients, calculated
+     *  corrections are added and returned by reference
+     */
+    void addSphericalHarmonicsCorrections(
+            const double time,
+            Eigen::MatrixXd& sineCoefficients,
+            Eigen::MatrixXd& cosineCoefficients );
+
+    //! Function to return the maximum degree of the corrections.
+    /*!
+     *  Function to return the maximum degree of the corrections.
+     */
+    int getMaximumDegree( )
+    {
+        return maximumDegree_;
+    }
+
+    //! Function to return the maximum order of the corrections.
+    /*!
+     *  Function to return the maximum order of the corrections.
+     */
+    int getMaximumOrder( )
+    {
+        return maximumOrder_;
+    }
+
+    //! Function to return the minimum degree of the corrections.
+    /*!
+     *  Function to return the minimum degree of the corrections.
+     */
+    int getMinimumDegree( )
+    {
+        return minimumDegree_;
+    }
+
+    //! Function to return the minimum order of the corrections.
+    /*!
+     *  Function to return the minimum order of the corrections.
+     */
+    int getMinimumOrder( )
+    {
+        return minimumOrder_;
+    }
+
+    //! Function to return the number of degrees of the corrections.
+    /*!
+     *  Function to return the number of degrees of the corrections.
+     */
+    int getNumberOfDegrees( )
+    {
+        return numberOfDegrees_;
+    }
+
+    //! Function to return the number of orders of the corrections.
+    /*!
+     *  Function to return the number of orders of the corrections.
+     */
+    int getNumberOfOrders( )
+    {
+        return numberOfOrders_;
+    }
+protected:
+
+    //! Minimum degree of variations
+    /*!
+     *  Minimum degree of variations
+     */
+    int minimumDegree_;
+
+    //! Minimum order of variations
+    /*!
+     *  Minimum order of variations
+     */
+    int minimumOrder_;
+
+    //! Maximum degree of variations
+    /*!
+     *  Maximum degree of variations
+     */
+    int maximumDegree_;
+
+    //! Maximum order of variations
+    /*!
+     *  Maximum order of variations
+     */
+    int maximumOrder_;
+
+    //! Number of degrees of variations
+    /*!
+     *  Number of degrees of variations
+     */
+    int numberOfDegrees_;
+
+    //! Number of orders of variations
+    /*!
+     *  Number of orders of variations
+     */
+    int numberOfOrders_;
+};
+
+//! Function to create a function linearly interpolating the sine and cosine correction coefficients
+//! produced by an object of GravityFieldVariations type.
+/*!
+ *  Function to create a function linearly interpolating the sine and cosine correction coefficients
+ *  produced by an object of GravityFieldVariations type.
+ *  The function creates a function pointer to the getCosineSinePair function of
+ *  PairInterpolationInterface. The object of type PairInterpolationInterface is created by
+ *  generating an interpolator for sine/cosine coefficients from the variationObject object and
+ *  the initial/final time and time step that are passed.
+ *  \param variationObject Object generating cosine and sine coefficient corrections.
+ *  \param initialTime Start time of interpolator.
+ *  \param finalTime End time of interpolator.
+ *  \param timeStep Time step between subsequent evaluations of coefficient corrections
+ *  \return Function pointer to function mimicing the addSphericalHarmonicsCorrections
+ *  function of GravityFieldVariations.
+ */
+boost::function< void( const double, Eigen::MatrixXd&, Eigen::MatrixXd& ) >
+createInterpolatedSphericalHarmonicCorrectionFunctions(
+        boost::shared_ptr< GravityFieldVariations > variationObject,
+        const double initialTime,
+        const double finalTime,
+        const double timeStep,
+        const boost::shared_ptr< interpolators::InterpolatorSettings > interpolatorSettings =
+        boost::make_shared< interpolators::InterpolatorSettings >(
+            interpolators::linear_interpolator, interpolators::huntingAlgorithm ) );
+
+//! Container class containing all gravity field variations for a single Body
+//! (and TimeDependentSphericalHarmonicsGravityField).
+/*!
+ *  Container class containing all gravity field variations for a single Body
+ *  (and TimeDependentSphericalHarmonicsGravityField). Also contains information on whether an
+ *  interpolator is used for calculation of corrections by
+ *  TimeDependentSphericalHarmonicsGravityField and, if so, the associated interpolator settings.
+ *  Multiple corrections of a single type may be contained in this class, in which case each of them
+ *  must be supplied with a unique identifier (string).
+ */
+class GravityFieldVariationsSet
+{
+public:
+
+    //! Class constructor.
+    /*!
+     *  Class contructor, requires set of correction objects (and associated properties).
+     *  \param variationObjects List of GravityFieldVariations objects denoting the complete set of
+     *  variations to take into account.
+     *  \param variationType List of type identifiers of variationObjects (prevents use of dynamic
+     *  casts), must be of same size as variationObjects.
+     *  \param variationIdentifier Name of variation object for each entry of variationObjects, must
+     *  be of same size as variationObjects.
+     *  Entries only required to be non-empty if multiple variations objects of same type are
+     *  included in variationObjects list.
+     *  \param createInterpolator List of booleans denoting whether to interpolate a given
+     *  entry of variationObjects or not, must be of same size as variationObjects.
+     *  \param initialTimes Initial times for interpolation, must contain an entry for each
+     *  variation (map key denotes index of variationObjects) for which createInterpolator is true.
+     *  \param finalTimes Final times for interpolation, must contain an entry for each variation
+     *  (map key denotes index of variationObjects) for which createInterpolator is true.
+     *  \param timeSteps Time steps for interpolation, must contain an entry for each variation
+     *  (map key denotes index of variationObjects) for which createInterpolator is true.
+     */
+    GravityFieldVariationsSet(
+            const std::vector< boost::shared_ptr< GravityFieldVariations > > variationObjects,
+            const std::vector< BodyDeformationTypes > variationType,
+            const std::vector< std::string > variationIdentifier,
+            const std::map< int, boost::shared_ptr< interpolators::InterpolatorSettings > >
+            createInterpolator,
+            const std::map< int, double > initialTimes,
+            const std::map< int, double > finalTimes,
+            const std::map< int, double > timeSteps );
+
+    //! Function to retrieve a variation object of given type (and name if necessary).
+    /*!
+     *  Function to retrieve a variation object of given type (and name if necessary).
+     *  Name must be provided only if if multiple variation objects of same type are included in
+     *  variationObjects_ list.
+     *  \param deformationType Type of gravity field variation.
+     *  \param identifier Name of gravity field variation (only required if if multiple variation
+     *  objects of same type are included in variationObjects_ list (ignored otherwise).
+     *  \return Pair containing boolean (true if requested variation found, false otherwise) and
+     *  pointer to variation object (only if requested variation found).
+     */
+    std::pair< bool, boost::shared_ptr< gravitation::GravityFieldVariations > >
+     getGravityFieldVariation(
+            const BodyDeformationTypes deformationType,
+            const std::string identifier = "" );
+
+    //! Function to retrieve list of variation functions.
+    /*!
+     *  Function to retrieve list of variation functions, entries are either created using function
+     *  pointer binding to PairInterpolationInterface (if given variation is to be interpolated)
+     *  or to GravityFieldVariations directly (if no interpolation requested).
+     *  \return List of gravity field coefficient variation functions, matching the interface of
+     *  GravityFieldVariations::addSphericalHarmonicsCorrections
+     */
+    std::vector< boost::function< void( const double, Eigen::MatrixXd&, Eigen::MatrixXd& ) > >
+    getVariationFunctions( );
+
+    std::vector< boost::shared_ptr< GravityFieldVariations > > getVariationObjects( )
+    {
+        return variationObjects_;
+    }
+
+private:
+
+    //! List of GravityFieldVariations objects denoting the complete set of variations to take
+    //! into account.
+    /*!
+     *  List of GravityFieldVariations objects denoting the complete set of variations to take
+     *  into account.
+     */
+    std::vector< boost::shared_ptr< GravityFieldVariations > > variationObjects_;
+
+    //! List of type identifiers of variationObjects.
+    /*!
+     *  List of type identifiers of variationObjects (prevents use of dynamic casts), must be of
+     *  same size as variationObjects.
+     */
+    std::vector< BodyDeformationTypes > variationType_;
+
+    //! Name of variation object for each entry of variationObjects
+    /*!
+     *  Name of variation object for each entry of variationObjects, must be of same size as
+     *  variationObjects. Used for discriminating between different variation objects of same type.
+     *  Entries only required to be non-empty if multiple variations objects of same type are
+     *  included in variationObjects list.
+     */
+    std::vector< std::string > variationIdentifier_;
+
+    //! List of booleans denoting whether to interpolate a given entry of variationObjects or not
+    /*!
+     *  List of booleans denoting whether to interpolate a given entry of variationObjects or not,
+     *  must be of same size as variationObjects.
+     */
+    std::map< int, boost::shared_ptr< interpolators::InterpolatorSettings > > createInterpolator_;
+
+    //! Initial times for interpolation,
+    /*!
+     *  Initial times for interpolation, must contain an entry for each variation
+     *  (map key denotes index of variationObjects) for which createInterpolator is true.
+     */
+    std::map< int, double > initialTimes_;
+
+    //! Final times for interpolation,
+    /*!
+     *  Final times for interpolation, must contain an entry for each variation
+     *  (map key denotes index of variationObjects) for which createInterpolator is true.
+     */
+    std::map< int, double > finalTimes_;
+
+    //! Time steps for interpolation,
+    /*!
+     *  Time steps for interpolation, must contain an entry for each variation
+     *  (map key denotes index of variationObjects) for which createInterpolator is true.
+     */
+    std::map< int, double > timeSteps_;
+
+};
+
+}
+
+}
+
+#endif // GRAVITYFIELDVARIATIONS_H

=== added file 'Tudat/Astrodynamics/Gravitation/timeDependentSphericalHarmonicsGravityField.cpp'
--- Tudat/Astrodynamics/Gravitation/timeDependentSphericalHarmonicsGravityField.cpp	1970-01-01 00:00:00 +0000
+++ Tudat/Astrodynamics/Gravitation/timeDependentSphericalHarmonicsGravityField.cpp	2015-11-04 10:21:27 +0000
@@ -0,0 +1,51 @@
+#include <boost/bind.hpp>
+
+#include "Tudat/Astrodynamics/Gravitation/timeDependentSphericalHarmonicsGravityField.h"
+
+namespace tudat
+{
+
+namespace gravitation
+{
+
+//! Function to (re)set the gravity field variations
+void TimeDependentSphericalHarmonicsGravityField::setFieldVariationSettings(
+        const boost::shared_ptr< GravityFieldVariationsSet > gravityFieldVariationUpdateSettings,
+        const bool updateCorrections )
+{
+    // Set new variation set.
+    gravityFieldVariationsSet_ = gravityFieldVariationUpdateSettings;
+
+    // Update correction functions if necessary.
+    if( updateCorrections )
+    {
+        updateCorrectionFunctions( );
+    }
+}
+
+//! Function to clear all gravity field variations
+void TimeDependentSphericalHarmonicsGravityField::clearVariations( )
+{
+    gravityFieldVariationsSet_ = boost::shared_ptr< GravityFieldVariationsSet >( );
+    correctionFunctions_.clear( );
+}
+
+
+//! Update gravity field to current time.
+void TimeDependentSphericalHarmonicsGravityField::update( const double time )
+{
+    // Initialize current coefficients to nominal values.
+    sineCoefficients_ = nominalSineCoefficients_;
+    cosineCoefficients_ = nominalCosineCoefficients_;
+
+    // Iterate over all corrections.
+    for( unsigned int i = 0; i < correctionFunctions_.size( ); i++ )
+    {
+        // Add correction of this iteration to current coefficients.
+        correctionFunctions_[ i ]( time, sineCoefficients_, cosineCoefficients_ );
+    }
+}
+
+}
+
+}

=== added file 'Tudat/Astrodynamics/Gravitation/timeDependentSphericalHarmonicsGravityField.h'
--- Tudat/Astrodynamics/Gravitation/timeDependentSphericalHarmonicsGravityField.h	1970-01-01 00:00:00 +0000
+++ Tudat/Astrodynamics/Gravitation/timeDependentSphericalHarmonicsGravityField.h	2015-11-09 08:31:00 +0000
@@ -0,0 +1,280 @@
+#ifndef TIMEDEPENDENTSPHERICALHARMONICSGRAVITYFIELD_H
+#define TIMEDEPENDENTSPHERICALHARMONICSGRAVITYFIELD_H
+
+#include <boost/function.hpp>
+#include <boost/make_shared.hpp>
+
+#include <vector>
+
+#include "Tudat/Mathematics/Interpolators/cubicSplineInterpolator.h"
+
+#include "Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.h"
+#include "Tudat/Astrodynamics/Gravitation/gravityFieldVariations.h"
+
+
+namespace tudat
+{
+
+namespace gravitation
+{
+
+//! Class for time dependent spherical harmonic gravity field.
+/*!
+ *  Class for time dependent spherical harmonic gravity field, i.e where the sine and cosine
+ *  coefficients are functions of time. This class combines nominal values with time-dependent
+ *  variations, which are calculated by object of GravityFieldVariation derived classes (one object
+ *  per variation). All spherical harmonic coefficients used in this class, as well as the
+ *  variations, are implicitly assumed to be geodesy-normalized.
+ */
+class TimeDependentSphericalHarmonicsGravityField: public SphericalHarmonicsGravityField
+{
+public:
+
+    //! Semi-dummy constructor, used for setting up gravity field and variations.
+    /*!
+     *  Semi-dummy constructor, used for setting up gravity field and variations.
+     *  This constructor is neede, as some gravity field variations need to be linked to properties
+     *  of the nominal gravity field (for instance gravitational parameter), but the complete object
+     *  of this type cannot be created until all variations are created, causing a
+     *  circular dependency. The object is fully created when subsequently calling the
+     *  setFieldVariationSettings function and setting the field variation objects.
+     *  \param gravitationalParameter Gravitational parameter of massive body.
+     *  \param referenceRadius Reference radius of spherical harmonic field expansion.
+     *  \param nominalCosineCoefficients Nominal (i.e. with zero variation) cosine spherical
+     *  harmonic coefficients.
+     *  \param nominalSineCoefficients Nominal (i.e. with zero variation) sine spherical harmonic
+     *  coefficients.
+     *  \param rotationWrapper Object from which rotation between frame fixed to massive body and
+     *  inertial frame is retrieved.
+     */
+    TimeDependentSphericalHarmonicsGravityField(
+            const double gravitationalParameter, const double referenceRadius,
+            const Eigen::MatrixXd& nominalCosineCoefficients,
+            const Eigen::MatrixXd& nominalSineCoefficients,
+            const boost::function< Eigen::Quaterniond( ) > rotationWrapper =
+            boost::lambda::constant( Eigen::Quaterniond( Eigen::Matrix3d::Identity( ) ) ) ):
+        SphericalHarmonicsGravityField(
+            gravitationalParameter, referenceRadius, nominalCosineCoefficients,
+            nominalSineCoefficients, rotationWrapper ),
+        nominalSineCoefficients_( nominalSineCoefficients ),
+        nominalCosineCoefficients_( nominalCosineCoefficients )
+    { }
+
+    //! Full class constructor.
+    /*!
+     *  Full class constructor.
+     *  \param gravitationalParameter Gravitational parameter of massive body.
+     *  \param referenceRadius Reference radius of spherical harmonic field expansion.
+     *  \param nominalCosineCoefficients Nominal (i.e. with zero variation) cosine spherical
+     *  harmonic coefficients.
+     *  \param nominalSineCoefficients Nominal (i.e. with zero variation) sine spherical harmonic
+     *  coefficients.
+     *  \param gravityFieldVariationUpdateSettings Object containing all gravity field variations
+     *  and related settings.
+     *  \param rotationWrapper Object from which rotation between frame fixed to massive body
+     *  and inertial frame is retrieved.
+     */
+    TimeDependentSphericalHarmonicsGravityField(
+            const double gravitationalParameter, const double referenceRadius,
+            const Eigen::MatrixXd& nominalCosineCoefficients,
+            const Eigen::MatrixXd& nominalSineCoefficients,
+            const boost::shared_ptr< GravityFieldVariationsSet >&
+            gravityFieldVariationUpdateSettings,
+            const boost::function< Eigen::Quaterniond( ) > rotationWrapper =
+            boost::lambda::constant( Eigen::Quaterniond( Eigen::Matrix3d::Identity( ) ) ) ):
+        SphericalHarmonicsGravityField(
+            gravitationalParameter, referenceRadius,
+            nominalCosineCoefficients, nominalSineCoefficients, rotationWrapper ),
+        nominalSineCoefficients_( nominalSineCoefficients ),
+        nominalCosineCoefficients_( nominalCosineCoefficients ),
+        gravityFieldVariationsSet_( gravityFieldVariationUpdateSettings )
+    {
+        updateCorrectionFunctions( );
+    }
+
+    //! Destructor
+    /*!
+     *  Destructor
+     */
+    ~TimeDependentSphericalHarmonicsGravityField( ){ }
+
+    //! Update gravity field to current time.
+    /*!
+     *  Update gravity field coefficient corrections to current time. All correction functions are
+     *  called and subsequently added to the nominal value.
+     *  \param time Current time.
+     */
+    void update( const double time );
+
+    //! Update correction functions.
+    /*!
+     *  Update correction functions, for instance to account for changed changed environmental
+     *  parameters.
+     */
+    void updateCorrectionFunctions( )
+    {
+        // Check if field variation set exists.
+        if( gravityFieldVariationsSet_ == NULL )
+        {
+            std::cerr<<"Warning, gravity field coefficient update functions are NULL "<<
+                       " when requesting update"<<std::endl;
+        }
+        else
+        {
+            // Reset correction functions.
+            correctionFunctions_ = gravityFieldVariationsSet_->getVariationFunctions( );
+        }
+
+    }
+
+    //! Function to (re)set the gravity field variations
+    /*!
+     *  Function to (re)set the gravity field variations object. An option is provided for
+     *  determining whether or not the variations should be immediately recalculated.
+     *  \param gravityFieldVariationUpdateSettings Object storing all variation models and
+     *  associated settings.
+     *  \param updateCorrections Flag to determine whether the gravity field variation functions
+     *  should be immediately updated with new settings.
+     */
+    void setFieldVariationSettings(
+           const boost::shared_ptr< GravityFieldVariationsSet > gravityFieldVariationUpdateSettings,
+           const bool updateCorrections = 1 );
+
+    //! Function to clear all gravity field variations
+    /*!
+     *  Function to clear all gravity field variations, the gravityFieldVariationsSet_ is set to
+     *  NULL, and the correctionFunctions_ list is cleared.
+     */
+    void clearVariations( );
+
+    //! Get nominal (i.e. with zero variations) cosine coefficients.
+    /*!
+     *  Function to get nominal (i.e. with zero variations) cosine coefficients.
+     *  \return Nominal cosine coefficients.
+     */
+    Eigen::MatrixXd getNominalCosineCoefficients( )
+    {
+        return nominalCosineCoefficients_;
+    }
+
+    //! Set nominal (i.e. with zero variations) cosine coefficients.
+    /*!
+     *  Function to set nominal (i.e. with zero variations) cosine coefficients.
+     *  \param nominalCosineCoefficients New nominal cosine coefficients.
+     */
+    void setNominalCosineCoefficients( Eigen::MatrixXd nominalCosineCoefficients )
+    {
+        nominalCosineCoefficients_ = nominalCosineCoefficients;
+    }
+
+    //! Set nominal (i.e. with zero variations) cosine coefficient of given degree and order.
+    /*!
+     *  Set nominal (i.e. with zero variations) cosine coefficients of given degree and order.
+     *  \param degree Spherical harmonic degree.
+     *  \param order Spherical harmonic order.
+     *  \param coefficient New cosine coefficient for given degree and order.
+     */
+    void setNominalCosineCoefficient( const int degree, const int order, const double coefficient )
+    {
+        if( degree <= nominalCosineCoefficients_.rows( ) &&
+                order <= nominalCosineCoefficients_.cols( ) )
+        {
+            nominalCosineCoefficients_( degree, order ) = coefficient;
+        }
+        else
+        {
+            std::cerr<<"Error when resetting nominal cosine coefficient"<<std::endl;
+        }
+    }
+
+    //! Get nominal (i.e. with zero variations) sine coefficients.
+    /*!
+     *  Function to get nominal (i.e. with zero variations) sine coefficients.
+     *  \return Nominal sine coefficients.
+     */
+    Eigen::MatrixXd getNominalSineCoefficients( )
+    {
+        return nominalSineCoefficients_;
+    }
+
+    //! Set nominal (i.e. with zero variations) sine coefficients.
+    /*!
+     *  Function to set nominal (i.e. with zero variations) sine coefficients.
+     *  \param nominalSineCoefficients New nominal sine coefficients.
+     */
+    void setNominalSineCoefficients( const Eigen::MatrixXd& nominalSineCoefficients )
+    {
+        nominalSineCoefficients_ = nominalSineCoefficients;
+    }
+
+    //! Set nominal (i.e. with zero variations) sine coefficient of given degree and order.
+    /*!
+     *  Set nominal (i.e. with zero variations) sine coefficients of given degree and order.
+     *  \param degree Spherical harmonic degree.
+     *  \param order Spherical harmonic order.
+     *  \param coefficient New sine coefficient for given degree and order.
+     */
+    void setNominalSineCoefficient( const int degree, const int order, const double coefficient )
+    {
+        if( degree <= nominalSineCoefficients_.rows( ) &&
+                order <= nominalSineCoefficients_.cols( ) )
+        {
+            nominalSineCoefficients_( degree, order ) = coefficient;
+        }
+        else
+        {
+            std::cerr<<"Error when resetting nominal sine coefficient"<<std::endl;
+        }
+    }
+
+    //! Function to get object containing all gravity field variations and related settings
+    /*!
+     *  Function to get object containing all gravity field variations and related settings
+     */
+    boost::shared_ptr< GravityFieldVariationsSet > getGravityFieldVariationsSet( )
+    {
+        return gravityFieldVariationsSet_;
+    }
+
+private:
+
+    //! Nominal (i.e. with zero variations) cosine coefficients.
+    /*!
+     *  Nominal (i.e. with zero variations) cosine coefficients. When calling the update function,
+     *  all corrections are calculated and the sum of these corrections and this nominal value is
+     *  set as cosineCoefficients_ base class member.
+     */
+    Eigen::MatrixXd nominalSineCoefficients_;
+
+    //! Nominal (i.e. with zero variations) sine coefficients.
+    /*!
+     *  Nominal (i.e. with zero variations) sine coefficients. When calling the update function,
+     *  all corrections are calculated and the sum of these corrections and this nominal value is
+     *  set as sineCoefficients_ base class member.
+     */
+    Eigen::MatrixXd nominalCosineCoefficients_;
+
+    //! List of update functions which are called when calculating current gravity field variations.
+    /*!
+     *  List of update functions which are called when calculating current gravity field variations.
+     *  Functions are either linked to PairInterpolationInterface, which contains an interpolator
+     *  created from a GravityFieldVariations object, or the addSphericalHarmonicsCorrections of the
+     *  GravityFieldVariations object directly.
+     */
+    std::vector< boost::function< void( const double, Eigen::MatrixXd&, Eigen::MatrixXd& ) > >
+    correctionFunctions_;
+
+    //! Object containing all GravityFieldVariations objects and update settings.
+    /*!
+     *  Object containing all GravityFieldVariations objects and update settings
+     *  (i.e. time settings for interpolator)
+     */
+    boost::shared_ptr< GravityFieldVariationsSet > gravityFieldVariationsSet_;
+
+};
+
+}
+
+}
+
+#endif // TIMEDEPENDENTSPHERICALHARMONICSGRAVITYFIELD_H

=== modified file 'Tudat/Mathematics/BasicMathematics/legendrePolynomials.cpp'
--- Tudat/Mathematics/BasicMathematics/legendrePolynomials.cpp	2015-04-17 14:14:12 +0000
+++ Tudat/Mathematics/BasicMathematics/legendrePolynomials.cpp	2015-11-04 10:21:27 +0000
@@ -38,6 +38,7 @@
 #include <stdexcept>
 
 #include <boost/exception/all.hpp>
+#include <boost/math/special_functions/factorials.hpp>
 
 #include "Tudat/Mathematics/BasicMathematics/legendrePolynomials.h"
 
@@ -459,5 +460,21 @@
     outputStream << std::endl;
 }
 
+//! Function to calculate the normalization factor for Legendre polynomials to geodesy-normalized.
+double calculateLegendreGeodesyNormalizationFactor( const int degree, const int order )
+{
+
+    double deltaFunction = 0.0;
+    if( order == 0 )
+    {
+        deltaFunction = 1.0;
+    }
+
+    double factor = std::sqrt( boost::math::factorial< double >( static_cast< double >( degree + order ) ) /
+                               ( ( 2.0 - deltaFunction ) * ( 2.0 * static_cast< double >( degree ) + 1.0 ) *
+                                 boost::math::factorial< double >( static_cast< double >( degree - order ) ) ) );
+    return 1.0 / factor;
+}
+
 } // namespace basic_mathematics
 } // namespace tudat

=== modified file 'Tudat/Mathematics/BasicMathematics/legendrePolynomials.h'
--- Tudat/Mathematics/BasicMathematics/legendrePolynomials.h	2015-04-17 14:14:12 +0000
+++ Tudat/Mathematics/BasicMathematics/legendrePolynomials.h	2015-11-04 10:21:27 +0000
@@ -426,6 +426,19 @@
                                       boost::unordered_map< Point, double > cacheTable,
                                       boost::circular_buffer< Point > cacheHistory );
 
+//! Function to calculate the normalization factor for Legendre polynomials to geodesy-normalized.
+/*!
+ *  Function to calculate the normalization factor K_nm to convert regular Legendre polynomials P_nm
+ *  to geodesy-normalized Legendre polynomials \bar{P}_nm, so that \bar{P}_nm=K_nm*P_nm.
+ *  Note that the same conversion for spherical harmonic coefficients from regular to geodesy-
+ *  normalized requires the inverse factor: 1/K_nm
+ * \param degree Degree of Legendre polynomial
+ * \param order Order of Legendre polynomial
+ * \return Normalization factor K_nm
+ */
+double calculateLegendreGeodesyNormalizationFactor( const int degree, const int order );
+
+
 } // namespace basic_mathematics
 } // namespace tudat
 

=== modified file 'Tudat/Mathematics/BasicMathematics/mathematicalConstants.h'
--- Tudat/Mathematics/BasicMathematics/mathematicalConstants.h	2015-04-17 14:14:12 +0000
+++ Tudat/Mathematics/BasicMathematics/mathematicalConstants.h	2015-11-09 08:31:00 +0000
@@ -41,6 +41,7 @@
 #ifndef TUDAT_MATHEMATICAL_CONSTANTS_H
 #define TUDAT_MATHEMATICAL_CONSTANTS_H
 
+#include <complex>
 #include <cmath>
 #include <limits>
 
@@ -66,6 +67,12 @@
  */
 const static double GOLDEN_RATIO = 0.5 * ( 1.0 + std::sqrt( 5.0 ) );
 
+//! Independent root of -1, typically denoted i.
+/*!
+ *  Independent root of -1, typically denoted i
+ */
+const static std::complex< double > COMPLEX_I = std::complex< double >( 0.0, 1.0 );
+
 //! The constant PI \f$\approx\f$ 3.14159.
 /*!
  * The constant PI, denoted \f$\pi\f$, is a real number defined as the ratio of a circle's circumference

=== added file 'Tudat/Mathematics/Interpolators/createInterpolator.h'
--- Tudat/Mathematics/Interpolators/createInterpolator.h	1970-01-01 00:00:00 +0000
+++ Tudat/Mathematics/Interpolators/createInterpolator.h	2015-11-04 10:21:27 +0000
@@ -0,0 +1,139 @@
+#ifndef CREATEINTERPOLATOR_H
+#define CREATEINTERPOLATOR_H
+
+#include <boost/make_shared.hpp>
+#include <boost/shared_ptr.hpp>
+
+#include "Tudat/Mathematics/Interpolators/linearInterpolator.h"
+#include "Tudat/Mathematics/Interpolators/cubicSplineInterpolator.h"
+#include "Tudat/Mathematics/Interpolators/lagrangeInterpolator.h"
+
+namespace tudat
+{
+
+namespace interpolators
+{
+
+enum OneDimensionalInterpolatorTypes
+{
+    linear_interpolator = 1,
+    cubic_spline_interpolator = 2,
+    lagrange_interpolator = 3
+};
+
+class InterpolatorSettings
+{
+public:
+
+    InterpolatorSettings( const OneDimensionalInterpolatorTypes interpolatorType,
+                          const AvailableLookupScheme selectedLookupScheme ):
+        interpolatorType_( interpolatorType ), selectedLookupScheme_( selectedLookupScheme ){ }
+
+    virtual ~InterpolatorSettings( ){ }
+
+    OneDimensionalInterpolatorTypes getInterpolatorType( )
+    {
+        return interpolatorType_;
+    }
+
+    AvailableLookupScheme getSelectedLookupScheme( )
+    {
+        return selectedLookupScheme_;
+    }
+
+protected:
+
+    OneDimensionalInterpolatorTypes interpolatorType_;
+
+    AvailableLookupScheme selectedLookupScheme_;
+
+};
+
+class LagrangeInterpolatorSettings: public InterpolatorSettings
+{
+public:
+    LagrangeInterpolatorSettings( const int interpolatorOrder,
+                                  const bool useLongDoubleTimeStep,
+                                  const AvailableLookupScheme selectedLookupScheme ):
+        InterpolatorSettings( lagrange_interpolator, selectedLookupScheme ),
+        interpolatorOrder_( interpolatorOrder ), useLongDoubleTimeStep_( useLongDoubleTimeStep )
+        { }
+
+    ~LagrangeInterpolatorSettings( ){ }
+
+    int getInterpolatorOrder( )
+    {
+        return interpolatorOrder_;
+    }
+
+    bool getUseLongDoubleTimeStep( )
+    {
+        return useLongDoubleTimeStep_;
+    }
+
+
+protected:
+
+    int interpolatorOrder_;
+
+    bool useLongDoubleTimeStep_;
+
+
+
+};
+
+
+template< typename IndependentVariableType, typename DependentVariableType >
+boost::shared_ptr< OneDimensionalInterpolator< IndependentVariableType, DependentVariableType > > createOneDimensionalInterpolator(
+        const std::map< IndependentVariableType, DependentVariableType > dataToInterpolate,
+        const boost::shared_ptr< InterpolatorSettings > interpolatorSettings )
+{
+    boost::shared_ptr< OneDimensionalInterpolator< IndependentVariableType, DependentVariableType > > createdInterpolator;
+    switch( interpolatorSettings->getInterpolatorType( ) )
+    {
+    case linear_interpolator:
+        createdInterpolator = boost::make_shared< LinearInterpolator< IndependentVariableType, DependentVariableType > >(
+                    dataToInterpolate, interpolatorSettings->getSelectedLookupScheme( ) );
+        break;
+    case cubic_spline_interpolator:
+        createdInterpolator = boost::make_shared< CubicSplineInterpolator< IndependentVariableType, DependentVariableType > >(
+                    dataToInterpolate, interpolatorSettings->getSelectedLookupScheme( ) );
+        break;
+    case lagrange_interpolator:
+    {
+        boost::shared_ptr< LagrangeInterpolatorSettings > lagrangeInterpolatorSettings =
+                boost::dynamic_pointer_cast< LagrangeInterpolatorSettings >( interpolatorSettings );
+
+        if( lagrangeInterpolatorSettings != NULL )
+        {
+            if( !lagrangeInterpolatorSettings->getUseLongDoubleTimeStep( ) )
+            {
+                createdInterpolator = boost::make_shared< LagrangeInterpolator< IndependentVariableType, DependentVariableType, double > >(
+                            dataToInterpolate, lagrangeInterpolatorSettings->getInterpolatorOrder( ),
+                            interpolatorSettings->getSelectedLookupScheme( ) );
+            }
+            else
+            {
+                createdInterpolator = boost::make_shared< LagrangeInterpolator< IndependentVariableType, DependentVariableType, long double > >(
+                            dataToInterpolate, lagrangeInterpolatorSettings->getInterpolatorOrder( ),
+                            interpolatorSettings->getSelectedLookupScheme( ) );
+            }
+        }
+        else
+        {
+            std::cerr<<"Error, did not recognize lagrange interpolator settings"<<std::endl;
+
+        }
+        break;
+    }
+    default:
+        std::cerr<<"Error when making interpolator, function cannot be used to create interplator of type "<<interpolatorSettings->getInterpolatorType( )<<std::endl;
+    }
+    return createdInterpolator;
+}
+
+}
+
+}
+
+#endif // CREATEINTERPOLATOR_H

