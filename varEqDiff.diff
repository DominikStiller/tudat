diff --git a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/accelerationPartial.h b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/accelerationPartial.h
index b3b31f7..2c0a615 100644
--- a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/accelerationPartial.h
+++ b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/accelerationPartial.h
@@ -76,8 +76,10 @@ public:
         std::pair< boost::function< void( Eigen::Block< Eigen::MatrixXd > ) >, int >
                 partialFunction = std::make_pair( boost::function< void( Eigen::Block< Eigen::MatrixXd > ) >( ), 0 );
 
-        // Check if state is translational.
-        if( integratedStateType == propagators::transational_state )
+        // Check if state dependency exists
+        switch( integratedStateType )
+        {
+        case propagators::transational_state:
         {
             // Check if reference id is consistent.
             if( stateReferencePoint.second != "" )
@@ -98,12 +100,37 @@ public:
                 partialFunction = std::make_pair( boost::bind( &AccelerationPartial::wrtStateOfAdditionalBody,
                                                                this, _1, stateReferencePoint.first ), 3 );
             }
+            break;
+        }
+        case propagators::body_mass_state:
+        {
+            // Check if reference id is consistent.
+            if( stateReferencePoint.second != "" )
+            {
+                throw std::runtime_error( "Error when getting state derivative partial acceleration model, cannot have reference point on body for body mass" );
+            }
+            else if( isStateDerivativeDependentOnIntegratedNonTranslationalState( stateReferencePoint, integratedStateType ) )
+            {
+                partialFunction = std::make_pair( boost::bind( &AccelerationPartial::wrtNonTranslationalStateOfAdditionalBody,
+                                                               this, _1, stateReferencePoint, integratedStateType ), 1 );
+            }
+        }
+        default:
+            std::string errorMessage =
+                    "Error when getting state derivative partial acceleration model, dynamics type " +
+                    boost::lexical_cast< std::string >( integratedStateType ) + "not recognized" ;
+            throw std::runtime_error( errorMessage );
+            break;
         }
 
 
         return partialFunction;
     }
 
+    virtual bool isStateDerivativeDependentOnIntegratedNonTranslationalState(
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType ) = 0;
+
     //! Function to check whether a partial w.r.t. some integrated state is non-zero.
     /*!
      * Function to check whether a partial w.r.t. some integrated state is non-zero.
@@ -118,7 +145,9 @@ public:
         bool isDependent = 0;
 
         // Check if state is translational.
-        if( integratedStateType == propagators::transational_state )
+        switch( integratedStateType )
+        {
+        case propagators::transational_state:
         {
             // Check if reference id is consistent.
             if( stateReferencePoint.second != "" )
@@ -132,6 +161,11 @@ public:
             {
                 isDependent = 1;
             }
+            break;
+        }
+        default:
+            isDependent = isStateDerivativeDependentOnIntegratedNonTranslationalState( stateReferencePoint, integratedStateType );
+            break;
         }
         return isDependent;
     }
@@ -263,6 +297,11 @@ public:
         wrtVelocityOfAdditionalBody( bodyName, partialMatrix, true, 0, 3 );
     }
 
+    virtual void wrtNonTranslationalStateOfAdditionalBody(
+            Eigen::Block< Eigen::MatrixXd > partialMatrix,
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType ) = 0;
+
     //! Function to check whether the partial derivative w.r.t. the translational state of a third body is non-zero.
     /*!
      * Function to check whether the partial derivative w.r.t. the translational state of a third body is non-zero. This
diff --git a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/centralGravityAccelerationPartial.h b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/centralGravityAccelerationPartial.h
index ac7a724..4601922 100644
--- a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/centralGravityAccelerationPartial.h
+++ b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/centralGravityAccelerationPartial.h
@@ -129,6 +129,23 @@ public:
         }
     }
 
+    void wrtNonTranslationalStateOfAdditionalBody(
+            Eigen::Block< Eigen::MatrixXd > partialMatrix,
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType ){ }
+
+    bool isStateDerivativeDependentOnIntegratedNonTranslationalState(
+                const std::pair< std::string, std::string >& stateReferencePoint,
+                const propagators::IntegratedStateType integratedStateType )
+    {
+        if( ( stateReferencePoint.first == acceleratingBody_ || stateReferencePoint.first == acceleratedBody_  )
+              && integratedStateType == propagators::body_mass_state )
+        {
+            std::cerr<<"Warning, dependency of central gravity on body masses not yet implemented"<<std::endl;
+        }
+        return 0;
+    }
+
     //! Function for setting up and retrieving a function returning a partial w.r.t. a double parameter.
     /*!
      *  Function for setting up and retrieving a function returning a partial w.r.t. a double parameter.
diff --git a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/radiationPressureAccelerationPartial.h b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/radiationPressureAccelerationPartial.h
index d2f30a5..49e6b0e 100644
--- a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/radiationPressureAccelerationPartial.h
+++ b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/radiationPressureAccelerationPartial.h
@@ -121,6 +121,32 @@ public:
         }
     }
 
+    void wrtNonTranslationalStateOfAdditionalBody(
+            Eigen::Block< Eigen::MatrixXd > partialMatrix,
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType )
+    {
+        if( stateReferencePoint.first == acceleratedBody_ && integratedStateType == propagators::body_mass_state )
+        {
+            partialMatrix.block( 0, 0, 3, 1 ) +=
+                    radiationPressureFunction_( ) * areaFunction_( ) * radiationPressureCoefficientFunction_( ) *
+                    ( sourceBodyState_( ) - acceleratedBodyState_( ) ).normalized( ) /
+                    ( acceleratedBodyMassFunction_( ) * acceleratedBodyMassFunction_( ) );
+        }
+    }
+
+    bool isStateDerivativeDependentOnIntegratedNonTranslationalState(
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType )
+    {
+        bool isDependent = 0;
+        if( stateReferencePoint.first == acceleratedBody_ && integratedStateType == propagators::body_mass_state )
+        {
+            isDependent = 1;
+        }
+        return isDependent;
+    }
+
     //! Function for setting up and retrieving a function returning a partial w.r.t. a double parameter.
     /*!
      *  Function for setting up and retrieving a function returning a partial w.r.t. a double parameter.
diff --git a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/thirdBodyGravityPartial.h b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/thirdBodyGravityPartial.h
index 3d3e22a..9ccb78e 100644
--- a/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/thirdBodyGravityPartial.h
+++ b/Tudat/Astrodynamics/OrbitDetermination/AccelerationPartials/thirdBodyGravityPartial.h
@@ -255,6 +255,41 @@ public:
         return isAccelerationDependentOnBody;
     }
 
+
+    void wrtNonTranslationalStateOfAdditionalBody(
+            Eigen::Block< Eigen::MatrixXd > partialMatrix,
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType )
+    {
+        partialOfDirectGravityOnCentralBody_->
+                        wrtNonTranslationalStateOfAdditionalBody(
+                            partialMatrix, stateReferencePoint, integratedStateType );
+        partialOfDirectGravityOnBodyUndergoingAcceleration_->
+                        wrtNonTranslationalStateOfAdditionalBody(
+                            partialMatrix, stateReferencePoint, integratedStateType );
+    }
+
+    bool isStateDerivativeDependentOnIntegratedNonTranslationalState(
+            const std::pair< std::string, std::string >& stateReferencePoint,
+            const propagators::IntegratedStateType integratedStateType )
+    {
+        if( partialOfDirectGravityOnCentralBody_->
+                isStateDerivativeDependentOnIntegratedNonTranslationalState(
+                    stateReferencePoint, integratedStateType ) ||
+                partialOfDirectGravityOnBodyUndergoingAcceleration_->
+                isStateDerivativeDependentOnIntegratedNonTranslationalState(
+                    stateReferencePoint, integratedStateType ) )
+        {
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+
+
     //! Function for setting up and retrieving a function returning a partial w.r.t. a double parameter.
     /*!
      *  Function for setting up and retrieving a function returning a partial w.r.t. a double parameter.
diff --git a/Tudat/Astrodynamics/OrbitDetermination/stateDerivativePartial.h b/Tudat/Astrodynamics/OrbitDetermination/stateDerivativePartial.h
index be9bcd5..2d86c37 100644
--- a/Tudat/Astrodynamics/OrbitDetermination/stateDerivativePartial.h
+++ b/Tudat/Astrodynamics/OrbitDetermination/stateDerivativePartial.h
@@ -75,7 +75,7 @@ public:
      * \param integratedStateType Type of propagated state.
      * \return True if dependency exists, false otherwise.
      */
-    virtual bool isStateDerivativeDependentOnIntegratedState(
+    virtual bool isStateDerivativeDependentOnIntegratedNonTranslationalState(
             const std::pair< std::string, std::string >& stateReferencePoint,
             const propagators::IntegratedStateType integratedStateType ) = 0;
 
diff --git a/Tudat/Astrodynamics/Propagators/CMakeLists.txt b/Tudat/Astrodynamics/Propagators/CMakeLists.txt
index f173171..1413d90 100644
--- a/Tudat/Astrodynamics/Propagators/CMakeLists.txt
+++ b/Tudat/Astrodynamics/Propagators/CMakeLists.txt
@@ -101,6 +101,10 @@ add_executable(test_SequentialVariationEquationIntegration "${SRCROOT}${PROPAGAT
 setup_custom_test_program(test_SequentialVariationEquationIntegration "${SRCROOT}${PROPAGATORSDIR}")
 target_link_libraries(test_SequentialVariationEquationIntegration tudat_simulation_setup tudat_propagators tudat_acceleration_partials tudat_estimatable_parameters tudat_orbit_determination tudat_aerodynamics tudat_geometric_shapes tudat_gravitation tudat_mission_segments tudat_electro_magnetism tudat_ephemerides tudat_numerical_integrators tudat_reference_frames tudat_basic_astrodynamics tudat_input_output tudat_basic_mathematics tudat_propagators tudat_spice_interface cspice ${Boost_LIBRARIES})
 
+add_executable(test_VariationalEquations "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestVariationalEquationPropagation.cpp")
+setup_custom_test_program(test_VariationalEquations "${SRCROOT}${PROPAGATORSDIR}")
+target_link_libraries(test_VariationalEquations tudat_simulation_setup tudat_propagators tudat_acceleration_partials tudat_estimatable_parameters tudat_orbit_determination tudat_aerodynamics tudat_geometric_shapes tudat_gravitation tudat_mission_segments tudat_electro_magnetism tudat_ephemerides tudat_numerical_integrators tudat_reference_frames tudat_basic_astrodynamics tudat_input_output tudat_basic_mathematics tudat_propagators tudat_spice_interface cspice ${Boost_LIBRARIES})
+
 add_executable(test_EnvironmentModelUpdater
     "${SRCROOT}${PROPAGATORSDIR}/UnitTests/unitTestEnvironmentUpdater.cpp")
 setup_custom_test_program(test_EnvironmentModelUpdater "${SRCROOT}${PROPAGATORSDIR}")
diff --git a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestSequentialVariationalEquationIntegration.cpp b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestSequentialVariationalEquationIntegration.cpp
index a09ca8f..2ff1cf9 100644
--- a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestSequentialVariationalEquationIntegration.cpp
+++ b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestSequentialVariationalEquationIntegration.cpp
@@ -197,8 +197,8 @@ BOOST_AUTO_TEST_CASE( testSequentialVariationalEquationIntegration )
     std::pair< boost::shared_ptr< CombinedStateTransitionAndSensitivityMatrixInterface >, boost::shared_ptr< Ephemeris > >
             sequentialResult = integrateEquations( 1 );
 
-    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( concurrentResult.first->getCombinesStateTransitionAndSensitivityMatrix( 1.0E7 + 14.0 * 80000.0 ),
-                                       sequentialResult.first->getCombinesStateTransitionAndSensitivityMatrix( 1.0E7 + 14.0 * 80000.0 ), 2.0E-6 );
+    TUDAT_CHECK_MATRIX_CLOSE_FRACTION( concurrentResult.first->getCombinedStateTransitionAndSensitivityMatrix( 1.0E7 + 14.0 * 80000.0 ),
+                                       sequentialResult.first->getCombinedStateTransitionAndSensitivityMatrix( 1.0E7 + 14.0 * 80000.0 ), 2.0E-6 );
 
     TUDAT_CHECK_MATRIX_CLOSE_FRACTION( concurrentResult.second->getCartesianStateFromEphemeris( 1.0E7 + 14.0 * 80000.0 ),
                                        sequentialResult.second->getCartesianStateFromEphemeris( 1.0E7 + 14.0 * 80000.0 ),
diff --git a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestVariationalEquationPropagation.cpp b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestVariationalEquationPropagation.cpp
index 5ea974d..b622d32 100644
--- a/Tudat/Astrodynamics/Propagators/UnitTests/unitTestVariationalEquationPropagation.cpp
+++ b/Tudat/Astrodynamics/Propagators/UnitTests/unitTestVariationalEquationPropagation.cpp
@@ -46,7 +46,7 @@ BOOST_AUTO_TEST_SUITE( testVariationalEquationCalculation )
 template< typename TimeType = double , typename StateScalarType  = double >
         std::pair< std::vector< Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > >,
 std::vector< Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > >
-execute( const std::vector< std::string > centralBodies,
+executeEarthMoonSimulation( const std::vector< std::string > centralBodies,
          const Eigen::Matrix< StateScalarType, 12, 1 > initialStateDifference = Eigen::Matrix< StateScalarType, 12, 1 >::Zero( ) )
 {
 
@@ -171,13 +171,13 @@ execute( const std::vector< std::string > centralBodies,
         testStates.block( 6, 0, 6, 1 ) = bodyMap[ "Earth" ]->getStateInBaseFrameFromEphemeris( testEpoch );
         //testStates.block( 12, 0, 6, 1 ) = bodyMap[ "Sun" ]->getStateInBaseFrameFromEphemeris( testEpoch );
 
-        results.first.push_back( dynamicsSimulator.getStateTransitionMatrixInterface( )->getCombinesStateTransitionAndSensitivityMatrix( testEpoch ) );
+        results.first.push_back( dynamicsSimulator.getStateTransitionMatrixInterface( )->getCombinedStateTransitionAndSensitivityMatrix( testEpoch ) );
         results.second.push_back( testStates );
     }
     return results;
 }
 
-BOOST_AUTO_TEST_CASE( test_variational_equation_calculation )
+BOOST_AUTO_TEST_CASE( test_earth_moon_variational_equation_calculation )
 {
     std::pair< std::vector< Eigen::MatrixXd >, std::vector< Eigen::VectorXd > > currentOutput;
 
@@ -205,7 +205,7 @@ BOOST_AUTO_TEST_CASE( test_variational_equation_calculation )
     {
         std::cout<<"test"<<std::endl;
 
-        currentOutput = execute< double, double >( centralBodiesSet[ i ] );
+        currentOutput = executeEarthMoonSimulation< double, double >( centralBodiesSet[ i ] );
         Eigen::MatrixXd stateTransitionMatrixAtEpoch = currentOutput.first.at( 0 );
         Eigen::MatrixXd manualPartial = Eigen::MatrixXd::Zero( 12, 12 );
         if( i == 0 )
@@ -223,18 +223,15 @@ BOOST_AUTO_TEST_CASE( test_variational_equation_calculation )
             Eigen::VectorXd upPerturbedState, downPerturbedState;
             perturbedState.setZero( );
             perturbedState( j ) += statePerturbation( j );
-            upPerturbedState = execute< double, double >( centralBodiesSet[ i ], perturbedState ).second.at( 0 );
+            upPerturbedState = executeEarthMoonSimulation< double, double >( centralBodiesSet[ i ], perturbedState ).second.at( 0 );
 
             perturbedState.setZero( );
             perturbedState( j ) -= statePerturbation( j );
-            downPerturbedState = execute< double, double >( centralBodiesSet[ i ], perturbedState ).second.at( 0 );
+            downPerturbedState = executeEarthMoonSimulation< double, double >( centralBodiesSet[ i ], perturbedState ).second.at( 0 );
             manualPartial.block( 0, j, 12, 1 ) = ( upPerturbedState - downPerturbedState ) / ( 2.0 * statePerturbation( j ) );
         }
 
         TUDAT_CHECK_MATRIX_CLOSE_FRACTION( stateTransitionMatrixAtEpoch.block( 0, 0, 12, 12 ), manualPartial, 1.0E-3 );
-
-        std::cout<<(stateTransitionMatrixAtEpoch.block( 0, 0, 12, 12 ) - manualPartial ).cwiseQuotient( manualPartial )<<std::endl;
-
     }
 }
 
diff --git a/Tudat/Astrodynamics/Propagators/dynamicsSimulator.h b/Tudat/Astrodynamics/Propagators/dynamicsSimulator.h
index 5e778eb..3c73309 100644
--- a/Tudat/Astrodynamics/Propagators/dynamicsSimulator.h
+++ b/Tudat/Astrodynamics/Propagators/dynamicsSimulator.h
@@ -144,7 +144,7 @@ Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > getInitialStateOfBody(
  *  dynamical system. Governing equations are set once,
  *  but can be re-integrated for different initial conditions using the same instance of the class.
  *  Derived classes define the specific kind of integration that is performed
- *  (single-arc/multi-arc; dynamics/variational equations, etc.)
+ *  (single-arc/multi-arc/etc.)
  */
 template< typename StateScalarType = double, typename TimeType = double >
 class DynamicsSimulator
@@ -366,7 +366,7 @@ protected:
 
 };
 
-//! Class for performing full numerical integration of a dynamical system in a single arc..
+//! Class for performing full numerical integration of a dynamical system in a single arc.
 /*!
  *  Class for performing full numerical integration of a dynamical system in a single arc, i.e. the
  *  equations of motion have a single initial time, and are propagated once for the full prescribed
diff --git a/Tudat/Astrodynamics/Propagators/dynamicsStateDerivativeModel.h b/Tudat/Astrodynamics/Propagators/dynamicsStateDerivativeModel.h
index 08bc9ae..6f44cfa 100644
--- a/Tudat/Astrodynamics/Propagators/dynamicsStateDerivativeModel.h
+++ b/Tudat/Astrodynamics/Propagators/dynamicsStateDerivativeModel.h
@@ -53,11 +53,10 @@ public:
     /*!
      *  Derivative model constructor. Takes state derivative model and environment
      *  updater. Constructor checks whether all models use the same environment updater.     
-     *  \param stateDerivativeModels Vector of state derivative models, with one entry for each type
-     *         of dynamical equation.
-     *  \param environmentUpdater Object which is used to update time-dependent environment models
-     *         to current time and state,
+     *  \param stateDerivativeModels Vector of state derivative models, with one entry for each type of dynamical equation.
+     *  \param environmentUpdater Object which is used to update time-dependent environment models to current time and state,
      *  must be consistent with member environment updaters of stateDerivativeModels entries.
+     *  \param variationalEquations Object used for computing the state derivative in the variational equations
      */
     DynamicsStateDerivativeModel(
             const std::vector< boost::shared_ptr< SingleStateTypeDerivative< StateScalarType, TimeType > > >
@@ -322,6 +321,11 @@ public:
         return convertedSolution;
     }
 
+    //! Function to add variational equations to the state derivative model
+    /*!
+     * Function to add variational equations to the state derivative model.
+     * \param variationalEquations Object used for computing the state derivative in the variational equations
+     */
     void addVariationalEquations( boost::shared_ptr< VariationalEquations > variationalEquations )
     {
         variationalEquations_ = variationalEquations;
@@ -355,10 +359,17 @@ public:
         }
     }
 
+    //! Function to update the settings of the state derivative models with new initial states
+    /*!
+     * Function to update the settings of the state derivative models with new initial states. This function is
+     * called when using, for instance and Encke propagator for the translational dynamics, and the reference orbits
+     * are modified.
+     * \param initialBodyStates New initial state for the full propagated dynamics.
+     */
     void updateStateDerivativeModelSettings(
-            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > initialBodyStates,
-            const int currentStateArcIndex )
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > initialBodyStates )
     {
+        // Iterate over all dynamics types
         for( stateDerivativeModelsIterator_ = stateDerivativeModels_.begin( ); stateDerivativeModelsIterator_ != stateDerivativeModels_.end( );
              stateDerivativeModelsIterator_++ )
         {
@@ -376,12 +387,15 @@ public:
                     case cowell:
                         break;
                     default:
-                        throw std::runtime_error( "Error when updating state derivative model settings, did not recognize propagator type" );
+                        throw std::runtime_error( "Error when updating state derivative model settings, did not recognize translational propagator type" );
                         break;
                     }
                 }
             }
+            case body_mass_state:
+                break;
             default:
+                throw std::runtime_error( "Error when updating state derivative model settings, did not recognize dynamics type" );
                 break;
             }
         }
@@ -467,6 +481,7 @@ private:
     //! Object used to update the environment to the current state and time.
     boost::shared_ptr< EnvironmentUpdater< StateScalarType, TimeType > > environmentUpdater_;
 
+    //! Object used for computing the state derivative in the variational equations
     boost::shared_ptr< VariationalEquations > variationalEquations_;
 
     //! Map that denotes for each state derivative model the start index and size of the associated
diff --git a/Tudat/Astrodynamics/Propagators/setNumericallyIntegratedStates.h b/Tudat/Astrodynamics/Propagators/setNumericallyIntegratedStates.h
index 288107c..a698ad8 100644
--- a/Tudat/Astrodynamics/Propagators/setNumericallyIntegratedStates.h
+++ b/Tudat/Astrodynamics/Propagators/setNumericallyIntegratedStates.h
@@ -441,7 +441,7 @@ public:
             const simulation_setup::NamedBodyMap& bodyMap,
             const std::vector< std::string >& bodiesToIntegrate ):
         IntegratedStateProcessor<  TimeType, StateScalarType >(
-            transational_state, std::make_pair( startIndex, bodiesToIntegrate.size( ) ) ),
+            body_mass_state, std::make_pair( startIndex, bodiesToIntegrate.size( ) ) ),
         bodyMap_( bodyMap ), bodiesToIntegrate_( bodiesToIntegrate )
     { }
 
diff --git a/Tudat/Astrodynamics/Propagators/stateTransitionMatrixInterface.cpp b/Tudat/Astrodynamics/Propagators/stateTransitionMatrixInterface.cpp
index 1264cec..641dad5 100644
--- a/Tudat/Astrodynamics/Propagators/stateTransitionMatrixInterface.cpp
+++ b/Tudat/Astrodynamics/Propagators/stateTransitionMatrixInterface.cpp
@@ -8,35 +8,34 @@ namespace tudat
 namespace propagators
 {
 
+//! Function to reset the state transition and sensitivity matrix interpolators
+void SingleArcCombinedStateTransitionAndSensitivityMatrixInterface::updateMatrixInterpolators(
+        const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > > stateTransitionMatrixInterpolator,
+        const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > > sensitivityMatrixInterpolator )
+{
+    stateTransitionMatrixInterpolator_ = stateTransitionMatrixInterpolator;
+    sensitivityMatrixInterpolator_ = sensitivityMatrixInterpolator;
+}
 
-    void SingleArcCombinedStateTransitionAndSensitivityMatrixInterface::updateMatrixInterpolators(
-            const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > > stateTransitionMatrixInterpolator,
-            const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > > sensitivityMatrixInterpolator )
-    {
-        stateTransitionMatrixInterpolator_ = stateTransitionMatrixInterpolator;
-        sensitivityMatrixInterpolator_ = sensitivityMatrixInterpolator;
-    }
+//! Function to get the concatenated state transition and sensitivity matrix at a given time.
+Eigen::MatrixXd SingleArcCombinedStateTransitionAndSensitivityMatrixInterface::getCombinedStateTransitionAndSensitivityMatrix(
+        const double evaluationTime )
+{
+    combinedStateTransitionMatrix_.setZero( );
 
+    // Set Phi and S matrices.
+    combinedStateTransitionMatrix_.block( 0, 0, stateTransitionMatrixSize_, stateTransitionMatrixSize_ ) =
+            stateTransitionMatrixInterpolator_->interpolate( evaluationTime );
 
-    Eigen::MatrixXd SingleArcCombinedStateTransitionAndSensitivityMatrixInterface::getCombinesStateTransitionAndSensitivityMatrix(
-            const double evaluationTime )
+    if( sensitivityMatrixSize_ > 0 )
     {
-        Eigen::MatrixXd combinedStateTransitionMatrix = Eigen::MatrixXd::Zero(
-                    stateTransitionMatrixSize_, stateTransitionMatrixSize_ + sensitivityMatrixSize_ );
-
-        // Set Phi and S matrices.
-        combinedStateTransitionMatrix.block( 0, 0, stateTransitionMatrixSize_, stateTransitionMatrixSize_ ) =
-                stateTransitionMatrixInterpolator_->interpolate( evaluationTime );
-
-        if( sensitivityMatrixSize_ > 0 )
-        {
-            combinedStateTransitionMatrix.block( 0, stateTransitionMatrixSize_, stateTransitionMatrixSize_, sensitivityMatrixSize_ ) =
-                    sensitivityMatrixInterpolator_->interpolate( evaluationTime );
-        }
-
-        return combinedStateTransitionMatrix;
+        combinedStateTransitionMatrix_.block( 0, stateTransitionMatrixSize_, stateTransitionMatrixSize_, sensitivityMatrixSize_ ) =
+                sensitivityMatrixInterpolator_->interpolate( evaluationTime );
     }
 
+    return combinedStateTransitionMatrix_;
+}
+
 }
 
 }
diff --git a/Tudat/Astrodynamics/Propagators/stateTransitionMatrixInterface.h b/Tudat/Astrodynamics/Propagators/stateTransitionMatrixInterface.h
index b93297a..b68128b 100644
--- a/Tudat/Astrodynamics/Propagators/stateTransitionMatrixInterface.h
+++ b/Tudat/Astrodynamics/Propagators/stateTransitionMatrixInterface.h
@@ -15,10 +15,22 @@ namespace tudat
 namespace propagators
 {
 
-
+//! Base class for interface object of interpolation of numerically propagated state transition and sensitivity matrices.
+/*!
+ *  Base class for interface object of interpolation of numerically propagated state transition and sensitivity matrices.
+ *  Derived classes implement the case of single-arc/multi-arc/combined dynamics.
+ */
 class CombinedStateTransitionAndSensitivityMatrixInterface
 {
 public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param numberOfInitialDynamicalParameters Size of the estimated initial state vector (and size of square
+     * state transition matrix.
+     * \param numberOfParameters Total number of estimated parameters (initial states and other parameters).
+     */
     CombinedStateTransitionAndSensitivityMatrixInterface(
             const int numberOfInitialDynamicalParameters,
             const int numberOfParameters )
@@ -27,69 +39,157 @@ public:
         sensitivityMatrixSize_ = numberOfParameters - stateTransitionMatrixSize_;
     }
 
+    //! Destructor.
     virtual ~CombinedStateTransitionAndSensitivityMatrixInterface( ){ }
 
-    virtual Eigen::MatrixXd getCombinesStateTransitionAndSensitivityMatrix( const double evaluationTime ) = 0;
-
-    //! Includes zeros for parameters not in current arc.
-    virtual Eigen::MatrixXd getFullCombinesStateTransitionAndSensitivityMatrix( const double evaluationTime )
-    {
-        return getCombinesStateTransitionAndSensitivityMatrix( evaluationTime );
-    }
-
+    //! Function to get the concatenated state transition and sensitivity matrix at a given time.
+    /*!
+     *  Function to get the concatenated state transition and sensitivity matrix at a given time.
+     *  \param evaluationTime Time at which to evaluate matrix interpolators
+     *  \return Concatenated state transition and sensitivity matrices.
+     */
+    virtual Eigen::MatrixXd getCombinedStateTransitionAndSensitivityMatrix( const double evaluationTime ) = 0;
+
+    //! Function to get the concatenated state transition and sensitivity matrix at a given time, which includes
+    //! zero values for parameters not active in current arc.
+    /*!
+     *  Function to get the concatenated state transition and sensitivity matrix at a given time, which includes
+     *  zero values for parameters not active in current arc.
+     *  \param evaluationTime Time at which to evaluate matrix interpolators
+     *  \return Concatenated state transition and sensitivity matrices, including inactive parameters at
+     *  evaluationTime.
+     */
+    virtual Eigen::MatrixXd getFullCombinedStateTransitionAndSensitivityMatrix( const double evaluationTime ) = 0;
+
+    //! Function to get the size of state transition matrix
+    /*!
+     * Function to get the size of state transition matrix
+     * \return Size of state transition matrix
+     */
     int getStateTransitionMatrixSize( )
     {
         return stateTransitionMatrixSize_;
     }
 
+    //! Function to get the number of columns of sensitivity matrix.
+    /*!
+     * Function to get the number of columns of sensitivity matrix.
+     * \return Number of columns of sensitivity matrix.
+     */
     int getSensitivityMatrixSize( )
     {
         return sensitivityMatrixSize_;
     }
 
+    //! Function to get the size of the total parameter vector.
+    /*!
+     * Function to get the size of the total parameter vector (both global and all local parameters).
+     * \return Size of the total parameter vector.
+     */
     virtual int getFullParameterVectorSize( ) = 0;
 
 protected:
 
+    //! Size of state transition matrix
     int stateTransitionMatrixSize_;
 
+    //! Number of columns of sensitivity matrix.
     int sensitivityMatrixSize_;
 
 };
 
-class SingleArcCombinedStateTransitionAndSensitivityMatrixInterface: public CombinedStateTransitionAndSensitivityMatrixInterface
+//! Interface object of interpolation of numerically propagated state transition and sensitivity matrices for single-arc
+//! estimation.
+class SingleArcCombinedStateTransitionAndSensitivityMatrixInterface:
+        public CombinedStateTransitionAndSensitivityMatrixInterface
 {
 public:
+
+    //! Constructor
+    /*!
+     * Constructor
+     * \param stateTransitionMatrixInterpolator Interpolator returning the state transition matrix as a function of time.
+     * \param sensitivityMatrixInterpolator Interpolator returning the sensitivity matrix as a function of time.
+     * \param numberOfInitialDynamicalParameters Size of the estimated initial state vector (and size of square
+     * state transition matrix.
+     * \param numberOfParameters Total number of estimated parameters (initial states and other parameters).
+     */
     SingleArcCombinedStateTransitionAndSensitivityMatrixInterface(
-            const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > > stateTransitionMatrixInterpolator,
-            const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > > sensitivityMatrixInterpolator,
+            const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+            stateTransitionMatrixInterpolator,
+            const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+            sensitivityMatrixInterpolator,
             const int numberOfInitialDynamicalParameters,
             const int numberOfParameters ):
         CombinedStateTransitionAndSensitivityMatrixInterface( numberOfInitialDynamicalParameters, numberOfParameters ),
         stateTransitionMatrixInterpolator_( stateTransitionMatrixInterpolator ),
         sensitivityMatrixInterpolator_( sensitivityMatrixInterpolator )
-    { }
+    {
+        combinedStateTransitionMatrix_ = Eigen::MatrixXd::Zero(
+                        stateTransitionMatrixSize_, stateTransitionMatrixSize_ + sensitivityMatrixSize_ );
+    }
 
     ~SingleArcCombinedStateTransitionAndSensitivityMatrixInterface( ){ }
 
+    //! Function to reset the state transition and sensitivity matrix interpolators
+    /*!
+     * Function to reset the state transition and sensitivity matrix interpolators
+     * \param stateTransitionMatrixInterpolator New interpolator returning the state transition matrix as a function of time.
+     * \param sensitivityMatrixInterpolator New interpolator returning the sensitivity matrix as a function of time.
+     */
     void updateMatrixInterpolators(
-            const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > > stateTransitionMatrixInterpolator,
-            const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > > sensitivityMatrixInterpolator );
-
+            const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+            stateTransitionMatrixInterpolator,
+            const boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+            sensitivityMatrixInterpolator );
+
+    //! Function to get the interpolator returning the state transition matrix as a function of time.
+    /*!
+     * \brief Function to get the interpolator returning the state transition matrix as a function of time.
+     * \return Interpolator returning the state transition matrix as a function of time.
+     */
     boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
     getStateTransitionMatrixInterpolator( )
     {
         return stateTransitionMatrixInterpolator_;
     }
 
+    //! Function to get the interpolator returning the sensitivity matrix as a function of time.
+    /*!
+     * \brief Function to get the interpolator returning the sensitivity matrix as a function of time.
+     * \return Interpolator returning the sensitivity matrix as a function of time.
+     */
     boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
     getSensitivityMatrixInterpolator( )
     {
         return sensitivityMatrixInterpolator_;
     }
+    //! Function to get the concatenated state transition and sensitivity matrix at a given time.
+    /*!
+     *  Function to get the concatenated state transition and sensitivity matrix at a given time.
+     *  \param evaluationTime Time at which to evaluate matrix interpolators
+     *  \return Concatenated state transition and sensitivity matrices.
+     */
+    Eigen::MatrixXd getCombinedStateTransitionAndSensitivityMatrix( const double evaluationTime );
+
+    //! Function to get the concatenated state transition and sensitivity matrix at a given time.
+    /*!
+     *  Function to get the concatenated state transition and sensitivity matrix at a given time
+     *  (functionality equal to getCombinedStateTransitionAndSensitivityMatrix for single-arc case).
+     *  \param evaluationTime Time at which to evaluate matrix interpolators
+     *  \return Concatenated state transition and sensitivity matrices.
+     */
+    Eigen::MatrixXd getFullCombinedStateTransitionAndSensitivityMatrix( const double evaluationTime )
+    {
+        return getCombinedStateTransitionAndSensitivityMatrix( evaluationTime );
+    }
 
-    Eigen::MatrixXd getCombinesStateTransitionAndSensitivityMatrix( const double evaluationTime );
-
+    //! Function to get the size of the total parameter vector.
+    /*!
+     * Function to get the size of the total parameter vector. For single-arc, this is simply the combination of
+     * the size of the state transition and sensitivity matrices.
+     * \return Size of the total parameter vector.
+     */
     int getFullParameterVectorSize( )
     {
         return sensitivityMatrixSize_ + stateTransitionMatrixSize_;
@@ -98,9 +198,16 @@ public:
 
 private:
 
-    boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > > stateTransitionMatrixInterpolator_;
+    //! Predefined matrix to use as return value when calling getCombinedStateTransitionAndSensitivityMatrix.
+    Eigen::MatrixXd combinedStateTransitionMatrix_;
+
+    //! Interpolator returning the state transition matrix as a function of time.
+    boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+    stateTransitionMatrixInterpolator_;
 
-    boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > > sensitivityMatrixInterpolator_;
+    //! Interpolator returning the sensitivity matrix as a function of time.
+    boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+    sensitivityMatrixInterpolator_;
 };
 
 }
diff --git a/Tudat/Astrodynamics/Propagators/variationalEquations.cpp b/Tudat/Astrodynamics/Propagators/variationalEquations.cpp
index f6b346a..dc03339 100644
--- a/Tudat/Astrodynamics/Propagators/variationalEquations.cpp
+++ b/Tudat/Astrodynamics/Propagators/variationalEquations.cpp
@@ -14,9 +14,6 @@ namespace tudat
 namespace propagators
 {
 
-using orbit_determination::partial_derivatives::StateDerivativePartialsMap;
-using namespace tudat::estimatable_parameters;
-
 //! Calculates matrix containing partial derivatives of state derivatives w.r.t. body state.
 void VariationalEquations::setBodyStatePartialMatrix( )
 {
@@ -35,22 +32,25 @@ void VariationalEquations::setBodyStatePartialMatrix( )
     }
 
     // Iterate over all bodies undergoing accelerations for which initial condition is to be estimated.
-    for( std::map< IntegratedStateType, std::vector< std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > > > >::iterator
+    for( std::map< IntegratedStateType, std::vector< std::multimap< std::pair< int, int >,
+         boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > > > >::iterator
          typeIterator = statePartialList_.begin( ); typeIterator != statePartialList_.end( ); typeIterator++ )
     {
         int startIndex = stateTypeStartIndices_.at( typeIterator->first );
         int currentStateSize = getSingleIntegrationSize( typeIterator->first );
-        int entriesToSkipPerEntry = currentStateSize - currentStateSize / getSingleIntegrationDifferentialEquationOrder( typeIterator->first );
+        int entriesToSkipPerEntry = currentStateSize - currentStateSize /
+                getSingleIntegrationDifferentialEquationOrder( typeIterator->first );
         for( unsigned int i = 0; i < typeIterator->second.size( ); i++ )
         {
             // Iterate over all bodies exerting an acceleration on this body.
-            for( statePartialIterator_ = typeIterator->second.at( i ).begin( ); statePartialIterator_ != typeIterator->second.at( i ).end( );
+            for( statePartialIterator_ = typeIterator->second.at( i ).begin( );
+                 statePartialIterator_ != typeIterator->second.at( i ).end( );
                  statePartialIterator_++ )
             {
                 statePartialIterator_->second(
                             variationalMatrix_.block(
-                                        startIndex + entriesToSkipPerEntry + i * currentStateSize, statePartialIterator_->first.first,
-                                        currentStateSize - entriesToSkipPerEntry, statePartialIterator_->first.second ) );
+                                startIndex + entriesToSkipPerEntry + i* currentStateSize, statePartialIterator_->first.first,
+                                currentStateSize - entriesToSkipPerEntry, statePartialIterator_->first.second ) );
 
             }
         }
@@ -65,10 +65,10 @@ void VariationalEquations::setBodyStatePartialMatrix( )
 
 
 //! This function updates all state derivative models to the current time and state.
-
 void VariationalEquations::updatePartials( const double currentTime )
 {
-    for( stateDerivativeTypeIterator_ = stateDerivativePartialList_.begin( ); stateDerivativeTypeIterator_ != stateDerivativePartialList_.end( );
+    for( stateDerivativeTypeIterator_ = stateDerivativePartialList_.begin( );
+         stateDerivativeTypeIterator_ != stateDerivativePartialList_.end( );
          stateDerivativeTypeIterator_++ )
     {
         for( unsigned int i = 0; i < stateDerivativeTypeIterator_->second.size( ); i++ )
@@ -83,7 +83,8 @@ void VariationalEquations::updatePartials( const double currentTime )
 
     // Update all acceleration partials to current state and time. Information is passed indirectly from here, through
     // (function) pointers set in acceleration partial classes
-    for( stateDerivativeTypeIterator_ = stateDerivativePartialList_.begin( ); stateDerivativeTypeIterator_ != stateDerivativePartialList_.end( );
+    for( stateDerivativeTypeIterator_ = stateDerivativePartialList_.begin( );
+         stateDerivativeTypeIterator_ != stateDerivativePartialList_.end( );
          stateDerivativeTypeIterator_++ )
     {
         for( unsigned int i = 0; i < stateDerivativeTypeIterator_->second.size( ); i++ )
@@ -96,7 +97,8 @@ void VariationalEquations::updatePartials( const double currentTime )
         }
     }
 
-    for( stateDerivativeTypeIterator_ = stateDerivativePartialList_.begin( ); stateDerivativeTypeIterator_ != stateDerivativePartialList_.end( );
+    for( stateDerivativeTypeIterator_ = stateDerivativePartialList_.begin( );
+         stateDerivativeTypeIterator_ != stateDerivativePartialList_.end( );
          stateDerivativeTypeIterator_++ )
     {
         for( unsigned int i = 0; i < stateDerivativeTypeIterator_->second.size( ); i++ )
@@ -109,26 +111,34 @@ void VariationalEquations::updatePartials( const double currentTime )
         }
     }
 }
-
+\
+//! Function (called by constructor) to set up the statePartialList_ member from the state derivative partials
 void VariationalEquations::setStatePartialFunctionList( )
 {
     using namespace orbit_determination::partial_derivatives;
 
     std::pair< boost::function< void( Eigen::Block< Eigen::MatrixXd > ) >, int > currentDerivativeFunction;
 
-    for( std::map< propagators::IntegratedStateType, orbit_determination::partial_derivatives::StateDerivativePartialsMap >::iterator
-         stateDerivativeTypeIterator_ = stateDerivativePartialList_.begin( ); stateDerivativeTypeIterator_ != stateDerivativePartialList_.end( );
+    // Iterate over all state types
+    for( std::map< propagators::IntegratedStateType,
+         orbit_determination::partial_derivatives::StateDerivativePartialsMap >::iterator
+         stateDerivativeTypeIterator_ = stateDerivativePartialList_.begin( );
+         stateDerivativeTypeIterator_ != stateDerivativePartialList_.end( );
          stateDerivativeTypeIterator_++ )
     {
-        // Iterate over all bodies undergoing accelerations for which initial condition is to be estimated.
+        // Iterate over all bodies undergoing 'accelerations' for which initial state is to be estimated.
         for( unsigned int i = 0; i < stateDerivativeTypeIterator_->second.size( ); i++ )
         {
-            std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > > currentBodyPartialList;
-            // Iterate over all accelerations from single body on other single body
+            std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > >
+                    currentBodyPartialList;
+
+            // Iterate over all 'accelerations' from single body on other single body
             for( unsigned int j = 0; j < stateDerivativeTypeIterator_->second.at( i ).size( ); j++ )
             {
-                for( std::map< propagators::IntegratedStateType, std::vector< std::pair< std::string, std::string > > >::iterator
-                     estimatedStateIterator = dynamicalStatesToEstimate_.begin( ); estimatedStateIterator != dynamicalStatesToEstimate_.end( );
+                for( std::map< propagators::IntegratedStateType,
+                     std::vector< std::pair< std::string, std::string > > >::iterator
+                     estimatedStateIterator = dynamicalStatesToEstimate_.begin( );
+                     estimatedStateIterator != dynamicalStatesToEstimate_.end( );
                      estimatedStateIterator++ )
                 {
                     // Iterate over all bodies to see if body exerting acceleration is also to be estimated (cross-terms)
@@ -138,6 +148,7 @@ void VariationalEquations::setStatePartialFunctionList( )
                                 getDerivativeFunctionWrtStateOfIntegratedBody(
                                     estimatedStateIterator->second.at( k ), estimatedStateIterator->first );
 
+                        // If function is not-empty: add to list.
                         if( currentDerivativeFunction.second != 0 )
                         {
                             currentBodyPartialList.insert(
diff --git a/Tudat/Astrodynamics/Propagators/variationalEquations.h b/Tudat/Astrodynamics/Propagators/variationalEquations.h
index 4353728..b575e87 100644
--- a/Tudat/Astrodynamics/Propagators/variationalEquations.h
+++ b/Tudat/Astrodynamics/Propagators/variationalEquations.h
@@ -24,6 +24,13 @@ namespace propagators
 {
 
 //! Class from which the variational equations can be evaluated.
+/*!
+ *  Class from which the variational equations can be evaluated. The time derivative of the state transition  and
+ *  sensitivity matrices are computed from a set of state derivative partials objects, at the current time and state.
+ *  This class performs all required bookkeeping to update, evaluate and combine these state derivative partials into
+ *  the variational equations. The VariationalEquationsSolver object is used to manage and execute the full numerical
+ *  integration of these variational equations and equations of motion.
+ */
 class VariationalEquations
 {
     
@@ -36,8 +43,8 @@ public:
      * \param stateDerivativePartialList List partials of state derivative models from which the variational equations
      * are set up. The key is the type of dynamics for which partials are taken, the values are StateDerivativePartialsMap
      * (see StateDerivativePartialsMap definition for details)
-     *  \param parametersToEstimate Object containing all parameters that are to be estimated and their current settings and
-     *  values.
+     * \param parametersToEstimate Object containing all parameters that are to be estimated and their current settings and
+     * values.
      * \param stateTypeStartIndices Start index (value) in vector of propagated state for each type of state (key)
      */
     template< typename ParameterType >
@@ -46,36 +53,40 @@ public:
             stateDerivativePartialList,
             const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > parametersToEstimate,
             const std::map< IntegratedStateType, int >& stateTypeStartIndices ):
-        stateDerivativePartialList_( stateDerivativePartialList ), stateTypeStartIndices_( stateTypeStartIndices ),
-        estimatedUnintegratedBodies_( std::vector< std::string >( ) )
+        stateDerivativePartialList_( stateDerivativePartialList ), stateTypeStartIndices_( stateTypeStartIndices )
     {
-        dynamicalStatesToEstimate_ = estimatable_parameters::getListOfInitialDynamicalStateParametersEstimate< ParameterType >(
+        dynamicalStatesToEstimate_ =
+                estimatable_parameters::getListOfInitialDynamicalStateParametersEstimate< ParameterType >(
                     parametersToEstimate );
         
         // Get size of dynamical state to estimate
         numberOfParameterValues_ = estimatable_parameters::getSingleArcParameterSetSize( parametersToEstimate );
         totalDynamicalStateSize_ = 0;        
-        for( std::map< IntegratedStateType, orbit_determination::partial_derivatives::StateDerivativePartialsMap >::iterator partialTypeIterator =
-             stateDerivativePartialList_.begin( ); partialTypeIterator != stateDerivativePartialList_.end( ); partialTypeIterator++ )
+        for( std::map< IntegratedStateType, orbit_determination::partial_derivatives::StateDerivativePartialsMap >::iterator
+             partialTypeIterator = stateDerivativePartialList_.begin( );
+             partialTypeIterator != stateDerivativePartialList_.end( ); partialTypeIterator++ )
         {
             
             if( dynamicalStatesToEstimate_.count( partialTypeIterator->first ) == 0 )
             {
-                std::cerr<<"Error when making variational equations object, found no state to estimate of type "<<partialTypeIterator->first <<std::endl;
+                std::cerr<<"Error when making variational equations object, found no state to estimate of type "<<
+                           partialTypeIterator->first <<std::endl;
             }
-            else if( dynamicalStatesToEstimate_.at( partialTypeIterator->first ).size( ) != partialTypeIterator->second.size( ) )
+            else if( dynamicalStatesToEstimate_.at( partialTypeIterator->first ).size( ) !=
+                     partialTypeIterator->second.size( ) )
             {
-                std::cerr<<"Error when making variational equations object, input partial list size is inconsistent"<<std::endl;
+                std::cerr<<"Error when making variational equations object, input partial list size is inconsistent"
+                        <<std::endl;
             }
             
-            totalDynamicalStateSize_ += getSingleIntegrationSize( partialTypeIterator->first ) * partialTypeIterator->second.size( );
+            totalDynamicalStateSize_ +=
+                    getSingleIntegrationSize( partialTypeIterator->first ) * partialTypeIterator->second.size( );
         }
         
         // Initialize matrices.
-        currentMatrixDerivative_ = Eigen::MatrixXd::Zero( totalDynamicalStateSize_, numberOfParameterValues_ );
-        currentLongMatrixDerivative_ = Eigen::Matrix< long double, Eigen::Dynamic, Eigen::Dynamic >::Zero( totalDynamicalStateSize_, numberOfParameterValues_ );
         variationalMatrix_ = Eigen::MatrixXd::Zero( totalDynamicalStateSize_, totalDynamicalStateSize_ );
-        variationalParameterMatrix_ = Eigen::MatrixXd::Zero( totalDynamicalStateSize_, numberOfParameterValues_ - totalDynamicalStateSize_ );
+        variationalParameterMatrix_ =
+                Eigen::MatrixXd::Zero( totalDynamicalStateSize_, numberOfParameterValues_ - totalDynamicalStateSize_ );
 
         // Set parameter partial functions.
         setStatePartialFunctionList( );
@@ -133,25 +144,30 @@ public:
         {
             int startIndex = stateTypeStartIndices_.at( typeIterator->first );
             int currentStateSize = getSingleIntegrationSize( typeIterator->first );
-            int entriesToSkipPerEntry = currentStateSize - currentStateSize / getSingleIntegrationDifferentialEquationOrder( typeIterator->first );
+            int entriesToSkipPerEntry = currentStateSize -
+                    currentStateSize / getSingleIntegrationDifferentialEquationOrder( typeIterator->first );
 
             // Iterate over all bodies being estimated.
             for( unsigned int i = 0; i < typeIterator->second.size( ); i++ )
             {
                 // Iterate over all parameter partial functions determined by setParameterPartialFunctionList( )
-                for( functionIterator = typeIterator->second[ i ].begin( ); functionIterator != typeIterator->second[ i ].end( );
+                for( functionIterator = typeIterator->second[ i ].begin( );
+                     functionIterator != typeIterator->second[ i ].end( );
                      functionIterator++ )
                 {
                     functionIterator->second(
                                 variationalParameterMatrix_.block(
-                                startIndex + entriesToSkipPerEntry + currentStateSize * i, functionIterator->first.first - totalDynamicalStateSize_,
-                                currentStateSize - entriesToSkipPerEntry, functionIterator->first.second ) );
+                                    startIndex + entriesToSkipPerEntry + currentStateSize * i,
+                                    functionIterator->first.first - totalDynamicalStateSize_,
+                                    currentStateSize - entriesToSkipPerEntry,
+                                    functionIterator->first.second ) );
                 }
             }
 
         }
 
-        currentMatrixDerivative.block( 0, totalDynamicalStateSize_, totalDynamicalStateSize_, totalDynamicalStateSize_ - numberOfParameterValues_ ) +=
+        currentMatrixDerivative.block( 0, totalDynamicalStateSize_, totalDynamicalStateSize_,
+                                       totalDynamicalStateSize_ - numberOfParameterValues_ ) +=
                 variationalParameterMatrix_.template cast< StateScalarType >( );
     }
     
@@ -165,11 +181,12 @@ public:
      */
     template< typename StateScalarType >
     void evaluateVariationalEquations(
-            const double time, const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& stateTransitionAndSensitivityMatrices,
+            const double time, const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >&
+            stateTransitionAndSensitivityMatrices,
             Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > > currentMatrixDerivative )
     {
         // Compute and add state partials.
-        getBodyInitialStatePartialMatrix< StateScalarType >( stateTransitionAndSensitivityMatrices, currentMatrixDerivative );
+        getBodyInitialStatePartialMatrix< StateScalarType >( stateTransitionAndSensitivityMatrices,currentMatrixDerivative );
 
         if( numberOfParameterValues_ > totalDynamicalStateSize_ )
         {
@@ -199,19 +216,40 @@ protected:
     
 private:
     
+    //! Function (called by constructor) to set up the statePartialList_ member from the state derivative partials
+    /*!
+     * Function (called by constructor) to set up the functions to evaluate the partial derivatives of the state derivatives
+     * w.r.t. a current state (stored in the statePartialList_ member) from the state derivative partials.
+     */
     void setStatePartialFunctionList( );
         
+    //! Function to add parameter partial functions for single state derivative model, and set of parameter objects.
+    /*!
+     *  Function to add parameter partial functions for single state derivative model, and set of parameter objects.
+     *  Partial derivative functions that are not-empty are added to the functionListOfBody input (returned by reference).
+     *  A list of parameters of a single type (double or vector) are handled a single function call.
+     *  \param parameterList Map of parameters for which partial functions are to checked and created. Map keys are
+     *  start entry of parameter in total parameter vector.
+     *  \param partialObject State derivative partial object from which partial functions are to be retrieved.
+     *  \param functionListOfBody Multimap of partial derivative functions to which entries are to be added by this function.
+     *  Map key is start index and size of given parameter in sensitivity matrix. Map value is partial function.
+     *  \param totalParameterVectorIndicesToSubtract Number of entries by which to shift start index in sensitivity
+     *  matrix from entry in parameter vector (used for multi-arc estimation).
+     */
     template< typename CurrentParameterType >
     void addParameterPartialToList(
-            const std::map< int, boost::shared_ptr< estimatable_parameters::EstimatableParameter< CurrentParameterType > > >& parameterList,
+            const std::map< int, boost::shared_ptr< estimatable_parameters::EstimatableParameter< CurrentParameterType > > >&
+            parameterList,
             const boost::shared_ptr< orbit_determination::partial_derivatives::StateDerivativePartial > partialObject,
-            std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > >& functionListOfBody,
+            std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > >&
+            functionListOfBody,
             const int totalParameterVectorIndicesToSubtract = 0 )
     {
         using namespace orbit_determination::partial_derivatives;
 
         // Iterate over all parameters.
-        for( typename std::map< int, boost::shared_ptr< estimatable_parameters::EstimatableParameter< CurrentParameterType > > >::const_iterator
+        for( typename std::map< int,
+             boost::shared_ptr< estimatable_parameters::EstimatableParameter< CurrentParameterType > > >::const_iterator
              parameterIterator = parameterList.begin( ); parameterIterator != parameterList.end( ); parameterIterator++ )
         {
             // Add current parameter to list of partials to be computed for current acceleration (if dependency exists)
@@ -231,46 +269,58 @@ private:
                             std::pair< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > >
                             ( indexPair, boost::bind(
                                   static_cast< void ( StateDerivativePartial::* )
-                                  ( const boost::shared_ptr< estimatable_parameters::EstimatableParameter< CurrentParameterType > >,
+                                  ( const boost::shared_ptr<
+                                    estimatable_parameters::EstimatableParameter< CurrentParameterType > >,
                                     Eigen::Block< Eigen::MatrixXd > )>
-                                  ( &StateDerivativePartial::getCurrentParameterPartial ), partialObject, parameterIterator->second, _1  ) ) );
+                                  ( &StateDerivativePartial::getCurrentParameterPartial ),
+                                  partialObject, parameterIterator->second, _1  ) ) );
             }
         }
     }
     
     //! This function creates the list of partial derivatives of the state w.r.t. parameter values.
     /*!
-     *  This function creates the list of partial derivatives of the state w.r.t. parameter values. The function is called once by the constructor
-     *  and the resulting functions are set as memebr variables. This prevents having to check whether an acceleration model depends on every parameter
-     *  during every time step.
-     *  \param parametersToEstimate Object containing all parameters that are to be estimated and their current settings and values.
+     *  This function creates the list of partial derivatives of the state w.r.t. parameter values.
+     *  The function is called once by the constructor and the resulting functions are set as member variables.
+     *  This prevents having to check whether an acceleration model depends on every parameter during every time step.
+     *  \param parametersToEstimate Object containing all parameters that are to be estimated and their current settings and
+     *  values.
      */
     template< typename ParameterType >
     void setParameterPartialFunctionList(
-            const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > parametersToEstimate )
+            const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > >
+            parametersToEstimate )
     {
         // Get double parameters.
-        std::map< int, boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > > doubleParametersToEstimate =
+        std::map< int, boost::shared_ptr< estimatable_parameters::EstimatableParameter< double > > >
+                doubleParametersToEstimate =
                 parametersToEstimate->getDoubleParameters( );
-        std::map< int, boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > > vectorParametersToEstimate =
+
+        // Get vector parameters.
+        std::map< int, boost::shared_ptr< estimatable_parameters::EstimatableParameter< Eigen::VectorXd > > >
+                vectorParametersToEstimate =
                 parametersToEstimate->getVectorParameters( );
         
         int totalParameterVectorIndicesToSubtract = parametersToEstimate->getInitialDynamicalStateParameterSize( ) -
                 estimatable_parameters::getSingleArcInitialDynamicalStateParameterSetSize( parametersToEstimate );
 
-        for( std::map< propagators::IntegratedStateType, orbit_determination::partial_derivatives::StateDerivativePartialsMap >::iterator
-             stateDerivativeTypeIterator = stateDerivativePartialList_.begin( ); stateDerivativeTypeIterator != stateDerivativePartialList_.end( );
+        for( std::map< propagators::IntegratedStateType,
+             orbit_determination::partial_derivatives::StateDerivativePartialsMap >::iterator
+             stateDerivativeTypeIterator = stateDerivativePartialList_.begin( );
+             stateDerivativeTypeIterator != stateDerivativePartialList_.end( );
              stateDerivativeTypeIterator++ )
         {
             
             // Initialize vector of lists to correct size.
-            parameterPartialList_[ stateDerivativeTypeIterator->first ].resize( stateDerivativeTypeIterator->second.size( ) );
+            parameterPartialList_[ stateDerivativeTypeIterator->first ].resize(
+                        stateDerivativeTypeIterator->second.size( ) );
             
             // Iterate over all bodies of which initial position is being estimated.
             for( unsigned int i = 0; i < stateDerivativeTypeIterator->second.size( ); i++ )
             {
                 // Initialize list of parameter partial functions for single body.
-                std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > > functionListOfBody;
+                std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > >
+                        functionListOfBody;
                 
                 // Iterate over all accelerations due to this body on current body.
                 for( unsigned int j = 0; j < stateDerivativeTypeIterator->second.at( i ).size( ); j++ )
@@ -290,9 +340,17 @@ private:
         }
     }
 
+    //! Function called by constructor to handle estimation of hierarchical translational dynamics
+    /*!
+     *  Function called by constructor to handle estimation of hierarchical translational dynamics, i.e. where
+     *  the state of body A is estimated w.r.t. body B, and body B is itself estimated w.r.t. to some third body (or inertial
+     *  point) C.
+     *  \param parametersToEstimate Total list of parameters to estimate.
+     */
     template< typename ParameterType >
     void setTranslationalStatePartialFrameScalingFunctions(
-            const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > parametersToEstimate )
+            const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > >
+            parametersToEstimate )
     {
         std::vector< boost::shared_ptr< estimatable_parameters::EstimatableParameter<
                 Eigen::Matrix< ParameterType, Eigen::Dynamic, 1 > > > > initialDynamicalParameters =
@@ -301,32 +359,38 @@ private:
         std::vector< std::string > propagatedBodies;
         std::vector< std::string > centralBodies;
 
+        // Retrieve propagated bodies and central bodies of estimation.
         for( unsigned int i = 0; i < initialDynamicalParameters.size( ); i++ )
         {
             if( initialDynamicalParameters.at( i )->getParameterName( ).first == estimatable_parameters::initial_body_state )
             {
                 propagatedBodies.push_back(
                             initialDynamicalParameters.at( i )->getParameterName( ).second.first );
-                centralBodies.push_back( boost::dynamic_pointer_cast< estimatable_parameters::InitialTranslationalStateParameter< ParameterType > >(
+                centralBodies.push_back( boost::dynamic_pointer_cast
+                                         < estimatable_parameters::InitialTranslationalStateParameter< ParameterType > >(
                                              initialDynamicalParameters.at( i ) )->getCentralBody( ) );
             }
         }
 
+        // Get order in which ephemerides were to be updated.
         std::vector< std::string > updateOrder = determineEphemerisUpdateorder(
                     propagatedBodies, centralBodies, centralBodies );
 
+        // Iterate over central bodies and propagated bodies and check for dependencies
         for( int i = updateOrder.size( ) - 1; i >= 0 ; i-- )
         {
-            int currentBodyIndex = std::distance( propagatedBodies.begin( ),
-                                                  std::find( propagatedBodies.begin( ), propagatedBodies.end( ), updateOrder.at( i ) ) );
+            int currentBodyIndex = std::distance(
+                        propagatedBodies.begin( ),
+                        std::find( propagatedBodies.begin( ), propagatedBodies.end( ), updateOrder.at( i ) ) );
             for( unsigned int j = 0; j < propagatedBodies.size( ); j++ )
             {
                 if( centralBodies.at( currentBodyIndex ) == propagatedBodies.at( j ) )
                 {
 
-                    statePartialAdditionIndices_.push_back( std::make_pair( stateTypeStartIndices_[ propagators::transational_state ] +
-                                                            currentBodyIndex * propagators::getSingleIntegrationSize( propagators::transational_state ),
-                                                            stateTypeStartIndices_[ propagators::transational_state ] +
+                    statePartialAdditionIndices_.push_back(
+                                std::make_pair( stateTypeStartIndices_[ propagators::transational_state ] +
+                                currentBodyIndex * propagators::getSingleIntegrationSize( propagators::transational_state ),
+                                stateTypeStartIndices_[ propagators::transational_state ] +
                             j * propagators::getSingleIntegrationSize( propagators::transational_state ) ) );
                 }
             }
@@ -334,64 +398,80 @@ private:
     }
 
     
-    //! Map listing all (named) acceleration models exerted by the (named) bodies.
+    //! Map with list of StateDerivativePartialsMaps, with state type as key.
     /*!
-     *  Map listing all (named) acceleration models exerted by the (named) bodies.
+     *  List partials of state derivative models from which the variational equations
+     *  are set up. The key is the type of dynamics for which partials are taken, the values are StateDerivativePartialsMap
+     *  (see StateDerivativePartialsMap definition for details)
      */
-    std::map< propagators::IntegratedStateType, orbit_determination::partial_derivatives::StateDerivativePartialsMap > stateDerivativePartialList_;
+    std::map< propagators::IntegratedStateType, orbit_determination::partial_derivatives::StateDerivativePartialsMap >
+    stateDerivativePartialList_;
     
+    //! Map of start entry in sensitivity matrix of each type of estimated dynamics.
     std::map< IntegratedStateType, int > stateTypeStartIndices_;
     
+    //! List of all functions returning current partial derivative w.r.t. a current dynamical state
+    /*!
+     *  List of all functions returning current partial derivative w.r.t. a current dynamical state (map key). The
+     *  vector entries correspond to the entries in the outer vector of StateDerivativePartialsMaps in
+     *  stateDerivativePartialList_. The multimaps inside the vector provide the functions (as values) adding the
+     *  partials to a given matrix block and the start column and number of columns in matrix partial (as keys).
+     */
+    std::map< IntegratedStateType,
+    std::vector< std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > > > >
+    statePartialList_;
     
-    std::map< IntegratedStateType, std::vector< std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > > > > statePartialList_;
-    
-    std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > >::iterator statePartialIterator_;
+    //! Pre-defined iterator for efficiency.
+    std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > >::iterator
+    statePartialIterator_;
     
+    //! Vector of pair providing indices of column blocks of variational equations to add to other column blocks
+    /*!
+     * Vector of pair providing indices of column blocks of variational equations to add to other column blocks,
+     * which is needed by the hierarchical estimation fo dynamics. The second pair entry is the start of the column
+     * block (of size 3) to where it should be copied. The first entry denotes from where it should be copied.
+     * \sa setTranslationalStatePartialFrameScalingFunctions
+     */
     std::vector< std::pair< int, int > > statePartialAdditionIndices_;
 
     
-    //! Vector of multimaps of parameter partial function, with index information in variational equations as key
+    //! List of all functions returning current partial derivative w.r.t. a parameter
     /*!
-     *  Vector of multimaps of parameter partial function. Functions are set after checking dependencies of each accelration partial.
-     *  The vector indices coincide with the bodiesToEstimate indices. The key pair of the multimap indicates the start column on the sensitivity matrix
-     *  part of the variational equations and the number of columns that the return of the function occupies (number of rows = 3 from size of acceleration)
+     *  List of all functions returning current partial derivative w.r.t. a parameter.
+     *  Map key denotes associated dynamics type w.r.t which partial is taken. The
+     *  vector entries correspond to the entries in the outer vector of StateDerivativePartialsMaps in
+     *  stateDerivativePartialList_. The multimaps inside the vector provide the functions (as values) adding the
+     *  partials to a given matrix block and the start column and number of columns in matrix partial (as keys).
      */
     std::map< IntegratedStateType, std::vector< std::multimap< std::pair< int, int >,
     boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > > > > parameterPartialList_;
     
-    //! Pre-declared iterator over all parameter partial functions
-    /*!
-     *  Pre-declared iterator over all parameter partial functions. Declared to prevent large number of iterator crations and destructions (performance)
-     */
-    std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > >::iterator functionIterator;
+    //! Pre-declared iterator over all parameter partial functions.
+    std::multimap< std::pair< int, int >, boost::function< void( Eigen::Block< Eigen::MatrixXd > ) > >
+    ::iterator functionIterator;
 
-    std::map< propagators::IntegratedStateType, orbit_determination::partial_derivatives::StateDerivativePartialsMap >::iterator stateDerivativeTypeIterator_;
-    
+    //! Pre-declared iterator over all state types
+    std::map< propagators::IntegratedStateType, orbit_determination::partial_derivatives::StateDerivativePartialsMap >
+    ::iterator stateDerivativeTypeIterator_;
     
+    //! List of identifiers for points/bodies for which initial dynamical state is to be estimated.
+    std::map< propagators::IntegratedStateType, std::vector< std::pair< std::string, std::string > > >
+    dynamicalStatesToEstimate_;
 
     
-    std::map< propagators::IntegratedStateType, std::vector< std::pair< std::string, std::string > > > dynamicalStatesToEstimate_;
-    
-    
-    
-    std::vector< std::string > estimatedUnintegratedBodies_;
-    
-    
     //! Number of parameter values in estimation
     /*!
      *  Number of parameter values in estimation (i.e. number of columns in sensitivity matrix)
      */
     int numberOfParameterValues_;
     
-    
+    //! Total size of (single-arc) state vector of dynamics that is to be estimated.
     int totalDynamicalStateSize_;
 
-    Eigen::MatrixXd currentMatrixDerivative_;
-
-    Eigen::Matrix< long double, Eigen::Dynamic, Eigen::Dynamic > currentLongMatrixDerivative_;
-
+    //! Total matrix of partial derivatives of state derivatives w.r.t. current states.
     Eigen::MatrixXd variationalMatrix_;
 
+    //! Total matrix of partial derivatives of state derivatives w.r.t. parameter vectors.
     Eigen::MatrixXd variationalParameterMatrix_;
 };
 
diff --git a/Tudat/Astrodynamics/Propagators/variationalEquationsSolver.cpp b/Tudat/Astrodynamics/Propagators/variationalEquationsSolver.cpp
index a576da0..cbb70b3 100644
--- a/Tudat/Astrodynamics/Propagators/variationalEquationsSolver.cpp
+++ b/Tudat/Astrodynamics/Propagators/variationalEquationsSolver.cpp
@@ -6,6 +6,7 @@ namespace tudat
 namespace propagators
 {
 
+//! Function to create interpolators for state transition and sensitivity matrices from numerical results.
 void createStateTransitionAndSensitivityMatrixInterpolator(
         boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >& stateTransitionMatrixInterpolator,
         boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >& sensitivityMatrixInterpolator,
@@ -14,9 +15,9 @@ void createStateTransitionAndSensitivityMatrixInterpolator(
 {
     // Create interpolator for state transition matrix.
     stateTransitionMatrixInterpolator=
-            boost::make_shared< interpolators::LinearInterpolator< double, Eigen::MatrixXd > >(
+            boost::make_shared< interpolators::LagrangeInterpolator< double, Eigen::MatrixXd > >(
                 utilities::createVectorFromMapKeys< Eigen::MatrixXd, double >( variationalEquationsSolution[ 0 ] ),
-                utilities::createVectorFromMapValues< Eigen::MatrixXd, double >( variationalEquationsSolution[ 0 ] ) );
+                utilities::createVectorFromMapValues< Eigen::MatrixXd, double >( variationalEquationsSolution[ 0 ] ), 4 );
     if( clearRawSolution )
     {
         variationalEquationsSolution[ 0 ].clear( );
@@ -24,9 +25,9 @@ void createStateTransitionAndSensitivityMatrixInterpolator(
 
     // Create interpolator for sensitivity matrix.
     sensitivityMatrixInterpolator =
-            boost::make_shared< interpolators::LinearInterpolator< double, Eigen::MatrixXd > >(
+            boost::make_shared< interpolators::LagrangeInterpolator< double, Eigen::MatrixXd > >(
                 utilities::createVectorFromMapKeys< Eigen::MatrixXd, double >( variationalEquationsSolution[ 1 ] ),
-                utilities::createVectorFromMapValues< Eigen::MatrixXd, double >( variationalEquationsSolution[ 1 ] ) );
+                utilities::createVectorFromMapValues< Eigen::MatrixXd, double >( variationalEquationsSolution[ 1 ] ), 4 );
     if( clearRawSolution )
     {
         variationalEquationsSolution[ 1 ].clear( );
diff --git a/Tudat/Astrodynamics/Propagators/variationalEquationsSolver.h b/Tudat/Astrodynamics/Propagators/variationalEquationsSolver.h
index 21da2b2..a250c18 100644
--- a/Tudat/Astrodynamics/Propagators/variationalEquationsSolver.h
+++ b/Tudat/Astrodynamics/Propagators/variationalEquationsSolver.h
@@ -35,81 +35,44 @@ namespace propagators
 {
 
 
-template< typename StateScalarType = double, typename ParameterType = double >
-class VariationalEquationsSolverBase
-{
-public:
-    typedef Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > VectorType;
-
-    VariationalEquationsSolverBase(
-            const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > parametersToEstimate ):
-        parametersToEstimate_( parametersToEstimate ){ }
-
-    virtual ~VariationalEquationsSolverBase( ){ }
-
-    virtual void resetParameterEstimate( const Eigen::Matrix< ParameterType, Eigen::Dynamic, 1 > newParameterEstimate,
-                                         const bool areVariationalEquationsToBeIntegrated = true ) = 0;
-
-    virtual void integrateVariationalAndDynamicalEquations(
-            const VectorType& initialStateEstimate, const bool integrateEquationsConcurrently ) = 0;
-
-    virtual void integrateDynamicalEquationsOfMotionOnly(
-            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& initialCartesianStates ) = 0;
-
-
-    virtual boost::shared_ptr< CombinedStateTransitionAndSensitivityMatrixInterface > getStateTransitionMatrixInterface( ) = 0;
-
-    //! Function to get the list of objects representing the parameters that are to be integrated.
-    /*!
-     *  Function to get the list of objects representing the parameters that are to be integrated.
-     *  \return List of objects representing the parameters that are to be integrated.
-     */
-    boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > getParametersToEstimate( )
-    {
-        return parametersToEstimate_;
-    }
-
-protected:
-    //! Object containing all parameters that are to be estimated.
-    /*!
-     *  Object containing all parameters that are to be estimated and their current settings and values.
-     */
-    boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > parametersToEstimate_ ;
-};
-
-//! Class to manage integration of equations of motion and variational equations.
+//! Base class to manage and execute the numerical integration of equations of motion and variational equations.
 /*!
- *  Class to manage integration of equations of motion and variational equations. Derives from DynamicsSimulator that deals solely with
- *  equations of motion
+ *  Base class to manage and execute the numerical integration of equations of motion and variational equations.
+ *  Governing equations are set once, but can be re-integrated for different initial conditions using the same
+ *  instance of the class. Derived classes define the specific kind of integration that is performed
+ *  (single-arc/multi-arc; dynamics/variational equations, etc.)
  */
 template< typename StateScalarType = double, typename TimeType = double, typename ParameterType = double >
-class VariationalEquationsSolver : public VariationalEquationsSolverBase< StateScalarType, ParameterType >
+class VariationalEquationsSolver
 {
 public:
 
     typedef Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > MatrixType;
     typedef Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > VectorType;
 
-    using VariationalEquationsSolverBase< StateScalarType, ParameterType >::parametersToEstimate_;
-
     //! Constructor
     /*!
-     *  Constructor, sets up object for automatic evaluation and numerical integration of variational equations and equations of motion.
+     *  Constructor, sets up object for automatic evaluation and numerical integration of variational equations and
+     *  equations of motion.
      *  \param bodyMap Map of bodies (with names) of all bodies in integration.
-     *  \param integratorSettings Settings for numerical integrator.
-     *  \param propagatorSettings Settings for propagator.
-     *  \param parametersToEstimate Object containing all parameters that are to be estimated and their current settings and values.
-     *  \param bodiesToEstime List of bodies to estimate
+     *  \param integratorSettings Settings for numerical integrator of combined propagation of variational equations
+     *  and equations of motion.
+     *  \param propagatorSettings Settings for propagation of equations of motion.
+     *  \param parametersToEstimate Object containing all parameters that are to be estimated and their current
+     *  settings and values.
+     *  \param variationalOnlyIntegratorSettings Settings for numerical integrator when integrating only variational
+     *  equations.
+     *  \param clearNumericalSolution Boolean to determine whether to clear the raw numerical solution member variables
+     *  (default true) after propagation and resetting of state transition interface.
      */
     VariationalEquationsSolver(
             const simulation_setup::NamedBodyMap& bodyMap,
             const boost::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > > integratorSettings,
             const boost::shared_ptr< PropagatorSettings< StateScalarType > > propagatorSettings,
             const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > parametersToEstimate,
-            const boost::shared_ptr< numerical_integrators::IntegratorSettings< double > > variationalOnlyIntegratorSettings =
+            const boost::shared_ptr< numerical_integrators::IntegratorSettings< double > > variationalOnlyIntegratorSettings=
             boost::shared_ptr< numerical_integrators::IntegratorSettings< double > >( ),
             const bool clearNumericalSolution = 1 ):
-        VariationalEquationsSolverBase< StateScalarType, ParameterType >( parametersToEstimate ),
         bodyMap_( bodyMap ),
         propagatorSettings_( propagatorSettings ), integratorSettings_( integratorSettings ),
         variationalOnlyIntegratorSettings_( variationalOnlyIntegratorSettings ),
@@ -119,18 +82,47 @@ public:
     { }
 
     //! Destructor
+    virtual ~VariationalEquationsSolver( ){ }
+
+    //! Pure virtual function to integrate variational equations and equations of motion.
     /*!
-     *  Destructor
+     *  Pure virtual function to integrate variational equations and equations of motion, to be implemented in derived
+     *  class
+     *  \param initialStateEstimate Initial state of the equations of motion that is to be used.
+     *  \param integrateEquationsConcurrently Variable determining whether the equations of motion are to be
+     *  propagated concurrently with variational equations of motion (if true), or before variational equations (if false).
      */
-    virtual ~VariationalEquationsSolver( ){ }
+    virtual void integrateVariationalAndDynamicalEquations(
+            const VectorType& initialStateEstimate, const bool integrateEquationsConcurrently ) = 0;
+
+    //! Pure virtual function to integrate equations of motion only.
+    /*!
+     *  Pure virtual function to integrate equations of motion only, to be implemented in derived
+     *  class
+     *  \param initialStateEstimate Initial state of the equations of motion that is to be used.
+     */
+    virtual void integrateDynamicalEquationsOfMotionOnly(
+            const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& initialStateEstimate ) = 0;
+
+
+    //! Function to get the list of objects representing the parameters that are to be integrated.
+    /*!
+     *  Function to get the list of objects representing the parameters that are to be integrated.
+     *  \return List of objects representing the parameters that are to be integrated.
+     */
+    boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > getParametersToEstimate( )
+    {
+        return parametersToEstimate_;
+    }
 
     //! Function to reset parameter estimate and re-integrate equations of motion and, if desired, variational equations.
     /*!
      *  Function to reset parameter estimate and re-integrate equations of motion and, if desired, variational equations
      *  using the new physical parameters/body initial states.
-     *  \param newParameterEstimate New estimate of parameters that are to be estimated. First entries are initial
-     *  states of bodies to be integrated ( order determined by bodiesToIntegrate_ ),
-     *  followed by physical parameters that are to be estimated ( order determined by parametersToEstimate_).
+     *  \param newParameterEstimate New estimate of parameters that are to be estimated, in same order as defined
+     *  in parametersToEstimate_ member.
+     *  \param areVariationalEquationsToBeIntegrated Boolean defining whether the variational equations are to be
+     *  reintegrated with the new parameter values.
      */
     void resetParameterEstimate( const Eigen::Matrix< ParameterType, Eigen::Dynamic, 1 > newParameterEstimate,
                                  const bool areVariationalEquationsToBeIntegrated = true )
@@ -138,7 +130,8 @@ public:
     {
         // Reset values of parameters.
         parametersToEstimate_->template resetParameterValues< ParameterType >( newParameterEstimate );
-        propagatorSettings_->resetInitialStates( estimatable_parameters::getInitialStateVectorOfBodiesToEstimate( parametersToEstimate_ ) );
+        propagatorSettings_->resetInitialStates(
+                    estimatable_parameters::getInitialStateVectorOfBodiesToEstimate( parametersToEstimate_ ) );
 
         dynamicsStateDerivative_->template updateStateDerivativeModelSettings(
                     propagatorSettings_->getInitialStates( ), 0 );
@@ -155,6 +148,11 @@ public:
         }
     }
 
+    //! Function to get the state transition matric interface object.
+    /*!
+     *  Function to get the state transition matric interface object.
+     *  \return The state transition matric interface object.
+     */
     boost::shared_ptr< CombinedStateTransitionAndSensitivityMatrixInterface > getStateTransitionMatrixInterface( )
     {
         return stateTransitionInterface_;
@@ -164,15 +162,13 @@ public:
 protected:
 
 
-    //! Create initial matrix of numerical soluation to variation + state equations.
+    //! Create initial matrix of numerical soluation to variational + dynamical equations.
     /*!
-     *  Create initial matrix of numerical soluation to variation + state equations. The structure of the matrix is:
-     * [Phi(t,t0)_{nb*6,nb*6};S(t)_{6*nb,np};[y0_{6,1}...ynb_{6,1} ;0_{(nb-1)*6,nb}] ]. Subscripts denote the size of
-     *  the componets, Phi the state transition matrix, S the sensitivity matrix yi the state of body i, nb the number of bodies
-     *  and np the number of parameters to be estimated.
+     *  Create initial matrix of numerical soluation to variational + dynamical equations. The structure of the matrix is
+     *  [Phi;S;y], with Phi the state transition matrix, S the sensitivity matrix y the state vector.
      *  \param initialStateEstimate vector of initial state (position/velocity) of bodies to be integrated numerically.
      *  order determined by order of bodiesToIntegrate_.
-     *  \return Iinitial matrix of numerical soluation to variation + state equations.
+     *  \return Initial matrix of numerical soluation to variation + state equations.
      */
     MatrixType createInitialConditions( const VectorType initialStateEstimate )
     {
@@ -190,6 +186,12 @@ protected:
         return varSystemInitialState;
     }
 
+    //! Create initial matrix of numerical soluation to variational equations
+    /*!
+     *  Create initial matrix of numerical soluation to variational equations, with structure [Phi;S]. Initial state
+     *  transition matrix Phi is identity matrix. Initial sensitivity matrix S is all zeros.
+     *  \return Initial matrix solution to variational equations.
+     */
     Eigen::MatrixXd createInitialVariationalEquationsSolution( )
     {
         // Initialize initial conditions to zeros.
@@ -202,38 +204,77 @@ protected:
         return varSystemInitialState;
     }
 
+    //! Object containing all parameters that are to be estimated and their current  settings and values.
+    boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > parametersToEstimate_ ;
 
+    //! Map of bodies (with names) of all bodies in integration.
     simulation_setup::NamedBodyMap bodyMap_;
 
+    //! Settings for propagation of equations of motion.
     boost::shared_ptr< PropagatorSettings< StateScalarType > > propagatorSettings_;
 
+    //! Settings for numerical integrator of combined propagation of variational equations and equations of motion.
     boost::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > > integratorSettings_;
 
+    //! Settings for numerical integrator when integrating only variational equations.
     boost::shared_ptr< numerical_integrators::IntegratorSettings< double > > variationalOnlyIntegratorSettings_;
 
+    //! Size (rows and columns are equal) of state transition matrix.
     int stateTransitionMatrixSize_;
 
+    //! Number of rows in sensitivity matrix
     int parameterVectorSize_;
 
+    //! Boolean to determine whether to clear the raw numerical solution member variables after propagation
+    /*!
+     *  Boolean to determine whether to clear the raw numerical solution member variables after propagation
+     *  and resetting of state transition interface.
+     */
     bool clearNumericalSolution_;
 
-
+    //! Object used for interpolating numerical results of state transition and sensitivity matrix.
     boost::shared_ptr< CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionInterface_;  
 
+    //! Object used to compute the full state derivative in equations of motion and variational equations.
+    /*!
+     *  Object used to compute the full state derivative in equations of motion and variational equations,
+     *  including relevant updates of environment from current state and time. Object may be used for
+     *  either full or separate propagation of equations.
+     */
     boost::shared_ptr< DynamicsStateDerivativeModel< TimeType, StateScalarType > > dynamicsStateDerivative_;
 
 };
 
-template< typename MapTimeType, typename MapStateScalarType >
+//! Function to separate the time histories of the sensitivity and state transition matrices from a full numerical solution.
+/*!
+ *  Function to separate the time histories of the sensitivity and state transition matrices from a full numerical solution,
+ *  in which the solution is represented as a single matrix block per time value.
+ *  NOTE: numericalIntegrationResult contents are deleted by this function (all information is conserved in
+ *  variationalEquationsSolution.
+ *  \param numericalIntegrationResult Full time history from which separate matrix histories are to be retrieved.
+ *  \param variationalEquationsSolution Vector of two matrix histories (returned by reference). First vector entry
+ *  is state transition matrix history, second entry is sensitivity matrix history.
+ *  \param stateTransitionStartIndices First row and column (first and second) of state transition matrix in entries of
+ *  numericalIntegrationResult.
+ *  \param sensitivityStartIndices First row and column (first and second) of sensitivity matrix in entries of
+ *  numericalIntegrationResult.
+ *  \param stateTransitionMatrixSize Size (rows and columns are equal) of state transition matrix.
+ *  \param parameterSetSize Number of rows in sensitivity matrix
+ */
+template< typename TimeType, typename StateScalarType >
 void setVariationalEquationsSolution(
-        std::map< MapTimeType, Eigen::Matrix< MapStateScalarType, Eigen::Dynamic, Eigen::Dynamic > >& numericalIntegrationResult,
+        std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > >&
+        numericalIntegrationResult,
         std::vector< std::map< double, Eigen::MatrixXd > >& variationalEquationsSolution,
         const std::pair< int, int > stateTransitionStartIndices,
         const std::pair< int, int > sensitivityStartIndices,
         const int stateTransitionMatrixSize,
         const int parameterSetSize )
 {
-    for( typename std::map< MapTimeType, Eigen::Matrix< MapStateScalarType, Eigen::Dynamic, Eigen::Dynamic > >::iterator
+    variationalEquationsSolution.clear( );
+    variationalEquationsSolution.resize( 2 );
+
+    for( typename std::map< TimeType, Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > >::iterator
          integrationIterator = numericalIntegrationResult.begin( );
          integrationIterator != numericalIntegrationResult.end( ); )
     {
@@ -253,31 +294,55 @@ void setVariationalEquationsSolution(
     }
 }
 
-
+//! Function to create interpolators for state transition and sensitivity matrices from numerical results.
+/*!
+ * Function to create interpolators for state transition and sensitivity matrices from numerical results.
+ * \param stateTransitionMatrixInterpolator Interpolator object for state transition matrix (returned by reference).
+ * \param sensitivityMatrixInterpolator Interpolator object for sensitivity matrix (returned by reference).
+ * \param variationalEquationsSolution Vector of two matrix histories. First vector entry
+ *  is state transition matrix history, second entry is sensitivity matrix history.
+ * \param clearRawSolution Boolean denoting whether to clear entries of variationalEquationsSolution after creation
+ * of interpolators.
+ */
 void createStateTransitionAndSensitivityMatrixInterpolator(
-        boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >& stateTransitionMatrixInterpolator,
-        boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >& sensitivityMatrixInterpolator,
+        boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >&
+        stateTransitionMatrixInterpolator,
+        boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >&
+        sensitivityMatrixInterpolator,
         std::vector< std::map< double, Eigen::MatrixXd > >& variationalEquationsSolution,
         const bool clearRawSolution = 1 );
 
+//! Function to check the consistency between propagation settings of equations of motion, and estimated parameters.
+/*!
+ *  Function to check the consistency between propagation settings of equations of motion, and estimated parameters.
+ *  In particular, it is presently required that the set of propagated states is equal to the set of estimated states.
+ *  \param propagatorSettings Settings for propagation of equations of motion.
+ *  \param parametersToEstimate Object containing all parameters that are to be estimated and their current
+ *  settings and values.
+ */
 template< typename StateScalarType = double, typename TimeType = double, typename ParameterType = double >
 bool checkPropagatorSettingsAndParameterEstimationConsistency(
         const boost::shared_ptr< PropagatorSettings< StateScalarType > > propagatorSettings,
         const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > parametersToEstimate )
 {
     bool isInputConsistent = 1;
+
+    // Check type of dynamics
     switch( propagatorSettings->stateType_ )
     {
     case transational_state:
     {
         boost::shared_ptr< TranslationalStatePropagatorSettings< StateScalarType > > translationalPropagatorSettings =
                 boost::dynamic_pointer_cast< TranslationalStatePropagatorSettings< StateScalarType > >( propagatorSettings );
+
+        // Retrieve estimated and propagated translational states, and check equality.
         std::vector< std::string > propagatedBodies = translationalPropagatorSettings->bodiesToIntegrate_;
         std::vector< std::string > estimatedBodies = estimatable_parameters::getListOfBodiesWithTranslationalStateToEstimate(
                     parametersToEstimate );
         if( propagatedBodies.size( ) != estimatedBodies.size( ) )
         {
-            std::cerr<<"Error, propagated and estimated body vector sizes are inconsistent"<<propagatedBodies.size( )<<" "<<estimatedBodies.size( )<<std::endl;
+            std::cerr<<"Error, propagated and estimated body vector sizes are inconsistent"<<
+                       propagatedBodies.size( )<<" "<<estimatedBodies.size( )<<std::endl;
             isInputConsistent = 0;
         }
         else
@@ -301,16 +366,25 @@ bool checkPropagatorSettingsAndParameterEstimationConsistency(
     return isInputConsistent;
 }
 
+//! Class to manage and execute the numerical integration of variational equations of a dynamical system in a single arc.
+/*!
+ *  Class to manage and execute the numerical integration of variational equations of a dynamical system, in addition
+ *  to the dynamics itself, in a single arc: i.e. the governing equations a single initial time, and are propagated once
+ *  for the full prescribed time interval. This is in contrast to multi-arc dynamics, where the time interval is cut into
+ *  pieces. In this class, the governing equations are set once, but can be re-integrated for
+ *  different initial conditions using the same instance of the class.
+ */
 template< typename StateScalarType = double, typename TimeType = double, typename ParameterType = double >
 class SingleArcVariationalEquationsSolver: public VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >
 {
 public:
 
+    //! Local typedefs for vector and matrix of given scalar type
     typedef Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > MatrixType;
     typedef Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > VectorType;
 
-    using VariationalEquationsSolverBase< StateScalarType, ParameterType >::parametersToEstimate_;
-
+    //! Base class using statements
+    using VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >::parametersToEstimate_;
     using VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >::bodyMap_;
     using VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >::dynamicsStateDerivative_;
     using VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >::propagatorSettings_;
@@ -322,12 +396,22 @@ public:
 
     //! Constructor
     /*!
-     *  Constructor, sets up object for automatic evaluation and numerical integration of variational equations and equations of motion.
+     *  Constructor, sets up object for automatic evaluation and numerical integration of variational equations and
+     *  equations of motion.
      *  \param bodyMap Map of bodies (with names) of all bodies in integration.
-     *  \param integratorSettings Settings for numerical integrator.
-     *  \param propagatorSettings Settings for propagator.
-     *  \param parametersToEstimate Object containing all parameters that are to be estimated and their current settings and values.
-     *  \param bodiesToEstime List of bodies to estimate
+     *  \param integratorSettings Settings for numerical integrator of combined propagation of variational equations
+     *  and equations of motion.
+     *  \param propagatorSettings Settings for propagation of equations of motion.
+     *  \param parametersToEstimate Object containing all parameters that are to be estimated and their current
+     *  settings and values.
+     *  \param integrateDynamicalAndVariationalEquationsConcurrently Boolean defining whether variational and dynamical
+     *  equations are to be propagated concurrently (if true) or sequentially (of false)
+     *  \param variationalOnlyIntegratorSettings Settings for numerical integrator when integrating only variational
+     *  equations.
+     *  \param clearNumericalSolution Boolean to determine whether to clear the raw numerical solution member variables
+     *  (default true) after propagation and resetting of state transition interface.
+     *  \param integrateEquationsOnCreation Boolean to denote whether equations should be integrated immediately at the
+     *  end of this contructor.
      */
     SingleArcVariationalEquationsSolver(
             const simulation_setup::NamedBodyMap& bodyMap,
@@ -335,36 +419,50 @@ public:
             const boost::shared_ptr< PropagatorSettings< StateScalarType > > propagatorSettings,
             const boost::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > parametersToEstimate,
             const bool integrateDynamicalAndVariationalEquationsConcurrently = 1,
-            const boost::shared_ptr< numerical_integrators::IntegratorSettings< double > > variationalOnlyIntegratorSettings =
-            boost::shared_ptr< numerical_integrators::IntegratorSettings< double > >( ),
+            const boost::shared_ptr< numerical_integrators::IntegratorSettings< double > > variationalOnlyIntegratorSettings
+            = boost::shared_ptr< numerical_integrators::IntegratorSettings< double > >( ),
             const bool clearNumericalSolution = 1,
             const bool integrateEquationsOnCreation = 1 ):
         VariationalEquationsSolver< StateScalarType, TimeType, ParameterType >(
-            bodyMap, integratorSettings, propagatorSettings, parametersToEstimate, variationalOnlyIntegratorSettings, clearNumericalSolution )
+            bodyMap, integratorSettings, propagatorSettings, parametersToEstimate,
+            variationalOnlyIntegratorSettings, clearNumericalSolution )
     {
-        if( !checkPropagatorSettingsAndParameterEstimationConsistency< StateScalarType, TimeType, ParameterType >(
-                    propagatorSettings, parametersToEstimate ) )
-        {
-            std::cerr<<"Error when making single arc variational equations solver, estimated and propagated bodies are inconsistent"<<std::endl;
-        }
-        else
+        std::cout<<"test 1"<<std::endl;
+
+        // Check input consistency
+//        if( !checkPropagatorSettingsAndParameterEstimationConsistency< StateScalarType, TimeType, ParameterType >(
+//                    propagatorSettings, parametersToEstimate ) )
+//        {
+//            throw std::runtime_error(
+//                        "Error when making single arc variational equations solver, estimated and propagated bodies are inconsistent" );
+//        }
+//        else
         {
+            std::cout<<"test 1"<<std::endl;
+            // Create simulation object for dynamics only.
             dynamicsSimulator_ =  boost::make_shared< SingleArcDynamicsSimulator< StateScalarType, TimeType > >(
                         bodyMap, integratorSettings, propagatorSettings, false, clearNumericalSolution );
             dynamicsStateDerivative_ = dynamicsSimulator_->getDynamicsStateDerivative( );
+            std::cout<<"test 1"<<std::endl;
 
-            // Create variational equations objects.
-            std::map< IntegratedStateType, orbit_determination::partial_derivatives::StateDerivativePartialsMap > stateDerivativePartials =
-                    orbit_determination::partial_derivatives::createStateDerivativePartials< StateScalarType, TimeType, ParameterType >(
+            // Create state derivative partials
+            std::map< IntegratedStateType, orbit_determination::partial_derivatives::StateDerivativePartialsMap >
+                    stateDerivativePartials =
+                    orbit_determination::partial_derivatives::createStateDerivativePartials
+                    < StateScalarType, TimeType, ParameterType >(
                         dynamicsStateDerivative_->getStateDerivativeModels( ), bodyMap, parametersToEstimate );
+            std::cout<<"test 1"<<std::endl;
 
+            // Create variational equations objects.
             variationalEquationsObject_ = boost::make_shared< VariationalEquations >(
-                        stateDerivativePartials, parametersToEstimate_, dynamicsStateDerivative_->getStateTypeStartIndices( ) );
-
+                        stateDerivativePartials, parametersToEstimate_,
+                        dynamicsStateDerivative_->getStateTypeStartIndices( ) );
             dynamicsStateDerivative_->addVariationalEquations( variationalEquationsObject_ );
+            std::cout<<"test 1"<<std::endl;
 
             // Resize solution of variational equations to 2 (state transition and sensitivity matrices)
             variationalEquationsSolution_.resize( 2 );
+            std::cout<<"test 1"<<std::endl;
 
             // Integrate variational equations from initial state estimate.
             if( integrateEquationsOnCreation )
@@ -378,24 +476,38 @@ public:
                     integrateVariationalAndDynamicalEquations( propagatorSettings->getInitialStates( ), 0 );
                 }
             }
+            std::cout<<"test 1"<<std::endl;
+
         }
     }
 
     //! Destructor
-    /*!
-     *  Destructor
-     */
     ~SingleArcVariationalEquationsSolver( ){ }
 
+    //! Function to integrate equations of motion only.
+    /*!
+     *  Function to integrate equations of motion only (in single arc).  If dynamical
+     *  solution is to be processed, the environment is also updtaed to teh new solution.
+     *  \param initialStateEstimate Initial state of the equations of motion that is to be used (in same order as in
+     *  parametersToEstimate_)
+     */
     void integrateDynamicalEquationsOfMotionOnly(
             const Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic >& initialStateEstimate )
     {
-        std::cout<<"resetting only dynamics"<<std::endl;
-
         dynamicsStateDerivative_->setPropagationSettings( std::vector< IntegratedStateType >( ), 1, 0 );
         dynamicsSimulator_->integrateEquationsOfMotion( initialStateEstimate );
     }
 
+    //! Function to integrate variational equations and equations of motion.
+    /*!
+     *  Function to integrate variational equations and equations of motion (in single arc). At the end of this function,
+     *  the stateTransitionInterface_ is reset with the new state transition and sensitivity matrices. If dynamical
+     *  solution is to be processed, the environment is also updtaed to the new solution.
+     *  \param initialStateEstimate Initial state of the equations of motion that is to be used (in same order as in
+     *  parametersToEstimate_).
+     *  \param integrateEquationsConcurrently Variable determining whether the equations of motion are to be
+     *  propagated concurrently with variational equations of motion (if true), or before variational equations (if false).
+     */
     void integrateVariationalAndDynamicalEquations(
             const VectorType& initialStateEstimate, const bool integrateEquationsConcurrently )
     {
@@ -408,7 +520,8 @@ public:
 
             // Create initial conditions from new estimate.
             MatrixType initialVariationalState = this->createInitialConditions(
-                        dynamicsStateDerivative_->convertFromOutputSolution( initialStateEstimate, integratorSettings_->initialTime_ ) );
+                        dynamicsStateDerivative_->convertFromOutputSolution(
+                            initialStateEstimate, integratorSettings_->initialTime_ ) );
 
             // Integrate variational and state equations.
             dynamicsStateDerivative_->setPropagationSettings( std::vector< IntegratedStateType >( ), 1, 1 );
@@ -423,11 +536,13 @@ public:
 
             equationsOfMotionNumericalSolution = convertNumericalStateSolutionsToOutputSolutions(
                         equationsOfMotionNumericalSolution, dynamicsStateDerivative_ );
-            dynamicsSimulator_->manuallySetAndProcessRawNumericalEquationsOfMotionSolution( equationsOfMotionNumericalSolution );
+            dynamicsSimulator_->manuallySetAndProcessRawNumericalEquationsOfMotionSolution(
+                        equationsOfMotionNumericalSolution );
 
             // Reset solution for state transition and sensitivity matrices.
             setVariationalEquationsSolution< TimeType, StateScalarType >(
-                        rawNumericalSolution, variationalEquationsSolution_, std::make_pair( 0, 0 ), std::make_pair( 0, stateTransitionMatrixSize_ ),
+                        rawNumericalSolution, variationalEquationsSolution_,
+                        std::make_pair( 0, 0 ), std::make_pair( 0, stateTransitionMatrixSize_ ),
                         stateTransitionMatrixSize_, parameterVectorSize_ );
         }
         else
@@ -440,9 +555,11 @@ public:
             dynamicsStateDerivative_->setPropagationSettings( boost::assign::list_of( transational_state ), 0, 1 );
             Eigen::MatrixXd initialVariationalState = this->createInitialVariationalEquationsSolution( );
             std::map< double, Eigen::MatrixXd > rawNumericalSolution = integrateEquations< Eigen::MatrixXd, double >(
-                        dynamicsSimulator_->getDoubleStateDerivativeFunction( ), initialVariationalState, variationalOnlyIntegratorSettings_ );
+                        dynamicsSimulator_->getDoubleStateDerivativeFunction( ), initialVariationalState,
+                        variationalOnlyIntegratorSettings_ );
             setVariationalEquationsSolution< double, double >(
-                        rawNumericalSolution, variationalEquationsSolution_, std::make_pair( 0, 0 ), std::make_pair( 0, stateTransitionMatrixSize_ ),
+                        rawNumericalSolution, variationalEquationsSolution_, std::make_pair( 0, 0 ),
+                        std::make_pair( 0, stateTransitionMatrixSize_ ),
                         stateTransitionMatrixSize_, parameterVectorSize_ );
 
         }
@@ -454,15 +571,20 @@ public:
 
     //! Function to return the numerical solution history of numerically integrated variational equations.
     /*!
-     *  Function to return the numerical solution history of numerically integrated variational equations. Key of map denotes time, values are concatenated
-     *  matrices state transition Phi and sensitivity S: [Phi;S].
-     *  \return Map of state history of numerically integrated bodies.
+     *  Function to return the numerical solution history of numerically integrated variational equations.
+     *  \return Vector of mapa of state transition matrix history (first vector entry)
+     *  and sensitivity matrix history (second vector entry)
      */
     std::vector< std::map< double, Eigen::MatrixXd > >& getNumericalVariationalEquationsSolution( )
     {
         return variationalEquationsSolution_;
     }
 
+    //! Function to return object used for numerically propagating and managing the solution of the equations of motion.
+    /*!
+     * Function to return object used for numerically propagating and managing the solution of the equations of motion.
+     * \return Object used for numerically propagating and managing the solution of the equations of motion.
+     */
     boost::shared_ptr< SingleArcDynamicsSimulator< StateScalarType, TimeType > > getDynamicsSimulator( )
     {
         return dynamicsSimulator_;
@@ -477,7 +599,7 @@ private:
     /*!
      *  Reset solutions of variational equations (stateTransitionMatrixInterpolator_ and sensitivityMatrixInterpolator_),
      *  i.e. use numerical integration results to create new look-up tables
-     *  and interpolators of state transition and sensitivity matrix through the createInterpolatorsForVariationalSolution( )
+     *  and interpolators of state transition and sensitivity matrix through the createInterpolatorsForVariationalSolution
      *  function
      */
     void resetVariationalEquationsInterpolators( )
@@ -485,17 +607,21 @@ private:
         using namespace interpolators;
         using namespace utilities;
 
-        boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > > stateTransitionMatrixInterpolator;
-        boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > > sensitivityMatrixInterpolator;
-
+        // Create interpolators.
+        boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+                stateTransitionMatrixInterpolator;
+        boost::shared_ptr< interpolators::OneDimensionalInterpolator< double, Eigen::MatrixXd > >
+                sensitivityMatrixInterpolator;
         createStateTransitionAndSensitivityMatrixInterpolator(
-                    stateTransitionMatrixInterpolator, sensitivityMatrixInterpolator, variationalEquationsSolution_, this->clearNumericalSolution_ );
+                    stateTransitionMatrixInterpolator, sensitivityMatrixInterpolator, variationalEquationsSolution_,
+                    this->clearNumericalSolution_ );
 
+        // Create (if non-existent) or reset state transition matrix interface
         if( stateTransitionInterface_ == NULL )
         {
             stateTransitionInterface_ = boost::make_shared< SingleArcCombinedStateTransitionAndSensitivityMatrixInterface >(
-                        stateTransitionMatrixInterpolator, sensitivityMatrixInterpolator, propagatorSettings_->getStateSize( ),
-                        parameterVectorSize_ );
+                        stateTransitionMatrixInterpolator, sensitivityMatrixInterpolator,
+                        propagatorSettings_->getStateSize( ), parameterVectorSize_ );
         }
         else
         {
@@ -505,18 +631,16 @@ private:
         }
     }
 
+    //! Object used for numerically propagating and managing the solution of the equations of motion.
     boost::shared_ptr< SingleArcDynamicsSimulator< StateScalarType, TimeType > > dynamicsSimulator_;
 
-    //!  Function to return the evaluated variational equations
-    /*!
-     *   Function to return the evaluated variational equations and update environment to current integration step.
-     */
+    //!  Object that is used to evaluate the variational equations at the given state and time.
     boost::shared_ptr< VariationalEquations > variationalEquationsObject_;
 
     //! Map of history of numerically integrated variational equations.
     /*!
-     *  Map of history of numerically integrated variational equations. Key of map denotes time, values are concatenated
-     *  matrices state transition Phi and sensitivity S: [Phi;S].
+     *  Map of history of numerically integrated variational equations. Key of map denotes time, values are
+     *  state transition matrix Phi (first vector entry) and sensitivity matrix S (second vector entry)
      */
     std::vector< std::map< double, Eigen::MatrixXd > > variationalEquationsSolution_;
 
