diff --git a/Tudat/Astrodynamics/Gravitation/CMakeLists.txt b/Tudat/Astrodynamics/Gravitation/CMakeLists.txt
index 94803c3..e8d426c 100644
--- a/Tudat/Astrodynamics/Gravitation/CMakeLists.txt
+++ b/Tudat/Astrodynamics/Gravitation/CMakeLists.txt
@@ -120,7 +120,7 @@ target_link_libraries(test_SphericalHarmonicsGravityModel tudat_gravitation tuda
 
 add_executable(test_ThirdBodyPerturbation "${SRCROOT}${GRAVITATIONDIR}/UnitTests/unitTestThirdBodyPerturbation.cpp")
 setup_custom_test_program(test_ThirdBodyPerturbation "${SRCROOT}${GRAVITATIONDIR}")
-target_link_libraries(test_ThirdBodyPerturbation tudat_gravitation ${Boost_LIBRARIES} )
+target_link_libraries(test_ThirdBodyPerturbation tudat_gravitation tudat_basic_mathematics ${Boost_LIBRARIES} )
 
 add_executable(test_GravityFieldVariations "${SRCROOT}${GRAVITATIONDIR}/UnitTests/unitTestGravityFieldVariations.cpp")
 setup_custom_test_program(test_GravityFieldVariations "${SRCROOT}${GRAVITATIONDIR}")
diff --git a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.cpp b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.cpp
index d113307..81ef2a5 100644
--- a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.cpp
+++ b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.cpp
@@ -113,6 +113,7 @@ Eigen::Vector3d computeGeodesyNormalizedGravitationalAccelerationSum(
     sphericalpositionOfBodySubjectToAcceleration( 2 ) = cylindricalCoordinates( 1 );
 
     legendreCache->updateSines( sphericalpositionOfBodySubjectToAcceleration( 2 ) );
+    legendreCache->updateRadiusPowers( equatorialRadius / sphericalpositionOfBodySubjectToAcceleration( 0 ) );
 
     // Compute gradient premultiplier.
     const double preMultiplier = gravitationalParameter / equatorialRadius;
@@ -146,7 +147,6 @@ Eigen::Vector3d computeGeodesyNormalizedGravitationalAccelerationSum(
             // Compute the potential gradient of a single spherical harmonic term.
             sphericalGradient += basic_mathematics::computePotentialGradient(
                         sphericalpositionOfBodySubjectToAcceleration,
-                        equatorialRadius,
                         preMultiplier,
                         degree,
                         order,
@@ -215,6 +215,7 @@ Eigen::Vector3d computeSingleGeodesyNormalizedGravitationalAcceleration(
     // Compute longitude coordinate.
     sphericalpositionOfBodySubjectToAcceleration( 2 ) = cylindricalCoordinates( 1 );
     legendreCache->updateSines( sphericalpositionOfBodySubjectToAcceleration( 2 ) );
+    legendreCache->updateRadiusPowers( equatorialRadius / sphericalpositionOfBodySubjectToAcceleration( 0 ) );
 
     // Compute gradient premultiplier.
     const double preMultiplier = gravitationalParameter / equatorialRadius;
@@ -239,7 +240,6 @@ Eigen::Vector3d computeSingleGeodesyNormalizedGravitationalAcceleration(
     // Compute the potential gradient resulting from the spherical harmonic term.
     const Eigen::Vector3d sphericalGradient = basic_mathematics::computePotentialGradient(
                 sphericalpositionOfBodySubjectToAcceleration,
-                equatorialRadius,
                 preMultiplier,
                 degree,
                 order,
diff --git a/Tudat/Mathematics/BasicMathematics/legendrePolynomials.cpp b/Tudat/Mathematics/BasicMathematics/legendrePolynomials.cpp
index 036e5de..d31d704 100644
--- a/Tudat/Mathematics/BasicMathematics/legendrePolynomials.cpp
+++ b/Tudat/Mathematics/BasicMathematics/legendrePolynomials.cpp
@@ -56,7 +56,7 @@ void LegendreCache::update( const double polynomialParameter,
     {
         for( int j = 0; ( ( j <= i ) && ( j <= maximumOrder_ ) ) ; j++ )
         {
-            legendreValues_[ i ][ j ] = legendrePolynomialFunction( i, j, polynomialParameter, this );
+            legendreValues_[ i * ( maximumOrder_ + 1 ) + j ] = legendrePolynomialFunction( i, j, polynomialParameter, this );
         }
     }
 }
@@ -65,29 +65,25 @@ void LegendreCache::resetMaximumDegreeAndOrder( const int degree, const int orde
 {
     maximumDegree_ = degree;
     maximumOrder_ = order;
-    legendreValues_.resize( maximumDegree_ + 1 );
-    for( int i = 0; i < maximumDegree_ + 1; i++ )
-    {
-        legendreValues_[ i ].resize( i + 1 );
-    }
-    sinesOfLongitude_.resize( maximumDegree_ + 3 );
-    cosinesOfLongitude_.resize( maximumDegree_ + 3 );
+    legendreValues_.resize( ( maximumDegree_ + 1 ) * ( maximumOrder_ + 1 ) );
+    sinesOfLongitude_.resize( maximumOrder_ + 3 );
+    cosinesOfLongitude_.resize( maximumOrder_ + 3 );
+    referenceRadiusRatioPowers_.resize( maximumDegree_ + 3 );
 
     currentPolynomialParameter_ = -1.0E100;
+    currentPolynomialParameterComplement_ = -1.0E100;
 }
 
-
 //! Get Legendre polynomial from cache when possible, and from direct computation otherwise.
 double LegendreCache::getOrElseUpdate(
         const int degree, const int order, const double polynomialParameter,
-        const LegendrePolynomialFunction legendrePolynomialFunction )
+        const LegendrePolynomialFunction& legendrePolynomialFunction )
 {
-    double returnValue = TUDAT_NAN;
-    //std::cout<<std::setprecision( 10 )<<this<<" "<<polynomialParameter<<" "<<currentPolynomialParameter_<<" "<<degree<<" "<<order<<" "<<
-    //           maximumDegree_<<" "<<maximumOrder_<<std::endl;
     if( polynomialParameter != currentPolynomialParameter_ )
     {
         currentPolynomialParameter_ = polynomialParameter;
+        currentPolynomialParameterComplement_ = std::sqrt( 1.0 - currentPolynomialParameter_ * currentPolynomialParameter_ );
+
         update( polynomialParameter, legendrePolynomialFunction );
     }
 
@@ -98,16 +94,17 @@ double LegendreCache::getOrElseUpdate(
     }
     else if( order > degree )
     {
-        returnValue = 0.0;
+        returnValue_ = 0.0;
     }
     else
     {
-         returnValue = legendreValues_[ degree ][ order ];
+        returnValue_ = legendreValues_[ degree * ( maximumOrder_ + 1  ) + order ];
     }
 
-    return returnValue;
+    return returnValue_;
 
 }
+
 //! Compute unnormalized associated Legendre polynomial.
 double computeLegendrePolynomial( const int degree,
                                   const int order,
@@ -146,11 +143,11 @@ double computeLegendrePolynomial( const int degree,
     {
         // Obtain polynomial of degree one and order one.
         const double degreeOneOrderOnePolynomial = legendreCache->getOrElseUpdate(
-                    1, 1, polynomialParameter, &computeLegendrePolynomial );
+                    1, 1, polynomialParameter, legendrePolynomialFunction);
 
         // Obtain prior sectoral polynomial.
         const double priorSectoralPolynomial = legendreCache->getOrElseUpdate(
-                    degree - 1, order - 1, polynomialParameter, &computeLegendrePolynomial );
+                    degree - 1, order - 1, polynomialParameter, legendrePolynomialFunction);
 
         // Compute polynomial.
         return computeLegendrePolynomialDiagonal(
@@ -162,11 +159,11 @@ double computeLegendrePolynomial( const int degree,
     {
         // Obtain prior degree polynomial.
         const double oneDegreePriorPolynomial = legendreCache->getOrElseUpdate(
-                    degree - 1, order, polynomialParameter, &computeLegendrePolynomial );
+                    degree - 1, order, polynomialParameter, legendrePolynomialFunction);
 
         // Obtain two degrees prior polynomial.
         const double twoDegreesPriorPolynomial = legendreCache->getOrElseUpdate(
-                    degree - 2, order, polynomialParameter, &computeLegendrePolynomial );
+                    degree - 2, order, polynomialParameter, legendrePolynomialFunction);
 
         // Compute polynomial.
         return computeLegendrePolynomialVertical( degree,
@@ -215,11 +212,11 @@ double computeGeodesyLegendrePolynomial( const int degree,
     {
         // Obtain polynomial of degree one and order one.
         double degreeOneOrderOnePolynomial = geodesyLegendreCache->getOrElseUpdate(
-                    1, 1, polynomialParameter, &computeGeodesyLegendrePolynomial );
+                    1, 1, polynomialParameter, geodesyNormalizedLegendrePolynomialFunction );
 
         // Obtain prior sectoral polynomial.
         double priorSectoralPolynomial = geodesyLegendreCache->getOrElseUpdate(
-                    degree - 1, order - 1, polynomialParameter, &computeGeodesyLegendrePolynomial );
+                    degree - 1, order - 1, polynomialParameter, geodesyNormalizedLegendrePolynomialFunction);
 
         // Compute polynomial.
         return computeGeodesyLegendrePolynomialDiagonal(
@@ -231,11 +228,11 @@ double computeGeodesyLegendrePolynomial( const int degree,
     {
         // Obtain prior degree polynomial.
         double oneDegreePriorPolynomial = geodesyLegendreCache->getOrElseUpdate(
-                    degree - 1, order, polynomialParameter, &computeGeodesyLegendrePolynomial );
+                    degree - 1, order, polynomialParameter, geodesyNormalizedLegendrePolynomialFunction);
 
         // Obtain two degrees prior polynomial.
         double twoDegreesPriorPolynomial = geodesyLegendreCache->getOrElseUpdate(
-                    degree - 2, order, polynomialParameter, &computeGeodesyLegendrePolynomial );
+                    degree - 2, order, polynomialParameter, geodesyNormalizedLegendrePolynomialFunction);
 
         // Compute polynomial.
         return computeGeodesyLegendrePolynomialVertical( degree,
@@ -448,10 +445,8 @@ double computeGeodesyLegendrePolynomialVertical( const int degree,
 {
     // Return polynomial.
     return std::sqrt( ( 2.0 * static_cast< double >( degree ) + 1.0 )
-                      / ( static_cast< double >( degree + order ) )
-                      / ( static_cast< double >( degree - order ) ) )
-            * ( std::sqrt( 2.0 * static_cast< double >( degree ) - 1.0 ) * polynomialParameter
-                * oneDegreePriorPolynomial
+                      / ( ( static_cast< double >( degree + order ) ) * ( static_cast< double >( degree - order ) ) ) )
+            * ( std::sqrt( 2.0 * static_cast< double >( degree ) - 1.0 ) * polynomialParameter * oneDegreePriorPolynomial
                 - std::sqrt( ( static_cast< double >( degree + order ) - 1.0 )
                              * ( static_cast< double >( degree - order ) - 1.0 )
                              / ( 2.0 * static_cast< double >( degree ) - 3.0 ) )
diff --git a/Tudat/Mathematics/BasicMathematics/legendrePolynomials.h b/Tudat/Mathematics/BasicMathematics/legendrePolynomials.h
index 0d39afe..ad8344e 100644
--- a/Tudat/Mathematics/BasicMathematics/legendrePolynomials.h
+++ b/Tudat/Mathematics/BasicMathematics/legendrePolynomials.h
@@ -72,22 +72,27 @@ class LegendreCache
 {
 private:
 
-    //! Define Legendre polynomial function pointer.
-    typedef boost::function< double ( int, int, double, LegendreCache* ) > LegendrePolynomialFunction;
 
 public:
 
+    //! Define Legendre polynomial function pointer.
+    typedef boost::function< double ( int, int, double, LegendreCache* ) > LegendrePolynomialFunction;
+
     //! Initialize LegendreCache instance.
     LegendreCache( )
     {
         resetMaximumDegreeAndOrder( 0, 0 );
         currentLongitude_ = TUDAT_NAN;
+        referenceRadiusRatio_ = TUDAT_NAN;
+        returnValue_ = TUDAT_NAN;
     }
 
     LegendreCache( const int maximumDegree, const int maximumOrder )
     {
         resetMaximumDegreeAndOrder( maximumDegree, maximumOrder );
         currentLongitude_ = TUDAT_NAN;
+        referenceRadiusRatio_ = TUDAT_NAN;
+        returnValue_ = TUDAT_NAN;
     }
 
     ~LegendreCache( ){ }
@@ -110,6 +115,19 @@ public:
             }
         }
     }
+    void updateRadiusPowers( const double referenceRadiusRatio )
+    {
+        if( !( referenceRadiusRatio_ == referenceRadiusRatio ) )
+        {
+            referenceRadiusRatio_ = referenceRadiusRatio;
+            double currentRatioPower = 1.0;
+            for( int i = 0; i <= maximumDegree_ + 1; i++ )
+            {
+                referenceRadiusRatioPowers_[ i ] = currentRatioPower;
+                currentRatioPower *= referenceRadiusRatio_;
+            }
+        }
+    }
 
     double getSineOfMultipleLongitude( const int i )
     {
@@ -121,11 +139,23 @@ public:
         return cosinesOfLongitude_[ i ];
     }
 
+    double getReferenceRadiusRatioPowers( const int i )
+    {
+        return referenceRadiusRatioPowers_[ i ];
+    }
+
+
     double getCurrentPolynomialParameter( )
     {
         return currentPolynomialParameter_;
     }
 
+    double getCurrentPolynomialParameterComplement( )
+    {
+        return currentPolynomialParameterComplement_;
+    }
+
+
     //! Get Legendre polynomial value from either cache or from computation.
     /*!
     * \param degree Degree of requested Legendre polynomial.
@@ -137,7 +167,7 @@ public:
     * \return Legendre polynomial value.
     */
     double getOrElseUpdate( const int degree, const int order, const double polynomialParameter,
-                            const LegendrePolynomialFunction legendrePolynomialFunction );
+                            const LegendrePolynomialFunction& legendrePolynomialFunction );
 
     double getNormalizationCoefficient( int i, int j )
     {
@@ -159,9 +189,13 @@ private:
 
     double currentPolynomialParameter_;
 
+    double currentPolynomialParameterComplement_;
+
     double currentLongitude_;
 
-    std::vector< std::vector< double > > legendreValues_;
+    double referenceRadiusRatio_;
+
+    std::vector< double > legendreValues_;
 
     std::vector< std::vector< double > > normalizationCoefficients_;
 
@@ -169,6 +203,11 @@ private:
 
     std::vector< double > cosinesOfLongitude_;
 
+    std::vector< double > referenceRadiusRatioPowers_;
+
+    double returnValue_ ;
+
+
 };
 
 //! Compute unnormalized associated Legendre polynomial.
@@ -443,6 +482,9 @@ double computeGeodesyLegendrePolynomialVertical( const int degree,
 double calculateLegendreGeodesyNormalizationFactor( const int degree, const int order );
 
 
+static const LegendreCache::LegendrePolynomialFunction geodesyNormalizedLegendrePolynomialFunction = &computeGeodesyLegendrePolynomial;
+static const LegendreCache::LegendrePolynomialFunction legendrePolynomialFunction = &computeLegendrePolynomial;
+
 } // namespace basic_mathematics
 } // namespace tudat
 
diff --git a/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.cpp b/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.cpp
index d92af35..61bd74d 100644
--- a/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.cpp
+++ b/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.cpp
@@ -37,6 +37,7 @@
 #include <Eigen/Core>
 
 #include "Tudat/Mathematics/BasicMathematics/sphericalHarmonics.h"
+#include "Tudat/Mathematics/BasicMathematics/basicMathematicsFunctions.h"
 
 namespace tudat
 {
@@ -45,9 +46,9 @@ namespace basic_mathematics
 
 Eigen::Vector3d computePotentialGradient(
         const double distance,
+        const double radiusPowerTerm,
         const double cosineOfOrderLongitude, const double sineOfOrderLongitude,
         const double cosineOfLatitude,
-        const double referenceRadius,
         const double preMultiplier,
         const int degree,
         const int order,
@@ -56,34 +57,23 @@ Eigen::Vector3d computePotentialGradient(
         const double legendrePolynomial,
         const double legendrePolynomialDerivative )
 {
-    // Initialize return variable.
-    Eigen::Vector3d potentialGradient;
-
     // Compute radius power term.
-    const double radiusPowerTerm = std::pow( referenceRadius / distance,
-                                             static_cast< double >( degree ) + 1.0 );
-
-    // Calculate derivative with respect to radius.
-    potentialGradient( radiusIndex ) = - preMultiplier / distance
-            * radiusPowerTerm
-            * ( static_cast< double >( degree ) + 1.0 ) * legendrePolynomial
-            * ( cosineHarmonicCoefficient * cosineOfOrderLongitude
-                + sineHarmonicCoefficient * sineOfOrderLongitude );
-
-    // Calculate derivative with respect to latitude.
-    potentialGradient( latitudeIndex ) = preMultiplier * radiusPowerTerm
-            * legendrePolynomialDerivative * cosineOfLatitude * (
-                cosineHarmonicCoefficient * cosineOfOrderLongitude
-                + sineHarmonicCoefficient * sineOfOrderLongitude );
-
-    // Calculate derivative with respect to longitude.
-    potentialGradient( longitudeIndex ) = preMultiplier * radiusPowerTerm
-            * static_cast< double >( order ) * legendrePolynomial
-            * ( sineHarmonicCoefficient * cosineOfOrderLongitude
-            - cosineHarmonicCoefficient * sineOfOrderLongitude );
 
     // Return result.
-    return potentialGradient;
+    return ( Eigen::Vector3d( ) <<
+             - preMultiplier / distance
+             * radiusPowerTerm
+             * ( static_cast< double >( degree ) + 1.0 ) * legendrePolynomial
+             * ( cosineHarmonicCoefficient * cosineOfOrderLongitude
+                 + sineHarmonicCoefficient * sineOfOrderLongitude ),
+             preMultiplier * radiusPowerTerm
+             * legendrePolynomialDerivative * cosineOfLatitude * (
+                 cosineHarmonicCoefficient * cosineOfOrderLongitude
+                 + sineHarmonicCoefficient * sineOfOrderLongitude ),
+             preMultiplier * radiusPowerTerm
+             * static_cast< double >( order ) * legendrePolynomial
+             * ( sineHarmonicCoefficient * cosineOfOrderLongitude
+                 - cosineHarmonicCoefficient * sineOfOrderLongitude ) ).finished( );
 }
 
 // Compute the gradient of a single term of a spherical harmonics potential field.
@@ -99,14 +89,16 @@ Eigen::Vector3d computePotentialGradient(
         const double legendrePolynomialDerivative )
 {
     return computePotentialGradient(
-                sphericalPosition( radiusIndex ), std::cos( static_cast< double >( order ) * sphericalPosition( longitudeIndex ) ),
+                sphericalPosition( radiusIndex ),
+                basic_mathematics::raiseToIntegerPower
+                ( referenceRadius / sphericalPosition( radiusIndex ), static_cast< double >( degree ) + 1.0 ),
+                std::cos( static_cast< double >( order ) * sphericalPosition( longitudeIndex ) ),
                 std::sin( static_cast< double >( order ) * sphericalPosition( longitudeIndex ) ),
-                std::cos( sphericalPosition( latitudeIndex ) ), referenceRadius, preMultiplier, degree, order,
+                std::cos( sphericalPosition( latitudeIndex ) ), preMultiplier, degree, order,
                 cosineHarmonicCoefficient, sineHarmonicCoefficient, legendrePolynomial,legendrePolynomialDerivative );
 }
 
 Eigen::Vector3d computePotentialGradient( const Eigen::Vector3d& sphericalPosition,
-                                          const double referenceRadius,
                                           const double preMultiplier,
                                           const int degree,
                                           const int order,
@@ -117,9 +109,11 @@ Eigen::Vector3d computePotentialGradient( const Eigen::Vector3d& sphericalPositi
                                           LegendreCache* legendreCache )
 {
     return computePotentialGradient(
-                sphericalPosition( radiusIndex ), legendreCache->getCosineOfMultipleLongitude( order ),
-                legendreCache->getSineOfMultipleLongitude( order ), std::cos( sphericalPosition( latitudeIndex ) ),
-                referenceRadius, preMultiplier, degree, order,
+                sphericalPosition( radiusIndex ),
+                legendreCache->getReferenceRadiusRatioPowers( degree + 1 ),
+                legendreCache->getCosineOfMultipleLongitude( order ),
+                legendreCache->getSineOfMultipleLongitude( order ), legendreCache->getCurrentPolynomialParameterComplement( ),
+                preMultiplier, degree, order,
                 cosineHarmonicCoefficient, sineHarmonicCoefficient, legendrePolynomial,legendrePolynomialDerivative );
 }
 
diff --git a/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.h b/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.h
index 584093f..99e35ea 100644
--- a/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.h
+++ b/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.h
@@ -49,9 +49,9 @@ enum SphericalCoordinatesIndices{ radiusIndex, latitudeIndex, longitudeIndex };
 
 Eigen::Vector3d computePotentialGradient(
         const double distance,
+        const double radiusPowerTerm,
         const double cosineOfOrderLongitude, const double sineOfOrderLongitude,
         const double cosineOfLatitude,
-        const double referenceRadius,
         const double preMultiplier,
         const int degree,
         const int order,
@@ -60,6 +60,8 @@ Eigen::Vector3d computePotentialGradient(
         const double legendrePolynomial,
         const double legendrePolynomialDerivative );
 
+
+
 //! Compute the gradient of a single term of a spherical harmonics potential field.
 /*!
  * This function returns a vector with the derivatives of a generic potential field (defined by
@@ -126,7 +128,6 @@ Eigen::Vector3d computePotentialGradient( const Eigen::Vector3d& sphericalPositi
                                           const double legendrePolynomialDerivative );
 
 Eigen::Vector3d computePotentialGradient( const Eigen::Vector3d& sphericalPosition,
-                                          const double referenceRadius,
                                           const double preMultiplier,
                                           const int degree,
                                           const int order,
