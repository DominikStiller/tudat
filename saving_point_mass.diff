diff --git a/include/tudat/astro/basic_astro/accelerationModel.h b/include/tudat/astro/basic_astro/accelerationModel.h
index bb5a0c876..5605b8628 100644
--- a/include/tudat/astro/basic_astro/accelerationModel.h
+++ b/include/tudat/astro/basic_astro/accelerationModel.h
@@ -15,6 +15,7 @@
 #include <vector>
 #include <map>
 #include <unordered_map>
+#include <iostream>
 
 #include <memory>
 
@@ -152,6 +153,7 @@ AccelerationDataType updateAndGetAcceleration(
         const double currentTime = TUDAT_NAN )
 {
     // Update members.
+    std::cout<<"Acc model: "<<accelerationModel<<std::endl;
     accelerationModel->updateMembers( currentTime );
 
     // Evaluate and return acceleration.
diff --git a/include/tudat/astro/gravitation/centralGravityModel.h b/include/tudat/astro/gravitation/centralGravityModel.h
index ef1833563..e287fc0d9 100644
--- a/include/tudat/astro/gravitation/centralGravityModel.h
+++ b/include/tudat/astro/gravitation/centralGravityModel.h
@@ -219,14 +219,24 @@ public:
      */
     void updateMembers( const double currentTime = TUDAT_NAN )
     {
+        std::cout<<"Update AA"<<std::endl;
+
         if( !( this->currentTime_ == currentTime ) )
         {
+            std::cout<<"Update AB"<<std::endl;
+
             this->updateBaseMembers( );
+            std::cout<<"Update AC"<<std::endl;
+
             this->currentAcceleration_ = computeGravitationalAcceleration(
                         this->positionOfBodySubjectToAcceleration,
                         this->gravitationalParameter,
                         this->positionOfBodyExertingAcceleration );
+            std::cout<<"Update AC"<<std::endl;
+
         }
+        std::cout<<"Update AD"<<std::endl;
+
     }
 
 
diff --git a/include/tudat/astro/gravitation/sphericalHarmonicsGravityModelBase.h b/include/tudat/astro/gravitation/sphericalHarmonicsGravityModelBase.h
index 55150cba8..76afc5395 100644
--- a/include/tudat/astro/gravitation/sphericalHarmonicsGravityModelBase.h
+++ b/include/tudat/astro/gravitation/sphericalHarmonicsGravityModelBase.h
@@ -112,9 +112,16 @@ public:
      */
     void updateBaseMembers( )
     {
+        std::cout<<"Update A"<<std::endl;
         this->gravitationalParameter = this->gravitationalParameterFunction( );
+        std::cout<<"Update B"<<std::endl;
+
         this->subjectPositionFunction( this->positionOfBodySubjectToAcceleration );
+        std::cout<<"Update C"<<std::endl;
+
         this->sourcePositionFunction( this->positionOfBodyExertingAcceleration );
+        std::cout<<"Update D"<<std::endl;
+
     }
 
     //! Function to return the function returning the relevant gravitational parameter.
diff --git a/include/tudat/astro/propagators/dynamicsStateDerivativeModel.h b/include/tudat/astro/propagators/dynamicsStateDerivativeModel.h
index e7829b629..519aaf6fd 100644
--- a/include/tudat/astro/propagators/dynamicsStateDerivativeModel.h
+++ b/include/tudat/astro/propagators/dynamicsStateDerivativeModel.h
@@ -749,7 +749,7 @@ std::vector< std::shared_ptr< basic_astrodynamics::AccelerationModel3d > > getAc
     {
         basic_astrodynamics::AccelerationMap accelerationModelList =
                 std::dynamic_pointer_cast< NBodyStateDerivative< StateScalarType, TimeType > >(
-                    stateDerivativeModels.at( propagators::translational_state ).at( 0 ) )->getAccelerationsMap( );
+                    stateDerivativeModels.at( propagators::translational_state ).at( 0 ) )->getOriginalAccelerationsMap( );
 
         if( accelerationModelList.count( bodyUndergoingAcceleration ) == 0 )
         {
diff --git a/include/tudat/astro/propagators/nBodyEnckeStateDerivative.h b/include/tudat/astro/propagators/nBodyEnckeStateDerivative.h
index 822643a67..06d3bd9a4 100644
--- a/include/tudat/astro/propagators/nBodyEnckeStateDerivative.h
+++ b/include/tudat/astro/propagators/nBodyEnckeStateDerivative.h
@@ -81,8 +81,6 @@ public:
         currentKeplerianOrbitCartesianState_.resize( bodiesToIntegrate.size( ) );
 
 
-        originalAccelerationModelsPerBody_ = this->accelerationModelsPerBody_ ;
-
         // Remove central gravitational acceleration from list of accelerations that is to be evaluated
         centralBodyGravitationalParameters_ =
                 removeCentralGravityAccelerations(
@@ -223,10 +221,6 @@ public:
         }
     }
 
-    basic_astrodynamics::AccelerationMap getFullAccelerationsMap( )
-    {
-        return originalAccelerationModelsPerBody_;
-    }
 
 private:
 
@@ -294,7 +288,6 @@ private:
     //! referfence Kepler state.
     TimeType currentKeplerOrbitTime_;
 
-    basic_astrodynamics::AccelerationMap originalAccelerationModelsPerBody_;
 
 
 };
diff --git a/include/tudat/astro/propagators/nBodyGaussKeplerStateDerivative.h b/include/tudat/astro/propagators/nBodyGaussKeplerStateDerivative.h
index 1eb9b65d1..59bcdc39c 100644
--- a/include/tudat/astro/propagators/nBodyGaussKeplerStateDerivative.h
+++ b/include/tudat/astro/propagators/nBodyGaussKeplerStateDerivative.h
@@ -107,7 +107,6 @@ public:
             accelerationModelsPerBody, centralBodyData, gauss_keplerian, bodiesToIntegrate )
     {
         currentTrueAnomalies_.resize( bodiesToIntegrate.size( ) );
-        originalAccelerationModelsPerBody_ = this->accelerationModelsPerBody_ ;
 
         // Remove central gravitational acceleration from list of accelerations that is to be evaluated
         centralBodyGravitationalParameters_ =
@@ -252,16 +251,6 @@ public:
         currentCartesianLocalSolution_ = currentCartesianLocalSolution.template cast< double >( );
     }
 
-    //! Function to get the acceleration models
-    /*!
-     * Function to get the acceleration models, including the central body accelerations that are removed for the Gauss
-     * propagation scheme
-     * \return List of acceleration models, including the central body accelerations that are removed in this propagation scheme.
-     */
-    basic_astrodynamics::AccelerationMap getFullAccelerationsMap( )
-    {
-        return originalAccelerationModelsPerBody_;
-    }
 
 private:
 
@@ -272,9 +261,6 @@ private:
     std::vector< std::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > >
     centralAccelerations_;
 
-    //! List of acceleration models, including the central body accelerations that are removed in this propagation scheme.
-    basic_astrodynamics::AccelerationMap originalAccelerationModelsPerBody_;
-
     //! Current full Cartesian state of the propagated bodies, w.r.t. trhe central bodies
     /*!
      *  Current full Cartesian state of the propagated bodies, w.r.t. trhe central bodies. These variables are set when calling
diff --git a/include/tudat/astro/propagators/nBodyGaussModifiedEquinoctialStateDerivative.h b/include/tudat/astro/propagators/nBodyGaussModifiedEquinoctialStateDerivative.h
index 8d062241c..c9efcf6de 100644
--- a/include/tudat/astro/propagators/nBodyGaussModifiedEquinoctialStateDerivative.h
+++ b/include/tudat/astro/propagators/nBodyGaussModifiedEquinoctialStateDerivative.h
@@ -69,8 +69,6 @@ public:
         NBodyStateDerivative< StateScalarType, TimeType >(
             accelerationModelsPerBody, centralBodyData, gauss_modified_equinoctial, bodiesToIntegrate )
     {
-        originalAccelerationModelsPerBody_ = this->accelerationModelsPerBody_ ;
-
         // Remove central gravitational acceleration from list of accelerations that is to be evaluated
         centralBodyGravitationalParameters_ =
                 removeCentralGravityAccelerations(
@@ -199,29 +197,12 @@ public:
         currentCartesianLocalSolution_ = currentCartesianLocalSolution;
     }
 
-    //! Function to get the acceleration models
-    /*!
-     * Function to get the acceleration models, including the central body accelerations that are removed for the Gauss
-     * propagation scheme
-     * \return List of acceleration models, including the central body accelerations that are removed in this propagation scheme.
-     */
-    basic_astrodynamics::AccelerationMap getFullAccelerationsMap( )
-    {
-        return originalAccelerationModelsPerBody_;
-    }
 
 private:
 
     //!  Gravitational parameters of central bodies used to convert Cartesian to Keplerian orbits, and vice versa
     std::vector< std::function< double( ) > > centralBodyGravitationalParameters_;
 
-    //! Central body accelerations for each propagated body, which has been removed from accelerationModelsPerBody_
-    std::vector< std::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > >
-    centralAccelerations_;
-
-    //! List of acceleration models, including the central body accelerations thta are removed in this propagation scheme.
-    basic_astrodynamics::AccelerationMap originalAccelerationModelsPerBody_;
-
     //! Current full Cartesian state of the propagated bodies, w.r.t. the central bodies
     /*!
      *  Current full Cartesian state of the propagated bodies, w.r.t. the central bodies. These variables are set when calling
diff --git a/include/tudat/astro/propagators/nBodyStateDerivative.h b/include/tudat/astro/propagators/nBodyStateDerivative.h
index 4c53808ed..f95a30d0e 100644
--- a/include/tudat/astro/propagators/nBodyStateDerivative.h
+++ b/include/tudat/astro/propagators/nBodyStateDerivative.h
@@ -120,6 +120,8 @@ public:
         propagatorType_( propagatorType ),
         bodiesToBeIntegratedNumerically_( bodiesToIntegrate )
     {
+        originalAccelerationModelsPerBody_ = accelerationModelsPerBody;
+
         // Add empty acceleration map if body is to be propagated with no accelerations.
         for( unsigned int i = 0; i < bodiesToBeIntegratedNumerically_.size( ); i++ )
         {
@@ -160,9 +162,9 @@ public:
      */
     void clearTranslationalStateDerivativeModel( )
     {
-        for( unsigned int i = 0; i < accelerationModelList_.size( ); i++ )
+        for( unsigned int i = 0; i < originalAccelerationModelList_.size( ); i++ )
         {
-            accelerationModelList_.at( i )->resetTime( TUDAT_NAN );
+            originalAccelerationModelList_.at( i )->resetTime( TUDAT_NAN );
         }
     }
 
@@ -231,15 +233,6 @@ public:
         return bodiesToBeIntegratedNumerically_;
     }
 
-    // Function to get map containing the list of accelerations acting on each body,
-    /*
-     * Function to get map containing the list of accelerations acting on each body,
-     * \return A map containing the list of accelerations acting on each body,
-     */
-    virtual basic_astrodynamics::AccelerationMap getFullAccelerationsMap( )
-    {
-        return accelerationModelsPerBody_;
-    }
 
     // Function to get object providing the current integration origins
     /*
@@ -282,7 +275,8 @@ public:
      * \return
      */
     Eigen::Vector3d getTotalAccelerationForBody(
-            const std::string& bodyName )
+            const std::string& bodyName,
+            const double currentTime )
     {
         // Check if body is propagated.
         Eigen::Vector3d totalAcceleration = Eigen::Vector3d::Zero( );
@@ -296,10 +290,10 @@ public:
         }
         else
         {
-            if( accelerationModelsPerBody_.count( bodyName ) != 0 )
+            if( originalAccelerationModelsPerBody_.count( bodyName ) != 0 )
             {
                 basic_astrodynamics::SingleBodyAccelerationMap accelerationsOnBody =
-                        accelerationModelsPerBody_.at( bodyName );
+                        originalAccelerationModelsPerBody_.at( bodyName );
 
                 // Iterate over all accelerations acting on body
                 for( innerAccelerationIterator  = accelerationsOnBody.begin( );
@@ -309,6 +303,7 @@ public:
                     for( unsigned int j = 0; j < innerAccelerationIterator->second.size( ); j++ )
                     {
                         // Calculate acceleration and add to state derivative.
+                         innerAccelerationIterator->second[ j ]->updateMembers( currentTime );
                          innerAccelerationIterator->second[ j ]->addCurrentAcceleration( totalAcceleration );
                     }
                 }
@@ -327,6 +322,18 @@ public:
         return accelerationModelsPerBody_;
     }
 
+    //! Function to get the acceleration models
+    /*!
+     * Function to get the acceleration models, including the central body accelerations that are removed for certain
+     * propagation schemes
+     * \return List of acceleration models, including the central body accelerations that are removed in certain propagation schemes.
+     */
+    basic_astrodynamics::AccelerationMap getOriginalAccelerationsMap( )
+    {
+        return originalAccelerationModelsPerBody_;
+    }
+
+
 protected:
 
     // Function to set the vector of acceleration models (accelerationModelList_) form the map of map of
@@ -350,6 +357,24 @@ protected:
                 }
             }
         }
+
+        // Iterate over all accelerations and update their internal state.
+        originalAccelerationModelList_.clear( );
+        for( outerAccelerationIterator = originalAccelerationModelsPerBody_.begin( );
+             outerAccelerationIterator != originalAccelerationModelsPerBody_.end( ); outerAccelerationIterator++ )
+        {
+            // Iterate over all accelerations acting on body
+            for( innerAccelerationIterator  = outerAccelerationIterator->second.begin( );
+                 innerAccelerationIterator != outerAccelerationIterator->second.end( );
+                 innerAccelerationIterator++ )
+            {
+                // Update accelerations
+                for( unsigned int j = 0; j < innerAccelerationIterator->second.size( ); j++ )
+                {
+                    originalAccelerationModelList_.push_back( innerAccelerationIterator->second.at( j ) );
+                }
+            }
+        }
     }
 
     // Function to get the state derivative of the system in Cartesian coordinates.
@@ -437,9 +462,13 @@ protected:
      */
     basic_astrodynamics::AccelerationMap accelerationModelsPerBody_;
 
+    basic_astrodynamics::AccelerationMap originalAccelerationModelsPerBody_;
+
     // Vector of acceleration models, containing all entries of accelerationModelsPerBody_.
     std::vector< std::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > > accelerationModelList_;
 
+    std::vector< std::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > > originalAccelerationModelList_;
+
     // Object responsible for providing the current integration origins from the global origins.
     std::shared_ptr< CentralBodyData< StateScalarType, TimeType > > centralBodyData_;
 
diff --git a/include/tudat/astro/propagators/nBodyUnifiedStateModelExponentialMapStateDerivative.h b/include/tudat/astro/propagators/nBodyUnifiedStateModelExponentialMapStateDerivative.h
index 7ad7fbaad..f0c5064f9 100644
--- a/include/tudat/astro/propagators/nBodyUnifiedStateModelExponentialMapStateDerivative.h
+++ b/include/tudat/astro/propagators/nBodyUnifiedStateModelExponentialMapStateDerivative.h
@@ -113,8 +113,6 @@ public:
         NBodyStateDerivative< StateScalarType, TimeType >(
             accelerationModelsPerBody, centralBodyData, unified_state_model_exponential_map, bodiesToIntegrate )
     {
-        originalAccelerationModelsPerBody_ = this->accelerationModelsPerBody_;
-
         // Remove central gravitational acceleration from list of accelerations that is to be evaluated
         centralBodyGravitationalParameters_ =
                 removeCentralGravityAccelerations(
@@ -217,17 +215,6 @@ public:
         currentCartesianLocalSolution_ = currentCartesianLocalSolution;
     }
 
-    //! Function to get the acceleration models
-    /*!
-     * Function to get the acceleration models, including the central body accelerations that are removed for the
-     * propagation scheme
-     * \return List of acceleration models, including the central body accelerations that are removed in this propagation scheme.
-     */
-    basic_astrodynamics::AccelerationMap getFullAccelerationsMap( )
-    {
-        return originalAccelerationModelsPerBody_;
-    }
-
     //! Function to return the size of the state handled by the object.
     /*!
      * Function to return the size of the state handled by the object.
@@ -289,9 +276,6 @@ private:
     std::vector< std::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > >
     centralAccelerations_;
 
-    //! List of acceleration models, including the central body accelerations that are removed in this propagation scheme.
-    basic_astrodynamics::AccelerationMap originalAccelerationModelsPerBody_;
-
     //! Current full Cartesian state of the propagated bodies, w.r.t. the central bodies
     /*!
      *  Current full Cartesian state of the propagated bodies, w.r.t. the central bodies. These variables are set when calling
diff --git a/include/tudat/astro/propagators/nBodyUnifiedStateModelModifiedRodriguesParametersStateDerivative.h b/include/tudat/astro/propagators/nBodyUnifiedStateModelModifiedRodriguesParametersStateDerivative.h
index 0590c7041..c13d3cd03 100644
--- a/include/tudat/astro/propagators/nBodyUnifiedStateModelModifiedRodriguesParametersStateDerivative.h
+++ b/include/tudat/astro/propagators/nBodyUnifiedStateModelModifiedRodriguesParametersStateDerivative.h
@@ -113,8 +113,6 @@ public:
         NBodyStateDerivative< StateScalarType, TimeType >(
             accelerationModelsPerBody, centralBodyData, unified_state_model_modified_rodrigues_parameters, bodiesToIntegrate )
     {
-        originalAccelerationModelsPerBody_ = this->accelerationModelsPerBody_ ;
-
         // Remove central gravitational acceleration from list of accelerations that is to be evaluated
         centralBodyGravitationalParameters_ =
                 removeCentralGravityAccelerations(
@@ -218,17 +216,6 @@ public:
         currentCartesianLocalSolution_ = currentCartesianLocalSolution;
     }
 
-    //! Function to get the acceleration models
-    /*!
-     * Function to get the acceleration models, including the central body accelerations that are removed for the
-     * propagation scheme
-     * \return List of acceleration models, including the central body accelerations that are removed in this propagation scheme.
-     */
-    basic_astrodynamics::AccelerationMap getFullAccelerationsMap( )
-    {
-        return originalAccelerationModelsPerBody_;
-    }
-
     //! Function to return the size of the state handled by the object.
     /*!
      * Function to return the size of the state handled by the object.
@@ -291,9 +278,6 @@ private:
     std::vector< std::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > >
     centralAccelerations_;
 
-    //! List of acceleration models, including the central body accelerations that are removed in this propagation scheme.
-    basic_astrodynamics::AccelerationMap originalAccelerationModelsPerBody_;
-
     //! Current full Cartesian state of the propagated bodies, w.r.t. the central bodies
     /*!
      *  Current full Cartesian state of the propagated bodies, w.r.t. the central bodies. These variables are set when calling
diff --git a/include/tudat/astro/propagators/nBodyUnifiedStateModelQuaternionsStateDerivative.h b/include/tudat/astro/propagators/nBodyUnifiedStateModelQuaternionsStateDerivative.h
index 686091485..66797ddd8 100644
--- a/include/tudat/astro/propagators/nBodyUnifiedStateModelQuaternionsStateDerivative.h
+++ b/include/tudat/astro/propagators/nBodyUnifiedStateModelQuaternionsStateDerivative.h
@@ -111,8 +111,6 @@ public:
         NBodyStateDerivative< StateScalarType, TimeType >(
             accelerationModelsPerBody, centralBodyData, unified_state_model_quaternions, bodiesToIntegrate )
     {
-        originalAccelerationModelsPerBody_ = this->accelerationModelsPerBody_ ;
-
         // Remove central gravitational acceleration from list of accelerations that is to be evaluated
         centralBodyGravitationalParameters_ =
                 removeCentralGravityAccelerations(
@@ -215,17 +213,6 @@ public:
         currentCartesianLocalSolution_ = currentCartesianLocalSolution;
     }
 
-    //! Function to get the acceleration models
-    /*!
-     * Function to get the acceleration models, including the central body accelerations that are removed for the
-     * propagation scheme
-     * \return List of acceleration models, including the central body accelerations that are removed in this propagation scheme.
-     */
-    basic_astrodynamics::AccelerationMap getFullAccelerationsMap( )
-    {
-        return originalAccelerationModelsPerBody_;
-    }
-
     //! Function to return the size of the state handled by the object.
     /*!
      * Function to return the size of the state handled by the object.
@@ -284,9 +271,6 @@ private:
     std::vector< std::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > >
     centralAccelerations_;
 
-    //! List of acceleration models, including the central body accelerations that are removed in this propagation scheme.
-    basic_astrodynamics::AccelerationMap originalAccelerationModelsPerBody_;
-
     //! Current full Cartesian state of the propagated bodies, w.r.t. the central bodies
     /*!
      *  Current full Cartesian state of the propagated bodies, w.r.t. the central bodies. These variables are set when calling
diff --git a/include/tudat/simulation/environment_setup/body.h b/include/tudat/simulation/environment_setup/body.h
index c6d5cec46..4f052f064 100644
--- a/include/tudat/simulation/environment_setup/body.h
+++ b/include/tudat/simulation/environment_setup/body.h
@@ -1785,6 +1785,18 @@ public:
         bodyMap_.erase( bodyName );
 
     }
+
+    void setLastUpdateTime( const double lastUpdateTime )
+    {
+        std::cout<<"Setting update time "<<lastUpdateTime<<std::endl;
+        lastUpdateTime_ = lastUpdateTime;
+    }
+
+    double getLastUpdateTime( ) const
+    {
+       return lastUpdateTime_;
+    }
+
 private:
 
     std::string frameOrigin_;
@@ -1793,6 +1805,8 @@ private:
 
     std::unordered_map< std::string, std::shared_ptr< Body > > bodyMap_;
 
+    double lastUpdateTime_;
+
 };
 
 double getBodyGravitationalParameter( const SystemOfBodies& bodies, const std::string bodyName );
@@ -1804,7 +1818,7 @@ double getBodyGravitationalParameter( const SystemOfBodies& bodies, const std::s
  * \param bodies List of body objects.
  * \return Global translational state origin of the environment
  */
-std::string getGlobalFrameOrigin(const SystemOfBodies &bodies);
+std::string getGlobalFrameOrigin(const SystemOfBodies& bodies);
 
 //! Function to set whether the bodies are currently being propagated, or not
 /*!
@@ -1812,7 +1826,7 @@ std::string getGlobalFrameOrigin(const SystemOfBodies &bodies);
  * \param bodies List of body objects.
  * \param areBodiesInPropagation Boolean defining whether the bodies are currently being propagated, or not
  */
-void setAreBodiesInPropagation(const SystemOfBodies &bodies,
+void setAreBodiesInPropagation(const SystemOfBodies& bodies,
                                const bool areBodiesInPropagation);
 
 //! Function to compute the acceleration of a body, using its ephemeris and finite differences
diff --git a/include/tudat/simulation/estimation_setup/createDifferencedOneWayRangeRatePartials.h b/include/tudat/simulation/estimation_setup/createDifferencedOneWayRangeRatePartials.h
index fc23d855b..a6454e98e 100755
--- a/include/tudat/simulation/estimation_setup/createDifferencedOneWayRangeRatePartials.h
+++ b/include/tudat/simulation/estimation_setup/createDifferencedOneWayRangeRatePartials.h
@@ -62,7 +62,7 @@ std::map< observation_models::LinkEnds,
 std::pair< SingleLinkObservationPartialList, std::shared_ptr< PositionPartialScaling > > >
 createDifferencedOneWayRangeRatePartials(
         const std::vector< observation_models::LinkEnds > linkEnds,
-        const simulation_setup::SystemOfBodies bodies,
+        const simulation_setup::SystemOfBodies& bodies,
         const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< ParameterType > > parametersToEstimate,
         const PerLinkEndPerLightTimeSolutionCorrections& lightTimeCorrections =
         PerLinkEndPerLightTimeSolutionCorrections( ) )
diff --git a/include/tudat/simulation/estimation_setup/createObservationManager.h b/include/tudat/simulation/estimation_setup/createObservationManager.h
index e7ee0329b..8f69fb09c 100644
--- a/include/tudat/simulation/estimation_setup/createObservationManager.h
+++ b/include/tudat/simulation/estimation_setup/createObservationManager.h
@@ -293,7 +293,7 @@ template< int ObservationSize = 1, typename ObservationScalarType, typename Time
 std::shared_ptr< ObservationManagerBase< ObservationScalarType, TimeType > > createObservationManager(
         const ObservableType observableType,
         const std::vector< std::shared_ptr< ObservationModelSettings  > > observationModelSettingsList,
-        const simulation_setup::SystemOfBodies &bodies,
+        const simulation_setup::SystemOfBodies& bodies,
         const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< ObservationScalarType > >
         parametersToEstimate,
         const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface >
@@ -351,7 +351,7 @@ template< typename ObservationScalarType, typename TimeType >
 std::shared_ptr< ObservationManagerBase< ObservationScalarType, TimeType > > createObservationManagerBase(
         const ObservableType observableType,
         const std::vector< std::shared_ptr< ObservationModelSettings > > observationModelSettingsList,
-        const simulation_setup::SystemOfBodies &bodies,
+        const simulation_setup::SystemOfBodies& bodies,
         const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< ObservationScalarType > > parametersToEstimate,
         const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface )
 {
diff --git a/include/tudat/simulation/estimation_setup/createObservationModel.h b/include/tudat/simulation/estimation_setup/createObservationModel.h
index 19d7477b4..6aec99e0b 100644
--- a/include/tudat/simulation/estimation_setup/createObservationModel.h
+++ b/include/tudat/simulation/estimation_setup/createObservationModel.h
@@ -690,7 +690,7 @@ template< typename ObservationScalarType = double, typename TimeType = double >
 std::shared_ptr< DopplerProperTimeRateInterface > createOneWayDopplerProperTimeCalculator(
         std::shared_ptr< DopplerProperTimeRateSettings > properTimeRateSettings,
         const LinkEnds& linkEnds,
-        const simulation_setup::SystemOfBodies &bodies,
+        const simulation_setup::SystemOfBodies& bodies,
         const LinkEndType linkEndForCalculator )
 {
     std::shared_ptr< DopplerProperTimeRateInterface > properTimeRateInterface;
@@ -789,7 +789,7 @@ std::shared_ptr< ObservationBias< ObservationSize > > createObservationBiasCalcu
         const LinkEnds linkEnds,
         const ObservableType observableType,
         const std::shared_ptr< ObservationBiasSettings > biasSettings,
-        const simulation_setup::SystemOfBodies &bodies )
+        const simulation_setup::SystemOfBodies& bodies )
 {
     std::shared_ptr< ObservationBias< ObservationSize > > observationBias;
     switch( biasSettings->observationBiasType_ )
@@ -964,7 +964,7 @@ public:
     static std::shared_ptr< observation_models::ObservationModel<
     ObservationSize, ObservationScalarType, TimeType > > createObservationModel(
             const std::shared_ptr< ObservationModelSettings > observationSettings,
-            const simulation_setup::SystemOfBodies &bodies );
+            const simulation_setup::SystemOfBodies& bodies );
 };
 
 //! Interface class for creating observation models of size 1.
@@ -984,7 +984,7 @@ public:
     static std::shared_ptr< observation_models::ObservationModel<
     1, ObservationScalarType, TimeType > > createObservationModel(
             const std::shared_ptr< ObservationModelSettings > observationSettings,
-            const simulation_setup::SystemOfBodies &bodies )
+            const simulation_setup::SystemOfBodies& bodies )
     {
         using namespace observation_models;
 
@@ -1367,7 +1367,7 @@ public:
     static std::shared_ptr< observation_models::ObservationModel<
     2, ObservationScalarType, TimeType > > createObservationModel(
             const std::shared_ptr< ObservationModelSettings > observationSettings,
-            const simulation_setup::SystemOfBodies &bodies )
+            const simulation_setup::SystemOfBodies& bodies )
     {
         using namespace observation_models;
         std::shared_ptr< observation_models::ObservationModel<
@@ -1446,7 +1446,7 @@ public:
     static std::shared_ptr< observation_models::ObservationModel<
     3, ObservationScalarType, TimeType > > createObservationModel(
             const std::shared_ptr< ObservationModelSettings > observationSettings,
-            const simulation_setup::SystemOfBodies &bodies )
+            const simulation_setup::SystemOfBodies& bodies )
     {
         using namespace observation_models;
         std::shared_ptr< observation_models::ObservationModel<
@@ -1626,7 +1626,7 @@ template< int ObservationSize = 1, typename ObservationScalarType = double, type
 std::shared_ptr< ObservationSimulator< ObservationSize, ObservationScalarType, TimeType > > createObservationSimulator(
         const ObservableType observableType,
         const std::vector< std::shared_ptr< ObservationModelSettings  > > settingsList,
-        const simulation_setup::SystemOfBodies &bodies )
+        const simulation_setup::SystemOfBodies& bodies )
 {
     std::map< LinkEnds, std::shared_ptr< ObservationModel< ObservationSize, ObservationScalarType, TimeType > > >
             observationModels;
diff --git a/include/tudat/simulation/estimation_setup/createStateDerivativePartials.h b/include/tudat/simulation/estimation_setup/createStateDerivativePartials.h
index 1f1a52458..2ac3eeb30 100644
--- a/include/tudat/simulation/estimation_setup/createStateDerivativePartials.h
+++ b/include/tudat/simulation/estimation_setup/createStateDerivativePartials.h
@@ -69,7 +69,7 @@ std::map< propagators::IntegratedStateType, orbit_determination::StateDerivative
                 // Retrieve acceleration models and create partials
                 basic_astrodynamics::AccelerationMap accelerationModelList =
                         std::dynamic_pointer_cast< propagators::NBodyStateDerivative< StateScalarType, TimeType > >(
-                            stateDerivativeIterator->second.at( 0 ) )->getFullAccelerationsMap( );
+                            stateDerivativeIterator->second.at( 0 ) )->getOriginalAccelerationsMap( );
                 stateDerivativePartials[ propagators::translational_state ] =
                         createAccelerationPartialsMap< StateScalarType >(
                             accelerationModelList, bodies, parametersToEstimate );
diff --git a/include/tudat/simulation/estimation_setup/orbitDeterminationManager.h b/include/tudat/simulation/estimation_setup/orbitDeterminationManager.h
index 7dca869c3..1ed491ffa 100644
--- a/include/tudat/simulation/estimation_setup/orbitDeterminationManager.h
+++ b/include/tudat/simulation/estimation_setup/orbitDeterminationManager.h
@@ -122,7 +122,7 @@ public:
      *  true)
      */
     OrbitDeterminationManager(
-            const SystemOfBodies &bodies,
+            const SystemOfBodies& bodies,
             const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< ObservationScalarType > >
             parametersToEstimate,
             const std::vector< std::shared_ptr< observation_models::ObservationModelSettings > >& observationSettingsList,
@@ -136,7 +136,7 @@ public:
     }
 
     OrbitDeterminationManager(
-            const SystemOfBodies &bodies,
+            const SystemOfBodies& bodies,
             const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< ObservationScalarType > >
             parametersToEstimate,
             const std::vector< std::shared_ptr< observation_models::ObservationModelSettings > >& observationSettingsList,
@@ -753,7 +753,7 @@ protected:
      *  true)
      */
     void initializeOrbitDeterminationManager(
-            const SystemOfBodies &bodies,
+            const SystemOfBodies& bodies,
             const std::vector< std::shared_ptr< observation_models::ObservationModelSettings > >& observationSettingsList,
             const std::vector< std::shared_ptr< numerical_integrators::IntegratorSettings< TimeType > > > integratorSettings,
             const std::shared_ptr< propagators::PropagatorSettings< ObservationScalarType > > propagatorSettings,
diff --git a/include/tudat/simulation/estimation_setup/simulateObservations.h b/include/tudat/simulation/estimation_setup/simulateObservations.h
index c7dea06ee..930b68937 100644
--- a/include/tudat/simulation/estimation_setup/simulateObservations.h
+++ b/include/tudat/simulation/estimation_setup/simulateObservations.h
@@ -327,7 +327,7 @@ template< typename ObservationScalarType = double, typename TimeType = double >
 std::shared_ptr< observation_models::ObservationCollection< ObservationScalarType, TimeType > > simulateObservations(
         const std::vector< std::shared_ptr< ObservationSimulationSettings< TimeType > > >& observationsToSimulate,
         const std::vector< std::shared_ptr< observation_models::ObservationSimulatorBase< ObservationScalarType, TimeType > > >& observationSimulators,
-        const SystemOfBodies bodies )
+        const SystemOfBodies& bodies )
 {
     // Declare return map.
     typename observation_models::ObservationCollection< ObservationScalarType, TimeType >::SortedObservationSets sortedObservations;
diff --git a/include/tudat/simulation/propagation_setup/dynamicsSimulator.h b/include/tudat/simulation/propagation_setup/dynamicsSimulator.h
index 2eb466f17..daea57fac 100644
--- a/include/tudat/simulation/propagation_setup/dynamicsSimulator.h
+++ b/include/tudat/simulation/propagation_setup/dynamicsSimulator.h
@@ -302,7 +302,7 @@ public:
      *  Function to get the map of named bodies involved in simulation.
      *  \return Map of named bodies involved in simulation.
      */
-    simulation_setup::SystemOfBodies getSystemOfBodies( )
+    simulation_setup::SystemOfBodies& getSystemOfBodies( )
     {
         return bodies_;
     }
diff --git a/include/tudat/simulation/propagation_setup/environmentUpdater.h b/include/tudat/simulation/propagation_setup/environmentUpdater.h
index e40f810b8..d2ad227b0 100644
--- a/include/tudat/simulation/propagation_setup/environmentUpdater.h
+++ b/include/tudat/simulation/propagation_setup/environmentUpdater.h
@@ -122,6 +122,8 @@ public:
         {
             updateFunctionVector_.at( i ).template get< 2 >( )( currentTime );
         }
+
+        bodyList_.setLastUpdateTime( currentTime );
     }
 
 private:
diff --git a/include/tudat/simulation/propagation_setup/propagationOutput.h b/include/tudat/simulation/propagation_setup/propagationOutput.h
index 121794f07..3c2053cfa 100644
--- a/include/tudat/simulation/propagation_setup/propagationOutput.h
+++ b/include/tudat/simulation/propagation_setup/propagationOutput.h
@@ -400,9 +400,8 @@ std::pair< std::function< Eigen::VectorXd( ) >, int > getVectorDependentVariable
         // Retrieve model responsible for computing accelerations of requested bodies.
         std::shared_ptr< NBodyStateDerivative< StateScalarType, TimeType > > nBodyModel =
                 getTranslationalStateDerivativeModelForBody( bodyWithProperty, stateDerivativeModels );
-        variableFunction =
-                std::bind( &NBodyStateDerivative< StateScalarType, TimeType >::getTotalAccelerationForBody, nBodyModel,
-                           bodyWithProperty );
+
+        variableFunction = [&]( ){ return nBodyModel->getTotalAccelerationForBody( bodyWithProperty, bodies.getLastUpdateTime( ) ); };
         parameterSize = 3;
 
 
@@ -420,12 +419,14 @@ std::pair< std::function< Eigen::VectorXd( ) >, int > getVectorDependentVariable
         }
         else
         {
+            std::cout<<"test a"<<std::endl;
             // Retrieve list of suitable acceleration models (size should be one to avoid ambiguities)
             std::vector< std::shared_ptr< basic_astrodynamics::AccelerationModel< Eigen::Vector3d > > >
                     listOfSuitableAccelerationModels = getAccelerationBetweenBodies(
                         accelerationDependentVariableSettings->associatedBody_,
                         accelerationDependentVariableSettings->secondaryBody_,
                         stateDerivativeModels, accelerationDependentVariableSettings->accelerationModelType_ );
+            std::cout<<"test b"<<std::endl;
 
             // Check if third-body counterpart of acceleration is found
             if( listOfSuitableAccelerationModels.size( ) == 0 && basic_astrodynamics::isAccelerationDirectGravitational(
@@ -450,10 +451,21 @@ std::pair< std::function< Eigen::VectorXd( ) >, int > getVectorDependentVariable
             }
             else
             {
+                std::cout<<"test c"<<std::endl;
+
                 //std::function< Eigen::Vector3d( ) > vectorFunction =
-                variableFunction = std::bind( &basic_astrodynamics::AccelerationModel3d::getAcceleration,
-                                              listOfSuitableAccelerationModels.at( 0 ) );
+                variableFunction = [&]( ){
+                    std::cout<<"In func"<<std::endl;
+//                    std::cout<<bodies.getLastUpdateTime( )<<std::endl;
+                    std::cout<<"In func2 "<<listOfSuitableAccelerationModels.at( 0 )<<std::endl;
+                    Eigen::Vector3d valueToRetrieve = basic_astrodynamics::updateAndGetAcceleration(
+                                listOfSuitableAccelerationModels.at( 0 ), 100.0 );
+                    std::cout<<"In func3"<<std::endl;
+
+                    return valueToRetrieve; };
                 parameterSize = 3;
+                std::cout<<"test d"<<std::endl;
+
             }
         }
         break;
@@ -1411,10 +1423,8 @@ std::function< double( ) > getDoubleDependentVariableFunction(
                 }
                 else
                 {
-                    std::function< Eigen::Vector3d( ) > vectorFunction =
-                            std::bind( &basic_astrodynamics::AccelerationModel3d::getAcceleration,
-                                       listOfSuitableAccelerationModels.at( 0 ) );
-                    variableFunction = std::bind( &linear_algebra::getVectorNormFromFunction, vectorFunction );
+                    variableFunction = [&]( ){ return ( basic_astrodynamics::updateAndGetAcceleration(
+                                listOfSuitableAccelerationModels.at( 0 ), bodies.getLastUpdateTime( ) ) ).norm( ); };
                 }
             }
             break;
@@ -1424,10 +1434,9 @@ std::function< double( ) > getDoubleDependentVariableFunction(
             // Retrieve model responsible for computing accelerations of requested bodies.
             std::shared_ptr< NBodyStateDerivative< StateScalarType, TimeType > > nBodyModel =
                     getTranslationalStateDerivativeModelForBody( bodyWithProperty, stateDerivativeModels );
-            std::function< Eigen::Vector3d( ) > vectorFunction =
-                    std::bind( &NBodyStateDerivative< StateScalarType, TimeType >::getTotalAccelerationForBody,
-                               nBodyModel, bodyWithProperty );
-            variableFunction = std::bind( &linear_algebra::getVectorNormFromFunction, vectorFunction );
+            variableFunction = [&]( ){ return ( nBodyModel->getTotalAccelerationForBody(
+                                                    bodyWithProperty, bodies.getLastUpdateTime( ) ) ).norm( ); };
+
 
             break;
         }
diff --git a/src/simulation/estimation_setup/createObservationManager.cpp b/src/simulation/estimation_setup/createObservationManager.cpp
index c7fb16fe3..380408975 100644
--- a/src/simulation/estimation_setup/createObservationManager.cpp
+++ b/src/simulation/estimation_setup/createObservationManager.cpp
@@ -9,75 +9,75 @@ namespace observation_models
 //template std::shared_ptr< ObservationManagerBase< double, double > > createObservationManagerBase< double, double >(
 //        const ObservableType observableType,
 //        const std::map< LinkEnds, std::shared_ptr< ObservationModelSettings  > > settingsPerLinkEnds,
-//        const simulation_setup::SystemOfBodies &bodies,
+//        const simulation_setup::SystemOfBodies& bodies,
 //        const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< double > > parametersToEstimate,
 //        const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface );
 //template std::shared_ptr< ObservationManagerBase< double, Time > > createObservationManagerBase< double, Time >(
 //        const ObservableType observableType,
 //        const std::map< LinkEnds, std::shared_ptr< ObservationModelSettings  > > settingsPerLinkEnds,
-//        const simulation_setup::SystemOfBodies &bodies,
+//        const simulation_setup::SystemOfBodies& bodies,
 //        const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< double > > parametersToEstimate,
 //        const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface );
 //template std::shared_ptr< ObservationManagerBase< long double, double > > createObservationManagerBase< long double, double >(
 //        const ObservableType observableType,
 //        const std::map< LinkEnds, std::shared_ptr< ObservationModelSettings  > > settingsPerLinkEnds,
-//        const simulation_setup::SystemOfBodies &bodies,
+//        const simulation_setup::SystemOfBodies& bodies,
 //        const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< long double > > parametersToEstimate,
 //        const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface );
 //template std::shared_ptr< ObservationManagerBase< long double, Time > > createObservationManagerBase< long double, Time >(
 //        const ObservableType observableType,
 //        const std::map< LinkEnds, std::shared_ptr< ObservationModelSettings  > > settingsPerLinkEnds,
-//        const simulation_setup::SystemOfBodies &bodies,
+//        const simulation_setup::SystemOfBodies& bodies,
 //        const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< long double > > parametersToEstimate,
 //        const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface );
 
 //template std::shared_ptr< ObservationManagerBase< double, double > > createObservationManager< 1, double, double >(
 //        const ObservableType observableType,
 //        const std::map< LinkEnds, std::shared_ptr< ObservationModelSettings  > > settingsPerLinkEnds,
-//        const simulation_setup::SystemOfBodies &bodies,
+//        const simulation_setup::SystemOfBodies& bodies,
 //        const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< double > > parametersToEstimate,
 //        const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface );
 //template std::shared_ptr< ObservationManagerBase< double, Time > > createObservationManager< 1, double, Time >(
 //        const ObservableType observableType,
 //        const std::map< LinkEnds, std::shared_ptr< ObservationModelSettings  > > settingsPerLinkEnds,
-//        const simulation_setup::SystemOfBodies &bodies,
+//        const simulation_setup::SystemOfBodies& bodies,
 //        const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< double > > parametersToEstimate,
 //        const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface );
 //template std::shared_ptr< ObservationManagerBase< long double, double > > createObservationManager< 1, long double, double >(
 //        const ObservableType observableType,
 //        const std::map< LinkEnds, std::shared_ptr< ObservationModelSettings  > > settingsPerLinkEnds,
-//        const simulation_setup::SystemOfBodies &bodies,
+//        const simulation_setup::SystemOfBodies& bodies,
 //        const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< long double > > parametersToEstimate,
 //        const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface );
 //template std::shared_ptr< ObservationManagerBase< long double, Time > > createObservationManager< 1, long double, Time >(
 //        const ObservableType observableType,
 //        const std::map< LinkEnds, std::shared_ptr< ObservationModelSettings  > > settingsPerLinkEnds,
-//        const simulation_setup::SystemOfBodies &bodies,
+//        const simulation_setup::SystemOfBodies& bodies,
 //        const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< long double > > parametersToEstimate,
 //        const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface );
 
 //template std::shared_ptr< ObservationManagerBase< double, double > > createObservationManager< 2, double, double >(
 //        const ObservableType observableType,
 //        const std::map< LinkEnds, std::shared_ptr< ObservationModelSettings  > > settingsPerLinkEnds,
-//        const simulation_setup::SystemOfBodies &bodies,
+//        const simulation_setup::SystemOfBodies& bodies,
 //        const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< double > > parametersToEstimate,
 //        const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface );
 //template std::shared_ptr< ObservationManagerBase< double, Time > > createObservationManager< 2, double, Time >(
 //        const ObservableType observableType,
 //        const std::map< LinkEnds, std::shared_ptr< ObservationModelSettings  > > settingsPerLinkEnds,
-//        const simulation_setup::SystemOfBodies &bodies,
+//        const simulation_setup::SystemOfBodies& bodies,
 //        const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< double > > parametersToEstimate,
 //        const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface );
 //template std::shared_ptr< ObservationManagerBase< long double, double > > createObservationManager< 2, long double, double >(
 //        const ObservableType observableType,
 //        const std::map< LinkEnds, std::shared_ptr< ObservationModelSettings  > > settingsPerLinkEnds,
-//        const simulation_setup::SystemOfBodies &bodies,
+//        const simulation_setup::SystemOfBodies& bodies,
 //        const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< long double > > parametersToEstimate,
 //        const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface );
 //template std::shared_ptr< ObservationManagerBase< long double, Time > > createObservationManager< 2, long double, Time >(
 //        const ObservableType observableType,
 //        const std::map< LinkEnds, std::shared_ptr< ObservationModelSettings  > > settingsPerLinkEnds,
-//        const simulation_setup::SystemOfBodies &bodies,
+//        const simulation_setup::SystemOfBodies& bodies,
 //        const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< long double > > parametersToEstimate,
 //        const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface );
 
@@ -85,25 +85,25 @@ namespace observation_models
 //template std::shared_ptr< ObservationManagerBase< double, double > > createObservationManager< 3, double, double >(
 //        const ObservableType observableType,
 //        const std::map< LinkEnds, std::shared_ptr< ObservationModelSettings  > > settingsPerLinkEnds,
-//        const simulation_setup::SystemOfBodies &bodies,
+//        const simulation_setup::SystemOfBodies& bodies,
 //        const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< double > > parametersToEstimate,
 //        const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface );
 //template std::shared_ptr< ObservationManagerBase< double, Time > > createObservationManager< 3, double, Time >(
 //        const ObservableType observableType,
 //        const std::map< LinkEnds, std::shared_ptr< ObservationModelSettings  > > settingsPerLinkEnds,
-//        const simulation_setup::SystemOfBodies &bodies,
+//        const simulation_setup::SystemOfBodies& bodies,
 //        const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< double > > parametersToEstimate,
 //        const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface );
 //template std::shared_ptr< ObservationManagerBase< long double, double > > createObservationManager< 3, long double, double >(
 //        const ObservableType observableType,
 //        const std::map< LinkEnds, std::shared_ptr< ObservationModelSettings  > > settingsPerLinkEnds,
-//        const simulation_setup::SystemOfBodies &bodies,
+//        const simulation_setup::SystemOfBodies& bodies,
 //        const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< long double > > parametersToEstimate,
 //        const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface );
 //template std::shared_ptr< ObservationManagerBase< long double, Time > > createObservationManager< 3, long double, Time >(
 //        const ObservableType observableType,
 //        const std::map< LinkEnds, std::shared_ptr< ObservationModelSettings  > > settingsPerLinkEnds,
-//        const simulation_setup::SystemOfBodies &bodies,
+//        const simulation_setup::SystemOfBodies& bodies,
 //        const std::shared_ptr< estimatable_parameters::EstimatableParameterSet< long double > > parametersToEstimate,
 //        const std::shared_ptr< propagators::CombinedStateTransitionAndSensitivityMatrixInterface > stateTransitionMatrixInterface );
 
diff --git a/tests/src/astro/aerodynamics/unitTestAerodynamicMomentAndAerodynamicForce.cpp b/tests/src/astro/aerodynamics/unitTestAerodynamicMomentAndAerodynamicForce.cpp
index e16d22b1d..f18330a35 100644
--- a/tests/src/astro/aerodynamics/unitTestAerodynamicMomentAndAerodynamicForce.cpp
+++ b/tests/src/astro/aerodynamics/unitTestAerodynamicMomentAndAerodynamicForce.cpp
@@ -22,8 +22,8 @@
  *
  */
 
-#define BOOST_TEST_DYN_LINK
-#define BOOST_TEST_MAIN
+//#define BOOST_TEST_DYN_LINK
+//#define BOOST_TEST_MAIN
 
 #include <limits>
 
@@ -48,222 +48,224 @@
 //#include "tudat/simulation/estimation_setup/createNumericalSimulator.h"
 #include "tudat/simulation/environment_setup/defaultBodies.h"
 
-namespace tudat
-{
+using namespace tudat;
 
-namespace unit_tests
-{
+//namespace tudat
+//{
+
+//namespace unit_tests
+//{
 
-BOOST_AUTO_TEST_SUITE( test_aerodynamic_acceleration_force_moment_models )
+//BOOST_AUTO_TEST_SUITE( test_aerodynamic_acceleration_force_moment_models )
 
 using namespace aerodynamics;
 using namespace simulation_setup;
 
-//! Test implementation of aerodynamic force and acceleration models.
-BOOST_AUTO_TEST_CASE( testAerodynamicForceAndAcceleration )
-{
-    // Set force coefficients.
-    const Eigen::Vector3d forceCoefficients( 1.1, 1.2, 1.3 );
-
-    // Set dynamical model parameters.
-    const double density = 3.5e-5;
-    const double airSpeed = 3.491e3;
-    const double dynamicPressure = 0.5 * density * airSpeed * airSpeed;
-    const double referenceArea = 2.2;
-    const double referenceLength = 3.2;
-    const double mass = 1.93;
-
-    // Compute expected force.
-    const Eigen::Vector3d expectedForce = forceCoefficients * dynamicPressure * referenceArea;
-
-    // Declare tolerance used for Boost tests.
-    const double tolerance = std::numeric_limits< double >::epsilon( );
-
-    // Test 1: test the force model implemented as free function with primitive arguments.
-    {
-        // Compute force.
-        Eigen::Vector3d force = computeAerodynamicForce( dynamicPressure,
-                                                         referenceArea, forceCoefficients );
-
-        // Check if computed force matches expected.
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
-    }
-
-    // Test 2: test the force model implemented as free function, with coefficient interface
-    //         argument.
-    {
-        // Set coefficients and model parameters in aerodynamics coefficient interface object.
-        AerodynamicCoefficientInterfacePointer aerodynamicCoefficientInterface =
-                createConstantCoefficientAerodynamicCoefficientInterface(
-                    forceCoefficients, Eigen::Vector3d::Zero( ),
-                    referenceLength, referenceArea, referenceLength, Eigen::Vector3d::Zero( ) );
-
-        // Compute aerodynamic force using free function with coefficient interface argument.
-        Eigen::Vector3d force = computeAerodynamicForce( dynamicPressure,
-                                                         aerodynamicCoefficientInterface );
-
-        // Check if computed force matches expected.
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
-
-        // Test aerodynamic coefficient interface properties
-        BOOST_CHECK_EQUAL(
-                    aerodynamicCoefficientInterface->getIndependentVariableNames( ).size( ), 0 );
-
-        bool isVariableIndexTooHigh = 0;
-        try
-        {
-            aerodynamicCoefficientInterface->getIndependentVariableName( 0 );
-        }
-        catch( std::runtime_error const& )
-
-        {
-            isVariableIndexTooHigh = 1;
-        }
-        BOOST_CHECK_EQUAL( isVariableIndexTooHigh, 1 );
-    }
-
-    // Test 3: test the acceleration model implemented as free function with primitive arguments,
-    //         based on the force that can be derived from the computed acceleration.
-    {
-        // Set coefficients and model parameters in aerodynamics coefficient interface object.
-        AerodynamicCoefficientInterfacePointer aerodynamicCoefficientInterface =
-                createConstantCoefficientAerodynamicCoefficientInterface(
-                    forceCoefficients, Eigen::Vector3d::Zero( ),
-                    referenceLength, referenceArea, referenceLength, Eigen::Vector3d::Zero( ) );
-
-        // Compute aerodynamic force from aerodynamic acceleration free function with primitive
-        // arguments.
-        Eigen::Vector3d force = computeAerodynamicAcceleration(
-                    dynamicPressure, aerodynamicCoefficientInterface, mass ) * mass;
-
-        // Check if computed force matches expected.
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
-    }
-
-    // Test 4: test the acceleration model implemented as free function with coefficient interface
-    //         argument, based on the force that can be derived from the computed acceleration.
-    {
-        // Compute aerodynamic force from aerodynamic acceleration free function with
-        // coefficient interface argument.
-        Eigen::Vector3d force = computeAerodynamicAcceleration(
-                    dynamicPressure, referenceArea, forceCoefficients, mass ) * mass;
-
-        // Check if computed force matches expected.
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
-    }
-
-    // Test 5: Test the acceleration model class without inverted coefficients.
-    {
-        // Create aaerodynamic acceleration model class, no inverted coefficients, direct mass
-        // and reference area.
-        AerodynamicAccelerationPointer accelerationClass
-                = std::make_shared< AerodynamicAcceleration >(
-                    [ & ]( Eigen::Vector3d& input ){ input = forceCoefficients; },
-                    [ & ]( ){ return density; },
-                    [ & ]( ){ return airSpeed; },
-                    mass, referenceArea, false );
-        accelerationClass->updateMembers( );
-        Eigen::Vector3d force = accelerationClass->getAcceleration( ) * mass;
-
-        // Check if computed force matches expected.
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
-
-        // Create aerodynamic acceleration model class, no inverted coefficients, mass and
-        // reference area set through std::functions.
-        AerodynamicAccelerationPointer accelerationClass2 =
-                std::make_shared< AerodynamicAcceleration >(
-                    [ & ]( Eigen::Vector3d& input ){ input = forceCoefficients; },
-                    [ & ]( ){ return density; },
-                    [ & ]( ){ return airSpeed; },
-                    [ & ]( ){ return mass; },
-                    [ & ]( ){ return referenceArea; },
-                    false );
-        accelerationClass2->updateMembers( );
-        force = accelerationClass2->getAcceleration( ) * mass;
-
-        // Check if computed force matches expected.
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
-    }
-
-    // Test 6: Test the acceleration model class with inverted coefficients
-    {
-        // Create aaerodynamic acceleration model class, inverted coefficients, direct mass
-        // and reference area.
-        AerodynamicAccelerationPointer accelerationClass =
-                std::make_shared< AerodynamicAcceleration >(
-                    [ & ]( Eigen::Vector3d& input ){ input = -forceCoefficients; },
-                    [ & ]( ){ return density; },
-                    [ & ]( ){ return airSpeed; },
-                    mass, referenceArea, true );
-        accelerationClass->updateMembers( );
-        Eigen::Vector3d force = accelerationClass->getAcceleration( ) * mass;
-
-        // Check if computed force matches expected.
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
-
-        // Create aerodynamic acceleration model class, inverted coefficients, mass and
-        // reference area set through std::functions.
-        AerodynamicAccelerationPointer accelerationClass2 =
-                std::make_shared< AerodynamicAcceleration >(
-                    [ & ]( Eigen::Vector3d& input ){ input = -forceCoefficients; },
-                    [ & ]( ){ return density; },
-                    [ & ]( ){ return airSpeed; },
-                    [ & ]( ){ return mass; },
-                    [ & ]( ){ return referenceArea; },
-                    true );
-        accelerationClass2->updateMembers( );
-        force = accelerationClass2->getAcceleration( ) * mass;
-
-        // Check if computed force matches expected.
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
-    }
-}
-
-//! Test implementation of aerodynamic moment and rotational acceleration models.
-BOOST_AUTO_TEST_CASE( testAerodynamicMomentAndRotationalAcceleration )
-{
-    // Set moment coefficients.
-    const Eigen::Vector3d momentCoefficients( -3.2, 1.0, 8.4 );
-
-    // Set dynamical model parameters.
-    const double dynamicPressure = 123.6;
-    const double referenceArea = 1.7;
-    const double referenceLength = 2.6;
-
-    // Calculate expected moment.
-    const Eigen::Vector3d expectedMoment = dynamicPressure * referenceArea *
-            referenceLength * momentCoefficients;
-
-    // Declare tolerance used for Boost tests.
-    const double tolerance = std::numeric_limits< double >::epsilon( );
-
-    // Test 1: test the moment model implemented as free function with primitive arguments.
-    {
-        // Compute aerodynamic moment using free function with primitive arguments.
-        Eigen::Vector3d moment = computeAerodynamicMoment( dynamicPressure, referenceArea,
-                                                           referenceLength, momentCoefficients );
-
-        // Check if computed moment matches expected.
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedMoment, moment, tolerance );
-    }
-
-    // Test 2: test the moment moment implemented as free function with coefficient interface
-    //         argument.
-    {
-        // Set coefficients and model parameters in aerodynamics coefficient interface object.
-        AerodynamicCoefficientInterfacePointer aerodynamicCoefficientInterface =
-        createConstantCoefficientAerodynamicCoefficientInterface(
-            Eigen::Vector3d::Zero( ), momentCoefficients,
-            referenceLength, referenceArea, referenceLength, Eigen::Vector3d::Zero( ) );
-
-        // Compute aerodynamic moment using free function with coefficient interface argument.
-        Eigen::Vector3d moment = computeAerodynamicMoment( dynamicPressure,
-                                                           aerodynamicCoefficientInterface );
-
-        // Check if computed moment matches expected.
-        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedMoment, moment, tolerance );
-    }
-}
+////! Test implementation of aerodynamic force and acceleration models.
+//BOOST_AUTO_TEST_CASE( testAerodynamicForceAndAcceleration )
+//{
+//    // Set force coefficients.
+//    const Eigen::Vector3d forceCoefficients( 1.1, 1.2, 1.3 );
+
+//    // Set dynamical model parameters.
+//    const double density = 3.5e-5;
+//    const double airSpeed = 3.491e3;
+//    const double dynamicPressure = 0.5 * density * airSpeed * airSpeed;
+//    const double referenceArea = 2.2;
+//    const double referenceLength = 3.2;
+//    const double mass = 1.93;
+
+//    // Compute expected force.
+//    const Eigen::Vector3d expectedForce = forceCoefficients * dynamicPressure * referenceArea;
+
+//    // Declare tolerance used for Boost tests.
+//    const double tolerance = std::numeric_limits< double >::epsilon( );
+
+//    // Test 1: test the force model implemented as free function with primitive arguments.
+//    {
+//        // Compute force.
+//        Eigen::Vector3d force = computeAerodynamicForce( dynamicPressure,
+//                                                         referenceArea, forceCoefficients );
+
+//        // Check if computed force matches expected.
+//        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
+//    }
+
+//    // Test 2: test the force model implemented as free function, with coefficient interface
+//    //         argument.
+//    {
+//        // Set coefficients and model parameters in aerodynamics coefficient interface object.
+//        AerodynamicCoefficientInterfacePointer aerodynamicCoefficientInterface =
+//                createConstantCoefficientAerodynamicCoefficientInterface(
+//                    forceCoefficients, Eigen::Vector3d::Zero( ),
+//                    referenceLength, referenceArea, referenceLength, Eigen::Vector3d::Zero( ) );
+
+//        // Compute aerodynamic force using free function with coefficient interface argument.
+//        Eigen::Vector3d force = computeAerodynamicForce( dynamicPressure,
+//                                                         aerodynamicCoefficientInterface );
+
+//        // Check if computed force matches expected.
+//        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
+
+//        // Test aerodynamic coefficient interface properties
+//        BOOST_CHECK_EQUAL(
+//                    aerodynamicCoefficientInterface->getIndependentVariableNames( ).size( ), 0 );
+
+//        bool isVariableIndexTooHigh = 0;
+//        try
+//        {
+//            aerodynamicCoefficientInterface->getIndependentVariableName( 0 );
+//        }
+//        catch( std::runtime_error const& )
+
+//        {
+//            isVariableIndexTooHigh = 1;
+//        }
+//        BOOST_CHECK_EQUAL( isVariableIndexTooHigh, 1 );
+//    }
+
+//    // Test 3: test the acceleration model implemented as free function with primitive arguments,
+//    //         based on the force that can be derived from the computed acceleration.
+//    {
+//        // Set coefficients and model parameters in aerodynamics coefficient interface object.
+//        AerodynamicCoefficientInterfacePointer aerodynamicCoefficientInterface =
+//                createConstantCoefficientAerodynamicCoefficientInterface(
+//                    forceCoefficients, Eigen::Vector3d::Zero( ),
+//                    referenceLength, referenceArea, referenceLength, Eigen::Vector3d::Zero( ) );
+
+//        // Compute aerodynamic force from aerodynamic acceleration free function with primitive
+//        // arguments.
+//        Eigen::Vector3d force = computeAerodynamicAcceleration(
+//                    dynamicPressure, aerodynamicCoefficientInterface, mass ) * mass;
+
+//        // Check if computed force matches expected.
+//        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
+//    }
+
+//    // Test 4: test the acceleration model implemented as free function with coefficient interface
+//    //         argument, based on the force that can be derived from the computed acceleration.
+//    {
+//        // Compute aerodynamic force from aerodynamic acceleration free function with
+//        // coefficient interface argument.
+//        Eigen::Vector3d force = computeAerodynamicAcceleration(
+//                    dynamicPressure, referenceArea, forceCoefficients, mass ) * mass;
+
+//        // Check if computed force matches expected.
+//        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
+//    }
+
+//    // Test 5: Test the acceleration model class without inverted coefficients.
+//    {
+//        // Create aaerodynamic acceleration model class, no inverted coefficients, direct mass
+//        // and reference area.
+//        AerodynamicAccelerationPointer accelerationClass
+//                = std::make_shared< AerodynamicAcceleration >(
+//                    [ & ]( Eigen::Vector3d& input ){ input = forceCoefficients; },
+//                    [ & ]( ){ return density; },
+//                    [ & ]( ){ return airSpeed; },
+//                    mass, referenceArea, false );
+//        accelerationClass->updateMembers( );
+//        Eigen::Vector3d force = accelerationClass->getAcceleration( ) * mass;
+
+//        // Check if computed force matches expected.
+//        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
+
+//        // Create aerodynamic acceleration model class, no inverted coefficients, mass and
+//        // reference area set through std::functions.
+//        AerodynamicAccelerationPointer accelerationClass2 =
+//                std::make_shared< AerodynamicAcceleration >(
+//                    [ & ]( Eigen::Vector3d& input ){ input = forceCoefficients; },
+//                    [ & ]( ){ return density; },
+//                    [ & ]( ){ return airSpeed; },
+//                    [ & ]( ){ return mass; },
+//                    [ & ]( ){ return referenceArea; },
+//                    false );
+//        accelerationClass2->updateMembers( );
+//        force = accelerationClass2->getAcceleration( ) * mass;
+
+//        // Check if computed force matches expected.
+//        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
+//    }
+
+//    // Test 6: Test the acceleration model class with inverted coefficients
+//    {
+//        // Create aaerodynamic acceleration model class, inverted coefficients, direct mass
+//        // and reference area.
+//        AerodynamicAccelerationPointer accelerationClass =
+//                std::make_shared< AerodynamicAcceleration >(
+//                    [ & ]( Eigen::Vector3d& input ){ input = -forceCoefficients; },
+//                    [ & ]( ){ return density; },
+//                    [ & ]( ){ return airSpeed; },
+//                    mass, referenceArea, true );
+//        accelerationClass->updateMembers( );
+//        Eigen::Vector3d force = accelerationClass->getAcceleration( ) * mass;
+
+//        // Check if computed force matches expected.
+//        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
+
+//        // Create aerodynamic acceleration model class, inverted coefficients, mass and
+//        // reference area set through std::functions.
+//        AerodynamicAccelerationPointer accelerationClass2 =
+//                std::make_shared< AerodynamicAcceleration >(
+//                    [ & ]( Eigen::Vector3d& input ){ input = -forceCoefficients; },
+//                    [ & ]( ){ return density; },
+//                    [ & ]( ){ return airSpeed; },
+//                    [ & ]( ){ return mass; },
+//                    [ & ]( ){ return referenceArea; },
+//                    true );
+//        accelerationClass2->updateMembers( );
+//        force = accelerationClass2->getAcceleration( ) * mass;
+
+//        // Check if computed force matches expected.
+//        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedForce, force, tolerance );
+//    }
+//}
+
+////! Test implementation of aerodynamic moment and rotational acceleration models.
+//BOOST_AUTO_TEST_CASE( testAerodynamicMomentAndRotationalAcceleration )
+//{
+//    // Set moment coefficients.
+//    const Eigen::Vector3d momentCoefficients( -3.2, 1.0, 8.4 );
+
+//    // Set dynamical model parameters.
+//    const double dynamicPressure = 123.6;
+//    const double referenceArea = 1.7;
+//    const double referenceLength = 2.6;
+
+//    // Calculate expected moment.
+//    const Eigen::Vector3d expectedMoment = dynamicPressure * referenceArea *
+//            referenceLength * momentCoefficients;
+
+//    // Declare tolerance used for Boost tests.
+//    const double tolerance = std::numeric_limits< double >::epsilon( );
+
+//    // Test 1: test the moment model implemented as free function with primitive arguments.
+//    {
+//        // Compute aerodynamic moment using free function with primitive arguments.
+//        Eigen::Vector3d moment = computeAerodynamicMoment( dynamicPressure, referenceArea,
+//                                                           referenceLength, momentCoefficients );
+
+//        // Check if computed moment matches expected.
+//        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedMoment, moment, tolerance );
+//    }
+
+//    // Test 2: test the moment moment implemented as free function with coefficient interface
+//    //         argument.
+//    {
+//        // Set coefficients and model parameters in aerodynamics coefficient interface object.
+//        AerodynamicCoefficientInterfacePointer aerodynamicCoefficientInterface =
+//        createConstantCoefficientAerodynamicCoefficientInterface(
+//            Eigen::Vector3d::Zero( ), momentCoefficients,
+//            referenceLength, referenceArea, referenceLength, Eigen::Vector3d::Zero( ) );
+
+//        // Compute aerodynamic moment using free function with coefficient interface argument.
+//        Eigen::Vector3d moment = computeAerodynamicMoment( dynamicPressure,
+//                                                           aerodynamicCoefficientInterface );
+
+//        // Check if computed moment matches expected.
+//        TUDAT_CHECK_MATRIX_CLOSE_FRACTION( expectedMoment, moment, tolerance );
+//    }
+//}
 
 class DummyAngleCalculator: public AerodynamicGuidance
 {
@@ -509,175 +511,176 @@ void testAerodynamicForceDirection( const bool includeThrustForce,
 
         double thrustAcceleration = thrustMagnitude / vehicleMass;
         Eigen::Matrix3d matrixDifference;
-        for( std::map< double, Eigen::Matrix< double, Eigen::Dynamic, 1 > >::const_iterator outputIterator =
-             dependentVariableOutput.begin( ); outputIterator != dependentVariableOutput.end( ); outputIterator++ )
-        {
-
-
-            // Retrieve dependent variables from output;
-            Eigen::Matrix3d rotationToAerodynamicFrame =
-                    getMatrixFromVectorRotationRepresentation(
-                        outputIterator->second.segment( 3, 9 ) );
-            Eigen::Matrix3d rotationToBodyFrame =
-                    getMatrixFromVectorRotationRepresentation(
-                        outputIterator->second.segment( 12, 9 ) );
-            Eigen::Matrix3d rotationToCorotatingFrame = getMatrixFromVectorRotationRepresentation(
-                        outputIterator->second.segment( 21, 9 ) );
-            Eigen::Matrix3d rotationToTrajectoryFrame = getMatrixFromVectorRotationRepresentation(
-                        outputIterator->second.segment( 30, 9 ) );
-            Eigen::Vector3d bodyFixedAirspeed = outputIterator->second.segment( 39, 3 );
-
-            // Velocity vector in aerodynamic and trajectory frames should have component in positivie x-direction only.
-            Eigen::Vector3d bodyFixedAirspeedInAerodynamicFrame = rotationToAerodynamicFrame *
-                    rotationToCorotatingFrame.transpose( ) * bodyFixedAirspeed;
-            Eigen::Vector3d bodyFixedAirspeedInTrajectoryFrame = rotationToTrajectoryFrame *
-                    rotationToCorotatingFrame.transpose( ) * bodyFixedAirspeed;
-
-            // Check velocity in aerodynamic frame
-            BOOST_CHECK_CLOSE_FRACTION( bodyFixedAirspeedInAerodynamicFrame.x( ),
-                                        bodyFixedAirspeedInAerodynamicFrame.norm( ),
-                                        std::numeric_limits< double >::epsilon( ) );
-
-            // Check velocity in trajectory frame
-            BOOST_CHECK_CLOSE_FRACTION( bodyFixedAirspeedInTrajectoryFrame.x( ),
-                                        bodyFixedAirspeedInTrajectoryFrame.norm( ),
-                                        std::numeric_limits< double >::epsilon( ) );
-
-            // For drag-only aerodynamics
-            if( ( i % 4 ) == 0 )
-            {
-                Eigen::Vector3d aerodynamicForceInAerodynamicFrame = rotationToAerodynamicFrame * outputIterator->second.segment( 0, 3 );
-                BOOST_CHECK_CLOSE_FRACTION( -aerodynamicForceInAerodynamicFrame.x( ),
-                                            aerodynamicForceInAerodynamicFrame.norm( ),
-                                            std::numeric_limits< double >::epsilon( ) );
-            }
-
-            // For C_{x}-only aerodynamics
-            else if( ( i % 4 ) == 1 )
-            {
-                Eigen::Vector3d aerodynamicForceInBodyFrame = rotationToBodyFrame * outputIterator->second.segment( 0, 3 );
-                BOOST_CHECK_CLOSE_FRACTION( -aerodynamicForceInBodyFrame.x( ),
-                                            aerodynamicForceInBodyFrame.norm( ),
-                                            std::numeric_limits< double >::epsilon( ) );
-            }
-
-            // Check that aerodynamic force is in correct direction (in aerodynamic frame).
-            else if( ( i % 4 ) == 2 )
-            {
-                Eigen::Vector3d aerodynamicForceDirectionInAerodynamicFrame =
-                        ( rotationToAerodynamicFrame * outputIterator->second.segment( 0, 3 ) ).normalized( );
-                for( unsigned int j = 0; j < 3; j++ )
-                {
-                    BOOST_CHECK_CLOSE_FRACTION( -aerodynamicForceDirectionInAerodynamicFrame( j ),
-                                                aerodynamicCoefficientsDirection( j ), 5.0E-14 );
-                }
-            }
-
-            // Check that aerodynamic force is in correct direction (in body frame).
-            else if( ( i % 4 ) == 3 )
-            {
-                Eigen::Vector3d aerodynamicForceDirectionInBodyFrame =
-                        ( rotationToBodyFrame * outputIterator->second.segment( 0, 3 ) ).normalized( );
-                for( unsigned int j = 0; j < 3; j++ )
-                {
-                    BOOST_CHECK_CLOSE_FRACTION( -aerodynamicForceDirectionInBodyFrame( j ),
-                                                aerodynamicCoefficientsDirection( j ), 5.0E-14 );
-                }
-            }
-
-            // Check if thrust force is in correct direction.
-            if( includeThrustForce && !imposeThrustDirection )
-            {
-                Eigen::Vector3d thrustForceInBodyFrame = rotationToBodyFrame * outputIterator->second.segment( 42, 3 );
-
-                for( unsigned int j = 0; j < 3; j++ )
-                {
-                    BOOST_CHECK_SMALL(
-                                std::fabs( thrustForceInBodyFrame( j ) - bodyFixedThrustDirection( j ) *
-                                           thrustAcceleration ), 1.0E-14 );
-                }
-            }
-            else if( includeThrustForce && imposeThrustDirection )
-            {
-                Eigen::Vector3d thrustForceInPropagationFrame = ( outputIterator->second.segment( 42, 3 ) );
-
-                Eigen::Matrix3d rotationToBodyFrameFromEphemeris = spice_interface::computeRotationQuaternionBetweenFrames(
-                            "IAU_Earth", "IAU_Mars", outputIterator->first ).toRotationMatrix( );
-                Eigen::Vector3d imposedThrustForceInPropagationFrame =
-                        thrustAcceleration * ( rotationToBodyFrameFromEphemeris.transpose( ) * bodyFixedThrustDirection );
-
-
-
-                for( unsigned int j = 0; j < 3; j++ )
-                {
-                    BOOST_CHECK_SMALL(
-                                std::fabs( thrustForceInPropagationFrame( j ) - imposedThrustForceInPropagationFrame( j ) ),
-                                1.0E-15 );
-                }
-                matrixDifference = rotationToBodyFrameFromEphemeris - rotationToBodyFrame;
-
-                for( unsigned int j = 0; j < 3; j++ )
-                {
-                    for( unsigned int k = 0; k < 3; k++ )
-                    {
-                        BOOST_CHECK_SMALL( std::fabs( matrixDifference( j, k ) ), 5.0E-14 );
-                    }
-                }
-
-            }
-
-            if( i < 4 && !imposeThrustDirection )
-            {
-                // Check if imposed and indirectly obtained rotation matrices are equal.
-                Eigen::Matrix3d rotationToBodyFrameFromEphemeris = rotationalEphemeris->getRotationToTargetFrame(
-                            outputIterator->first ).toRotationMatrix( );
-                matrixDifference = rotationToBodyFrameFromEphemeris - rotationToBodyFrame;
-                for( unsigned int j = 0; j < 3; j++ )
-                {
-                    for( unsigned int k = 0; k < 3; k++ )
-                    {
-                        BOOST_CHECK_SMALL( std::fabs( matrixDifference( j, k ) ), 1.0E-13 );
-                    }
-                }
-            }
-            else if( !( i < 4 ) )
-            {
-                testAngles->updateGuidance( outputIterator->first );
-
-                Eigen::Matrix3d aerodynamicToBodyFrame = rotationToBodyFrame * rotationToAerodynamicFrame.inverse( );
-                Eigen::Matrix3d aerodynamicToTrajectoryFrame = rotationToTrajectoryFrame * rotationToAerodynamicFrame.inverse( );
-
-                Eigen::Matrix3d manualAerodynamicToBodyFrame =
-                        reference_frames::getAirspeedBasedAerodynamicToBodyFrameTransformationMatrix(
-                            testAngles->getDummyAngleOfAttack( ), testAngles->getDummyAngleOfSideslip( ) );
-                Eigen::Matrix3d manualAerodynamicToTrajectoryFrame =
-                        reference_frames::getAerodynamicToTrajectoryFrameTransformationMatrix(
-                            testAngles->getDummyBankAngle( ) );
-
-                matrixDifference = aerodynamicToBodyFrame - manualAerodynamicToBodyFrame;
-
-                for( unsigned int j = 0; j < 3; j++ )
-                {
-                    for( unsigned int k = 0; k < 3; k++ )
-                    {
-                        BOOST_CHECK_SMALL( std::fabs( matrixDifference( j, k ) ), 1.0E-14 );
-                    }
-                }
-
-                matrixDifference = aerodynamicToTrajectoryFrame - manualAerodynamicToTrajectoryFrame;
-                for( unsigned int j = 0; j < 3; j++ )
-                {
-                    for( unsigned int k = 0; k < 3; k++ )
-                    {
-                        BOOST_CHECK_SMALL( std::fabs( matrixDifference( j, k ) ), 1.0E-14 );
-                    }
-                }
-            }
-        }
+//        for( std::map< double, Eigen::Matrix< double, Eigen::Dynamic, 1 > >::const_iterator outputIterator =
+//             dependentVariableOutput.begin( ); outputIterator != dependentVariableOutput.end( ); outputIterator++ )
+//        {
+
+
+//            // Retrieve dependent variables from output;
+//            Eigen::Matrix3d rotationToAerodynamicFrame =
+//                    getMatrixFromVectorRotationRepresentation(
+//                        outputIterator->second.segment( 3, 9 ) );
+//            Eigen::Matrix3d rotationToBodyFrame =
+//                    getMatrixFromVectorRotationRepresentation(
+//                        outputIterator->second.segment( 12, 9 ) );
+//            Eigen::Matrix3d rotationToCorotatingFrame = getMatrixFromVectorRotationRepresentation(
+//                        outputIterator->second.segment( 21, 9 ) );
+//            Eigen::Matrix3d rotationToTrajectoryFrame = getMatrixFromVectorRotationRepresentation(
+//                        outputIterator->second.segment( 30, 9 ) );
+//            Eigen::Vector3d bodyFixedAirspeed = outputIterator->second.segment( 39, 3 );
+
+//            // Velocity vector in aerodynamic and trajectory frames should have component in positivie x-direction only.
+//            Eigen::Vector3d bodyFixedAirspeedInAerodynamicFrame = rotationToAerodynamicFrame *
+//                    rotationToCorotatingFrame.transpose( ) * bodyFixedAirspeed;
+//            Eigen::Vector3d bodyFixedAirspeedInTrajectoryFrame = rotationToTrajectoryFrame *
+//                    rotationToCorotatingFrame.transpose( ) * bodyFixedAirspeed;
+
+//            // Check velocity in aerodynamic frame
+//            BOOST_CHECK_CLOSE_FRACTION( bodyFixedAirspeedInAerodynamicFrame.x( ),
+//                                        bodyFixedAirspeedInAerodynamicFrame.norm( ),
+//                                        std::numeric_limits< double >::epsilon( ) );
+
+//            // Check velocity in trajectory frame
+//            BOOST_CHECK_CLOSE_FRACTION( bodyFixedAirspeedInTrajectoryFrame.x( ),
+//                                        bodyFixedAirspeedInTrajectoryFrame.norm( ),
+//                                        std::numeric_limits< double >::epsilon( ) );
+
+//            // For drag-only aerodynamics
+//            if( ( i % 4 ) == 0 )
+//            {
+//                Eigen::Vector3d aerodynamicForceInAerodynamicFrame = rotationToAerodynamicFrame * outputIterator->second.segment( 0, 3 );
+//                BOOST_CHECK_CLOSE_FRACTION( -aerodynamicForceInAerodynamicFrame.x( ),
+//                                            aerodynamicForceInAerodynamicFrame.norm( ),
+//                                            std::numeric_limits< double >::epsilon( ) );
+//            }
+
+//            // For C_{x}-only aerodynamics
+//            else if( ( i % 4 ) == 1 )
+//            {
+//                Eigen::Vector3d aerodynamicForceInBodyFrame = rotationToBodyFrame * outputIterator->second.segment( 0, 3 );
+//                BOOST_CHECK_CLOSE_FRACTION( -aerodynamicForceInBodyFrame.x( ),
+//                                            aerodynamicForceInBodyFrame.norm( ),
+//                                            std::numeric_limits< double >::epsilon( ) );
+//            }
+
+//            // Check that aerodynamic force is in correct direction (in aerodynamic frame).
+//            else if( ( i % 4 ) == 2 )
+//            {
+//                Eigen::Vector3d aerodynamicForceDirectionInAerodynamicFrame =
+//                        ( rotationToAerodynamicFrame * outputIterator->second.segment( 0, 3 ) ).normalized( );
+//                for( unsigned int j = 0; j < 3; j++ )
+//                {
+//                    BOOST_CHECK_CLOSE_FRACTION( -aerodynamicForceDirectionInAerodynamicFrame( j ),
+//                                                aerodynamicCoefficientsDirection( j ), 5.0E-14 );
+//                }
+//            }
+
+//            // Check that aerodynamic force is in correct direction (in body frame).
+//            else if( ( i % 4 ) == 3 )
+//            {
+//                Eigen::Vector3d aerodynamicForceDirectionInBodyFrame =
+//                        ( rotationToBodyFrame * outputIterator->second.segment( 0, 3 ) ).normalized( );
+//                for( unsigned int j = 0; j < 3; j++ )
+//                {
+//                    BOOST_CHECK_CLOSE_FRACTION( -aerodynamicForceDirectionInBodyFrame( j ),
+//                                                aerodynamicCoefficientsDirection( j ), 5.0E-14 );
+//                }
+//            }
+
+//            // Check if thrust force is in correct direction.
+//            if( includeThrustForce && !imposeThrustDirection )
+//            {
+//                Eigen::Vector3d thrustForceInBodyFrame = rotationToBodyFrame * outputIterator->second.segment( 42, 3 );
+
+//                for( unsigned int j = 0; j < 3; j++ )
+//                {
+//                    BOOST_CHECK_SMALL(
+//                                std::fabs( thrustForceInBodyFrame( j ) - bodyFixedThrustDirection( j ) *
+//                                           thrustAcceleration ), 1.0E-14 );
+//                }
+//            }
+//            else if( includeThrustForce && imposeThrustDirection )
+//            {
+//                Eigen::Vector3d thrustForceInPropagationFrame = ( outputIterator->second.segment( 42, 3 ) );
+
+//                Eigen::Matrix3d rotationToBodyFrameFromEphemeris = spice_interface::computeRotationQuaternionBetweenFrames(
+//                            "IAU_Earth", "IAU_Mars", outputIterator->first ).toRotationMatrix( );
+//                Eigen::Vector3d imposedThrustForceInPropagationFrame =
+//                        thrustAcceleration * ( rotationToBodyFrameFromEphemeris.transpose( ) * bodyFixedThrustDirection );
+
+
+
+//                for( unsigned int j = 0; j < 3; j++ )
+//                {
+//                    BOOST_CHECK_SMALL(
+//                                std::fabs( thrustForceInPropagationFrame( j ) - imposedThrustForceInPropagationFrame( j ) ),
+//                                1.0E-15 );
+//                }
+//                matrixDifference = rotationToBodyFrameFromEphemeris - rotationToBodyFrame;
+
+//                for( unsigned int j = 0; j < 3; j++ )
+//                {
+//                    for( unsigned int k = 0; k < 3; k++ )
+//                    {
+//                        BOOST_CHECK_SMALL( std::fabs( matrixDifference( j, k ) ), 5.0E-14 );
+//                    }
+//                }
+
+//            }
+
+//            if( i < 4 && !imposeThrustDirection )
+//            {
+//                // Check if imposed and indirectly obtained rotation matrices are equal.
+//                Eigen::Matrix3d rotationToBodyFrameFromEphemeris = rotationalEphemeris->getRotationToTargetFrame(
+//                            outputIterator->first ).toRotationMatrix( );
+//                matrixDifference = rotationToBodyFrameFromEphemeris - rotationToBodyFrame;
+//                for( unsigned int j = 0; j < 3; j++ )
+//                {
+//                    for( unsigned int k = 0; k < 3; k++ )
+//                    {
+//                        BOOST_CHECK_SMALL( std::fabs( matrixDifference( j, k ) ), 1.0E-13 );
+//                    }
+//                }
+//            }
+//            else if( !( i < 4 ) )
+//            {
+//                testAngles->updateGuidance( outputIterator->first );
+
+//                Eigen::Matrix3d aerodynamicToBodyFrame = rotationToBodyFrame * rotationToAerodynamicFrame.inverse( );
+//                Eigen::Matrix3d aerodynamicToTrajectoryFrame = rotationToTrajectoryFrame * rotationToAerodynamicFrame.inverse( );
+
+//                Eigen::Matrix3d manualAerodynamicToBodyFrame =
+//                        reference_frames::getAirspeedBasedAerodynamicToBodyFrameTransformationMatrix(
+//                            testAngles->getDummyAngleOfAttack( ), testAngles->getDummyAngleOfSideslip( ) );
+//                Eigen::Matrix3d manualAerodynamicToTrajectoryFrame =
+//                        reference_frames::getAerodynamicToTrajectoryFrameTransformationMatrix(
+//                            testAngles->getDummyBankAngle( ) );
+
+//                matrixDifference = aerodynamicToBodyFrame - manualAerodynamicToBodyFrame;
+
+//                for( unsigned int j = 0; j < 3; j++ )
+//                {
+//                    for( unsigned int k = 0; k < 3; k++ )
+//                    {
+//                        BOOST_CHECK_SMALL( std::fabs( matrixDifference( j, k ) ), 1.0E-14 );
+//                    }
+//                }
+
+//                matrixDifference = aerodynamicToTrajectoryFrame - manualAerodynamicToTrajectoryFrame;
+//                for( unsigned int j = 0; j < 3; j++ )
+//                {
+//                    for( unsigned int k = 0; k < 3; k++ )
+//                    {
+//                        BOOST_CHECK_SMALL( std::fabs( matrixDifference( j, k ) ), 1.0E-14 );
+//                    }
+//                }
+//            }
+//        }
     }
 }
 
-BOOST_AUTO_TEST_CASE( testAerodynamicForceDirectionInPropagation )
+//BOOST_AUTO_TEST_CASE( testAerodynamicForceDirectionInPropagation )
+int main( )
 {
     testAerodynamicForceDirection( 0, 0, 0, 0 );
     testAerodynamicForceDirection( 1, 0, 0, 0 );
@@ -692,8 +695,8 @@ BOOST_AUTO_TEST_CASE( testAerodynamicForceDirectionInPropagation )
     testAerodynamicForceDirection( 1, 1, 1, 1 );
 }
 
-BOOST_AUTO_TEST_SUITE_END( )
+//BOOST_AUTO_TEST_SUITE_END( )
 
-}
+//}
 
-}
+//}
