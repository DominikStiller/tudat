diff --git a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.cpp b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.cpp
index 2a32b8b..ac42de0 100644
--- a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.cpp
+++ b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityField.cpp
@@ -97,6 +97,8 @@ double calculateSphericalHarmonicGravitationalPotential(
         ratioToPowerDegree *= basic_mathematics::raiseToIntegerPower< double >( radiusRatio, startDegree - 1 );
     }
 
+    basic_mathematics::LegendreCache& legendreCacheReference = *sphericalHarmonicsCache->getLegendreCache( );
+
     // Iterate over all degrees
     for( int degree = startDegree; degree < cosineCoefficients.rows( ); degree++ )
     {
@@ -108,7 +110,7 @@ double calculateSphericalHarmonicGravitationalPotential(
         {
             // Calculate legendre polynomial (geodesy-normalized) at current degree and order
             legendrePolynomial = basic_mathematics::computeGeodesyLegendrePolynomial(
-                        degree, order, std::sin( latitude ), sphericalHarmonicsCache->getLegendreCache( ) );
+                        degree, order, std::sin( latitude ), legendreCacheReference );
 
             // Calculate contribution to potential from current degree and order
             singleDegreeTerm += legendrePolynomial * ( cosineCoefficients( degree, order ) *
diff --git a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.cpp b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.cpp
index fad921d..a1d4845 100644
--- a/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.cpp
+++ b/Tudat/Astrodynamics/Gravitation/sphericalHarmonicsGravityModel.cpp
@@ -122,7 +122,9 @@ Eigen::Vector3d computeGeodesyNormalizedGravitationalAccelerationSum(
     // Initialize gradient vector.
     Eigen::Vector3d sphericalGradient = Eigen::Vector3d::Zero( );
     double sineOfAngle = std::sin( sphericalpositionOfBodySubjectToAcceleration( 1 ) );
-    sphericalHarmonicsCache->getLegendreCache( )->update( sineOfAngle, basic_mathematics::geodesyNormalizedLegendrePolynomialFunction );
+
+    basic_mathematics::LegendreCache& legendreCacheReference = *sphericalHarmonicsCache->getLegendreCache( );
+    legendreCacheReference.update( sineOfAngle, basic_mathematics::geodesyNormalizedLegendrePolynomialFunction );
 
     // Loop through all degrees.
     for ( int degree = 0; degree < highestDegree; degree++ )
@@ -133,11 +135,11 @@ Eigen::Vector3d computeGeodesyNormalizedGravitationalAccelerationSum(
             // Compute geodesy-normalized Legendre polynomials.
             const double legendrePolynomial = basic_mathematics::computeGeodesyLegendrePolynomial(
                         degree, order,
-                        sineOfAngle, sphericalHarmonicsCache->getLegendreCache( ) );
+                        sineOfAngle, legendreCacheReference );
             const double incrementedLegendrePolynomial =
                     basic_mathematics::computeGeodesyLegendrePolynomial(
                         degree, order + 1,
-                        sineOfAngle, sphericalHarmonicsCache->getLegendreCache( ) );
+                        sineOfAngle, legendreCacheReference );
 
             // Compute geodesy-normalized Legendre polynomial derivative.
             const double legendrePolynomialDerivative =
@@ -224,15 +226,17 @@ Eigen::Vector3d computeSingleGeodesyNormalizedGravitationalAcceleration(
     const double preMultiplier = gravitationalParameter / equatorialRadius;
 
     double sineOfAngle = std::sin( sphericalpositionOfBodySubjectToAcceleration( 1 ) );
-    sphericalHarmonicsCache->getLegendreCache( )->update( sineOfAngle, basic_mathematics::geodesyNormalizedLegendrePolynomialFunction );
+
+    basic_mathematics::LegendreCache& legendreCacheReference = *sphericalHarmonicsCache->getLegendreCache( );
+    legendreCacheReference.update( sineOfAngle, basic_mathematics::geodesyNormalizedLegendrePolynomialFunction );
 
     // Compute geodesy-normalized Legendre polynomials.
     const double legendrePolynomial = basic_mathematics::computeGeodesyLegendrePolynomial(
-                degree, order, sineOfAngle, sphericalHarmonicsCache->getLegendreCache( ) );
+                degree, order, sineOfAngle, legendreCacheReference );
     const double incrementedLegendrePolynomial =
             basic_mathematics::computeGeodesyLegendrePolynomial(
                 degree, order + 1,
-                sineOfAngle, sphericalHarmonicsCache->getLegendreCache( ) );
+                sineOfAngle, legendreCacheReference );
 
     // Compute geodesy-normalized Legendre polynomial derivative.
     const double legendrePolynomialDerivative =
diff --git a/Tudat/Mathematics/BasicMathematics/UnitTests/unitTestLegendrePolynomials.cpp b/Tudat/Mathematics/BasicMathematics/UnitTests/unitTestLegendrePolynomials.cpp
index 11d77d2..659cd91 100644
--- a/Tudat/Mathematics/BasicMathematics/UnitTests/unitTestLegendrePolynomials.cpp
+++ b/Tudat/Mathematics/BasicMathematics/UnitTests/unitTestLegendrePolynomials.cpp
@@ -82,7 +82,7 @@ BOOST_AUTO_TEST_CASE( test_LegendrePolynomial )
     const Vector12i order
             = ( Eigen::VectorXi( 12 ) << 0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 150 ).finished( );
 
-    boost::shared_ptr< basic_mathematics::LegendreCache > legendreCache = boost::make_shared< basic_mathematics::LegendreCache >( 150, 150 );
+    basic_mathematics::LegendreCache legendreCache = basic_mathematics::LegendreCache( 150, 150 );
 
     // Define polynomial parameter.
     const double polynomialParameter = 0.5;
@@ -129,7 +129,7 @@ BOOST_AUTO_TEST_CASE( test_GeodesyLegendrePolynomial )
     // Declare test values vector.
     Vector10d computedTestValues;
 
-    boost::shared_ptr< basic_mathematics::LegendreCache > legendreCache = boost::make_shared< basic_mathematics::LegendreCache >( 4, 4 );
+    basic_mathematics::LegendreCache legendreCache = basic_mathematics::LegendreCache( 4, 4 );
 
     // Define degree and order vectors.
     const Vector10i degree = ( Eigen::VectorXi( 10 ) << 0, 1, 1, 2, 2, 2, 3, 3, 3, 3 ).finished( );
diff --git a/Tudat/Mathematics/BasicMathematics/legendrePolynomials.cpp b/Tudat/Mathematics/BasicMathematics/legendrePolynomials.cpp
index 3eb0626..5642e1c 100644
--- a/Tudat/Mathematics/BasicMathematics/legendrePolynomials.cpp
+++ b/Tudat/Mathematics/BasicMathematics/legendrePolynomials.cpp
@@ -48,6 +48,20 @@ namespace tudat
 namespace basic_mathematics
 {
 
+
+//! Initialize LegendreCache instance.
+LegendreCache::LegendreCache( )
+{
+    resetMaximumDegreeAndOrder( 0, 0 );
+    returnValue_ = TUDAT_NAN;
+}
+
+LegendreCache::LegendreCache( const int maximumDegree, const int maximumOrder )
+{
+    resetMaximumDegreeAndOrder( maximumDegree, maximumOrder );
+    returnValue_ = TUDAT_NAN;
+}
+
 //! Get Legendre polynomial from cache when possible, and from direct computation otherwise.
 void LegendreCache::update( const double polynomialParameter,
                             const LegendrePolynomialFunction legendrePolynomialFunction )
@@ -55,12 +69,12 @@ void LegendreCache::update( const double polynomialParameter,
     currentPolynomialParameter_ = polynomialParameter;
     currentPolynomialParameterComplement_ = std::sqrt( 1.0 - polynomialParameter * polynomialParameter ); // cosine of latitude is always positive!
 
+    LegendreCache& thisReference = *this;
     for( int i = 0; i <= maximumDegree_; i++ )
     {
         for( int j = 0; ( ( j <= i ) && ( j <= maximumOrder_ ) ) ; j++ )
         {
-
-            legendreValues_[ i * ( maximumOrder_ + 1 ) + j ] = legendrePolynomialFunction( i, j, polynomialParameter, shared_from_this( ) );
+            legendreValues_[ i * ( maximumOrder_ + 1 ) + j ] = legendrePolynomialFunction( i, j, polynomialParameter, thisReference );
         }
     }
 }
@@ -78,12 +92,20 @@ void LegendreCache::resetMaximumDegreeAndOrder( const int degree, const int orde
 //! Get Legendre polynomial from cache when possible, and from direct computation otherwise.
 double LegendreCache::getOrElseUpdate(
         const int degree, const int order, const double polynomialParameter,
-        const LegendrePolynomialFunction& legendrePolynomialFunction )
+        const bool useGeodesyNormalizedFunction )
 {
 
     if( ! ( polynomialParameter == currentPolynomialParameter_ ) )
     {
-        update( polynomialParameter, legendrePolynomialFunction );
+        if( useGeodesyNormalizedFunction )
+        {
+            update( polynomialParameter, geodesyNormalizedLegendrePolynomialFunction );
+        }
+        else
+        {
+            update( polynomialParameter, regularLegendrePolynomialFunction );
+
+        }
     }
 
     if( degree > maximumDegree_ || order > maximumOrder_ )
@@ -108,7 +130,7 @@ double LegendreCache::getOrElseUpdate(
 double computeLegendrePolynomial( const int degree,
                                   const int order,
                                   const double polynomialParameter,
-                                  boost::shared_ptr< basic_mathematics::LegendreCache > legendreCache )
+                                  LegendreCache& legendreCache )
 {
     // If degree or order is negative...
     if ( degree < 0 || order < 0 )
@@ -141,12 +163,12 @@ double computeLegendrePolynomial( const int degree,
     else if ( degree == order )
     {
         // Obtain polynomial of degree one and order one.
-        const double degreeOneOrderOnePolynomial = legendreCache->getOrElseUpdate(
-                    1, 1, polynomialParameter, legendrePolynomialFunction);
+        const double degreeOneOrderOnePolynomial = legendreCache.getOrElseUpdate(
+                    1, 1, polynomialParameter, 0 );
 
         // Obtain prior sectoral polynomial.
-        const double priorSectoralPolynomial = legendreCache->getOrElseUpdate(
-                    degree - 1, order - 1, polynomialParameter, legendrePolynomialFunction);
+        const double priorSectoralPolynomial = legendreCache.getOrElseUpdate(
+                    degree - 1, order - 1, polynomialParameter, 0 );
 
         // Compute polynomial.
         return computeLegendrePolynomialDiagonal(
@@ -157,12 +179,12 @@ double computeLegendrePolynomial( const int degree,
     else
     {
         // Obtain prior degree polynomial.
-        const double oneDegreePriorPolynomial = legendreCache->getOrElseUpdate(
-                    degree - 1, order, polynomialParameter, legendrePolynomialFunction);
+        const double oneDegreePriorPolynomial = legendreCache.getOrElseUpdate(
+                    degree - 1, order, polynomialParameter, 0 );
 
         // Obtain two degrees prior polynomial.
-        const double twoDegreesPriorPolynomial = legendreCache->getOrElseUpdate(
-                    degree - 2, order, polynomialParameter, legendrePolynomialFunction);
+        const double twoDegreesPriorPolynomial = legendreCache.getOrElseUpdate(
+                    degree - 2, order, polynomialParameter, 0 );
 
         // Compute polynomial.
         return computeLegendrePolynomialVertical( degree,
@@ -177,7 +199,7 @@ double computeLegendrePolynomial( const int degree,
 double computeGeodesyLegendrePolynomial( const int degree,
                                          const int order,
                                          const double polynomialParameter,
-                                         boost::shared_ptr< basic_mathematics::LegendreCache > geodesyLegendreCache )
+                                         LegendreCache& geodesyLegendreCache )
 {
     // If degree or order is negative...
     if ( degree < 0 || order < 0 )
@@ -210,12 +232,12 @@ double computeGeodesyLegendrePolynomial( const int degree,
     else if ( degree == order )
     {
         // Obtain polynomial of degree one and order one.
-        double degreeOneOrderOnePolynomial = geodesyLegendreCache->getOrElseUpdate(
-                    1, 1, polynomialParameter, geodesyNormalizedLegendrePolynomialFunction );
+        double degreeOneOrderOnePolynomial = geodesyLegendreCache.getOrElseUpdate(
+                    1, 1, polynomialParameter, 1 );
 
         // Obtain prior sectoral polynomial.
-        double priorSectoralPolynomial = geodesyLegendreCache->getOrElseUpdate(
-                    degree - 1, order - 1, polynomialParameter, geodesyNormalizedLegendrePolynomialFunction);
+        double priorSectoralPolynomial = geodesyLegendreCache.getOrElseUpdate(
+                    degree - 1, order - 1, polynomialParameter, 1 );
 
         // Compute polynomial.
         return computeGeodesyLegendrePolynomialDiagonal(
@@ -226,12 +248,12 @@ double computeGeodesyLegendrePolynomial( const int degree,
     else
     {
         // Obtain prior degree polynomial.
-        double oneDegreePriorPolynomial = geodesyLegendreCache->getOrElseUpdate(
-                    degree - 1, order, polynomialParameter, geodesyNormalizedLegendrePolynomialFunction);
+        double oneDegreePriorPolynomial = geodesyLegendreCache.getOrElseUpdate(
+                    degree - 1, order, polynomialParameter, 1 );
 
         // Obtain two degrees prior polynomial.
-        double twoDegreesPriorPolynomial = geodesyLegendreCache->getOrElseUpdate(
-                    degree - 2, order, polynomialParameter, geodesyNormalizedLegendrePolynomialFunction);
+        double twoDegreesPriorPolynomial = geodesyLegendreCache.getOrElseUpdate(
+                    degree - 2, order, polynomialParameter, 1 );
 
         // Compute polynomial.
         return computeGeodesyLegendrePolynomialVertical( degree,
diff --git a/Tudat/Mathematics/BasicMathematics/legendrePolynomials.h b/Tudat/Mathematics/BasicMathematics/legendrePolynomials.h
index 75665cf..8b1f791 100644
--- a/Tudat/Mathematics/BasicMathematics/legendrePolynomials.h
+++ b/Tudat/Mathematics/BasicMathematics/legendrePolynomials.h
@@ -69,7 +69,7 @@ namespace basic_mathematics
 {
 
 //! Class for creating and accessing a back-end cache of Legendre polynomials.
-class LegendreCache: public boost::enable_shared_from_this< LegendreCache >
+class LegendreCache
 {
 private:
 
@@ -78,20 +78,12 @@ public:
 
     //! Define Legendre polynomial function pointer.
 
-    typedef boost::function< double ( int, int, double, boost::shared_ptr< LegendreCache > ) > LegendrePolynomialFunction;
+    typedef boost::function< double ( int, int, double, LegendreCache& ) > LegendrePolynomialFunction;
 
     //! Initialize LegendreCache instance.
-    LegendreCache( )
-    {
-        resetMaximumDegreeAndOrder( 0, 0 );
-        returnValue_ = TUDAT_NAN;
-    }
+    LegendreCache( );
 
-    LegendreCache( const int maximumDegree, const int maximumOrder )
-    {
-        resetMaximumDegreeAndOrder( maximumDegree, maximumOrder );
-        returnValue_ = TUDAT_NAN;
-    }
+    LegendreCache( const int maximumDegree, const int maximumOrder );
 
     void resetMaximumDegreeAndOrder( const int degree, const int order );
 
@@ -121,7 +113,7 @@ public:
     * \return Legendre polynomial value.
     */
     double getOrElseUpdate( const int degree, const int order, const double polynomialParameter,
-                            const LegendrePolynomialFunction& legendrePolynomialFunction );
+                            const bool useGeodesyNormalizedFunction );
 
     int getMaximumDegree( ){ return maximumDegree_; }
 
@@ -144,6 +136,8 @@ private:
 
 };
 
+
+
 //! Compute unnormalized associated Legendre polynomial.
 /*!
  * This function returns an unnormalized associated Legendre polynomial \f$ P _{ n, m }( u ) \f$
@@ -173,7 +167,7 @@ private:
 double computeLegendrePolynomial( const int degree,
                                   const int order,
                                   const double polynomialParameter,
-                                  boost::shared_ptr< basic_mathematics::LegendreCache > legendreCache );
+                                  LegendreCache& legendreCache );
 
 //! Compute geodesy-normalized associated Legendre polynomial.
 /*!
@@ -217,7 +211,7 @@ double computeLegendrePolynomial( const int degree,
 double computeGeodesyLegendrePolynomial( const int degree,
                                          const int order,
                                          const double polynomialParameter,
-                                         boost::shared_ptr< basic_mathematics::LegendreCache > geodesyLegendreCache );
+                                         LegendreCache& geodesyLegendreCache );
 
 //! Compute derivative of unnormalized Legendre polynomial.
 /*!
@@ -416,7 +410,7 @@ double computeGeodesyLegendrePolynomialVertical( const int degree,
 double calculateLegendreGeodesyNormalizationFactor( const int degree, const int order );
 
 static const LegendreCache::LegendrePolynomialFunction geodesyNormalizedLegendrePolynomialFunction = &computeGeodesyLegendrePolynomial;
-static const LegendreCache::LegendrePolynomialFunction legendrePolynomialFunction = &computeLegendrePolynomial;
+static const LegendreCache::LegendrePolynomialFunction regularLegendrePolynomialFunction = &computeLegendrePolynomial;
 
 } // namespace basic_mathematics
 } // namespace tudat
diff --git a/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.h b/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.h
index 7b4f4af..5a7dc77 100644
--- a/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.h
+++ b/Tudat/Mathematics/BasicMathematics/sphericalHarmonics.h
@@ -124,6 +124,7 @@ public:
         return sphericalHarmonicsCache_;
     }
 
+
 private:
 
     int maximumDegree_;
